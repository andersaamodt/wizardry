#!/bin/sh

# This spell copies extended attributes into a YAML prologue within the file.
# After the runes are preserved in text, it clears the attributes from the file.


show_usage() {
cat <<'USAGE'
Usage: enchantment-to-yaml <path-to-file>

Extract all extended attributes from a file, write them into a YAML front matter header, and strip the original attributes from the file.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

if [ "$#" -ne 1 ]; then
    warn "Error: incorrect number of arguments"
    show_usage >&2
    exit 1
fi

file=$1
is file "$file" || { warn "Error: file does not exist"; exit 1; }

helper_usable() {
    helper=$1
    has "$helper" || return 1

    resolved=$(where "$helper")

  if [ "${WIZARDRY_TEST_HELPERS_ONLY-0}" -eq 1 ]; then
    case $resolved in
      /usr/*|/bin/*|/sbin/*|/usr/local/*)
                return 1
                ;;
        esac
    fi

    return 0
}

parse_attr_output() {
    printf '%s' "$1" | sed 's/.*has a value:[[:space:]]*//'
}

list_keys() {
    target=$1
    if helper_usable xattr; then
        if keys=$(xattr "$target" 2>/dev/null); then
            if [ -n "$keys" ]; then
                printf '%s\n' "$keys"
                return 0
            fi
        fi
    fi
    if helper_usable attr; then
        if keys=$(attr -l "$target" 2>/dev/null); then
            parsed=$(printf '%s\n' "$keys" | awk -F '"' '/Attribute/ {print $2}')
            if [ -n "$parsed" ]; then
                printf '%s\n' "$parsed"
                return 0
            fi
        fi
    fi
    if helper_usable getfattr; then
        if keys=$(getfattr -d "$target" 2>/dev/null); then
            parsed=$(printf '%s' "$keys" | awk -F '=' '/^# / {next} {print $1}')
            if [ -n "$parsed" ]; then
                printf '%s' "$parsed"
                return 0
            fi
        fi
    fi
    return 1
}

read_value() {
    key=$1
    target=$2

    if helper_usable xattr; then
        if output=$(xattr -p "$key" "$target" 2>/dev/null); then
            printf '%s' "$output"
            return 0
        fi
    fi
    if helper_usable attr; then
        if output=$(attr -g "$key" "$target" 2>/dev/null); then
            parse_attr_output "$output"
            return 0
        fi
    fi
    if helper_usable getfattr; then
        if output=$(getfattr -n "$key" --only-values "$target" 2>/dev/null); then
            printf '%s' "$output"
            return 0
        fi
    fi
    return 1
}

keys=$(list_keys "$file" || true)
empty "$keys" && { warn "Error: file does not have extended attributes"; exit 1; }

tmp=$(mktemp "${TMPDIR:-/tmp}/wizardry-yaml.XXXXXX") || exit 1
{
    printf '%s\n' '---'
    for key in $keys; do
        [ -z "$key" ] && continue
        value=$(read_value "$key" "$file" || printf '')
        printf '%s: %s\n' "$key" "$value"
    done
    printf '%s\n' '---'
    printf '\n'
} >"$tmp"
cat "$file" >>"$tmp" || exit 1
mv "$tmp" "$file"

if ! (helper_usable xattr || helper_usable attr || helper_usable setfattr); then
    warn "Error: requires one of attr, xattr, or setfattr to clear attributes"
    exit 1
fi

if helper_usable xattr; then
    xattr -c "$file" 2>/dev/null || true
fi

for key in $keys; do
    [ -z "$key" ] && continue
    if helper_usable attr; then
        attr -r "$key" "$file" 2>/dev/null || true
    fi
    if helper_usable setfattr; then
        setfattr -x "$key" "$file" 2>/dev/null || true
    fi
    if helper_usable xattr; then
        xattr -d "$key" "$file" 2>/dev/null || true
    fi
done
