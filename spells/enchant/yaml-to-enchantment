#!/bin/sh




# This spell reads a YAML front matter block and restores its keys as attributes.
# After the transfer, it trims the prologue so the file holds only its content.

require_wizardry || return 1

yaml_to_enchantment_usage() {
cat <<'USAGE'
Usage: yaml-to-enchantment <path-to-file>

Parse a YAML front matter header, write each key/value into the file's extended attributes, and rewrite the file without the header.
USAGE
}


yaml_to_enchantment() {
case "${1-}" in
--help|--usage|-h)
  yaml_to_enchantment_usage
  return 0
  ;;
esac

set -eu
env_clear

if [ "$#" -ne 1 ]; then
    warn "Error: incorrect number of arguments"
    yaml_to_enchantment_usage >&2
    return 1
fi

scroll=$1
is file "$scroll" || { warn "Error: file does not exist"; return 1; }

header_count=$(awk '/^---$/{c++} END{print c}' "$scroll")
if [ "$header_count" -lt 2 ]; then
    warn "Error: file does not have a YAML header"
    return 1
fi

yaml_header=$(awk '
    /^---$/ {delim++; next}
    delim==1 {print}
' "$scroll")

empty "$yaml_header" && { warn "Error: file does not have a YAML header"; return 1; }

resolve_helper() {
    helper=$1
    has "$helper" || return 1

    helper_path=$(where "$helper")
    if [ "${WIZARDRY_TEST_HELPERS_ONLY-0}" -eq 1 ]; then
        case "$helper_path" in
            /usr/*|/bin/*|/sbin/*|/usr/local/*)
                return 1 ;;
        esac
    fi

    say "$helper_path"
}

has_attr=$(resolve_helper attr >/dev/null 2>&1 && echo "yes" || echo "no")
has_setfattr=$(resolve_helper setfattr >/dev/null 2>&1 && echo "yes" || echo "no")
has_xattr=$(resolve_helper xattr >/dev/null 2>&1 && echo "yes" || echo "no")

if [ "$has_attr" = "no" ] && [ "$has_setfattr" = "no" ] && [ "$has_xattr" = "no" ]; then
    warn "Error: requires attr, setfattr, or xattr to restore enchantments"
    return 1
fi

printf '%s' "$yaml_header" |
    while IFS= read -r line || nonempty "$line"; do
        key=${line%%:*}
        value=${line#*:}
        value=${value# }
        empty "$key" && continue
        
        # Inline set_attr logic - only used once
        success=0
        if helper_path=$(resolve_helper attr); then
            if "$helper_path" -s "$key" -V "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        if [ "$success" -eq 0 ] && helper_path=$(resolve_helper setfattr); then
            if "$helper_path" -n "$key" -v "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        if [ "$success" -eq 0 ] && helper_path=$(resolve_helper xattr); then
            if "$helper_path" -w "$key" "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        
        if [ "$success" -eq 0 ]; then
            warn "Error: failed to set attribute $key"
            return 1
        fi
    done || return 1

body_tmp=$(temp-file wizardry-body) || return 1
awk '
    /^---$/ {delim++; next}
    delim<2 {next}
    {print}
' "$scroll" >"$body_tmp"
mv "$body_tmp" "$scroll"
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
