#!/bin/sh

# This spell reads a YAML front matter block and restores its keys as attributes.
# After the transfer, it trims the prologue so the file holds only its content.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: yaml-to-enchantment <path-to-file>

Parse a YAML front matter header, write each key/value into the file's extended attributes, and rewrite the file without the header.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

if [ "$#" -ne 1 ]; then
    printf '%s\n' "Error: incorrect number of arguments" >&2
    cat >&2 <<'USAGE'
Usage: yaml-to-enchantment <path-to-file>

Parse a YAML front matter header, write each key/value into the file's extended attributes, and rewrite the file without the header.
USAGE
    exit 1
fi

scroll=$1
if [ ! -f "$scroll" ]; then
  printf '%s\n' "Error: file does not exist" >&2
  exit 1
fi

header_count=$(awk '/^---$/{c++} END{print c}' "$scroll")
if [ "$header_count" -lt 2 ]; then
    printf '%s\n' "Error: file does not have a YAML header" >&2
    exit 1
fi

yaml_header=$(awk '
    /^---$/ {delim++; next}
    delim==1 {print}
' "$scroll")

if [ -z "$yaml_header" ]; then
  printf '%s\n' "Error: file does not have a YAML header" >&2
  exit 1
fi

resolve_helper() {
    helper=$1
    if ! command -v "$helper" >/dev/null 2>&1; then
      return 1
    fi

    helper_path=$(command -v "$helper")
    # xattr tools (attr, xattr, setfattr, getfattr) are platform tools
    # We should use them when available, even in test mode
    printf '%s\n' "$helper_path"
}

has_attr=$(resolve_helper attr >/dev/null 2>&1 && printf '%s\n' "yes" || printf '%s\n' "no")
has_setfattr=$(resolve_helper setfattr >/dev/null 2>&1 && printf '%s\n' "yes" || printf '%s\n' "no")
has_xattr=$(resolve_helper xattr >/dev/null 2>&1 && printf '%s\n' "yes" || printf '%s\n' "no")

if [ "$has_attr" = "no" ] && [ "$has_setfattr" = "no" ] && [ "$has_xattr" = "no" ]; then
    printf '%s\n' "Error: requires attr, setfattr, or xattr to restore enchantments" >&2
    exit 1
fi

printf '%s' "$yaml_header" |
    while IFS= read -r line || [ -n "$line" ]; do
        key=${line%%:*}
        value=${line#*:}
        value=${value# }
        [ -z "$key" ] && continue
        
        # Inline set_attr logic - only used once
        success=0
        if helper_path=$(resolve_helper attr); then
            if "$helper_path" -s "$key" -V "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        if [ "$success" -eq 0 ] && helper_path=$(resolve_helper setfattr); then
            if "$helper_path" -n "$key" -v "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        if [ "$success" -eq 0 ] && helper_path=$(resolve_helper xattr); then
            if "$helper_path" -w "$key" "$value" "$scroll" 2>/dev/null; then
                success=1
            fi
        fi
        
        if [ "$success" -eq 0 ]; then
            printf '%s\n' "Error: failed to set attribute $key" >&2
            exit 1
        fi
    done || exit 1

body_tmp=$(temp-file wizardry-body) || exit 1
awk '
    /^---$/ {delim++; next}
    delim<2 {next}
    {print}
' "$scroll" >"$body_tmp"
mv "$body_tmp" "$scroll"
