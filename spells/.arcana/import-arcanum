#!/bin/sh

# Import an arcanum from a path into the wizardry arcana collection.

import_arcanum_usage() {
  cat <<'USAGE'
Usage: import-arcanum [PATH]

Import an arcanum from the specified path into the wizardry arcana collection.
If no path is provided, the spell will prompt for one interactively.

An arcanum must:
- Be a directory
- Have a valid name (letters, digits, underscores, hyphens only)
- Not already exist in the arcana directory
USAGE
}

import_arcanum() {
case "${1-}" in
--help|--usage|-h)
  import_arcanum_usage
  return 0
  ;;
esac

require-wizardry || return 1


set -eu
. env-clear

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
arcana_dir=${INSTALL_MENU_ROOT:-$script_dir}

# Get path from argument or prompt
if [ "$#" -ge 1 ]; then
  source_path=$1
else
  if ! has ask-text; then
    die "import-arcanum: ask-text command not found"
  fi
  source_path=$(ask-text "Path to arcanum:") || die "import-arcanum: no path provided"
fi

# Validate that source path is not empty
if [ -z "$source_path" ]; then
  printf '%s\n' "import-arcanum: path cannot be empty." >&2
  return 1
fi

# Expand ~ to HOME if present at start of path
case "$source_path" in
  '~')
    source_path=$HOME
    ;;
  '~/'*)
    source_path=$HOME/${source_path#'~/'}
    ;;
esac

# Make path absolute if it's relative
case "$source_path" in
  /*)
    # Already absolute
    ;;
  *)
    # Make relative path absolute
    dir=$(dirname "$source_path")
    abs_dir=$(cd "$dir" 2>/dev/null && pwd -P) || {
      printf '%s\n' "import-arcanum: cannot access path: $source_path" >&2
      return 1
    }
    source_path="$abs_dir/$(basename "$source_path")"
    ;;
esac

# Validate that resolved path doesn't contain '..' components (path traversal protection)
parent_ref_found=0
old_ifs=$IFS
IFS='/'
for part in $source_path; do
  if [ "$part" = ".." ]; then
    parent_ref_found=1
    break
  fi
done
IFS=$old_ifs
if [ "$parent_ref_found" -eq 1 ]; then
  printf '%s\n' "import-arcanum: path traversal detected: $source_path" >&2
  return 1
fi

# Validate that source path exists and is a directory
if [ ! -d "$source_path" ]; then
  printf '%s\n' "import-arcanum: not a directory: $source_path" >&2
  return 1
fi

# Extract arcanum name from path
arcanum_name=$(basename "$source_path")

# Validate arcanum name (alphanumeric, hyphens, underscores only - no dots to prevent path traversal)
case "$arcanum_name" in
  ''|*[!A-Za-z0-9_-]*)
    printf '%s\n' "import-arcanum: invalid arcanum name: $arcanum_name" >&2
    printf '%s\n' "import-arcanum: names may contain only letters, digits, underscores, and hyphens." >&2
    return 1
    ;;
  -*)
    printf '%s\n' "import-arcanum: invalid arcanum name: $arcanum_name" >&2
    printf '%s\n' "import-arcanum: names may not begin with a dash." >&2
    return 1
    ;;
  .*)
    printf '%s\n' "import-arcanum: invalid arcanum name: $arcanum_name" >&2
    printf '%s\n' "import-arcanum: names may not begin with a dot." >&2
    return 1
    ;;
  *..*)
    printf '%s\n' "import-arcanum: invalid arcanum name: $arcanum_name" >&2
    printf '%s\n' "import-arcanum: names may not contain consecutive dots." >&2
    return 1
    ;;
esac

# Validate source path is not the same as or inside the arcana directory
case "$source_path" in
  "$arcana_dir"*)
    printf '%s\n' "import-arcanum: cannot import from arcana directory itself." >&2
    return 1
    ;;
esac

# Check if arcanum already exists in arcana directory
target_path="$arcana_dir/$arcanum_name"
if [ -e "$target_path" ]; then
  printf '%s\n' "import-arcanum: arcanum already exists: $arcanum_name" >&2
  return 1
fi

# Copy the arcanum to the arcana directory
if ! cp -R "$source_path" "$target_path" 2>/dev/null; then
  printf '%s\n' "import-arcanum: failed to copy arcanum to: $target_path" >&2
  return 1
fi

printf '%s\n' "Imported arcanum: $arcanum_name"
return 0

}

# Load castable imp for direct execution
# CRITICAL: Check if already available before sourcing to avoid fork limits
if ! command -v castable >/dev/null 2>&1; then
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"