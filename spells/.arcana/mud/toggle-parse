#!/bin/sh

# Toggle parse-enabled setting in MUD config - must be sourced for immediate effect

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . toggle-parse    OR    toggle parse    (via parse/gloss)

Toggle the parse-enabled setting. When parse is enabled, generate-glosses
creates first-word glosses that enable natural language commands like
"read magic" instead of "read-magic".

Changes take effect immediately in the current shell.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  exit 0
  ;;
esac

# Uncastable pattern - detect if sourced
toggle_parse_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) toggle_parse_sourced=1 ;;
  esac
else
  toggle_parse_base=${0##*/}
  case "$toggle_parse_base" in
    sh|dash|bash|zsh|ksh|mksh) toggle_parse_sourced=1 ;;
    toggle-parse) toggle_parse_sourced=0 ;;
    parse) toggle_parse_sourced=1 ;;  # Sourced via parse
    *) toggle_parse_sourced=1 ;;
  esac
fi

if [ "$toggle_parse_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . toggle-parse  OR  toggle parse" >&2
  return 1 2>/dev/null || exit 1
fi
unset toggle_parse_sourced toggle_parse_base

set +e  # Permissive mode since we're in user's shell
set -u

# Determine config file location
SPELLBOOK_DIR="${SPELLBOOK_DIR:-$HOME/.spellbook}"
CONFIG_FILE="$SPELLBOOK_DIR/.mud"

# Ensure spellbook directory exists
mkdir -p "$SPELLBOOK_DIR"
touch "$CONFIG_FILE"

# Check current state
if config-has "$CONFIG_FILE" "parse-enabled" 2>/dev/null; then
  current_value=$(config-get "$CONFIG_FILE" "parse-enabled" 2>/dev/null)
  if [ "$current_value" = "1" ]; then
    # Currently enabled, disable it
    
    # IMPORTANT: Get list of currently loaded gloss functions
    # We need to unset the functions that are currently in memory
    # Using compgen or typeset to list all functions, then filter for glosses
    if [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use print with function list
      gloss_funcs=$(print -l ${(ok)functions} 2>/dev/null | grep -E '^[a-z]' || true)
    elif [ -n "${BASH_VERSION-}" ]; then
      # In bash, use compgen -A function
      gloss_funcs=$(compgen -A function 2>/dev/null | grep -E '^[a-z]' || true)
    else
      # Fallback: try to generate list from generate-glosses
      if command -v generate-glosses >/dev/null 2>&1; then
        gloss_output=$(generate-glosses --quiet 2>/dev/null || true)
        gloss_funcs=$(printf '%s\n' "$gloss_output" | \
          grep '^[a-zA-Z_][a-zA-Z0-9_]*() {$' | sed 's/() {$//' || true)
      fi
    fi
    
    # Debug: verify we got functions
    if [ -z "${gloss_funcs-}" ]; then
      printf 'Warning: No gloss functions found to unset.\n' >&2
    fi
    
    # Now change the config
    config-set "$CONFIG_FILE" "parse-enabled" "0"
    
    # Touch the config file to ensure it's newer than any cache
    # This is critical for cache invalidation across all shells
    touch "$CONFIG_FILE" 2>/dev/null || true
    
    # Delete gloss cache to ensure NEW shells regenerate with new setting
    # Cache is based on WIZARDRY_DIR and user ID
    cache_dir="${TMPDIR:-/tmp}"
    cache_file="${cache_dir}/.wizardry-glosses-$(printf '%s' "${WIZARDRY_DIR:-$HOME/.wizardry}" | cksum | cut -d' ' -f1)-$(id -u).sh"
    rm -f "$cache_file" 2>/dev/null || true
    
    # Unload all gloss functions immediately
    if [ -n "${gloss_funcs-}" ]; then
      # Unset each function individually
      # shellcheck disable=SC2086
      for func in $gloss_funcs; do
        [ -n "$func" ] || continue
        # Use unset -f for POSIX shells
        unset -f "$func" 2>/dev/null || true
        # Also try unfunction for zsh compatibility
        if [ -n "${ZSH_VERSION-}" ]; then
          unfunction "$func" 2>/dev/null || true
        fi
      done
    fi
    
    printf '%s\n' "✓ Parse disabled and unloaded from your current shell."
    printf '%s\n' "  Only exact spell names and synonyms will work"
    printf '%s\n' "  (e.g., 'jump-to-marker', not 'jump to marker')."
    return 0
  fi
fi

# Currently disabled or set to 0, enable it
config-set "$CONFIG_FILE" "parse-enabled" "1"

# Touch the config file to ensure it's newer than any cache
# This is critical for cache invalidation across all shells
touch "$CONFIG_FILE" 2>/dev/null || true

# Delete gloss cache to ensure invoke-wizardry regenerates with new setting
cache_dir="${TMPDIR:-/tmp}"
cache_file="${cache_dir}/.wizardry-glosses-$(printf '%s' "${WIZARDRY_DIR:-$HOME/.wizardry}" | cksum | cut -d' ' -f1)-$(id -u).sh"
rm -f "$cache_file" 2>/dev/null || true

# Reload glosses with parse enabled by sourcing invoke-wizardry
invoke_wizardry_path="${WIZARDRY_DIR:-$HOME/.wizardry}/spells/.imps/sys/invoke-wizardry"
if [ -f "$invoke_wizardry_path" ]; then
  # Temporarily unset WIZARDRY_INVOKED to allow re-sourcing
  temp_invoked="${WIZARDRY_INVOKED-}"
  unset WIZARDRY_INVOKED
  . "$invoke_wizardry_path" 2>/dev/null || {
    printf '%s\n' "Warning: Failed to reload glosses. They will be reloaded on next shell startup."
    WIZARDRY_INVOKED="$temp_invoked"
    return 1
  }
  unset temp_invoked
  printf '%s\n' "✓ Parse enabled and loaded in your current shell."
  printf '%s\n' "  Natural language commands are now available (e.g., 'jump to marker')."
else
  printf '%s\n' "✓ Parse enabled in config. Glosses will load on next shell startup."
fi
