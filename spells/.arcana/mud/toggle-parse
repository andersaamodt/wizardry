#!/bin/sh

# Toggle parse-enabled setting in MUD config - must be sourced for immediate effect

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . toggle-parse    OR    toggle parse    (via parse/gloss)

Toggle the parse-enabled setting. When parse is enabled, generate-glosses
creates first-word glosses that enable natural language commands like
"read magic" instead of "read-magic".
Changes take effect immediately in the current shell.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  exit 0
  ;;
esac

# Uncastable pattern - detect if sourced
toggle_parse_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) toggle_parse_sourced=1 ;;
  esac
else
  toggle_parse_base=${0##*/}
  case "$toggle_parse_base" in
    sh|dash|bash|zsh|ksh|mksh) toggle_parse_sourced=1 ;;
    toggle-parse) toggle_parse_sourced=0 ;;
    parse) toggle_parse_sourced=1 ;;  # Sourced via parse
    *) toggle_parse_sourced=1 ;;
  esac
fi

if [ "$toggle_parse_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . toggle-parse  OR  toggle parse" >&2
  return 1 2>/dev/null || exit 1
fi
unset toggle_parse_sourced toggle_parse_base

set +e  # Permissive mode since we're in user's shell
set -u


# Determine config file location
SPELLBOOK_DIR="${SPELLBOOK_DIR:-$HOME/.spellbook}"
CONFIG_FILE="$SPELLBOOK_DIR/.mud"

# Ensure spellbook directory exists
mkdir -p "$SPELLBOOK_DIR"
touch "$CONFIG_FILE"

# Check current state
# Default is enabled (1) when not set, matching generate-glosses behavior
# This ensures consistent behavior across wizardry components
current_value="1"
if config-has "$CONFIG_FILE" "parse-enabled" 2>/dev/null; then
  current_value=$(config-get "$CONFIG_FILE" "parse-enabled" 2>/dev/null)
fi

if [ "$current_value" = "1" ]; then
  # Currently enabled, disable it
  printf '[DEBUG] Disabling parse...\n' >&2
  config-set "$CONFIG_FILE" "parse-enabled" "0"
  
  # Force filesystem sync to ensure config write is flushed
  sync 2>/dev/null || true
  
  # Verify config was updated
  printf '[DEBUG] Config file: %s\n' "$CONFIG_FILE" >&2
  printf '[DEBUG] Config contents after update:\n' >&2
  cat "$CONFIG_FILE" >&2 || true
  
  # Invalidate gloss cache to force regeneration with new setting
  # Handle TMPDIR with or without trailing slash  
  gloss_cache_dir="${TMPDIR:-/tmp}"
  gloss_cache_dir="${gloss_cache_dir%/}"  # Remove trailing slash if present
  wizardry_dir="${WIZARDRY_DIR:-$HOME/.wizardry}"
  cache_id=$(printf '%s' "$wizardry_dir" | cksum | cut -d' ' -f1)
  gloss_cache="$gloss_cache_dir/.wizardry-glosses-$cache_id-$(id -u).sh"
  
  printf '[DEBUG] Cache file: %s\n' "$gloss_cache" >&2
  printf '[DEBUG] Deleting old cache...\n' >&2
  
  # Delete old cache first to ensure we don't source stale data
  rm -f "$gloss_cache" 2>/dev/null || true
  
  printf '[DEBUG] Regenerating cache with parse-enabled=0...\n' >&2
  printf '[DEBUG] SPELLBOOK_DIR=%s\n' "$SPELLBOOK_DIR" >&2
  
  # Debug: Check what generate-glosses will read
  printf '[DEBUG] About to call generate-glosses...\n' >&2
  printf '[DEBUG] Config file that generate-glosses will read: %s\n' "${SPELLBOOK_DIR:-$HOME/.spellbook}/.mud" >&2
  printf '[DEBUG] parse-enabled value in config:\n' >&2
  grep '^parse-enabled=' "${SPELLBOOK_DIR:-$HOME/.spellbook}/.mud" 2>/dev/null || printf '[DEBUG] parse-enabled not found in config!\n' >&2
  
  # Explicitly regenerate cache with parse-enabled=0
  if command -v generate-glosses >/dev/null 2>&1; then
    printf '[DEBUG] Calling: generate-glosses --output %s\n' "$gloss_cache" >&2
    # Call generate-glosses without --quiet to see diagnostic output
    if generate-glosses --output "$gloss_cache"; then
      printf '[DEBUG] Cache regenerated successfully\n' >&2
      # Verify the cache doesn't have first-word glosses
      if grep -q "^jump()" "$gloss_cache" 2>/dev/null; then
        printf '[DEBUG] ERROR: Cache still contains jump() gloss function!\n' >&2
        printf '[DEBUG] First 10 lines of cache that have jump:\n' >&2
        grep "jump" "$gloss_cache" 2>/dev/null | head -10 >&2 || true
      else
        printf '[DEBUG] Verified: Cache has no jump() gloss function\n' >&2
      fi
    else
      printf '[DEBUG] ERROR: generate-glosses failed!\n' >&2
    fi
  else
    printf '[DEBUG] WARNING: generate-glosses not found!\n' >&2
  fi
  
  printf '[DEBUG] Collecting first-word function names...\n' >&2
  
  # Unload ALL gloss functions and aliases from current shell
  # Get list of first words by scanning spell files directly
  if [ -d "${WIZARDRY_DIR:-$HOME/.wizardry}/spells" ]; then
    # Collect all first-word function names (avoid subshell issues)
    first_words=""
    for spell_file in "${WIZARDRY_DIR:-$HOME/.wizardry}/spells"/*/* \
                      "${WIZARDRY_DIR:-$HOME/.wizardry}/spells"/.arcana/*/*; do
      [ -f "$spell_file" ] && [ -x "$spell_file" ] || continue
      spell_name=${spell_file##*/}
      
      # Skip hidden files and parse
      case "$spell_name" in
        .*|parse) continue ;;
      esac
      
      # Extract first word
      case "$spell_name" in
        *-*) first_word=${spell_name%%-*} ;;
        *) first_word=$spell_name ;;
      esac
      
      # Add to list if not already present
      case " $first_words " in
        *" $first_word "*) ;;
        *) first_words="$first_words $first_word" ;;
      esac
    done
    
    printf '[DEBUG] First words to unset: %s\n' "$first_words" >&2
    printf '[DEBUG] Unsetting functions...\n' >&2
    
    # Unset each first-word gloss function
    for func_name in $first_words; do
      printf '[DEBUG]   Unsetting: %s\n' "$func_name" >&2
      if [ -n "${ZSH_VERSION-}" ]; then
        # In zsh, use both unfunction and unset -f for robustness
        unfunction "$func_name" 2>/dev/null || true
        unset -f "$func_name" 2>/dev/null || true
      else
        unset -f "$func_name" 2>/dev/null || true
      fi
      # Check if it's still defined
      if typeset -f "$func_name" >/dev/null 2>&1 || type "$func_name" >/dev/null 2>&1; then
        printf '[DEBUG]   WARNING: %s still defined after unset!\n' "$func_name" >&2
      fi
    done
  fi
  
  printf '[DEBUG] About to source new cache...\n' >&2
  
  # Source the new cache to load aliases (no first-word glosses when parse=0)
  if [ -f "$gloss_cache" ]; then
    printf '[DEBUG] Sourcing cache: %s\n' "$gloss_cache" >&2
    # Check functions before sourcing
    if type jump >/dev/null 2>&1; then
      printf '[DEBUG] WARNING: jump() exists BEFORE sourcing cache!\n' >&2
    else
      printf '[DEBUG] jump() not defined before sourcing (good)\n' >&2
    fi
    . "$gloss_cache"
    printf '[DEBUG] Cache sourced\n' >&2
    # Check functions after sourcing  
    if type jump >/dev/null 2>&1; then
      printf '[DEBUG] ERROR: jump() exists AFTER sourcing cache!\n' >&2
    else
      printf '[DEBUG] jump() not defined after sourcing (good)\n' >&2
    fi
  else
    printf '[DEBUG] WARNING: Cache file not found!\n' >&2
  fi
  
  # Final check: are functions still defined?
  printf '[DEBUG] Final function check:\n' >&2
  for func_name in jump toggle; do
    if typeset -f "$func_name" >/dev/null 2>&1 || type "$func_name" >/dev/null 2>&1; then
      printf '[DEBUG]   %s is STILL DEFINED\n' "$func_name" >&2
    else
      printf '[DEBUG]   %s is NOT defined (correct)\n' "$func_name" >&2
    fi
  done
  
  msg="✓ Parse disabled and gloss functions unloaded from current shell."
  printf '%s\n' "$msg"
  return 0
fi

# Currently disabled or not set, enable it
printf '[DEBUG] Enabling parse...\n' >&2
config-set "$CONFIG_FILE" "parse-enabled" "1"

# Invalidate gloss cache to force regeneration with new setting
# Handle TMPDIR with or without trailing slash
gloss_cache_dir="${TMPDIR:-/tmp}"
gloss_cache_dir="${gloss_cache_dir%/}"  # Remove trailing slash if present
wizardry_dir="${WIZARDRY_DIR:-$HOME/.wizardry}"
cache_id=$(printf '%s' "$wizardry_dir" | cksum | cut -d' ' -f1)
gloss_cache="$gloss_cache_dir/.wizardry-glosses-$cache_id-$(id -u).sh"

printf '[DEBUG] Cache file: %s\n' "$gloss_cache" >&2
printf '[DEBUG] Deleting old cache...\n' >&2

# Delete old cache first to ensure we don't source stale data
rm -f "$gloss_cache" 2>/dev/null || true

printf '[DEBUG] Regenerating cache with parse-enabled=1...\n' >&2

# Explicitly regenerate cache with parse-enabled=1
if command -v generate-glosses >/dev/null 2>&1; then
  generate-glosses --quiet --output "$gloss_cache" 2>/dev/null || true
  printf '[DEBUG] Cache regenerated\n' >&2
else
  printf '[DEBUG] WARNING: generate-glosses not found!\n' >&2
fi

printf '[DEBUG] About to source new cache...\n' >&2

# Source the new cache to load functions
if [ -f "$gloss_cache" ]; then
  printf '[DEBUG] Sourcing cache: %s\n' "$gloss_cache" >&2
  . "$gloss_cache"
  printf '[DEBUG] Cache sourced\n' >&2
else
  printf '[DEBUG] WARNING: Cache file not found!\n' >&2
fi

# Final check: are functions defined?
printf '[DEBUG] Final function check:\n' >&2
for func_name in jump toggle; do
  if typeset -f "$func_name" >/dev/null 2>&1 || type "$func_name" >/dev/null 2>&1; then
    printf '[DEBUG]   %s is defined (correct)\n' "$func_name" >&2
  else
    printf '[DEBUG]   %s is NOT defined (incorrect!)\n' "$func_name" >&2
  fi
done

msg="✓ Parse enabled and gloss functions loaded in your current shell."
printf '%s\n' "$msg"
