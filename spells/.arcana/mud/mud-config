#!/bin/sh

# Manage MUD feature configuration stored in $MUD_DIR/config
# This is a helper for reading and writing MUD feature toggle states.

require-wizardry || exit 1

mud_config_usage() {
cat <<'USAGE'
Usage: mud-config {get|set|toggle|list} [FEATURE] [VALUE]

Manage MUD feature toggles stored in $MUD_DIR/config. Supports get, set, toggle, and list for features like command-not-found, touch-hook, fantasy-theme, inventory, and combat.
USAGE
}

mud_config() {
case "${1-}" in
--help|--usage|-h)
        mud_config_usage
        return 0
        ;;
esac

require-wizardry || return 1


set -eu
. env-clear

# Resolve config directory
spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
config_dir=$(env-or MUD_DIR "$spell_home/.mud")
config_file="$config_dir/config"

# Ensure config directory exists
ensure_config_dir() {
        if [ ! -d "$config_dir" ]; then
                mkdir -p "$config_dir" || {
                        printf '%s\n' "mud-config: cannot create config directory '$config_dir'" >&2
                        return 1
                }
        fi
}

# Get feature value (returns '1' for enabled, '0' for disabled)
get_feature() {
        feature=$1
        if [ ! -f "$config_file" ]; then
                printf '%s\n' "0"
                return 0
        fi
        value=$(grep "^${feature}=" "$config_file" 2>/dev/null | cut -d= -f2 | head -1)
        if [ "$value" = "1" ]; then
                printf '%s\n' "1"
        else
                printf '%s\n' "0"
        fi
}

# Set feature value
set_feature() {
        feature=$1
        value=$2
        case "$value" in
                1|0) ;;
                *)
                        printf '%s\n' "mud-config: value must be '1' or '0'" >&2
                        return 1
                        ;;
        esac
        ensure_config_dir || return 1
        
        # Create or update config file
        if [ -f "$config_file" ]; then
                # Remove old entry and add new one
                tmp_file=$(temp-file mud-config) || return 1
                trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
                grep -v "^${feature}=" "$config_file" >"$tmp_file" 2>/dev/null || true
                printf '%s=%s\n' "$feature" "$value" >>"$tmp_file"
                if ! mv "$tmp_file" "$config_file"; then
                        trap - EXIT HUP INT TERM
                        rm -f "$tmp_file"
                        return 1
                fi
                trap - EXIT HUP INT TERM
        else
                printf '%s=%s\n' "$feature" "$value" >"$config_file"
        fi
}

# Main command dispatch
if [ "$#" -lt 1 ]; then
        mud_config_usage >&2
        return 1
fi

cmd=$1
shift

case "$cmd" in
        get)
                if [ "$#" -lt 1 ]; then
                        printf '%s\n' "mud-config: get requires a feature name" >&2
                        return 1
                fi
                get_feature "$1"
                ;;
        set)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "mud-config: set requires a feature name and value" >&2
                        return 1
                fi
                set_feature "$1" "$2"
                ;;
        toggle)
                # Toggle feature between 1/0
                if [ "$#" -lt 1 ]; then
                        printf '%s\n' "mud-config: toggle requires a feature name" >&2
                        return 1
                fi
                feature=$1
                current=$(get_feature "$feature")
                if [ "$current" = "1" ]; then
                        set_feature "$feature" "0"
                        printf '%s\n' "0"
                else
                        set_feature "$feature" "1"
                        printf '%s\n' "1"
                fi
                ;;
        list)
                # List all features
                features="command-not-found touch-hook fantasy-theme inventory combat"
                for feature in $features; do
                        value=$(get_feature "$feature")
                        printf '%s=%s\n' "$feature" "$value"
                done
                ;;
        *)
                printf '%s\n' "mud-config: unknown command '$cmd'" >&2
                mud_config_usage >&2
                return 1
                ;;
esac

}

# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="$(cd "$(dirname "$0")" && cd .. && cd .. && pwd)/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="$(cd "$(dirname "$0")" && cd .. && cd .. && pwd)/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
