#!/bin/sh

# The cd cantrip: source this file to enable the cd hook that runs 'look'.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: Source this file in your shell rc file to enable the cd hook.

    . $HOME/.wizardry/spells/.arcana/mud/load-cd-hook

Then use 'toggle-cd' to enable/disable the hook.

The hook runs 'look' after every successful directory change.
USAGE
  exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
cd_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) cd_sourced=1 ;;
  esac
else
  cd_base=${0##*/}
  case "$cd_base" in
    sh|dash|bash|zsh|ksh|mksh) cd_sourced=1 ;;
    load-cd-hook) cd_sourced=0 ;;
    *) cd_sourced=1 ;;
  esac
fi

if [ "$cd_sourced" -eq 0 ]; then
  printf '%s\n' "This spell cannot be cast directly. Invoke it with: . cd" >&2
  return 1 2>/dev/null || exit 1
fi
unset cd_sourced cd_base

# Explicitly use permissive error handling - this file is meant to be sourced into user's shell
# and we don't want their shell to exit on command failures or unset variable references
# Our code is safe without set -u because we use ${VAR:-default} patterns everywhere
set +e
set +u

# The cd override - calls cd-hook imp after successful directory change
cd() {
    # Save readline editing mode (emacs or vi) before doing anything
    # This is critical to prevent readline breakage after cd
    # Capture set -o output once for efficiency
    cd_set_output=$(set -o)
    cd_emacs_mode=$(printf '%s\n' "$cd_set_output" | grep '^emacs' | awk '{print $2}')
    cd_vi_mode=$(printf '%s\n' "$cd_set_output" | grep '^vi' | awk '{print $2}')
    unset cd_set_output
    
    # Use builtin for zsh/bash (where it's required for function override), command for POSIX sh
    # We use eval to check for bash/zsh in a way that won't fail in POSIX sh
    # This is necessary because 'builtin cd' is required in zsh, but doesn't exist in pure POSIX sh
    if eval '[ -n "${BASH_VERSION:-}" ] || [ -n "${ZSH_VERSION:-}" ]' 2>/dev/null; then
        # In bash/zsh, must use 'builtin' to call the actual cd builtin from within override function
        builtin cd "$@"
        cd_exit_code=$?
    else
        command cd "$@"
        cd_exit_code=$?
    fi
    
    # If cd failed, restore readline mode and return the error code
    if [ "$cd_exit_code" -ne 0 ]; then
        cd_return=$cd_exit_code
        unset cd_exit_code
        # Restore readline editing mode before returning
        [ "$cd_emacs_mode" = "on" ] && set -o emacs 2>/dev/null || true
        [ "$cd_vi_mode" = "on" ] && set -o vi 2>/dev/null || true
        unset cd_emacs_mode cd_vi_mode
        return $cd_return
    fi
    
    # cd succeeded, we can unset cd_exit_code now
    unset cd_exit_code
    
    # Run cd-hook logic inline so listen can access PS1
    # (cd-hook is executed, not sourced, so listen wouldn't have PS1 access otherwise)
    
    # Check if cd-look is enabled via config file (defaults to enabled when unset)
    # Skip automatic look if JUMP_TO_MARKER_ACTIVE is set (jump-to-marker handles it)
    cd_config_file="${SPELLBOOK_DIR:-$HOME/.spellbook}/.mud"
    cd_look_value=""
    if [ -f "$cd_config_file" ]; then
        cd_look_value=$(grep "^cd-look=" "$cd_config_file" 2>/dev/null | \
            cut -d= -f2- || printf '')
    fi
    # Default to enabled (1) if not set
    if [ -z "$cd_look_value" ]; then
        cd_look_value=$(command -v mud-defaults >/dev/null 2>&1 && \
            mud-defaults cd-look 2>/dev/null || printf '1')
    fi
    if [ "$cd_look_value" = "1" ] && [ -z "${JUMP_TO_MARKER_ACTIVE-}" ]; then
        command -v look >/dev/null 2>&1 && look 2>/dev/null || true
    fi
    
    # Check if cd-listen is enabled
    cd_listen_value=""
    if [ -f "$cd_config_file" ]; then
        cd_listen_value=$(grep "^cd-listen=" "$cd_config_file" 2>/dev/null | \
            cut -d= -f2- || printf '')
    fi
    # Default to disabled (0) if not set
    if [ -z "$cd_listen_value" ]; then
        cd_listen_value=$(command -v mud-defaults >/dev/null 2>&1 && \
            mud-defaults cd-listen 2>/dev/null || printf '0')
    fi
    if [ "$cd_listen_value" = "1" ]; then
        # Source listen directly so it can access PS1 from this shell context
        if command -v listen >/dev/null 2>&1; then
            . listen 2>/dev/null || true
        fi
    fi
    
    # Move avatar if avatar system is enabled (defaults to disabled when unset)
    cd_avatar_value=""
    if [ -f "$cd_config_file" ]; then
        cd_avatar_value=$(grep "^avatar=" "$cd_config_file" 2>/dev/null | \
            cut -d= -f2- || printf '')
    fi
    # Default to disabled (0) if not set
    if [ -z "$cd_avatar_value" ]; then
        cd_avatar_value=$(command -v mud-defaults >/dev/null 2>&1 && \
            mud-defaults avatar 2>/dev/null || printf '0')
    fi
    if [ "$cd_avatar_value" = "1" ]; then
        command -v move-avatar >/dev/null 2>&1 && move-avatar 2>/dev/null || true
    fi
    
    # Clean up variables
    unset cd_config_file cd_look_value cd_listen_value cd_avatar_value
    
    # Restore readline editing mode to prevent arrow key breakage
    # This is critical - without this, readline gets corrupted after cd
    # Note: emacs and vi are mutually exclusive in normal usage, but we handle both
    # for robustness. If both were somehow 'on', vi takes precedence (last wins).
    [ "$cd_emacs_mode" = "on" ] && set -o emacs 2>/dev/null || true
    [ "$cd_vi_mode" = "on" ] && set -o vi 2>/dev/null || true
    unset cd_emacs_mode cd_vi_mode
}

# Note: We intentionally do NOT set up custom completion for the cd function
# 
# Why: Attempting to restore completion after overriding builtins causes issues:
# - Custom completion functions can break readline on some systems (macOS bash 3.2)
# - bind commands from scripts corrupt readline state
# - Even simple complete flags can cause invisible character rendering
#
# Bash will use default filename completion for the cd function, which works
# adequately for most use cases. Users who want directory-only completion
# can configure it themselves in their ~/.inputrc or .bashrc
#
# If users want to restore directory-only completion, they can add to ~/.bashrc:
#   complete -o dirnames cd
#
# Or for better macOS compatibility, add to ~/.inputrc:
#   set colored-stats off
#   set colored-completion-prefix off

# Explicitly set permissive mode (don't restore saved options)
# This file is sourced into user's shell, must leave it in permissive mode
# to avoid breaking readline (same fix as invoke-wizardry for PR #1053 regression)
set +e
set +u

