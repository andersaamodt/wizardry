#!/bin/sh

# The cd cantrip keeps a tiny shell hook that immediately runs `look`
# after every successful directory change. The hook stays intentionally
# small so wizards can tweak it at a glance while still whispering just
# enough lore to keep the spell recognizable.

show_usage() {
cat <<'USAGE'
Usage: cd [DIRECTORY]
       cd {install|uninstall}

Replace builtin cd so it runs 'look' after each directory change, keeping the MUD view in sync. Use install or uninstall to add or remove the hook from your shell.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

# Add imps to PATH so we can use temp-file, cleanup-file, etc.
# This allows running the spell directly without wizardry being fully installed
_cd_script_source=$0
case $_cd_script_source in
*/*)
        _cd_script_dir=${_cd_script_source%/*}
        ;;
*)
        _cd_script_dir=.
        ;;
esac
_cd_repo_dir=$(CDPATH= cd -- "$_cd_script_dir/../../.." && pwd -P)
if [ -d "$_cd_repo_dir/spells/.imps" ]; then
        for _impdir in "$_cd_repo_dir"/spells/.imps/*; do
                [ -d "$_impdir" ] || continue
                PATH="$_impdir:$PATH"
        done
fi
export PATH

set -eu


SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

warn() {
        printf '%s\n' "cd cantrip: $1" >&2
}

# Run nixos-rebuild or home-manager switch to apply NixOS configuration changes
# This function follows project ethos: automatically fix things instead of telling users to do it.
# Returns 0 if rebuild succeeded, 1 if it could not be run automatically.
run_nix_rebuild() {
        # Allow tests to skip the rebuild
        if [ "${WIZARDRY_SKIP_NIX_REBUILD-}" = "1" ]; then
                return 0
        fi

        rebuild_success=0

        # Try to detect if we should use sudo or doas
        priv_cmd=""
        if command -v sudo >/dev/null 2>&1; then
                priv_cmd="sudo"
        elif command -v doas >/dev/null 2>&1; then
                priv_cmd="doas"
        fi

        # Try home-manager first (doesn't need privileges)
        if command -v home-manager >/dev/null 2>&1; then
                printf '%s\n' "cd cantrip: running home-manager switch..."
                if home-manager switch; then
                        printf '%s\n' "cd cantrip: user environment rebuilt successfully."
                        rebuild_success=1
                fi
        fi

        # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
        if [ "$rebuild_success" -eq 0 ] && \
          [ -n "$priv_cmd" ] && \
          command -v nixos-rebuild >/dev/null 2>&1; then
                printf '%s\n' "cd cantrip: running $priv_cmd nixos-rebuild switch..."
                if "$priv_cmd" nixos-rebuild switch; then
                        printf '%s\n' "cd cantrip: NixOS system rebuilt successfully."
                        rebuild_success=1
                fi
        fi

        if [ "$rebuild_success" -eq 0 ]; then
                warn "NixOS configuration could not be automatically rebuilt."
                return 1
        fi

        return 0
}

# Cache for detect-rc-file output to avoid multiple calls
# This cache is intentionally global so that resolve_rc_file() and resolve_rc_format()
# can share the same detect-rc-file output without running the command multiple times.
_detect_rc_cache=""

run_detect_rc_file() {
        if [ -n "$_detect_rc_cache" ]; then
                printf '%s\n' "$_detect_rc_cache"
                return 0
        fi
        if command -v detect-rc-file >/dev/null 2>&1; then
                if _detect_rc_cache=$(detect-rc-file 2>/dev/null); then
                        printf '%s\n' "$_detect_rc_cache"
                        return 0
                fi
        fi
        return 1
}

resolve_rc_file() {
        if [ -n "${WIZARDRY_RC_FILE-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FILE"
                return 0
        fi

        # Try to use detect-rc-file for cross-platform support
        if detected=$(run_detect_rc_file); then
                # Parse rc_file= line using shell parameter expansion
                while IFS= read -r line; do
                        case $line in
                        rc_file=*)
                                rc_file=${line#rc_file=}
                                if [ -n "$rc_file" ]; then
                                        printf '%s\n' "$rc_file"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi

        # Fallback to shell-specific defaults
        if [ -z "${HOME-}" ]; then
                warn "HOME is not set; cannot determine rc file."
                return 1
        fi

        shell_name=${SHELL-}
        case ${shell_name##*/} in
        zsh)
                printf '%s/.zshrc\n' "$HOME"
                ;;
        *)
                printf '%s/.bashrc\n' "$HOME"
                ;;
        esac
}

resolve_rc_format() {
        # Check env var override first
        if [ -n "${WIZARDRY_RC_FORMAT-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FORMAT"
                return 0
        fi

        # Try to get format from detect-rc-file output
        if detected=$(run_detect_rc_file); then
                while IFS= read -r line; do
                        case $line in
                        format=*)
                                format=${line#format=}
                                if [ -n "$format" ]; then
                                        printf '%s\n' "$format"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi

        # Fallback: detect from file extension
        if rc_file=$(resolve_rc_file 2>/dev/null); then
                case $rc_file in
                *.nix) printf 'nix\n'; return 0 ;;
                esac
        fi

        printf 'shell\n'
}

cd_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Check for shell format marker
        if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file"; then
                return 0
        fi
        # Check for nix format marker (used by nix-shell-add)
        # Note: nix-shell-add adds " # wizardry: cd-cantrip" (with space before #)
        if grep -Eq '#[ ]?wizardry: cd-cantrip' "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        rc_dir=${target%/*}
        [ "$rc_dir" = "$target" ] && rc_dir=.
        if [ -d "$rc_dir" ]; then
                return 0
        fi
        if mkdir -p "$rc_dir"; then
                return 0
        fi
        warn "unable to create directory '$rc_dir'."
        return 1
}

install() {
        # Detect nix format from detect-rc-file output
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1

        # For nix format, use nix-shell-add imp to add shell init code
        if [ "$rc_format" = "nix" ]; then
                # Find nix-shell-add helper
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-add" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-add"
                elif command -v nix-shell-add >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-add)
                fi

                
                if [ -z "$nix_helper" ]; then
                        printf '%s\n' "cd cantrip: nix-shell-add imp not found"\
" for NixOS installation."
                        return 1
                fi

                # Create the shell hook code - uses a function instead of storing path in a variable
                hook_code='cd() { command cd "$@" && { look 2>/dev/null || true; }; }'

                if printf '%s\n' "$hook_code" | "$nix_helper" cd-cantrip "$rc_file" bash; then
                        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
                        # Run nixos-rebuild to apply the changes
                        run_nix_rebuild || true
                else
                        warn "unable to update '$rc_file'."
                        return 1
                fi
                return 0
        fi

        # Standard shell format installation
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(temp-file wizardry-cd) || return 1
        trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        # Use a function instead of storing path in a variable - simpler and no pseudo-global needed
        cat <<'HOOK' >>"$tmp_file"
# >>> wizardry cd cantrip >>>
cd() { command cd "$@" && { look 2>/dev/null || true; }; }
# <<< wizardry cd cantrip <<<
HOOK
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        trap - EXIT HUP INT TERM
        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
}

uninstall() {
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "cd cantrip: no rc file found at '$rc_file'."
                return 0
        fi
        if ! cd_block_present "$rc_file"; then
                printf '%s\n' "cd cantrip: not installed in '$rc_file'."
                return 0
        fi

        # For nix format, use nix-shell-remove to remove the block
        if [ "$rc_format" = "nix" ]; then
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-remove" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-remove"
                elif command -v nix-shell-remove >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-remove)
                fi

                if [ -n "$nix_helper" ]; then
                        if "$nix_helper" cd-cantrip "$rc_file"; then
                                printf '%s\n' "cd cantrip: uninstalled wizardry hooks"\
" from '$rc_file'."
                                # Run nixos-rebuild to apply the changes
                                run_nix_rebuild || true
                                return 0
                        else
                                warn "unable to update '$rc_file'."
                                return 1
                        fi
                fi
                # nix-shell-remove helper not found - warn and attempt shell method fallback
                # This may not work correctly for nix format files
                warn "nix-shell-remove imp not found; attempting shell-style removal"\
" which may not work for nix files."
        fi

        # Shell format: use sed to remove the block
        tmp_file=$(temp-file wizardry-cd) || return 1
        trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
        sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        trap - EXIT HUP INT TERM
        printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
}

locate_ask_yn() {
        if command -v ask-yn >/dev/null 2>&1; then
                command -v ask-yn
                return 0
        fi
        if [ -x "$SCRIPT_DIR/ask-yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/ask-yn"
                return 0
        fi
        if [ -x "$SCRIPT_DIR/cantrips/ask-yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/cantrips/ask-yn"
                return 0
        fi
        warn "ask-yn spell is missing; skipping installation prompt."
        return 1
}

prompt_install_if_needed() {
        rc_file=$(resolve_rc_file) || return
        if cd_block_present "$rc_file"; then
                return
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                return
        fi
        rc_display=$(basename "$rc_file")
        printf '%s\n' "The cd cantrip can sprinkle the 'look' spell on every hop."
        if "$ask_yn_cmd" "Memorize the cd cantrip in $rc_display"\
" so each teleport reveals the room?" yes >/dev/null; then
                install || return
                printf '%s\n' "The hook is etched into $rc_display."
        else
                printf '%s\n' "Very wellâ€”cast 'memorize spells/cantrips/cd'"\
" when you crave automatic scouting."
        fi
}

wizardry_cd_cast_look() {
        if command -v look >/dev/null 2>&1; then
                look "$@"
                return
        fi
        warn "look spell is not available."
}

wizardry_cd_main() {
        # Use 'command cd' to call the builtin cd and avoid alias recursion
        command cd "$@" && wizardry_cd_cast_look
}

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
        install
        exit $?
        ;;
uninstall)
        uninstall
        exit $?
        ;;
esac

# If run directly (not sourced via alias and not install/uninstall),
# prompt to install and then run the cd
if [ -z "${WIZARDRY_MEMORIZE_TARGET-}" ]; then
        prompt_install_if_needed || true
        wizardry_cd_main "$@"
fi
