#!/bin/sh

# Report the installation and runtime status of Bitcoin Lightning.

lightning_status_usage() {
        cat <<'USAGE' >&2
Usage: lightning-status

Reports whether Bitcoin Lightning (lightningd/lightning-cli) is installed and running.
USAGE
}

lightning_status() {
case "${1-}" in
--help|--usage|-h)
        lightning_status_usage
        return 0
        ;;
esac

require-wizardry || return 1


set -eu
. env-clear

if command -v colors >/dev/null 2>&1; then
  # shellcheck source=/dev/null
  . colors
else
  RESET=""
  THEME_SUCCESS=""
  THEME_WARNING=""
  THEME_ERROR=""
  GREY=""
fi
# Older scripts expect GRAY, so mirror GREY when missing.
GRAY=${GREY-}

# Main execution - get_lightning_status inlined
# Determine service name - lightning_service_name inlined
service_name="lightningd"
if [ -n "${LIGHTNING_SERVICE-}" ]; then
  service_name=$LIGHTNING_SERVICE
else
  # Default to lightningd; fallback to clightningd or similar names if present.
  for candidate in lightningd clightningd c-lightning; do
    if has "$candidate" 2>/dev/null; then
      service_name=$candidate
      break
    fi
    if is-service-installed "$candidate" >/dev/null 2>&1; then
      service_name=$candidate
      break
    fi
  done
fi

# Determine status
if has lightning-cli 2>/dev/null || has "$service_name" 2>/dev/null; then
  if is-service-running "$service_name" >/dev/null 2>&1; then
    if lightning-cli getinfo >/dev/null 2>&1; then
      status="installed, running"
    else
      status="installed, needs setup"
    fi
  else
    status="installed, not running"
  fi
else
  status="not installed"
fi

# color_for_status - inlined
color=""
case "$status" in
  "installed, running")
    color="$THEME_SUCCESS"
    ;;
  "installed, not running")
    color="$THEME_WARNING"
    ;;
  "installed, needs setup"|"installed, error")
    color="$THEME_ERROR"
    ;;
  *)
    color="$GRAY"
    ;;
esac

printf "%s%s%s\n" "$color" "$status" "$RESET"

}

# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
