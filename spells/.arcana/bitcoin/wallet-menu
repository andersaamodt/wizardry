#!/bin/sh

# This script is a magical tome of sorcery, commanding the elusive entity known as Bitcoin.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . wallet-menu    OR    wallet menu    (via parse/gloss)

Displays the Bitcoin wallet menu.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

require-wizardry || return 1 2>/dev/null || exit 1

# Uncastable pattern - detect if sourced
wallet_menu_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) wallet_menu_sourced=1 ;;
  esac
else
  wallet_menu_base=${0##*/}
  case "$wallet_menu_base" in
    sh|dash|bash|zsh|ksh|mksh) wallet_menu_sourced=1 ;;
    wallet-menu) wallet_menu_sourced=0 ;;
    parse) wallet_menu_sourced=1 ;;  # Sourced via parse
    *) wallet_menu_sourced=1 ;;
  esac
fi

if [ "$wallet_menu_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . wallet-menu  OR  wallet menu" >&2
  return 1 2>/dev/null || exit 1
fi
unset wallet_menu_sourced wallet_menu_base

set +e  # Permissive mode since we're in user's shell
set -u
. env-clear

# Load colors
if command -v colors >/dev/null 2>&1; then
  # shellcheck source=/dev/null
  . colors
else
  BOLD=""
  CYAN=""
  RESET=""
fi

# Catch Ctrl-C and TERM signal to return cleanly
trap 'return 0' INT TERM

first_run=1

# Main execution loop
while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  # Display wallet menu
  title="${BOLD}${CYAN}Bitcoin Wallet"
  list_wallets="List Wallets%bitcoin-cli listwallets"
  create_wallet="Create Wallet%bitcoin-cli createwallet"
  exit_label=$(exit-label)
  exit_option="${exit_label}%kill -TERM \$PPID"
  
  menu "$title" "$list_wallets" "$create_wallet" "$exit_option" || true
done
