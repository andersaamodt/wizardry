#!/bin/sh

# Bootstrap spell: install and manage the core prerequisites for wizardry.

core_menu_usage() {
  cat <<'USAGE'
Usage: core-menu

Displays the core prerequisites management menu.
USAGE
}

core_menu() {
case "${1-}" in
  --help|--usage|-h)
    core_menu_usage
    return 0
    ;;
esac

require-wizardry || return 1


set -eu
. env-clear
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../../.." && pwd -P)

colors_bin=${COLORS_BIN-}
if [ -z "$colors_bin" ]; then
  colors_bin=$(command -v colors 2>/dev/null)
fi
if [ -z "$colors_bin" ] && [ -x "$root_dir/spells/cantrips/colors" ]; then
  colors_bin="$root_dir/spells/cantrips/colors"
fi
if [ -z "$colors_bin" ]; then
  echo "core-menu: missing dependency: colors" >&2
  exit 1
fi

menu_bin=${MENU_BIN-}
if [ -z "$menu_bin" ]; then
  menu_bin=$(command -v menu 2>/dev/null)
fi
if [ -z "$menu_bin" ] && [ -x "$root_dir/spells/cantrips/menu" ]; then
  menu_bin="$root_dir/spells/cantrips/menu"
fi
if [ -z "$menu_bin" ]; then
  echo "core-menu: missing dependency: menu" >&2
  exit 1
fi

exit_label_bin=${EXIT_LABEL_BIN-}
if [ -z "$exit_label_bin" ]; then
  exit_label_bin=$(command -v exit-label 2>/dev/null) || exit_label_bin=""
fi
if [ -z "$exit_label_bin" ] && [ -x "$root_dir/spells/.imps/menu/exit-label" ]; then
  exit_label_bin="$root_dir/spells/.imps/menu/exit-label"
fi

# shellcheck source=/dev/null
. "$script_dir/install-core"

# shellcheck source=/dev/null
. "$colors_bin"

loop_limit=${MENU_LOOP_LIMIT:-}

if [ -n "$loop_limit" ] && ! printf '%s' "$loop_limit" | grep -Eq '^[0-9]+$'; then
  echo "invalid MENU_LOOP_LIMIT: must be numeric" >&2
  exit 1
fi

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

title="${BOLD}${CYAN}Core prerequisites"
if [ -n "$exit_label_bin" ]; then
  exit_label=$($exit_label_bin)
else
  exit_label="Exit"
fi

# Signal parent process to exit menu loop
exit_entry="${exit_label}%kill -TERM \$PPID"

core_menu_resolve_spell() {
  spell_name=$1

  if command -v "$spell_name" >/dev/null 2>&1; then
    printf '%s\n' "$spell_name"
    return 0
  fi

  if [ -x "$script_dir/$spell_name" ]; then
    printf '%s\n' "$script_dir/$spell_name"
    return 0
  fi

  printf '%s\n' "core-menu: missing helper '$spell_name'" >&2
  return 1
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  set --

  while IFS=: read -r label command_name install_spell uninstall_spell essential; do
    installed=0
    
    # Special handling for clipboard helper marker
    if [ "$command_name" = "__clipboard_helper__" ]; then
      if clipboard_helper_installed; then
        installed=1
      fi
    elif command -v "$command_name" >/dev/null 2>&1; then
      installed=1
    fi

    # Handle essential commands differently
    if [ "$essential" = "1" ]; then
      if [ "$installed" -eq 1 ]; then
        display_label="$label - installed"
      else
        display_label="$label - not installed"
      fi
      # For essential commands, use the install spell if not installed
      # or show the essential message if installed
      if [ "$installed" -eq 1 ]; then
        # When selected, show message that this is essential
        # The label comes from the controlled core_dependencies function
        # and contains only alphanumeric characters, making it safe to use
        set -- "$@" "${display_label}%printf '\\n%s is essential for the shell to function and should not be uninstalled.\\n' '$label'; printf 'Press Enter to continue...'; read dummy"
      else
        spell=$(core_menu_resolve_spell "$install_spell") || return 1
        set -- "$@" "${display_label}%$spell"
      fi
    else
      # Non-essential command handling (original logic)
      if [ "$installed" -eq 1 ]; then
        entry_label="Uninstall $label"
        spell=$(core_menu_resolve_spell "$uninstall_spell") || return 1
      else
        entry_label="Install $label"
        spell=$(core_menu_resolve_spell "$install_spell") || return 1
      fi

      display_label=$entry_label
      if [ "$installed" -eq 1 ]; then
        display_label="$entry_label (installed; select to uninstall â€” Install $label to reinstall)"
      fi

      set -- "$@" "${display_label}%$spell"
    fi
  done <<EOF
$(core_dependencies)
EOF

  set -- "$@" "Install all%ASSUME_YES=1 $script_dir/install-core" "$exit_entry"

  "$menu_bin" "$title" "$@" || true

  if [ -n "$loop_limit" ]; then
    if [ "$loop_limit" -le 1 ] 2>/dev/null; then
      break
    fi
    loop_limit=$((loop_limit - 1))
  fi

done

}

# Load castable imp for direct execution
if true; then  # Always source castable, never use from PATH
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"