#!/bin/sh

# Teleport to a random accessible directory on your computer.
# This spell must be sourced (not executed) because it changes the current directory.

# DEBUG: Start of blink spell
printf '[blink DEBUG] Starting blink spell\n'
printf '[blink DEBUG] Args: %s\n' "$*"
printf '[blink DEBUG] $0 = %s\n' "$0"
printf '[blink DEBUG] Shell: %s\n' "${SHELL:-unknown}"

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . blink [--home] [max-depth]

Teleport to a random directory anywhere on your computer.
By default, searches from root (/) with depth 5.

Options:
  --home      Search from home directory instead of root
  max-depth   Limit how deep to search (default: 5 for root, 4 for home)

Note: This spell must be sourced (use '. blink') to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
printf '[blink DEBUG] Checking if sourced...\n'
_blink_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  printf '[blink DEBUG] ZSH detected, ZSH_VERSION=%s\n' "${ZSH_VERSION:-}"
  printf '[blink DEBUG] ZSH_EVAL_CONTEXT=%s\n' "${ZSH_EVAL_CONTEXT:-}"
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _blink_sourced=1 ;;
  esac
else
  _blink_base=${0##*/}
  printf '[blink DEBUG] Not ZSH, _blink_base=%s\n' "$_blink_base"
  case "$_blink_base" in
    sh|dash|bash|zsh|ksh|mksh) _blink_sourced=1 ;;
    blink) _blink_sourced=0 ;;
    *) _blink_sourced=1 ;;
  esac
fi

printf '[blink DEBUG] _blink_sourced=%s\n' "$_blink_sourced"

if [ "$_blink_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use: . blink" >&2
  printf '%s\n' "(Or ensure wizardry is loaded, then just: blink)" >&2
  printf '[blink DEBUG] ERROR: Not sourced, exiting\n' >&2
  return 1 2>/dev/null || exit 1
fi
unset _blink_sourced _blink_base

printf '[blink DEBUG] Sourced check passed\n'
printf '[blink DEBUG] About to set -eu\n'
set -eu
printf '[blink DEBUG] set -eu completed\n'
printf '[blink DEBUG] About to source env-clear\n'
printf '[blink DEBUG] Checking if env-clear is available...\n'
if command -v env-clear >/dev/null 2>&1; then
  printf '[blink DEBUG] env-clear found in PATH\n'
else
  printf '[blink DEBUG] ERROR: env-clear NOT in PATH\n' >&2
  printf '[blink DEBUG] PATH=%s\n' "$PATH" >&2
  printf '[blink DEBUG] This will fail with set -eu\n' >&2
fi
. env-clear
printf '[blink DEBUG] env-clear completed\n'

# Parse arguments
printf '[blink DEBUG] Parsing arguments\n'
use_home=0
max_depth=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --home)
      use_home=1
      shift
      ;;
    *)
      # Assume it's the depth parameter
      max_depth=$1
      shift
      ;;
  esac
done
printf '[blink DEBUG] Arguments parsed: use_home=%s, max_depth=%s\n' "$use_home" "${max_depth:-default}"

# Set base directory and default depth
printf '[blink DEBUG] Setting base directory\n'
if [ "$use_home" -eq 1 ]; then
  base_dir=$HOME
  default_depth=4
else
  base_dir=/
  default_depth=5
fi

# Use provided depth or default
max_depth=${max_depth:-$default_depth}
printf '[blink DEBUG] base_dir=%s, max_depth=%s\n' "$base_dir" "$max_depth"

# Validate max_depth is a positive integer
case "$max_depth" in
  ''|*[!0-9]*|0)
    printf '%s\n' "blink: max-depth must be a positive integer" >&2
    printf '[blink DEBUG] ERROR: Invalid depth\n' >&2
    set +eu; return 1 2>/dev/null || exit 1
    ;;
esac

# Search for directories - let blink take you anywhere!
printf '[blink DEBUG] Starting directory search\n'
if command -v info >/dev/null 2>&1; then
  info "Scanning for destinations..."
fi

# Use find to get all accessible directories
printf '[blink DEBUG] Creating temp file\n'
temp_list=$(mktemp "${TMPDIR:-/tmp}/blink.XXXXXX")
printf '[blink DEBUG] temp_list=%s\n' "$temp_list"
cleanup_temp() {
  rm -f "$temp_list"
}
trap cleanup_temp EXIT HUP INT TERM

# Find all readable directories, no exclusions (that's part of the fun!)
# Note: find returns non-zero on permission errors, but still outputs accessible dirs
# Use -xdev to stay on the current filesystem (excludes network volumes and mounted drives)
printf '[blink DEBUG] Running find command...\n'
# Temporarily disable set -e because find returns non-zero on permission errors
set +e
find "$base_dir" -xdev -maxdepth "$max_depth" -type d -readable 2>/dev/null > "$temp_list"
find_exit_code=$?
set -e
printf '[blink DEBUG] find completed with exit code %s\n' "$find_exit_code"

# Check if we got any results (don't rely on exit code)
dir_count=$(wc -l < "$temp_list" | tr -d ' ')
printf '[blink DEBUG] Found %s directories\n' "$dir_count"

# If -readable flag found nothing, try without it (macOS compatibility)
if [ "$dir_count" -eq 0 ]; then
  printf '[blink DEBUG] No results with -readable flag, trying without it (macOS compatibility)\n'
  set +e
  find "$base_dir" -xdev -maxdepth "$max_depth" -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  printf '[blink DEBUG] find without -readable completed with exit code %s\n' "$find_exit_code"
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
  printf '[blink DEBUG] Found %s directories without -readable flag\n' "$dir_count"
fi

if [ "$dir_count" -eq 0 ]; then
  # No results from main search, try simpler search at depth 1
  if command -v warn >/dev/null 2>&1; then
    warn "blink: no directories found at depth $max_depth, trying depth 1"
  fi
  printf '[blink DEBUG] No directories found, trying simpler search at depth 1\n'
  set +e
  find "$base_dir" -xdev -maxdepth 1 -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  printf '[blink DEBUG] Fallback find completed with exit code %s\n' "$find_exit_code"
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
  
  if [ "$dir_count" -eq 0 ]; then
    printf '%s\n' "blink: no accessible directories found" >&2
    printf '[blink DEBUG] ERROR: No directories found even at depth 1\n' >&2
    set +eu; return 1 2>/dev/null || exit 1
  fi
fi

if command -v debug >/dev/null 2>&1; then
  debug "Found $dir_count accessible directories"
fi

# Select a random directory using awk
printf '[blink DEBUG] Selecting random directory\n'
destination=$(awk 'BEGIN{srand();}{lines[NR]=$0}END{if(NR==0)exit 1;idx=int(rand()*NR)+1;print lines[idx];}' "$temp_list")
printf '[blink DEBUG] Selected destination: %s\n' "$destination"

if [ -z "$destination" ]; then
  printf '%s\n' "blink: failed to select random destination" >&2
  printf '[blink DEBUG] ERROR: Empty destination\n' >&2
  set +eu; return 1 2>/dev/null || exit 1
fi

if [ ! -d "$destination" ]; then
  printf '%s\n' "blink: selected destination no longer exists" >&2
  printf '[blink DEBUG] ERROR: Destination not a directory\n' >&2
  set +eu; return 1 2>/dev/null || exit 1
fi

# Check if already at destination (handle symlinks by resolving paths)
printf '[blink DEBUG] Checking if already at destination\n'
current_dir=$(pwd -P 2>/dev/null || pwd)
printf '[blink DEBUG] current_dir=%s\n' "$current_dir"
# Use command cd to avoid cd gloss/spell interference (works in all POSIX shells)
dest_resolved=$(command cd "$destination" 2>/dev/null && pwd -P 2>/dev/null || printf '%s' "$destination")
printf '[blink DEBUG] dest_resolved=%s\n' "$dest_resolved"
current_resolved=$(printf '%s' "$current_dir" | sed 's|//|/|g')
dest_resolved=$(printf '%s' "$dest_resolved" | sed 's|//|/|g')

if [ "$current_resolved" = "$dest_resolved" ]; then
  printf '%s\n' "You have already blinked to this location."
  printf '[blink DEBUG] Already at destination, returning\n'
  set +eu; return 0 2>/dev/null || exit 0
fi

# Try to cd to the destination
printf '[blink DEBUG] Attempting to cd to destination\n'
# Use command cd to avoid cd gloss/spell interference (works in all POSIX shells)
if ! command cd "$destination" 2>/dev/null; then
  printf '%s\n' "blink: cannot access destination: $destination" >&2
  printf '[blink DEBUG] ERROR: Cannot cd to destination\n' >&2
  set +eu; return 1 2>/dev/null || exit 1
fi
printf '[blink DEBUG] Successfully changed to destination\n'

# Pick a random blink message
printf '[blink DEBUG] Selecting random message\n'
blink_message=$(cat <<'BLINK_MESSAGES'
Reality stutters, and you blink into existence elsewhere.
Space folds like origami—you arrive in a new location.
A shimmer of displaced air marks your sudden arrival.
The world blurs, then snaps back into focus somewhere new.
You phase through the dimensions and materialize in unfamiliar territory.
A pulse of arcane energy whisks you to another corner of the realm.
Time hiccups; when it resumes, you stand in a different place.
Your atoms scatter and reassemble in a random location.
A flash of violet light, and your surroundings have changed.
The ley-lines tug at your essence, depositing you elsewhere.
You blink, and the world around you has shifted.
A crack in space swallows you and spits you out anew.
Starlight traces your path through the void to here.
Your vision doubles, then halves—you're somewhere else now.
The universe shuffles its cards; you draw a new location.
A whisper of wind, and you've teleported across the filesystem.
Quantum uncertainty resolves in your favor... or not. You're elsewhere.
The fabric of reality wrinkles, and you slip through the crease.
A momentary void, then solid ground beneath your feet again.
Magic crackles as you hop between coordinates.
Your shadow stretches and contracts, pulling you to new ground.
A door that wasn't there opens and closes behind you instantly.
Gravity hiccups, launching you sideways through space.
The air shimmers with displaced probability as you arrive.
You feel the tug of randomness and surrender to it.
BLINK_MESSAGES
)

selected_message=$(printf '%s\n' "$blink_message" | awk 'BEGIN{srand();}{lines[NR]=$0}END{if(NR==0)exit 0;idx=int(rand()*NR)+1;print lines[idx];}')
printf '[blink DEBUG] Selected message: %s\n' "$selected_message"

if [ -n "$selected_message" ]; then
  printf '%s\n' "$selected_message"
fi

# Show current location
printf '[blink DEBUG] Showing current location\n'
printf 'You have blinked to: %s\n' "$(pwd -P)"

# Describe current location if look command exists
if command -v look >/dev/null 2>&1; then
  printf '[blink DEBUG] Running look command\n'
  look 2>/dev/null || true
fi

# Restore shell options before returning
printf '[blink DEBUG] Restoring shell options and returning\n'
set +eu
printf '[blink DEBUG] Blink completed successfully\n'
