#!/bin/sh

# Teleport to a random accessible directory on your computer.
# This spell must be sourced (not executed) because it changes the current directory.

# DEBUG: Start of blink spell
printf '[blink DEBUG] Starting blink spell\n'
printf '[blink DEBUG] Args: %s\n' "$*"
printf '[blink DEBUG] $0 = %s\n' "$0"
printf '[blink DEBUG] Shell: %s\n' "${SHELL:-unknown}"

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . blink [--home] [max-depth]

Teleport to a random directory anywhere on your computer.
By default, searches from root (/) with depth 5.

Options:
  --home      Search from home directory instead of root
  max-depth   Limit how deep to search (default: 5 for root, 4 for home)

Note: This spell must be sourced (use '. blink') to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
printf '[blink DEBUG] Checking if sourced...\n'
_blink_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  printf '[blink DEBUG] ZSH detected, ZSH_VERSION=%s\n' "${ZSH_VERSION:-}"
  printf '[blink DEBUG] ZSH_EVAL_CONTEXT=%s\n' "${ZSH_EVAL_CONTEXT:-}"
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _blink_sourced=1 ;;
  esac
else
  _blink_base=${0##*/}
  printf '[blink DEBUG] Not ZSH, _blink_base=%s\n' "$_blink_base"
  case "$_blink_base" in
    sh|dash|bash|zsh|ksh|mksh) _blink_sourced=1 ;;
    blink) _blink_sourced=0 ;;
    *) _blink_sourced=1 ;;
  esac
fi

printf '[blink DEBUG] _blink_sourced=%s\n' "$_blink_sourced"

if [ "$_blink_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use: . blink" >&2
  printf '%s\n' "(Or ensure wizardry is loaded, then just: blink)" >&2
  printf '[blink DEBUG] ERROR: Not sourced, exiting\n' >&2
  return 1 2>/dev/null || exit 1
fi
unset _blink_sourced _blink_base

printf '[blink DEBUG] Sourced check passed\n'
printf '[blink DEBUG] About to set -eu\n'
set -eu
printf '[blink DEBUG] set -eu completed\n'
printf '[blink DEBUG] About to source env-clear\n'
printf '[blink DEBUG] Checking if env-clear is available...\n'
if command -v env-clear >/dev/null 2>&1; then
  printf '[blink DEBUG] env-clear found in PATH\n'
else
  printf '[blink DEBUG] ERROR: env-clear NOT in PATH\n' >&2
  printf '[blink DEBUG] PATH=%s\n' "$PATH" >&2
  printf '[blink DEBUG] This will fail with set -eu\n' >&2
fi
. env-clear
printf '[blink DEBUG] env-clear completed\n'

# Parse arguments
printf '[blink DEBUG] Parsing arguments\n'
use_home=0
max_depth=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --home)
      use_home=1
      shift
      ;;
    *)
      # Assume it's the depth parameter
      max_depth=$1
      shift
      ;;
  esac
done
printf '[blink DEBUG] Arguments parsed: use_home=%s, max_depth=%s\n' "$use_home" "${max_depth:-default}"

# Set base directory and default depth
printf '[blink DEBUG] Setting base directory\n'
if [ "$use_home" -eq 1 ]; then
  base_dir=$HOME
  default_depth=4
else
  base_dir=/
  default_depth=5
fi

# Use provided depth or default
max_depth=${max_depth:-$default_depth}
printf '[blink DEBUG] base_dir=%s, max_depth=%s\n' "$base_dir" "$max_depth"

# Validate max_depth is a positive integer
case "$max_depth" in
  ''|*[!0-9]*|0)
    printf '%s\n' "blink: max-depth must be a positive integer" >&2
    printf '[blink DEBUG] ERROR: Invalid depth\n' >&2
    set +eu; return 1 2>/dev/null || exit 1
    ;;
esac

# Search for directories - let blink take you anywhere!
printf '[blink DEBUG] Starting directory search\n'
if command -v info >/dev/null 2>&1; then
  info "Scanning for destinations..."
fi

# Use find to get all accessible directories
printf '[blink DEBUG] Creating temp file\n'
temp_list=$(mktemp "${TMPDIR:-/tmp}/blink.XXXXXX")
printf '[blink DEBUG] temp_list=%s\n' "$temp_list"
cleanup_temp() {
  rm -f "$temp_list"
}
trap cleanup_temp EXIT HUP INT TERM

# Find all readable directories, no exclusions (that's part of the fun!)
# Note: find returns non-zero on permission errors, but still outputs accessible dirs
# Use -xdev to stay on the current filesystem (excludes network volumes and mounted drives)
printf '[blink DEBUG] Running find command...\n'
# Temporarily disable set -e because find returns non-zero on permission errors
set +e
find "$base_dir" -xdev -maxdepth "$max_depth" -type d -readable 2>/dev/null > "$temp_list"
find_exit_code=$?
set -e
printf '[blink DEBUG] find completed with exit code %s\n' "$find_exit_code"

# Check if we got any results (don't rely on exit code)
dir_count=$(wc -l < "$temp_list" | tr -d ' ')
printf '[blink DEBUG] Found %s directories\n' "$dir_count"

# If -readable flag found nothing, try without it (macOS compatibility)
if [ "$dir_count" -eq 0 ]; then
  printf '[blink DEBUG] No results with -readable flag, trying without it (macOS compatibility)\n'
  set +e
  find "$base_dir" -xdev -maxdepth "$max_depth" -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  printf '[blink DEBUG] find without -readable completed with exit code %s\n' "$find_exit_code"
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
  printf '[blink DEBUG] Found %s directories without -readable flag\n' "$dir_count"
fi

if [ "$dir_count" -eq 0 ]; then
  # No results from main search, try simpler search at depth 1
  if command -v warn >/dev/null 2>&1; then
    warn "blink: no directories found at depth $max_depth, trying depth 1"
  fi
  printf '[blink DEBUG] No directories found, trying simpler search at depth 1\n'
  set +e
  find "$base_dir" -xdev -maxdepth 1 -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  printf '[blink DEBUG] Fallback find completed with exit code %s\n' "$find_exit_code"
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
  
  if [ "$dir_count" -eq 0 ]; then
    printf '%s\n' "blink: no accessible directories found" >&2
    printf '[blink DEBUG] ERROR: No directories found even at depth 1\n' >&2
    set +eu; return 1 2>/dev/null || exit 1
  fi
fi

if command -v debug >/dev/null 2>&1; then
  debug "Found $dir_count accessible directories"
fi

# Select a random accessible directory (retry up to 50 times if needed)
# Note: On macOS, most system directories exist but can't be accessed, so we need many retries
printf '[blink DEBUG] Selecting random accessible directory\n'
current_dir=$(pwd -P 2>/dev/null || pwd)
current_resolved=$(printf '%s' "$current_dir" | sed 's|//|/|g')
max_attempts=50
attempt=0

while [ "$attempt" -lt "$max_attempts" ]; do
  attempt=$((attempt + 1))
  printf '[blink DEBUG] Attempt %s of %s\n' "$attempt" "$max_attempts"
  
  # Use shell arithmetic for randomness
  # Combine PID, attempt number, and microseconds from date for maximum entropy
  # On systems without date +%N, fall back to seconds only
  time_seed=$(date +%N 2>/dev/null || date +%s)
  random_line=$(( (($$ * 7 + attempt * 13 + time_seed) % dir_count) + 1 ))
  destination=$(sed -n "${random_line}p" "$temp_list")
  printf '[blink DEBUG] Selected destination: %s\n' "$destination"
  
  if [ -z "$destination" ]; then
    printf '[blink DEBUG] Empty destination, trying again\n'
    continue
  fi
  
  if [ ! -d "$destination" ]; then
    printf '[blink DEBUG] Destination not a directory, trying again\n'
    continue
  fi
  
  # Check if we can actually cd to this directory
  # Use command cd to avoid cd gloss/spell interference (works in all POSIX shells)
  printf '[blink DEBUG] About to test cd to: %s\n' "$destination"
  printf '[blink DEBUG] Current directory before cd: %s\n' "$(pwd)"
  if ! command cd "$destination" 2>/dev/null; then
    printf '[blink DEBUG] cd command failed (exit code: %s)\n' "$?"
    printf '[blink DEBUG] Cannot access destination, trying another\n'
    continue
  fi
  printf '[blink DEBUG] cd command succeeded\n'
  printf '[blink DEBUG] Current directory after cd: %s\n' "$(pwd)"
  
  # Get the resolved path
  dest_resolved=$(pwd -P 2>/dev/null || pwd)
  dest_resolved=$(printf '%s' "$dest_resolved" | sed 's|//|/|g')
  printf '[blink DEBUG] dest_resolved=%s\n' "$dest_resolved"
  printf '[blink DEBUG] current_resolved=%s\n' "$current_resolved"
  
  # Check if already at this location
  if [ "$current_resolved" = "$dest_resolved" ]; then
    printf '[blink DEBUG] Already at this location, trying another\n'
    # Return to original directory before trying again
    command cd "$current_dir" 2>/dev/null || true
    continue
  fi
  
  # Success! We found an accessible directory that's different from current
  # We're already there from the cd on line 216, so just break
  printf '[blink DEBUG] Successfully changed to destination\n'
  break
done

# Check if we failed all attempts
if [ "$attempt" -ge "$max_attempts" ]; then
  printf '%s\n' "blink: could not find an accessible destination after $max_attempts attempts" >&2
  printf '[blink DEBUG] ERROR: Failed all attempts\n' >&2
  set +eu; return 1 2>/dev/null || exit 1
fi

# Pick a random blink message
printf '[blink DEBUG] Selecting random message\n'
blink_message=$(cat <<'BLINK_MESSAGES'
Reality stutters, and you blink into existence elsewhere.
Space folds like origami—you arrive in a new location.
A shimmer of displaced air marks your sudden arrival.
The world blurs, then snaps back into focus somewhere new.
You phase through the dimensions and materialize in unfamiliar territory.
A pulse of arcane energy whisks you to another corner of the realm.
Time hiccups; when it resumes, you stand in a different place.
Your atoms scatter and reassemble in a random location.
A flash of violet light, and your surroundings have changed.
The ley-lines tug at your essence, depositing you elsewhere.
You blink, and the world around you has shifted.
A crack in space swallows you and spits you out anew.
Starlight traces your path through the void to here.
Your vision doubles, then halves—you're somewhere else now.
The universe shuffles its cards; you draw a new location.
A whisper of wind, and you've teleported across the filesystem.
Quantum uncertainty resolves in your favor... or not. You're elsewhere.
The fabric of reality wrinkles, and you slip through the crease.
A momentary void, then solid ground beneath your feet again.
Magic crackles as you hop between coordinates.
Your shadow stretches and contracts, pulling you to new ground.
A door that wasn't there opens and closes behind you instantly.
Gravity hiccups, launching you sideways through space.
The air shimmers with displaced probability as you arrive.
You feel the tug of randomness and surrender to it.
BLINK_MESSAGES
)

# Count messages and select one using shell arithmetic with time-based entropy
message_count=$(printf '%s\n' "$blink_message" | wc -l | tr -d ' ')
if [ "$message_count" -gt 0 ]; then
  msg_time_seed=$(date +%N 2>/dev/null || date +%s)
  random_msg_line=$(( (($$ * 11 + msg_time_seed) % message_count) + 1 ))
  selected_message=$(printf '%s\n' "$blink_message" | sed -n "${random_msg_line}p")
  printf '[blink DEBUG] Selected message: %s\n' "$selected_message"
else
  selected_message=""
  printf '[blink DEBUG] No messages available\n'
fi

if [ -n "$selected_message" ]; then
  printf '%s\n' "$selected_message"
fi

# Show current location
printf '[blink DEBUG] Showing current location\n'
printf 'You have blinked to: %s\n' "$(pwd -P)"

# Describe current location if look command exists
if command -v look >/dev/null 2>&1; then
  printf '[blink DEBUG] Running look command\n'
  look 2>/dev/null || true
fi

# Restore shell options before returning
printf '[blink DEBUG] Restoring shell options and returning\n'
set +eu
printf '[blink DEBUG] Blink completed successfully\n'
