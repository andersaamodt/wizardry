#!/bin/sh

# Teleport to a random accessible directory on your computer.
# This spell must be sourced (not executed) because it changes the current directory.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . blink [--home] [max-depth]

Teleport to a random directory anywhere on your computer.
By default, searches from root (/) with depth 5.

Options:
  --home      Search from home directory instead of root
  max-depth   Limit how deep to search (default: 5 for root, 4 for home)

Note: This spell must be sourced (use '. blink') to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
_blink_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _blink_sourced=1 ;;
  esac
else
  _blink_base=${0##*/}
  case "$_blink_base" in
    sh|dash|bash|zsh|ksh|mksh) _blink_sourced=1 ;;
    blink) _blink_sourced=0 ;;
    *) _blink_sourced=1 ;;
  esac
fi

if [ "$_blink_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use: . blink" >&2
  printf '%s\n' "(Or ensure wizardry is loaded, then just: blink)" >&2
  return 1 2>/dev/null || exit 1
fi
unset _blink_sourced _blink_base

set -eu
. env-clear

# Parse arguments
use_home=0
max_depth=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --home)
      use_home=1
      shift
      ;;
    *)
      # Assume it's the depth parameter
      max_depth=$1
      shift
      ;;
  esac
done

# Set base directory and default depth
if [ "$use_home" -eq 1 ]; then
  base_dir=$HOME
  default_depth=4
else
  base_dir=/
  default_depth=5
fi

# Use provided depth or default
max_depth=${max_depth:-$default_depth}

# Validate max_depth is a positive integer
case "$max_depth" in
  ''|*[!0-9]*|0)
    printf '%s\n' "blink: max-depth must be a positive integer" >&2
    set +eu; return 1 2>/dev/null || exit 1
    ;;
esac

# Search for directories - let blink take you anywhere!
if command -v info >/dev/null 2>&1; then
  info "Scanning for destinations..."
fi

# Use find to get all accessible directories
temp_list=$(mktemp "${TMPDIR:-/tmp}/blink.XXXXXX")
cleanup_temp() {
  rm -f "$temp_list"
}
trap cleanup_temp EXIT HUP INT TERM

# Find all readable directories, no exclusions (that's part of the fun!)
# Note: find returns non-zero on permission errors, but still outputs accessible dirs
# Use -xdev to stay on the current filesystem (excludes network volumes and mounted drives)
# Temporarily disable set -e because find returns non-zero on permission errors
set +e
find "$base_dir" -xdev -maxdepth "$max_depth" -type d -readable 2>/dev/null > "$temp_list"
find_exit_code=$?
set -e

# Check if we got any results (don't rely on exit code)
dir_count=$(wc -l < "$temp_list" | tr -d ' ')

# If -readable flag found nothing, try without it (macOS compatibility)
if [ "$dir_count" -eq 0 ]; then
  set +e
  find "$base_dir" -xdev -maxdepth "$max_depth" -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
fi

if [ "$dir_count" -eq 0 ]; then
  # No results from main search, try simpler search at depth 1
  if command -v warn >/dev/null 2>&1; then
    warn "blink: no directories found at depth $max_depth, trying depth 1"
  fi
  set +e
  find "$base_dir" -xdev -maxdepth 1 -type d 2>/dev/null > "$temp_list"
  find_exit_code=$?
  set -e
  dir_count=$(wc -l < "$temp_list" | tr -d ' ')
  
  if [ "$dir_count" -eq 0 ]; then
    printf '%s\n' "blink: no accessible directories found" >&2
    set +eu; return 1 2>/dev/null || exit 1
  fi
fi

if command -v debug >/dev/null 2>&1; then
  debug "Found $dir_count accessible directories"
fi

# Select a random accessible directory (retry up to 50 times if needed)
# Note: On macOS, most system directories exist but can't be accessed, so we need many retries
current_dir=$(pwd -P 2>/dev/null || pwd)
current_resolved=$(printf '%s' "$current_dir" | sed 's|//|/|g')
max_attempts=50
attempt=0

while [ "$attempt" -lt "$max_attempts" ]; do
  attempt=$((attempt + 1))
  
  # Use shell arithmetic for randomness
  # Combine PID, attempt number, and time-based seed for maximum entropy
  # Try nanoseconds first, fall back to seconds if not supported
  time_seed=$(date +%N 2>/dev/null || echo "0")
  # Validate time_seed is a number (on some systems, date +%N returns "N")
  case "$time_seed" in
    *[!0-9]*) time_seed=$(date +%s) ;;
  esac
  # Strip leading zeros to avoid octal interpretation (08 and 09 are invalid)
  time_seed=$(printf '%s' "$time_seed" | sed 's/^0*//')
  # Handle empty string after stripping (when time_seed was "0" or "000...")
  time_seed=${time_seed:-0}
  random_line=$(( (($$ * 7 + attempt * 13 + time_seed) % dir_count) + 1 ))
  destination=$(sed -n "${random_line}p" "$temp_list")
  
  if [ -z "$destination" ]; then
    continue
  fi
  
  if [ ! -d "$destination" ]; then
    continue
  fi
  
  # Resolve destination path (in subshell to avoid changing directory during test)
  # Use command cd to avoid cd gloss/spell interference (works in all POSIX shells)
  # Use same pattern as jump-to-marker
  dest_resolved=$(command cd "$destination" 2>/dev/null && pwd -P | sed 's|//|/|g')
  if [ -z "$dest_resolved" ]; then
    continue
  fi
  
  # Check if already at this location
  if [ "$current_resolved" = "$dest_resolved" ]; then
    continue
  fi
  
  # Success! We found an accessible directory that's different from current
  # Now do the ACTUAL cd (not in a subshell)
  if ! command cd "$destination"; then
    continue
  fi
  break
done

# Check if we failed all attempts
if [ "$attempt" -ge "$max_attempts" ]; then
  printf '%s\n' "blink: could not find an accessible destination after $max_attempts attempts" >&2
  set +eu; return 1 2>/dev/null || exit 1
fi

# Pick a random blink message
blink_message=$(cat <<'BLINK_MESSAGES'
Reality stutters, and you blink into existence elsewhere.
Space folds like origami—you arrive in a new location.
A shimmer of displaced air marks your sudden arrival.
The world blurs, then snaps back into focus somewhere new.
You phase through the dimensions and materialize in unfamiliar territory.
A pulse of arcane energy whisks you to another corner of the realm.
Time hiccups; when it resumes, you stand in a different place.
Your atoms scatter and reassemble in a random location.
A flash of violet light, and your surroundings have changed.
The ley-lines tug at your essence, depositing you elsewhere.
You blink, and the world around you has shifted.
A crack in space swallows you and spits you out anew.
Starlight traces your path through the void to here.
Your vision doubles, then halves—you're somewhere else now.
The universe shuffles its cards; you draw a new location.
A whisper of wind, and you've teleported across the filesystem.
Quantum uncertainty resolves in your favor... or not. You're elsewhere.
The fabric of reality wrinkles, and you slip through the crease.
A momentary void, then solid ground beneath your feet again.
Magic crackles as you hop between coordinates.
Your shadow stretches and contracts, pulling you to new ground.
A door that wasn't there opens and closes behind you instantly.
Gravity hiccups, launching you sideways through space.
The air shimmers with displaced probability as you arrive.
You feel the tug of randomness and surrender to it.
BLINK_MESSAGES
)

# Count messages and select one using shell arithmetic with time-based entropy
message_count=$(printf '%s\n' "$blink_message" | wc -l | tr -d ' ')
if [ "$message_count" -gt 0 ]; then
  msg_time_seed=$(date +%N 2>/dev/null || date +%s)
  # Strip leading zeros from time seed to avoid octal interpretation
  msg_time_seed=$(printf '%s' "$msg_time_seed" | sed 's/^0*//')
  msg_time_seed=${msg_time_seed:-0}
  random_msg_line=$(( (($$ * 11 + msg_time_seed) % message_count) + 1 ))
  selected_message=$(printf '%s\n' "$blink_message" | sed -n "${random_msg_line}p")
else
  selected_message=""
fi

if [ -n "$selected_message" ]; then
  printf '%s\n' "$selected_message"
fi

# Show current location
printf 'You have blinked to: %s\n' "$(pwd -P)"

# Describe current location if look command exists
if command -v look >/dev/null 2>&1; then
  look 2>/dev/null || true
fi

# Restore shell options before returning
set +eu
