#!/bin/sh

# Inscribe bookmarks for jump-to-marker to teleport you back.

require-wizardry || return 1

mark_location_usage() {
  cat <<'USAGE'
Usage: mark-location [marker] [path]

Record the current directory (or path) for jump-to-marker to return to later.
Markers are stored in $SPELLBOOK_DIR/.markers/.
USAGE
}


mark_location() {
case "${1-}" in
--help|--usage|-h)
  mark_location_usage
  return 0
  ;;
esac

set -eu
. env-clear

if [ "$#" -gt 2 ]; then
  mark_location_usage
  return 1
fi

spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
markers_dir="$spell_home/.markers"

# Store the markers in $SPELLBOOK_DIR/.markers/ (persists across wizardry resets).
make dir "$markers_dir" || return 1

# Determine marker name: if first arg looks like a path, it's the path, not name
marker_name=""
target_path=""

if [ "$#" -eq 0 ]; then
  # No args: auto-increment marker, mark current directory
  target_path=""
elif [ "$#" -eq 1 ]; then
  # One arg: could be marker name OR path
  # Treat as path if it contains / or starts with . or ~, otherwise marker name
  case "$1" in
    /*|./*|../*|~|~/*)
      # Looks like a path
      target_path="$1"
      ;;
    *)
      # Treat as marker name if it exists as directory, otherwise as marker
      if [ -d "$1" ]; then
        target_path="$1"
      else
        marker_name="$1"
      fi
      ;;
  esac
else
  # Two args: first is marker, second is path
  marker_name="$1"
  target_path="$2"
fi

# Get next marker number if no name given using O_EXCL loop
# This finds the first available number without needing a .next file
if [ -z "$marker_name" ]; then
  n=1
  while [ -e "$markers_dir/$n" ]; do
    n=$((n + 1))
  done
  marker_name=$n
fi

# Validate marker name (alphanumeric, dashes, underscores only)
case "$marker_name" in
  *[!A-Za-z0-9_-]*)
    warn "mark-location: marker name may only contain letters, numbers, dashes, and underscores."
    return 1
    ;;
esac

# Determine destination path
if [ -z "$target_path" ]; then
  destination=$(here)
else
  case "$target_path" in
    /*)
      if [ -d "$target_path" ]; then
        destination=$(cd "$target_path" && here)
      else
        destination="$(cd "$(dirname "$target_path")" && here)/$(basename "$target_path")"
      fi
      ;;
    "~/"*)
      if is set "${HOME-}"; then
        destination="$HOME/${target_path#"~/"}"
      else
        destination="$target_path"
      fi
      ;;
    "~")
      if is set "${HOME-}"; then
        destination="$HOME"
      else
        destination="$target_path"
      fi
      ;;
    *)
      destination="$(here)/$target_path"
      ;;
  esac
  gone "$destination" && { warn "mark-location: $target_path does not exist."; return 1; }
fi

# Normalize any double slashes in the path (can occur on macOS where TMPDIR ends with /)
destination=$(norm-path "$destination")

marker_file="$markers_dir/$marker_name"
say "$destination" >"$marker_file"
say "Marked location $marker_name at $destination."
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
