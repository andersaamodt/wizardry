#!/bin/sh

# This spell sets or updates the priority of a file within a directory using echelons.
# Files are organized using both echelon (tier) and priority (order within tier) attributes.
# Use it to organize files by importance using extended attributes.

case "${1-}" in
--help|--usage|-h)
  cat << 'USAGE'
Usage: prioritize [--interactive] <file>
       prioritize --interactive

Promote a file to the highest echelon or create a new higher echelon. Files are organized using echelon (tier) and priority (order within tier) attributes stored in the file's extended attributes.

Higher echelon numbers appear first in the list. Within an echelon, items are ordered by priority number (lower priority numbers first).

With --interactive, prompts for the file to prioritize.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Check for --interactive flag
interactive=0
if [ "${1-}" = "--interactive" ]; then
  interactive=1
  shift
fi

# If interactive mode and no file argument, prompt for it
if [ "$interactive" -eq 1 ] && [ -z "${1-}" ]; then
  if ! command -v ask-text >/dev/null 2>&1; then
    printf '%s\n' "prioritize: ask-text command required for interactive mode" >&2
    exit 1
  fi
  file=$(ask-text "What to prioritize?") || {
    printf '%s\n' "prioritize: no input provided" >&2
    exit 1
  }
  if [ -z "$file" ]; then
    printf '%s\n' "prioritize: file path required" >&2
    exit 2
  fi
else
  # Ensure file argument is provided
  if [ -z "${1-}" ]; then
    printf '%s\n' "prioritize: file path required" >&2
    exit 2
  fi
  file=$1
fi

# Check if the target file exists
if [ ! -e "$file" ]; then
  # Ask to create the file if it doesn't exist
  if ask-yn "'$file' does not exist. Create it?" yes; then
    touch "$file" || {
      printf '%s\n' "prioritize: failed to create file: $file" >&2
      exit 1
    }
  else
    exit 1
  fi
fi

# Hash the target file for identification (still needed for checked/unchecked tracking)
if ! hashchant "$file" >/dev/null 2>&1; then
  printf '%s\n' "prioritize: failed to hash file: $file" >&2
  printf '%s\n' "prioritize: extended attributes (xattr) may not be supported on this filesystem" >&2
  exit 1
fi

# Get the directory the file is in
directory=$(dirname "$file")
if [ "$directory" = "." ]; then
  directory=$(pwd -P)
fi

# Get the file's current echelon and priority
current_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
case "$current_echelon" in
  *Error*|''|*[!0-9]*) current_echelon=0 ;;
esac

current_priority=$(read-magic "$file" priority 2>/dev/null || printf '0')
case "$current_priority" in
  *Error*|''|*[!0-9]*) current_priority=0 ;;
esac

# Check if file is checked, and uncheck it when prioritizing
checked_value=$(read-magic "$file" checked 2>/dev/null || printf '0')
case "$checked_value" in
  *Error*|''|*[!0-9]*) checked_value=0 ;;
esac

if [ "$checked_value" = "1" ]; then
  enchant "$file" checked 0 >/dev/null
fi

# Find the highest echelon in the directory
highest_echelon=0
for f in "$directory"/*; do
  [ -e "$f" ] || continue
  
  file_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
  case "$file_echelon" in
    *Error*|''|*[!0-9]*) continue ;;
  esac
  
  if [ "$file_echelon" -gt "$highest_echelon" ]; then
    highest_echelon=$file_echelon
  fi
done

# If this is the first priority, set echelon=1, priority=1
if [ "$highest_echelon" -eq 0 ]; then
  enchant "$file" echelon 1 >/dev/null
  enchant "$file" priority 1 >/dev/null
  printf '%s\n' "Prioritized '$(basename "$file")' as the first priority."
  exit 0
fi

# If file is already at the highest echelon, promote to new echelon
if [ "$current_echelon" -eq "$highest_echelon" ] && [ "$current_echelon" -gt 0 ]; then
  new_echelon=$((highest_echelon + 1))
  enchant "$file" echelon "$new_echelon" >/dev/null
  enchant "$file" priority 1 >/dev/null
  printf '%s\n' "Promoted '$(basename "$file")' to echelon $new_echelon."
  exit 0
fi

# File is not in highest echelon - move it to the highest echelon
# Find the highest priority number in the highest echelon
highest_priority_in_echelon=0
for f in "$directory"/*; do
  [ -e "$f" ] || continue
  
  file_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
  case "$file_echelon" in
    *Error*|''|*[!0-9]*) continue ;;
  esac
  
  # Only look at files in the highest echelon
  if [ "$file_echelon" -eq "$highest_echelon" ]; then
    file_priority=$(read-magic "$f" priority 2>/dev/null || printf '0')
    case "$file_priority" in
      *Error*|''|*[!0-9]*) continue ;;
    esac
    
    if [ "$file_priority" -gt "$highest_priority_in_echelon" ]; then
      highest_priority_in_echelon=$file_priority
    fi
  fi
done

# Set to highest echelon with priority at the end (highest + 1)
new_priority=$((highest_priority_in_echelon + 1))
enchant "$file" echelon "$highest_echelon" >/dev/null
enchant "$file" priority "$new_priority" >/dev/null

printf '%s\n' "Moved '$(basename "$file")' to echelon $highest_echelon (priority $new_priority)."
