#!/bin/sh

# This spell sets or updates the priority of a file within a directory.
# Use it to organize files by importance using extended attributes.

case "${1-}" in
--help|--usage|-h)
  cat << 'USAGE'
Usage: prioritize <file> [directory]

Set or update the priority of a file, storing it in the file's extended attributes and the directory's priorities list. If no directory is specified, the file's parent directory is used.
USAGE
  exit 0
  ;;
esac

set -eu

# Ensure file argument is provided
if [ -z "${1-}" ]; then
  printf '%s\n' "prioritize: file path required" >&2
  exit 2
fi

file=$1
directory=${2-}

# Check if the target file exists
if [ ! -f "$file" ]; then
  printf '%s\n' "prioritize: file not found: $file" >&2
  exit 1
fi

# Hash the target file for identification
hashchant "$file" >/dev/null
target_hash=$(read-magic "$file" hash 2>/dev/null || true)

if [ -z "$target_hash" ] || [ "${target_hash#Error}" != "$target_hash" ]; then
  printf '%s\n' "prioritize: failed to hash file: $file" >&2
  exit 1
fi

# Get the directory the file is in, if a target directory was not provided
if [ -z "$directory" ]; then
  directory=$(dirname "$file")
  if [ "$directory" = "." ]; then
    directory=$(pwd -P)
  fi
fi

# Get the file's priority, or default to 0
target_priority=$(read-magic "$file" priority 2>/dev/null || printf '0')
case "$target_priority" in
  *Error*|''|*[!0-9]*) target_priority=0 ;;
esac

# Retrieve the priority list from the directory's extended attributes
priorities=$(read-magic "$directory" priorities 2>/dev/null || true)

# If there are no priorities, add the target file as the only priority
case "$priorities" in
  ''|*Error*)
    enchant "$directory" priorities "$target_hash" >/dev/null
    enchant "$file" priority 1 >/dev/null
    printf '%s\n' "Prioritized '$(basename "$file")' as the first priority."
    exit 0
    ;;
esac

# Get the priority of the first item in the current list of priorities
first_hash=$(printf '%s' "$priorities" | cut -d',' -f1)

# If the target file is already the first priority, exit
if [ "$target_hash" = "$first_hash" ]; then
  printf '%s\n' "'$(basename "$file")' is already the highest priority."
  exit 0
fi

# Filter the target hash from the current priorities list to avoid duplicates
# Using sed to remove the target hash from the comma-separated list
filtered=$(printf '%s' "$priorities" | sed "s/^${target_hash},//;s/,${target_hash},/,/;s/,${target_hash}\$//;s/^${target_hash}\$//")
# Remove trailing comma if any
filtered=${filtered%,}

# Prepend the target hash to make it highest priority
new_priorities="$target_hash"
if [ -n "$filtered" ]; then
  new_priorities="$target_hash,$filtered"
fi

# Calculate the new priority value (one higher than current highest)
new_priority=$((target_priority + 1))

# Update the file's priority and the directory's priority list
enchant "$file" priority "$new_priority" >/dev/null
enchant "$directory" priorities "$new_priorities" >/dev/null

printf '%s\n' "Prioritized '$(basename "$file")'."
