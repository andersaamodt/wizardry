#!/bin/sh

# This spell sets or updates the priority of a file within a directory using echelons.
# Files are organized using both echelon (tier) and priority (order within tier) attributes.
# Use it to organize files by importance using extended attributes.

case "${1-}" in
--help|--usage|-h)
  cat << 'USAGE'
Usage: prioritize [--interactive] [--yes|-y] <file>
       prioritize --interactive [--yes|-y]

Promote a file to the highest echelon or create a new higher echelon. Files are organized using echelon (tier) and priority (order within tier) attributes stored in the file's extended attributes.

Higher echelon numbers appear first in the list. Within an echelon, items are ordered by priority number (lower priority numbers first).

With --interactive, prompts for the file to prioritize.
With --yes or -y, automatically creates the file if it doesn't exist without prompting.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Check for flags
interactive=0
auto_create=0
while [ $# -gt 0 ]; do
  case "${1-}" in
    --interactive)
      interactive=1
      shift
      ;;
    --yes|-y)
      auto_create=1
      shift
      ;;
    *)
      break
      ;;
  esac
done

# If interactive mode and no file argument, prompt for it
if [ "$interactive" -eq 1 ] && [ -z "${1-}" ]; then
  if ! command -v ask-text >/dev/null 2>&1; then
    printf '%s\n' "prioritize: ask-text command required for interactive mode" >&2
    exit 1
  fi
  file=$(ask-text "What to prioritize?") || {
    printf '%s\n' "prioritize: no input provided" >&2
    exit 1
  }
  if [ -z "$file" ]; then
    printf '%s\n' "prioritize: file path required" >&2
    exit 2
  fi
else
  # Ensure file argument is provided
  if [ -z "${1-}" ]; then
    printf '%s\n' "prioritize: file path required" >&2
    exit 2
  fi
  file=$1
fi

# Check if the target file exists
if [ ! -e "$file" ]; then
  # Ask to create the file if it doesn't exist (unless --yes/-y is used)
  if [ "$auto_create" -eq 1 ]; then
    # Auto-create without prompting
    touch "$file" || {
      printf '%s\n' "prioritize: failed to create file: $file" >&2
      exit 1
    }
  elif ask-yn "'$file' does not exist. Create it?" yes; then
    touch "$file" || {
      printf '%s\n' "prioritize: failed to create file: $file" >&2
      exit 1
    }
  else
    exit 1
  fi
fi

# Hash the target file for identification (still needed for checked/unchecked tracking)
if ! hashchant "$file" >/dev/null 2>&1; then
  printf '%s\n' "prioritize: hashchant failed for file: $file" >&2
  printf '%s\n' "prioritize: extended attributes (xattr) may not be supported on this filesystem" >&2
  exit 1
fi

# Get the directory the file is in
directory=$(dirname "$file")
if [ "$directory" = "." ]; then
  directory=$(pwd -P)
fi

# Get the file's current echelon, priority, and checked status in one batch
attrs=$(xattr-read-batch "$file" echelon priority checked 2>/dev/null || printf '')

current_echelon=""
current_priority=""
checked_value=""

for pair in $attrs; do
  case "$pair" in
    echelon=*) current_echelon="${pair#echelon=}" ;;
    priority=*) current_priority="${pair#priority=}" ;;
    checked=*) checked_value="${pair#checked=}" ;;
  esac
done

# Default to 0 if not set
case "$current_echelon" in
  *Error*|''|*[!0-9]*) current_echelon=0 ;;
esac

case "$current_priority" in
  *Error*|''|*[!0-9]*) current_priority=0 ;;
esac

case "$checked_value" in
  *Error*|''|*[!0-9]*) checked_value=0 ;;
esac

if [ "$checked_value" = "1" ]; then
  enchant "$file" checked 0 >/dev/null
fi

# Find the highest echelon in the directory and highest priority within that echelon
# Combined into single loop for performance
highest_echelon=0
highest_priority_in_echelon=0
for f in "$directory"/*; do
  [ -e "$f" ] || continue
  
  # Read both echelon and priority in one batch call
  attrs=$(xattr-read-batch "$f" echelon priority 2>/dev/null || true)
  
  file_echelon=""
  file_priority=""
  
  for pair in $attrs; do
    case "$pair" in
      echelon=*) file_echelon="${pair#echelon=}" ;;
      priority=*) file_priority="${pair#priority=}" ;;
    esac
  done
  
  # Skip if echelon not valid
  case "$file_echelon" in
    *Error*|''|*[!0-9]*) continue ;;
  esac
  
  # Update highest echelon
  if [ "$file_echelon" -gt "$highest_echelon" ]; then
    highest_echelon=$file_echelon
    # Reset highest priority when we find a new highest echelon
    highest_priority_in_echelon=0
  fi
  
  # Track highest priority in the highest echelon
  if [ "$file_echelon" -eq "$highest_echelon" ]; then
    case "$file_priority" in
      *Error*|''|*[!0-9]*) file_priority=0 ;;
    esac
    
    if [ "$file_priority" -gt "$highest_priority_in_echelon" ]; then
      highest_priority_in_echelon=$file_priority
    fi
  fi
done

# If this is the first priority, set echelon=1, priority=1
if [ "$highest_echelon" -eq 0 ]; then
  enchant "$file" echelon 1 >/dev/null
  enchant "$file" priority 1 >/dev/null
  printf '%s\n' "Prioritized '$(basename "$file")' as the first priority."
  exit 0
fi

# If file is already at the highest echelon, promote to new echelon
if [ "$current_echelon" -eq "$highest_echelon" ] && [ "$current_echelon" -gt 0 ]; then
  new_echelon=$((highest_echelon + 1))
  enchant "$file" echelon "$new_echelon" >/dev/null
  enchant "$file" priority 1 >/dev/null
  printf '%s\n' "Promoted '$(basename "$file")' to echelon $new_echelon."
  exit 0
fi

# File is not in highest echelon - move it to the highest echelon
# Set to highest echelon with priority at the end (highest + 1)
new_priority=$((highest_priority_in_echelon + 1))
enchant "$file" echelon "$highest_echelon" >/dev/null
enchant "$file" priority "$new_priority" >/dev/null

printf '%s\n' "Moved '$(basename "$file")' to echelon $highest_echelon (priority $new_priority)."
