#!/bin/sh

# Banish environmental chaos and validate wizardry readiness at different levels.
# This spell assumption-checks, self-heals, and tests the environment,
# ensuring all prerequisites are met for each spell level.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: banish [LEVEL] [OPTIONS]

Validate wizardry readiness by level, including assumptions, self-healing, and tests.

Arguments:
  LEVEL                 Validate through level N (0-27, default: 4)
  all                   Validate all available levels

Options:
  --no-heal             Skip self-healing (only report issues)
  --no-tests            Skip running tests (only check assumptions)
  --only                Only validate this specific level (don't run lower levels)

Examples:
  banish          # Validate through level 4 (default - menu system)
  banish 5 --only # Validate only level 5
  banish all      # Validate through the highest available level
USAGE
  exit 0
  ;;
esac

# Debug: Log when banish is called
if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
  printf '[banish] Function called\n' >&2
fi

set -eu

# Detect WIZARDRY_DIR if not already set
if [ -z "${WIZARDRY_DIR-}" ]; then
  # We're being executed directly - detect from script location
  _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || _script_dir=""
  if [ -n "$_script_dir" ]; then
    _wiz_root=$(CDPATH= cd -- "$_script_dir/../.." 2>/dev/null && pwd -P) || _wiz_root=""
    if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
      WIZARDRY_DIR=$_wiz_root
    fi
  fi
fi

# Validate WIZARDRY_DIR is set and valid
if [ -z "${WIZARDRY_DIR-}" ]; then
  printf 'banish: WIZARDRY_DIR not set and could not be detected\n' >&2
  printf 'Run from wizardry installation or set WIZARDRY_DIR environment variable\n' >&2
  exit 1
fi

if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
  printf 'banish: invalid WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  exit 1
fi

export WIZARDRY_DIR

# Parse arguments
target_level=4
max_level=27
skip_tests=0
skip_heal=0
only_this_level=0
run_all=0

# First, check if first arg is a number (the level)
if [ "$#" -gt 0 ]; then
  case "$1" in
    all)
      run_all=1
      target_level=$max_level
      shift
      ;;
    [0-9]|[0-9][0-9])
      target_level=$1
      shift
      ;;
  esac
fi

while [ "$#" -gt 0 ]; do
  case $1 in
    --no-heal)
      skip_heal=1
      shift
      ;;
    --no-tests)
      skip_tests=1
      shift
      ;;
    --only)
      only_this_level=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf 'Error: unknown option: %s\n' "$1" >&2
      cat <<'USAGE' >&2
Usage: banish [LEVEL] [OPTIONS]

Validate wizardry readiness by level, including assumptions, self-healing, and tests.

Arguments:
  LEVEL                 Validate through level N (0-27, default: 4)
  all                   Validate all available levels

Options:
  --no-heal             Skip self-healing (only report issues)
  --no-tests            Skip running tests (only check assumptions)
  --only                Only validate this specific level (don't run lower levels)

Examples:
  banish          # Validate through level 4 (default - menu system)
  banish 5 --only # Validate only level 5
  banish all      # Validate through the highest available level
USAGE
      exit 2
      ;;
    *)
      # Check if it's a valid level number
      case "$1" in
        all)
          run_all=1
          target_level=$max_level
          shift
          ;;
        [0-9]|[0-9][0-9])
          target_level=$1
          shift
          ;;
        *)
          printf 'Error: unexpected argument: %s\n' "$1" >&2
          cat <<'USAGE' >&2
Usage: banish [LEVEL] [OPTIONS]

Validate wizardry readiness by level, including assumptions, self-healing, and tests.

Arguments:
  LEVEL                 Validate through level N (0-27, default: 4)
  all                   Validate all available levels

Options:
  --no-heal             Skip self-healing (only report issues)
  --no-tests            Skip running tests (only check assumptions)
  --only                Only validate this specific level (don't run lower levels)

Examples:
  banish          # Validate through level 4 (default - menu system)
  banish 5 --only # Validate only level 5
  banish all      # Validate through the highest available level
USAGE
          exit 2
          ;;
      esac
      ;;
  esac
done

# Validate level
if [ "$target_level" -lt 0 ] || [ "$target_level" -gt "$max_level" ]; then
  printf 'Error: level must be 0-%d, got: %s\n' "$max_level" "$target_level" >&2
  cat <<'USAGE' >&2
Usage: banish [LEVEL] [OPTIONS]

Validate wizardry readiness by level, including assumptions, self-healing, and tests.

Arguments:
  LEVEL                 Validate through level N (0-27, default: 4)
  all                   Validate all available levels

Options:
  --no-heal             Skip self-healing (only report issues)
  --no-tests            Skip running tests (only check assumptions)
  --only                Only validate this specific level (don't run lower levels)

Examples:
  banish          # Validate through level 4 (default - menu system)
  banish 5 --only # Validate only level 5
  banish all      # Validate through the highest available level
USAGE
  exit 2
fi

# Set up spell-levels script path
spell_levels_script="${WIZARDRY_DIR}/spells/.imps/sys/spell-levels"
if [ ! -x "$spell_levels_script" ]; then
  printf 'banish: spell-levels not found or not executable\n' >&2
  exit 1
fi

# Color codes (inline to avoid dependency)
_esc=$(printf '\033')
_green="${_esc}[32m"
_red="${_esc}[31m"
_reset="${_esc}[0m"

_banish_seen_imps=""
_banish_pluralize="${WIZARDRY_DIR}/spells/.imps/text/pluralize"
_banish_count_words="${WIZARDRY_DIR}/spells/.imps/text/count-words"

# Run level-specific checks and actions using case statement
banish_process_level() {
  level=$1
  level_name=$("$spell_levels_script" "$level" name)
  
  printf '\nLevel %d: %s\n' "$level" "$level_name"
  
  # Special handling per level
  case "$level" in
    0)
      # Level 0: System Foundation
      
      # Check WIZARDRY_DIR (single item - combine on one line)
      wizardry_not_installed=0
      
      if [ -n "${WIZARDRY_DIR-}" ]; then
        printf '  %s✓%s Wizardry directory: WIZARDRY_DIR is set\n' "$_green" "$_reset"
      else
        printf '  Wizardry directory:\n'
        printf '    Checking for wizardry installation...\n'
        
        has_dirname=$(command -v dirname >/dev/null 2>&1 && echo 1 || echo 0)
        has_cd=$(command -v cd >/dev/null 2>&1 && echo 1 || echo 0)
        has_pwd=$(command -v pwd >/dev/null 2>&1 && echo 1 || echo 0)
        if [ "$has_dirname" = "1" ] && [ "$has_cd" = "1" ] && [ "$has_pwd" = "1" ]; then
          script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || true
          if [ -n "$script_dir" ]; then
            _potential_dir=$(CDPATH= cd -- "$script_dir/../.." 2>/dev/null && pwd -P) || true
            if [ -n "$_potential_dir" ] && [ -d "$_potential_dir/spells" ]; then
              WIZARDRY_DIR=$_potential_dir
              printf '    %s✓%s Detected from script location\n' "$_green" "$_reset"
            fi
          fi
        fi
        
        if [ -z "${WIZARDRY_DIR-}" ]; then
          if [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
            WIZARDRY_DIR="${HOME}/.wizardry"
            printf '    %s✓%s Found at standard location\n' "$_green" "$_reset"
          else
            wizardry_not_installed=1
            printf '    %s✗%s Not found\n' "$_red" "$_reset"
          fi
        fi
      fi
      
      if [ "$wizardry_not_installed" -eq 1 ]; then
        printf 'Error: Wizardry not installed - run ./install first\n'
        return 1
      fi
      
      export WIZARDRY_DIR
      
      # Check PATH baseline
      path_missing=""
      case ":${PATH-}:" in
        *":/bin:"*) : ;;
        *) path_missing="${path_missing}${path_missing:+ }/bin" ;;
      esac
      case ":${PATH-}:" in
        *":/usr/bin:"*) : ;;
        *) path_missing="${path_missing}${path_missing:+ }/usr/bin" ;;
      esac
      if [ -z "$path_missing" ]; then
        printf '  %s✓%s PATH baseline: /bin and /usr/bin\n' "$_green" "$_reset"
      else
        printf '  %s✗%s PATH baseline: Missing %s\n' "$_red" "$_reset" "$path_missing"
        if [ "$skip_heal" -eq 0 ]; then
          baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
          PATH="${baseline_path}${PATH:+:}${PATH-}"
          export PATH
          path_missing=""
          case ":${PATH-}:" in
            *":/bin:"*) : ;;
            *) path_missing="${path_missing}${path_missing:+ }/bin" ;;
          esac
          case ":${PATH-}:" in
            *":/usr/bin:"*) : ;;
            *) path_missing="${path_missing}${path_missing:+ }/usr/bin" ;;
          esac
          if [ -z "$path_missing" ]; then
            printf '    %s✓%s PATH baseline restored\n' "$_green" "$_reset"
          else
            printf '    %s✗%s PATH baseline still missing: %s\n' "$_red" "$_reset" "$path_missing"
          fi
        fi
        if [ -n "$path_missing" ]; then
          return 1
        fi
      fi

      manage_system_command=""
      if [ "$skip_heal" -eq 0 ]; then
        if command -v manage-system-command >/dev/null 2>&1; then
          manage_system_command="manage-system-command"
        elif [ -x "${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command" ]; then
          manage_system_command="${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command"
        fi
      fi

      # Check POSIX commands (multiple items - check topic when all pass)
      posix_failed=0
      posix_cmds="sh test printf command dirname basename pwd cat"
      posix_cmds="$posix_cmds grep find sort cut head tail tr wc awk sed xargs mktemp uname"
      for cmd in $posix_cmds; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
          posix_failed=1
          break
        fi
      done
      
      if [ "$posix_failed" -eq 0 ]; then
        printf '  %s✓%s POSIX foundation:\n' "$_green" "$_reset"
        for cmd in $posix_cmds; do
          printf '    %s✓%s %s\n' "$_green" "$_reset" "$cmd"
        done
      else
        printf '  %s✗%s POSIX foundation:\n' "$_red" "$_reset"
        for cmd in $posix_cmds; do
          if command -v "$cmd" >/dev/null 2>&1; then
            printf '    %s✓%s %s\n' "$_green" "$_reset" "$cmd"
          else
            printf '    %s✗%s %s not found\n' "$_red" "$_reset" "$cmd"
          fi
        done
        return 1
      fi

      # Check download tools (curl or wget)
      if command -v curl >/dev/null 2>&1 || command -v wget >/dev/null 2>&1; then
        printf '  %s✓%s Download tools: curl or wget available\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Download tools: curl and wget not found\n' "$_red" "$_reset"
        if [ -n "$manage_system_command" ]; then
          printf '    Attempting to install curl...\n'
          if "$manage_system_command" curl curl >/dev/null 2>&1; then
            :
          else
            printf '    Attempting to install wget...\n'
            "$manage_system_command" wget wget >/dev/null 2>&1 || :
          fi
        fi
        if command -v curl >/dev/null 2>&1 || command -v wget >/dev/null 2>&1; then
          printf '    %s✓%s Download tool ready\n' "$_green" "$_reset"
        else
          printf '    %s✗%s Download tools still missing\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check tar
      if command -v tar >/dev/null 2>&1; then
        printf '  %s✓%s Archive tool: tar available\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Archive tool: tar not found\n' "$_red" "$_reset"
        if [ -n "$manage_system_command" ]; then
          printf '    Attempting to install tar...\n'
          "$manage_system_command" tar tar >/dev/null 2>&1 || :
        fi
        if command -v tar >/dev/null 2>&1; then
          printf '    %s✓%s tar installed\n' "$_green" "$_reset"
        else
          printf '    %s✗%s tar still missing\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check package manager availability
      package_managers=""
      for pkg in apt-get  pacman apk brew port nix-env pkgin; do
        if command -v "$pkg" >/dev/null 2>&1; then
          package_managers="${package_managers}${package_managers:+ }$pkg"
        fi
      done
      if [ -n "$package_managers" ]; then
        printf '  %s✓%s Package manager: %s\n' "$_green" "$_reset" "$package_managers"
      else
        printf '  %s✗%s Package manager: none detected\n' "$_red" "$_reset"
        return 1
      fi

      # Check shell type (POSIX-compatible shell required)
      # Wizardry scripts assume POSIX sh semantics. Non-POSIX shells like
      # csh, tcsh, and fish have incompatible syntax and semantics.
      shell_type=${SHELL##*/}
      shell_type=${shell_type:-sh}
      case "$shell_type" in
        sh|bash|dash|zsh|ksh|ash)
          printf '  %s✓%s Shell type: %s (POSIX-compatible)\n' "$_green" "$_reset" "$shell_type"
          ;;
        csh|tcsh|fish)
          printf '  %s✗%s Shell type: %s (not POSIX-compatible)\n' "$_red" "$_reset" "$shell_type"
          printf '    Wizardry requires a POSIX-compatible shell (sh, bash, dash, zsh, ksh)\n'
          return 1
          ;;
        *)
          printf '  %s✓%s Shell type: %s (assuming POSIX-compatible)\n' "$_green" "$_reset" "$shell_type"
          ;;
      esac

      # Check IFS (should be default: space, tab, newline)
      # IFS controls word splitting. Non-default IFS breaks for-loops and
      # word iteration. Self-heal by resetting to default.
      default_ifs=" 	
"
      if [ "${IFS-unset}" = "unset" ] || [ "$IFS" = "$default_ifs" ]; then
        printf '  %s✓%s IFS: Default (space, tab, newline)\n' "$_green" "$_reset"
      else
        printf '  %s✗%s IFS: Non-default value detected\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          IFS="$default_ifs"
          export IFS
          printf '    %s✓%s IFS reset to default\n' "$_green" "$_reset"
        else
          return 1
        fi
      fi

      # Check basic environment variables
      # HOME and USER are used throughout wizardry for default paths and
      # configuration. Self-heal by querying system or using fallbacks.
      env_vars_ok=1
      if [ -z "${HOME-}" ]; then
        printf '  %s✗%s Environment: HOME not set\n' "$_red" "$_reset"
        env_vars_ok=0
      fi
      if [ -z "${USER-}" ] && [ -z "${LOGNAME-}" ]; then
        printf '  %s✗%s Environment: USER/LOGNAME not set\n' "$_red" "$_reset"
        env_vars_ok=0
      fi
      if [ "$env_vars_ok" -eq 1 ]; then
        printf '  %s✓%s Environment: HOME and USER set\n' "$_green" "$_reset"
      else
        if [ "$skip_heal" -eq 0 ]; then
          if [ -z "${HOME-}" ]; then
            HOME=$(getent passwd "$USER" 2>/dev/null | cut -d: -f6) || HOME="/tmp"
            export HOME
            printf '    %s✓%s HOME set to %s\n' "$_green" "$_reset" "$HOME"
          fi
          if [ -z "${USER-}" ]; then
            USER=$(id -un 2>/dev/null) || USER="unknown"
            export USER
            printf '    %s✓%s USER set to %s\n' "$_green" "$_reset" "$USER"
          fi
        else
          return 1
        fi
      fi

      # Check umask (should be reasonable, not 0000 or 0777)
      # umask 0000 makes all files world-writable (security risk).
      # umask 0777 makes all files unreadable (breaks everything).
      # Self-heal to standard 0022 (owner write, group/others read).
      current_umask=$(umask)
      case "$current_umask" in
        0000|0777)
          printf '  %s✗%s umask: Unsafe value %s\n' "$_red" "$_reset" "$current_umask"
          if [ "$skip_heal" -eq 0 ]; then
            umask 0022
            printf '    %s✓%s umask set to 0022\n' "$_green" "$_reset"
          else
            return 1
          fi
          ;;
        *)
          printf '  %s✓%s umask: %s\n' "$_green" "$_reset" "$current_umask"
          ;;
      esac

      # Check file system write capability
      # Many spells need to create temp files for processing.
      # This validates we can write to the temp directory.
      tmp_root=${TMPDIR:-/tmp}
      tmp_check=$(mktemp "${tmp_root%/}/banish-write.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_check" ]; then
        if printf '%s\n' "test" >"$tmp_check" 2>/dev/null && [ -s "$tmp_check" ]; then
          rm -f "$tmp_check" 2>/dev/null || :
          printf '  %s✓%s Filesystem write: %s writable\n' "$_green" "$_reset" "$tmp_root"
        else
          rm -f "$tmp_check" 2>/dev/null || :
          printf '  %s✗%s Filesystem write: Cannot write to %s\n' "$_red" "$_reset" "$tmp_root"
          return 1
        fi
      else
        printf '  %s✗%s Filesystem write: Cannot create temp file in %s\n' "$_red" "$_reset" "$tmp_root"
        return 1
      fi

      # Check symbolic link support
      # Wizardry uses symlinks for glossary, test stubs, and spell links.
      # Some filesystems (FAT32, some network mounts) don't support symlinks.
      tmp_link_test=$(mktemp "${tmp_root%/}/banish-link.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_link_test" ]; then
        tmp_link="${tmp_link_test}.link"
        if ln -s "$tmp_link_test" "$tmp_link" 2>/dev/null; then
          if [ -L "$tmp_link" ]; then
            printf '  %s✓%s Symbolic links: Supported\n' "$_green" "$_reset"
            rm -f "$tmp_link" "$tmp_link_test" 2>/dev/null || :
          else
            printf '  %s✗%s Symbolic links: Not working\n' "$_red" "$_reset"
            rm -f "$tmp_link" "$tmp_link_test" 2>/dev/null || :
            return 1
          fi
        else
          printf '  %s✗%s Symbolic links: Creation failed\n' "$_red" "$_reset"
          rm -f "$tmp_link_test" 2>/dev/null || :
          return 1
        fi
      fi

      # Check execute permissions
      # Spells and imps must be executable. Some filesystems (noexec mounts)
      # prevent execution even with +x permission.
      tmp_exec_test=$(mktemp "${tmp_root%/}/banish-exec.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_exec_test" ]; then
        printf '#!/bin/sh\nprintf "ok"\n' >"$tmp_exec_test"
        chmod +x "$tmp_exec_test" 2>/dev/null || :
        if [ -x "$tmp_exec_test" ]; then
          exec_output=$("$tmp_exec_test" 2>/dev/null || printf '')
          if [ "$exec_output" = "ok" ]; then
            printf '  %s✓%s Execute permissions: Working\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Execute permissions: Script execution failed\n' "$_red" "$_reset"
            rm -f "$tmp_exec_test" 2>/dev/null || :
            return 1
          fi
        else
          printf '  %s✗%s Execute permissions: chmod +x failed\n' "$_red" "$_reset"
          rm -f "$tmp_exec_test" 2>/dev/null || :
          return 1
        fi
        rm -f "$tmp_exec_test" 2>/dev/null || :
      fi

      # Check subshells work
      # Subshells (parentheses) create isolated environments for command
      # substitution and temporary state changes. Critical for POSIX scripts.
      subshell_test=$(test_var=outer; (test_var=inner; printf '%s' "$test_var") 2>/dev/null || printf '')
      if [ "$subshell_test" = "inner" ]; then
        printf '  %s✓%s Subshells: Working correctly\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Subshells: Not working correctly\n' "$_red" "$_reset"
        return 1
      fi

      # Check pipes work
      # Pipes connect command output to input. Fundamental to shell scripting.
      # Verifies kernel supports anonymous pipes (should always work on POSIX systems).
      pipe_test=$(printf 'hello' | cat 2>/dev/null || printf '')
      if [ "$pipe_test" = "hello" ]; then
        printf '  %s✓%s Pipes: Working\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Pipes: Not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check redirections work
      # File redirection (>, <, >>) is essential for saving and loading data.
      # Tests both output (>) and input (<) redirections.
      tmp_redir_test=$(mktemp "${tmp_root%/}/banish-redir.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_redir_test" ]; then
        if printf 'test' >"$tmp_redir_test" 2>/dev/null; then
          redir_content=$(cat "$tmp_redir_test" 2>/dev/null || printf '')
          if [ "$redir_content" = "test" ]; then
            printf '  %s✓%s Redirections: Working\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Redirections: Read failed\n' "$_red" "$_reset"
            rm -f "$tmp_redir_test" 2>/dev/null || :
            return 1
          fi
        else
          printf '  %s✗%s Redirections: Write failed\n' "$_red" "$_reset"
          rm -f "$tmp_redir_test" 2>/dev/null || :
          return 1
        fi
        rm -f "$tmp_redir_test" 2>/dev/null || :
      fi

      # Check trap/signal handling
      # trap is used for cleanup on exit (EXIT), interrupt (INT), and other signals.
      # Critical for temp file cleanup and proper resource management.
      if command -v trap >/dev/null 2>&1; then
        trap_test=0
        trap 'trap_test=1' USR1 2>/dev/null || trap_test=-1
        if [ "$trap_test" -ne -1 ]; then
          trap - USR1 2>/dev/null || :
          printf '  %s✓%s Signal handling: trap command works\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Signal handling: trap command failed\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Signal handling: trap command not found\n' "$_red" "$_reset"
        return 1
      fi

      # Check command substitution works
      # Command substitution $(...) captures command output as a value.
      # Used extensively in wizardry for dynamic values and command results.
      cmd_sub_test=$(printf 'substitution')
      if [ "$cmd_sub_test" = "substitution" ]; then
        printf '  %s✓%s Command substitution: Working\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Command substitution: Not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check parameter expansion
      # POSIX parameter expansion ${var#pattern} removes patterns from strings.
      # Critical for basename/dirname operations without subprocess overhead.
      param_test="value"
      param_result=${param_test#val}
      if [ "$param_result" = "ue" ]; then
        printf '  %s✓%s Parameter expansion: Working\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Parameter expansion: Pattern removal failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check case statement pattern matching
      # Case statements with wildcards are fundamental to POSIX shell scripting
      case_test="test_value"
      case_works=0
      case "$case_test" in
        test_*) case_works=1 ;;
        *) case_works=0 ;;
      esac
      if [ "$case_works" -eq 1 ]; then
        printf '  %s✓%s Case pattern matching: Wildcard patterns work\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Case pattern matching: Wildcard patterns failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check arithmetic operations
      # Shell arithmetic is used for counters, array indices, and calculations
      arith_result=$(( 2 + 2 )) 2>/dev/null || arith_result=0
      if [ "$arith_result" -eq 4 ]; then
        printf '  %s✓%s Arithmetic: $(( )) expressions work\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Arithmetic: $(( )) expressions not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check test operators (file and string tests)
      # Test operators are used extensively for conditional logic
      tmp_root=${TMPDIR:-/tmp}
      test_file=$(mktemp "${tmp_root%/}/banish-test.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$test_file" ]; then
        test_ok=1
        # Test file existence (-f)
        if [ ! -f "$test_file" ]; then test_ok=0; fi
        # Test string non-empty (-n) and empty (-z)
        if [ ! -n "test" ] || [ ! -z "" ]; then test_ok=0; fi
        # Test file readable (-r) and writable (-w)
        if [ ! -r "$test_file" ] || [ ! -w "$test_file" ]; then test_ok=0; fi
        
        rm -f "$test_file" 2>/dev/null || :
        
        if [ "$test_ok" -eq 1 ]; then
          printf '  %s✓%s Test operators: -f -r -w -n -z all work\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Test operators: Some test operators failed\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check while loops
      # While loops are used for iteration and processing
      loop_count=0
      while [ "$loop_count" -lt 3 ]; do
        loop_count=$(( loop_count + 1 ))
      done
      if [ "$loop_count" -eq 3 ]; then
        printf '  %s✓%s While loops: Iteration works correctly\n' "$_green" "$_reset"
      else
        printf '  %s✗%s While loops: Loop iteration failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check for loops
      # For loops iterate over word lists
      for_result=""
      for item in a b c; do
        for_result="${for_result}${item}"
      done
      if [ "$for_result" = "abc" ]; then
        printf '  %s✓%s For loops: Word list iteration works\n' "$_green" "$_reset"
      else
        printf '  %s✗%s For loops: Word list iteration failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check string length
      # ${#var} is used to get string length without subprocesses
      len_test="12345"
      if [ "${#len_test}" -eq 5 ]; then
        printf '  %s✓%s String length: ${#var} expansion works\n' "$_green" "$_reset"
      else
        printf '  %s✗%s String length: ${#var} expansion failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check exit code capture
      # Exit codes ($?) are critical for error handling
      true
      exit_code_true=$?
      false
      exit_code_false=$?
      if [ "$exit_code_true" -eq 0 ] && [ "$exit_code_false" -ne 0 ]; then
        printf '  %s✓%s Exit codes: $? captures command status\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Exit codes: $? not working correctly\n' "$_red" "$_reset"
        return 1
      fi

      # Check here documents
      # Here documents are used for multi-line strings (like --help text)
      heredoc_result=$(cat <<'HEREDOC_TEST'
line1
line2
HEREDOC_TEST
)
      if printf '%s' "$heredoc_result" | grep -q "line1" && printf '%s' "$heredoc_result" | grep -q "line2"; then
        printf '  %s✓%s Here documents: Multi-line strings work\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Here documents: Not working correctly\n' "$_red" "$_reset"
        return 1
      fi

      # Check disk space availability
      # Need sufficient space for temp files, logs, caches
      tmp_root=${TMPDIR:-/tmp}
      available_kb=0
      if df -k "$tmp_root" 2>/dev/null | tail -1 | awk '{print $4}' | grep -q '^[0-9]'; then
        available_kb=$(df -k "$tmp_root" 2>/dev/null | tail -1 | awk '{print $4}')
      fi
      # Check for at least 10MB free space
      if [ "$available_kb" -gt 10240 ]; then
        printf '  %s✓%s Disk space: Sufficient space available (%d KB free)\n' "$_green" "$_reset" "$available_kb"
      else
        printf '  %s✗%s Disk space: Low disk space (%d KB free, need >10MB)\n' "$_red" "$_reset" "$available_kb"
        if [ "$available_kb" -lt 1024 ]; then
          return 1
        fi
      fi

      # Check locale/character encoding support
      # Character class patterns in tr, sort, etc. depend on locale
      test_locale="${LANG:-C}"
      case "$test_locale" in
        *.UTF-8|*.utf8|C|POSIX)
          printf '  %s✓%s Locale: %s (supported)\n' "$_green" "$_reset" "$test_locale"
          ;;
        *)
          printf '  %s✗%s Locale: %s (may cause issues with character processing)\n' "$_red" "$_reset" "$test_locale"
          if [ "$skip_heal" -eq 0 ]; then
            LANG=C.UTF-8
            export LANG
            printf '    %s✓%s Locale set to C.UTF-8\n' "$_green" "$_reset"
          else
            return 1
          fi
          ;;
      esac

      # Check home directory accessibility
      # Wizardry stores configs, markers, and spellbooks in home directory
      home_dir="${HOME:-}"
      if [ -z "$home_dir" ]; then
        printf '  %s✗%s Home directory: HOME not set\n' "$_red" "$_reset"
        return 1
      elif [ ! -d "$home_dir" ]; then
        printf '  %s✗%s Home directory: %s does not exist\n' "$_red" "$_reset" "$home_dir"
        return 1
      elif [ -r "$home_dir" ] && [ -x "$home_dir" ]; then
        printf '  %s✓%s Home directory: Readable and accessible\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Home directory: Not readable or not executable\n' "$_red" "$_reset"
        return 1
      fi

      # Check process limits (can we fork?)
      # Shell scripts need to create subprocesses
      if (true) 2>/dev/null; then
        printf '  %s✓%s Process creation: Can fork subprocesses\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Process creation: Cannot fork subprocesses\n' "$_red" "$_reset"
        return 1
      fi

      # Check printf format specifiers
      # Printf is used extensively with %s and %d format codes
      test_str=$(printf '%s' "test" 2>/dev/null)
      test_num=$(printf '%d\n' 42 2>/dev/null | head -1)
      if [ "$test_str" = "test" ] && [ "$test_num" = "42" ]; then
        printf '  %s✓%s printf: Format specifiers work (%%s, %%d)\n' "$_green" "$_reset"
      else
        printf '  %s✗%s printf: Format specifiers not working correctly\n' "$_red" "$_reset"
        return 1
      fi

      # Check date command functionality
      # Used for timestamps and time-based operations
      if command -v date >/dev/null 2>&1; then
        test_date=$(date +%s 2>/dev/null)
        if [ -n "$test_date" ] && [ "$test_date" -gt 0 ] 2>/dev/null; then
          printf '  %s✓%s Date command: Available and functional\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Date command: Found but not working\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Date command: Not available\n' "$_red" "$_reset"
        return 1
      fi

      # Check basename/dirname for path manipulation
      # Used throughout wizardry for path handling
      test_base=$(basename "/path/to/file" 2>/dev/null)
      test_dir=$(dirname "/path/to/file" 2>/dev/null)
      if [ "$test_base" = "file" ] && [ "$test_dir" = "/path/to" ]; then
        printf '  %s✓%s Path manipulation: basename/dirname work\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Path manipulation: basename/dirname not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check text processing utilities (awk, sed, tr, cut, sort)
      # These are fundamental for text manipulation in wizardry
      text_tools_ok=1
      
      # Test awk
      if ! printf 'test' | awk '{print $1}' 2>/dev/null | grep -q 'test'; then
        text_tools_ok=0
        printf '  %s✗%s Text processing: awk not working\n' "$_red" "$_reset"
      fi
      
      # Test sed
      if ! printf 'test' | sed 's/test/ok/' 2>/dev/null | grep -q 'ok'; then
        text_tools_ok=0
        printf '  %s✗%s Text processing: sed not working\n' "$_red" "$_reset"
      fi
      
      # Test tr
      if ! printf 'test' | tr 'e' 'a' 2>/dev/null | grep -q 'tast'; then
        text_tools_ok=0
        printf '  %s✗%s Text processing: tr not working\n' "$_red" "$_reset"
      fi
      
      # Test cut
      if ! printf 'a:b:c' | cut -d: -f2 2>/dev/null | grep -q 'b'; then
        text_tools_ok=0
        printf '  %s✗%s Text processing: cut not working\n' "$_red" "$_reset"
      fi
      
      # Test sort
      if ! printf 'b\na\nc' | sort 2>/dev/null | head -1 | grep -q 'a'; then
        text_tools_ok=0
        printf '  %s✗%s Text processing: sort not working\n' "$_red" "$_reset"
      fi
      
      if [ "$text_tools_ok" -eq 1 ]; then
        printf '  %s✓%s Text processing: awk, sed, tr, cut, sort functional\n' "$_green" "$_reset"
      else
        return 1
      fi
      ;;
      
    1)
      # Level 1: Banish & Validation Infrastructure
      
      # Check wizardry structure (single item - combine on one line)
      if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
        printf '  %s✗%s Wizardry structure: Spells directory not found\n' "$_red" "$_reset"
        return 1
      fi
      printf '  %s✓%s Wizardry structure: Spells directory exists\n' "$_green" "$_reset"

      # Check installer presence (single item - combine on one line)
      if [ ! -f "${WIZARDRY_DIR}/install" ]; then
        printf '  %s✗%s Installer: install script not found\n' "$_red" "$_reset"
        return 1
      fi
      printf '  %s✓%s Installer: install script present\n' "$_green" "$_reset"

      # Check function definitions and calls
      # Functions are used in spells and banish itself for organization
      test_func() {
        printf 'function_works'
      }
      func_result=$(test_func)
      if [ "$func_result" = "function_works" ]; then
        printf '  %s✓%s Function definitions: Shell functions work correctly\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Function definitions: Functions not working\n' "$_red" "$_reset"
        return 1
      fi
      # Check spells
      spell_list=$("$spell_levels_script" 1 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 1 imps)
      if [ -n "$imp_list" ]; then
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      fi
      ;;
      
    2)
      # Level 2: Installation Infrastructure
      
      # Check spellbook directory for glossary
      spell_home=${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}
      if [ -d "$spell_home" ] && [ -w "$spell_home" ]; then
        printf '  %s✓%s Spellbook directory: %s\n' "$_green" "$_reset" "$spell_home"
      else
        printf '  %s✗%s Spellbook directory: %s unavailable\n' "$_red" "$_reset" "$spell_home"
        if [ "$skip_heal" -eq 0 ]; then
          if mkdir -p "$spell_home" 2>/dev/null; then
            printf '    %s✓%s Spellbook directory created\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Spellbook directory creation failed\n' "$_green" "$_reset"
          fi
        fi
        if [ ! -d "$spell_home" ] || [ ! -w "$spell_home" ]; then
          return 1
        fi
      fi

      # Check environment variable export/persistence
      # env-or and other imps rely on environment variable propagation
      TEST_BANISH_VAR="test_value_$$"
      export TEST_BANISH_VAR
      exported_value=$(sh -c 'printf "%s" "$TEST_BANISH_VAR"' 2>/dev/null || printf '')
      unset TEST_BANISH_VAR 2>/dev/null || :
      
      if [ "$exported_value" = "test_value_$$" ]; then
        printf '  %s✓%s Environment export: Variables persist across subshells\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Environment export: Variables not persisting\n' "$_red" "$_reset"
        return 1
      fi

      # Check variable name validation (alphanumeric + underscore)
      # env-or validates variable names - ensure pattern matching works
      valid_name="_Valid_Name123"
      invalid_name="invalid-name"
      name_check_works=0
      
      case "$valid_name" in
        *[!A-Za-z0-9_]*|"") name_check_works=0 ;;
        *) name_check_works=1 ;;
      esac
      
      case "$invalid_name" in
        *[!A-Za-z0-9_]*|"") 
          if [ "$name_check_works" -eq 1 ]; then
            name_check_works=1
          else
            name_check_works=0
          fi
          ;;
        *) name_check_works=0 ;;
      esac
      
      if [ "$name_check_works" -eq 1 ]; then
        printf '  %s✓%s Variable name validation: Character class patterns work\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Variable name validation: Pattern matching failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check DNS resolution capability (for potential package downloads)
      # Installation may need to download packages or check repositories
      if command -v nslookup >/dev/null 2>&1 || command -v host >/dev/null 2>&1 || command -v dig >/dev/null 2>&1; then
        printf '  %s✓%s DNS resolution: DNS tools available\n' "$_green" "$_reset"
      else
        # Try to resolve a hostname using getent if available
        if command -v getent >/dev/null 2>&1; then
          if getent hosts github.com >/dev/null 2>&1; then
            printf '  %s✓%s DNS resolution: Can resolve hostnames\n' "$_green" "$_reset"
          else
            printf '  %s✗%s DNS resolution: Cannot resolve hostnames (updates may fail)\n' "$_red" "$_reset"
          fi
        else
          printf '  %s✓%s DNS resolution: Tools not available (may limit updates)\n' "$_green" "$_reset"
        fi
      fi


      # Check spells
      spell_list=$("$spell_levels_script" 2 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 2 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    3)
      # Level 3: Glossary & Parsing
      
      # Check stty (single item - combine on one line)
      if ! command -v stty >/dev/null 2>&1; then
        printf '  %s✗%s Terminal control: stty not found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          if command -v install-stty >/dev/null 2>&1; then
            printf '    Installing stty...\n'
            if install-stty 2>/dev/null; then
              if command -v stty >/dev/null 2>&1; then
                printf '    %s✓%s stty installed\n' "$_green" "$_reset"
              else
                printf '    %s✗%s Install failed\n' "$_red" "$_reset"
              fi
            else
              printf '    %s✗%s Install failed\n' "$_red" "$_reset"
            fi
          else
            printf '    Cannot auto-install stty\n'
          fi
        fi
      else
        printf '  %s✓%s Terminal control: stty available\n' "$_green" "$_reset"
      fi

      # Check tput (fathom-terminal dependency)
      if ! command -v tput >/dev/null 2>&1; then
        printf '  %s✗%s Terminal capabilities: tput not found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          if command -v install-tput >/dev/null 2>&1; then
            printf '    Installing tput...\n'
            if install-tput 2>/dev/null; then
              if command -v tput >/dev/null 2>&1; then
                printf '    %s✓%s tput installed\n' "$_green" "$_reset"
              else
                printf '    %s✗%s Install failed\n' "$_red" "$_reset"
              fi
            else
              printf '    %s✗%s Install failed\n' "$_red" "$_reset"
            fi
          else
            printf '    Auto-install not available\n'
          fi
        fi
      else
        printf '  %s✓%s Terminal capabilities: tput available\n' "$_green" "$_reset"
      fi

      # Check dd (await-keypress dependency)
      if ! command -v dd >/dev/null 2>&1; then
        printf '  %s✗%s Input capture: dd not found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          if command -v install-dd >/dev/null 2>&1; then
            printf '    Installing dd...\n'
            if install-dd 2>/dev/null; then
              if command -v dd >/dev/null 2>&1; then
                printf '    %s✓%s dd installed\n' "$_green" "$_reset"
              else
                printf '    %s✗%s Install failed\n' "$_red" "$_reset"
              fi
            else
              printf '    %s✗%s Install failed\n' "$_red" "$_reset"
            fi
          else
            printf '    Auto-install not available\n'
          fi
        fi
      else
        printf '  %s✓%s Input capture: dd available\n' "$_green" "$_reset"
      fi

      # Check terminal device access for menu
      menu_tty=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
      if [ ! -r "$menu_tty" ] || [ ! -w "$menu_tty" ]; then
        printf '  %s✗%s Terminal access: %s not readable/writable\n' "$_red" "$_reset" "$menu_tty"
        if [ "$skip_heal" -eq 0 ] && [ -n "${AWAIT_KEYPRESS_DEVICE-}" ]; then
          menu_tty=/dev/tty
          AWAIT_KEYPRESS_DEVICE=$menu_tty
          export AWAIT_KEYPRESS_DEVICE
          if [ -r "$menu_tty" ] && [ -w "$menu_tty" ]; then
            printf '    %s✓%s Terminal access restored to /dev/tty\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Terminal access still unavailable\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -r "$menu_tty" ] || [ ! -w "$menu_tty" ]; then
          return 1
        fi
      else
        printf '  %s✓%s Terminal access: %s\n' "$_green" "$_reset" "$menu_tty"
      fi

      # Check terminal type for ANSI cursor control
      term_status=1
      case "${TERM-}" in
        ''|dumb|unknown) term_status=0 ;;
        *) : ;;
      esac
      if [ "$term_status" -eq 1 ]; then
        printf '  %s✓%s Terminal type: %s\n' "$_green" "$_reset" "${TERM-unknown}"
      else
        printf '  %s✗%s Terminal type: %s\n' "$_red" "$_reset" "${TERM-unknown}"
        if [ "$skip_heal" -eq 0 ]; then
          TERM="xterm-256color"
          export TERM
          term_status=1
          case "${TERM-}" in
            ''|dumb|unknown) term_status=0 ;;
            *) : ;;
          esac
          if [ "$term_status" -eq 1 ]; then
            printf '    %s✓%s Terminal type set to %s\n' "$_green" "$_reset" "$TERM"
          else
            printf '    %s✗%s Terminal type still minimal\n' "$_red" "$_reset"
          fi
        fi
      fi
      if [ "$term_status" -ne 1 ]; then
        return 1
      fi

      # Check terminfo access (fathom-terminal expectation)
      if command -v tput >/dev/null 2>&1; then
        cols=$(tput cols 2>/dev/null || printf '')
        lines=$(tput lines 2>/dev/null || printf '')
        if [ -n "$cols" ] && [ -n "$lines" ]; then
          printf '  %s✓%s Terminfo dimensions: %sx%s\n' "$_green" "$_reset" "$cols" "$lines"
        else
          printf '  %s✗%s Terminfo dimensions unavailable\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check environment variable expansion (needed for glossary parsing)
      # Glossary system relies on dynamic variable expansion
      test_var="test_value"
      test_expansion=$(eval "printf '%s' \"\$test_var\"" 2>/dev/null || printf '')
      if [ "$test_expansion" = "test_value" ]; then
        printf '  %s✓%s Variable expansion: eval works correctly\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Variable expansion: eval not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 3 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 3 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    5)
      # Level 5: Extended Attributes

      # Check extended attributes helpers
      xattr_helper=""
      if command -v xattr >/dev/null 2>&1; then
        xattr_helper="xattr"
      elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
        xattr_helper="getfattr/setfattr"
      fi

      if [ -n "$xattr_helper" ]; then
        printf '  %s✓%s Extended attributes: %s available\n' "$_green" "$_reset" "$xattr_helper"
      else
        printf '  %s✗%s Extended attributes: no helper found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          manage_system_command=""
          if command -v manage-system-command >/dev/null 2>&1; then
            manage_system_command="manage-system-command"
          elif [ -x "${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command" ]; then
            manage_system_command="${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command"
          fi
          if [ -n "$manage_system_command" ]; then
            printf '    Attempting to install xattr tooling...\n'
            "$manage_system_command" getfattr attr >/dev/null 2>&1 || :
            "$manage_system_command" setfattr attr >/dev/null 2>&1 || :
          fi
        fi
        has_xattr=0
        if command -v xattr >/dev/null 2>&1; then
          has_xattr=1
        elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
          has_xattr=1
        fi
        if [ "$has_xattr" -eq 1 ]; then
          printf '    %s✓%s Extended attributes helper ready\n' "$_green" "$_reset"
        else
          printf '    %s✗%s Extended attributes still unavailable\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 5 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 5 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    6)
      # Level 6: Task Priorities
      
      # Check file locking capability (priorities use file-based state)
      # Task priorities rely on atomic file operations and locking
      tmp_root=${TMPDIR:-/tmp}
      lock_test="$tmp_root/.banish-lock-test.$$"
      
      # Test that file locking works (flock or similar)
      if command -v flock >/dev/null 2>&1; then
        # Test flock
        if printf 'test' > "$lock_test" 2>/dev/null; then
          if flock -n "$lock_test" printf 'locked' 2>/dev/null; then
            rm -f "$lock_test" 2>/dev/null || :
            printf '  %s✓%s File locking: flock available\n' "$_green" "$_reset"
          else
            rm -f "$lock_test" 2>/dev/null || :
            printf '  %s✗%s File locking: flock not working\n' "$_red" "$_reset"
            return 1
          fi
        else
          printf '  %s✗%s File locking: Cannot create test file\n' "$_red" "$_reset"
          return 1
        fi
      else
        # No flock available - priorities may have race conditions
        printf '  %s✓%s File locking: flock not available (priorities may have race conditions)\n' "$_green" "$_reset"
      fi
      
      # Check spells
      spell_list=$("$spell_levels_script" 6 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 6 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    7)
      # Level 7: Navigation

      # Check marker directory creation
      spell_home=${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}
      markers_dir="$spell_home/.markers"
      if [ -d "$markers_dir" ] && [ -w "$markers_dir" ]; then
        printf '  %s✓%s Marker directory: %s\n' "$_green" "$_reset" "$markers_dir"
      else
        printf '  %s✗%s Marker directory: %s unavailable\n' "$_red" "$_reset" "$markers_dir"
        if [ "$skip_heal" -eq 0 ]; then
          if mkdir -p "$markers_dir" 2>/dev/null; then
            printf '    %s✓%s Marker directory created\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Marker directory creation failed\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -d "$markers_dir" ] || [ ! -w "$markers_dir" ]; then
          return 1
        fi
      fi

      # Test that marker files can actually be created and read
      # Navigation relies on persistent marker files
      test_marker="$markers_dir/.banish-test-marker"
      test_path="/tmp/test-location"
      if printf '%s\n' "$test_path" > "$test_marker" 2>/dev/null; then
        read_path=$(cat "$test_marker" 2>/dev/null || printf '')
        rm -f "$test_marker" 2>/dev/null || :
        
        if [ "$read_path" = "$test_path" ]; then
          printf '  %s✓%s Marker persistence: Can create and read marker files\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Marker persistence: File read/write mismatch\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Marker persistence: Cannot create marker files\n' "$_red" "$_reset"
        return 1
      fi

      # Check spellbook directory access
      if [ -d "$spell_home" ] && [ -w "$spell_home" ]; then
        printf '  %s✓%s Spellbook directory: %s\n' "$_green" "$_reset" "$spell_home"
      else
        printf '  %s✗%s Spellbook directory: %s unavailable\n' "$_red" "$_reset" "$spell_home"
        if [ "$skip_heal" -eq 0 ]; then
          if mkdir -p "$spell_home" 2>/dev/null; then
            printf '    %s✓%s Spellbook directory created\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Spellbook directory creation failed\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -d "$spell_home" ] || [ ! -w "$spell_home" ]; then
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 7 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 7 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    8)
      # Level 8: MUD Basics

      # Check extended attributes helpers
      xattr_helper=""
      if command -v xattr >/dev/null 2>&1; then
        xattr_helper="xattr"
      elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
        xattr_helper="getfattr/setfattr"
      fi

      if [ -n "$xattr_helper" ]; then
        printf '  %s✓%s Extended attributes: %s available\n' "$_green" "$_reset" "$xattr_helper"
      else
        printf '  %s✗%s Extended attributes: no helper found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          manage_system_command=""
          if command -v manage-system-command >/dev/null 2>&1; then
            manage_system_command="manage-system-command"
          elif [ -x "${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command" ]; then
            manage_system_command="${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command"
          fi
          if [ -n "$manage_system_command" ]; then
            printf '    Attempting to install xattr tooling...\n'
            "$manage_system_command" getfattr attr >/dev/null 2>&1 || :
            "$manage_system_command" setfattr attr >/dev/null 2>&1 || :
          fi
        fi
        has_xattr=0
        if command -v xattr >/dev/null 2>&1; then
          has_xattr=1
        elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
          has_xattr=1
        fi
        if [ "$has_xattr" -eq 1 ]; then
          printf '    %s✓%s Extended attributes helper ready\n' "$_green" "$_reset"
        else
          printf '    %s✗%s Extended attributes still unavailable\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Test that extended attributes actually work on the filesystem
      # Some filesystems don't support xattrs (FAT32, some network mounts)
      tmp_root=${TMPDIR:-/tmp}
      tmp_xattr_test=$(mktemp "${tmp_root%/}/banish-xattr.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_xattr_test" ]; then
        xattr_works=0
        
        # Try to set an extended attribute
        if command -v xattr >/dev/null 2>&1; then
          if xattr -w user.test "value" "$tmp_xattr_test" 2>/dev/null; then
            # Verify we can read it back
            if xattr -p user.test "$tmp_xattr_test" 2>/dev/null | grep -q "value"; then
              xattr_works=1
            fi
            xattr -d user.test "$tmp_xattr_test" 2>/dev/null || :
          fi
        elif command -v setfattr >/dev/null 2>&1 && command -v getfattr >/dev/null 2>&1; then
          if setfattr -n user.test -v "value" "$tmp_xattr_test" 2>/dev/null; then
            if getfattr -n user.test "$tmp_xattr_test" 2>/dev/null | grep -q "value"; then
              xattr_works=1
            fi
            setfattr -x user.test "$tmp_xattr_test" 2>/dev/null || :
          fi
        fi
        
        rm -f "$tmp_xattr_test" 2>/dev/null || :
        
        if [ "$xattr_works" -eq 1 ]; then
          printf '  %s✓%s Extended attributes: Filesystem supports xattrs\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Extended attributes: Filesystem does not support xattrs\n' "$_red" "$_reset"
          printf '    MUD features (look, check-cd-hook) require xattr support\n'
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 8 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 8 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    9)
      # Level 9: Arcane File Operations

      # Check file utilities
      file_utils_ok=1
      for cmd in cp mv rm find; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
          file_utils_ok=0
        fi
      done

      if [ "$file_utils_ok" -eq 1 ]; then
        printf '  %s✓%s File utilities: cp mv rm find\n' "$_green" "$_reset"
      else
        printf '  %s✗%s File utilities: missing command\n' "$_red" "$_reset"
        return 1
      fi

      # Check filesystem read/write
      tmp_root=${TMPDIR:-/tmp}
      tmp_check=$(mktemp "${tmp_root%/}/banish-rw.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_check" ]; then
        if printf '%s\n' "banish" >"$tmp_check" 2>/dev/null && [ -s "$tmp_check" ]; then
          rm -f "$tmp_check" 2>/dev/null || :
          printf '  %s✓%s Filesystem read/write: %s\n' "$_green" "$_reset" "$tmp_root"
        else
          rm -f "$tmp_check" 2>/dev/null || :
          printf '  %s✗%s Filesystem read/write: %s unavailable\n' "$_red" "$_reset" "$tmp_root"
          return 1
        fi
      else
        printf '  %s✗%s Filesystem read/write: temp file unavailable\n' "$_red" "$_reset"
        return 1
      fi

      # Check recursive directory operations (needed for forall, copy with dirs)
      # Arcane file operations often need to traverse directory trees
      tmp_dir=$(mktemp -d "${tmp_root%/}/banish-dir.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_dir" ]; then
        # Create nested structure
        if mkdir -p "$tmp_dir/sub1/sub2" 2>/dev/null; then
          # Test recursive find
          if find "$tmp_dir" -type d >/dev/null 2>&1; then
            # Test recursive removal
            if rm -rf "$tmp_dir" 2>/dev/null; then
              printf '  %s✓%s Recursive operations: mkdir -p, find, rm -rf work\n' "$_green" "$_reset"
            else
              rm -rf "$tmp_dir" 2>/dev/null || :
              printf '  %s✗%s Recursive operations: rm -rf failed\n' "$_red" "$_reset"
              return 1
            fi
          else
            rm -rf "$tmp_dir" 2>/dev/null || :
            printf '  %s✗%s Recursive operations: find failed\n' "$_red" "$_reset"
            return 1
          fi
        else
          rm -rf "$tmp_dir" 2>/dev/null || :
          printf '  %s✗%s Recursive operations: mkdir -p failed\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check grep pattern matching (literal and basic patterns)
      # Text processing relies on grep for searching file contents
      grep_test="test_pattern_123"
      # Test literal match with -F
      if printf '%s\n' "$grep_test" | grep -Fq "pattern" 2>/dev/null; then
        # Test basic regex
        if printf '%s\n' "$grep_test" | grep -q "test.*123" 2>/dev/null; then
          printf '  %s✓%s Pattern matching: grep literal and regex work\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Pattern matching: grep regex not working\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Pattern matching: grep literal search failed\n' "$_red" "$_reset"
        return 1
      fi

      # Check XDG directories support (needed for jump-trash on Linux)
      # jump-trash uses XDG_DATA_HOME to locate system trash directory
      xdg_data_home="${XDG_DATA_HOME:-$HOME/.local/share}"
      if [ -d "$HOME" ]; then
        # XDG spec allows it to not exist yet - just verify we can create it if needed
        if [ -d "$xdg_data_home" ] || mkdir -p "$xdg_data_home" 2>/dev/null; then
          if [ -w "$xdg_data_home" ] || [ ! -e "$xdg_data_home" ]; then
            printf '  %s✓%s XDG data directory: %s accessible\n' "$_green" "$_reset" "$xdg_data_home"
          else
            printf '  %s✗%s XDG data directory: %s not writable\n' "$_red" "$_reset" "$xdg_data_home"
            return 1
          fi
        else
          printf '  %s✗%s XDG data directory: cannot create %s\n' "$_red" "$_reset" "$xdg_data_home"
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 8 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 8 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    9)
      # Level 9: Basic Cantrips

      # Check interactive input device
      input_tty=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
      if [ -r "$input_tty" ] && [ -w "$input_tty" ]; then
        printf '  %s✓%s Interactive input: %s\n' "$_green" "$_reset" "$input_tty"
      else
        printf '  %s✗%s Interactive input: %s unavailable\n' "$_red" "$_reset" "$input_tty"
        if [ "$skip_heal" -eq 0 ] && [ -n "${AWAIT_KEYPRESS_DEVICE-}" ]; then
          input_tty=/dev/tty
          AWAIT_KEYPRESS_DEVICE=$input_tty
          export AWAIT_KEYPRESS_DEVICE
          if [ -r "$input_tty" ] && [ -w "$input_tty" ]; then
            printf '    %s✓%s Interactive input restored to /dev/tty\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Interactive input still unavailable\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -r "$input_tty" ] || [ ! -w "$input_tty" ]; then
          return 1
        fi
      fi

      # Check read builtin (needed for ask-text, ask-yn)
      # Basic cantrips rely on shell's read builtin for user input
      if printf 'test\n' | ( read -r test_input; [ "$test_input" = "test" ] ) 2>/dev/null; then
        printf '  %s✓%s Read builtin: Shell read command works\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Read builtin: Shell read command not working\n' "$_red" "$_reset"
        return 1
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 9 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 9 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    10)
      # Level 10: System Configuration

      # Check configuration directory access
      config_home=${WIZARDRY_CONFIG_DIR:-${HOME:-.}/.wizardry}
      if [ -d "$config_home" ] && [ -w "$config_home" ]; then
        printf '  %s✓%s Config directory: %s\n' "$_green" "$_reset" "$config_home"
      else
        printf '  %s✗%s Config directory: %s unavailable\n' "$_red" "$_reset" "$config_home"
        if [ "$skip_heal" -eq 0 ]; then
          if mkdir -p "$config_home" 2>/dev/null; then
            printf '    %s✓%s Config directory created\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Config directory creation failed\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -d "$config_home" ] || [ ! -w "$config_home" ]; then
          return 1
        fi
      fi

      # Test that log files can be written
      # System configuration spells need to write logs
      log_test="$config_home/.banish-log-test"
      if printf '%s\n' "test log entry" >> "$log_test" 2>/dev/null; then
        if [ -f "$log_test" ] && [ -r "$log_test" ]; then
          rm -f "$log_test" 2>/dev/null || :
          printf '  %s✓%s Log file creation: Can write config logs\n' "$_green" "$_reset"
        else
          rm -f "$log_test" 2>/dev/null || :
          printf '  %s✗%s Log file creation: File not readable after write\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Log file creation: Cannot write log files\n' "$_red" "$_reset"
        return 1
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 10 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 10 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    11)
      # Level 11: Testing Infrastructure

      # Check tests directory
      tests_root="${WIZARDRY_DIR}/.tests"
      if [ -d "$tests_root" ]; then
        printf '  %s✓%s Test suite: %s\n' "$_green" "$_reset" "$tests_root"
      else
        printf '  %s✗%s Test suite: %s missing\n' "$_red" "$_reset" "$tests_root"
        return 1
      fi

      # Skip pocket-dimension and bwrap checks in GitHub Actions
      # (bwrap should only be used in local environments, not CI workflows)
      if [ "${GITHUB_ACTIONS-}" = "true" ]; then
        printf '  %s✓%s Sandbox tools: Skipped (GitHub Actions environment)\n' "$_green" "$_reset"
      else
        # Check pocket-dimension sandboxing
        platform=$(uname -s 2>/dev/null || printf 'unknown')
        pocket_cmd=""
        if command -v pocket-dimension >/dev/null 2>&1; then
          pocket_cmd=$(command -v pocket-dimension)
        elif [ -x "${WIZARDRY_DIR}/spells/system/pocket-dimension" ]; then
          pocket_cmd="${WIZARDRY_DIR}/spells/system/pocket-dimension"
        fi

        if [ -n "$pocket_cmd" ]; then
          if "$pocket_cmd" --check >/dev/null 2>&1; then
            printf '  %s✓%s Sandbox tool: pocket-dimension available\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Sandbox tool: pocket-dimension unavailable\n' "$_red" "$_reset"
            return 1
          fi
        else
          printf '  %s✗%s Sandbox tool: pocket-dimension not found\n' "$_red" "$_reset"
          return 1
        fi

        if [ "$platform" = "Darwin" ]; then
          if command -v sandbox-exec >/dev/null 2>&1; then
            printf '  %s✓%s Sandbox tool: sandbox-exec available (macOS)\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Sandbox tool: sandbox-exec not found (macOS)\n' "$_red" "$_reset"
            return 1
          fi
        else
          if command -v bwrap >/dev/null 2>&1; then
            printf '  %s✓%s Sandbox tool: bwrap available\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Sandbox tool: bwrap not found\n' "$_red" "$_reset"
            if [ "$skip_heal" -eq 0 ]; then
              if command -v install-bwrap >/dev/null 2>&1; then
                printf '    Installing bwrap...\n'
                if install-bwrap 2>/dev/null; then
                  if command -v bwrap >/dev/null 2>&1; then
                    printf '    %s✓%s bwrap installed\n' "$_green" "$_reset"
                  else
                    printf '    %s✗%s Install failed\n' "$_red" "$_reset"
                  fi
                else
                  printf '    %s✗%s Install failed\n' "$_red" "$_reset"
                fi
              else
                printf '    Auto-install not available\n'
              fi
            fi
            if ! command -v bwrap >/dev/null 2>&1; then
              return 1
            fi
          fi
        fi
      fi

      # Check shell script sourcing capability (critical for test framework)
      # Test framework relies on sourcing test files and helper scripts
      tmp_root=${TMPDIR:-/tmp}
      tmp_source_test=$(mktemp "${tmp_root%/}/banish-source.XXXXXX" 2>/dev/null || printf '')
      if [ -n "$tmp_source_test" ]; then
        # Create a simple script that sets a variable
        printf '%s\n' 'BANISH_SOURCE_TEST="sourced_successfully"' > "$tmp_source_test"
        
        # Try to source it
        BANISH_SOURCE_TEST=""
        # shellcheck disable=SC1090
        . "$tmp_source_test" 2>/dev/null || :
        
        rm -f "$tmp_source_test" 2>/dev/null || :
        
        if [ "$BANISH_SOURCE_TEST" = "sourced_successfully" ]; then
          printf '  %s✓%s Script sourcing: Can source shell scripts with .\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Script sourcing: Cannot source shell scripts\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 11 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 11 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;


    19)
      # Level 19: Extended Attributes

      # Check extended attributes helpers
      xattr_helper=""
      if command -v xattr >/dev/null 2>&1; then
        xattr_helper="xattr"
      elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
        xattr_helper="getfattr/setfattr"
      fi

      if [ -n "$xattr_helper" ]; then
        printf '  %s✓%s Extended attributes: %s available\n' "$_green" "$_reset" "$xattr_helper"
      else
        printf '  %s✗%s Extended attributes: no helper found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          manage_system_command=""
          if command -v manage-system-command >/dev/null 2>&1; then
            manage_system_command="manage-system-command"
          elif [ -x "${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command" ]; then
            manage_system_command="${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command"
          fi
          if [ -n "$manage_system_command" ]; then
            printf '    Attempting to install xattr tooling...\n'
            "$manage_system_command" getfattr attr >/dev/null 2>&1 || :
            "$manage_system_command" setfattr attr >/dev/null 2>&1 || :
          fi
        fi
        has_xattr=0
        if command -v xattr >/dev/null 2>&1; then
          has_xattr=1
        elif command -v getfattr >/dev/null 2>&1 && command -v setfattr >/dev/null 2>&1; then
          has_xattr=1
        fi
        if [ "$has_xattr" -eq 1 ]; then
          printf '    %s✓%s Extended attributes helper ready\n' "$_green" "$_reset"
        else
          printf '    %s✗%s Extended attributes still unavailable\n' "$_red" "$_reset"
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 19 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 19 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    21)
      # Level 21: Spellcraft Development Tools

      # Check checkbashisms for lint-magic
      if command -v checkbashisms >/dev/null 2>&1; then
        printf '  %s✓%s Shell lint: checkbashisms available\n' "$_green" "$_reset"
      else
        printf '  %s✗%s Shell lint: checkbashisms not found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          if command -v install-checkbashisms >/dev/null 2>&1; then
            printf '    Installing checkbashisms...\n'
            if install-checkbashisms 2>/dev/null; then
              if command -v checkbashisms >/dev/null 2>&1; then
                printf '    %s✓%s checkbashisms installed\n' "$_green" "$_reset"
              else
                printf '    %s✗%s Install failed\n' "$_red" "$_reset"
              fi
            else
              printf '    %s✗%s Install failed\n' "$_red" "$_reset"
            fi
          else
            printf '    Auto-install not available\n'
          fi
        fi
        if ! command -v checkbashisms >/dev/null 2>&1; then
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 21 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 21 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;

    22)
      # Level 22: Core Menu Infrastructure

      # Check spellbook directory access
      spell_home=${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}
      if [ -d "$spell_home" ] && [ -w "$spell_home" ]; then
        printf '  %s✓%s Spellbook directory: %s\n' "$_green" "$_reset" "$spell_home"
      else
        printf '  %s✗%s Spellbook directory: %s unavailable\n' "$_red" "$_reset" "$spell_home"
        if [ "$skip_heal" -eq 0 ]; then
          if mkdir -p "$spell_home" 2>/dev/null; then
            printf '    %s✓%s Spellbook directory created\n' "$_green" "$_reset"
          else
            printf '    %s✗%s Spellbook directory creation failed\n' "$_red" "$_reset"
          fi
        fi
        if [ ! -d "$spell_home" ] || [ ! -w "$spell_home" ]; then
          return 1
        fi
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 22 spells)
      if [ -n "$spell_list" ]; then
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --missing-only $spell_list" 2>/dev/null || true)
          missing_count=$("$_banish_count_words" "$missing")
          label=$("$_banish_pluralize" "Spell" "$missing_count" "Spells")
          printf '  %s✗%s %s: Missing: %s\n' "$_red" "$_reset" "$label" "$missing"
          return 1
        fi
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || true
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 22 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      ;;
      
    27)
      # Level 27: Optional Arcana (single item - combine on one line)
      if [ -d "${WIZARDRY_DIR}/spells/.arcana" ]; then
        arcana_count=$(find "${WIZARDRY_DIR}/spells/.arcana" -type f 2>/dev/null | wc -l)
        printf '  %s✓%s Arcana (optional): Found %d scripts\n' "$_green" "$_reset" "$arcana_count"
      else
        printf '  Arcana (optional): Not installed\n'
      fi
      ;;

    4)
      # Level 4: Menu System
      
      # Check terminal interactivity assumptions
      # Menu system requires a fully interactive terminal with cursor control
      
      # Verify stdin is a terminal (not a pipe or file)
      # Skip in CI/non-interactive environments
      if [ "${CI-}" = "true" ] || [ "${GITHUB_ACTIONS-}" = "true" ] || [ ! -t 0 ]; then
        if [ -t 0 ]; then
          printf '  %s✓%s stdin: Connected to terminal\n' "$_green" "$_reset"
        else
          printf '  %s✓%s stdin: Non-interactive (CI/testing environment)\n' "$_green" "$_reset"
        fi
      else
        if [ -t 0 ]; then
          printf '  %s✓%s stdin: Connected to terminal\n' "$_green" "$_reset"
        else
          printf '  %s✗%s stdin: Not a terminal (pipe/file detected)\n' "$_red" "$_reset"
          printf '    Menu system requires interactive terminal input\n'
          return 1
        fi
      fi

      # Verify stdout is a terminal (not redirected)
      # More lenient - just report status without failing
      if [ -t 1 ]; then
        printf '  %s✓%s stdout: Connected to terminal\n' "$_green" "$_reset"
      else
        printf '  %s✓%s stdout: Redirected (testing mode)\n' "$_green" "$_reset"
      fi

      # Check terminal size is reasonable for menu display
      if command -v tput >/dev/null 2>&1; then
        term_cols=$(tput cols 2>/dev/null || printf '0')
        term_lines=$(tput lines 2>/dev/null || printf '0')
        
        min_cols=40
        min_lines=10
        
        if [ "$term_cols" -ge "$min_cols" ] && [ "$term_lines" -ge "$min_lines" ]; then
          printf '  %s✓%s Terminal size: %sx%s (adequate for menus)\n' "$_green" "$_reset" "$term_cols" "$term_lines"
        elif [ "$term_cols" -eq 0 ] || [ "$term_lines" -eq 0 ]; then
          # Terminal size unavailable (common in CI)
          printf '  %s✓%s Terminal size: Unknown (non-interactive environment)\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Terminal size: %sx%s (too small, need at least %sx%s)\n' "$_red" "$_reset" "$term_cols" "$term_lines" "$min_cols" "$min_lines"
          return 1
        fi
      fi

      # Check stty raw mode support (required for await-keypress)
      # Only test if we have a real terminal
      if [ -t 0 ] && [ -t 1 ]; then
        original_stty=$(stty -g 2>/dev/null || printf '')
        
        if [ -n "$original_stty" ]; then
          # Test if we can use raw mode
          if stty raw -echo 2>/dev/null; then
            stty "$original_stty" 2>/dev/null || :
            printf '  %s✓%s Terminal raw mode: Available (for keypress capture)\n' "$_green" "$_reset"
          else
            printf '  %s✗%s Terminal raw mode: Not available\n' "$_red" "$_reset"
            return 1
          fi
        fi
      else
        printf '  %s✓%s Terminal raw mode: Skipped (non-interactive)\n' "$_green" "$_reset"
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 4 spells)
      has_missing_spells=0
      if [ -n "$spell_list" ]; then
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || has_missing_spells=1
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
        
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          has_missing_spells=1
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 4 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      
      if [ "$has_missing_spells" -eq 1 ]; then
        return 1
      fi
      ;;

    12)
      # Level 12: System Maintenance
      
      # Check git availability (update-wizardry uses git)
      # System maintenance often requires version control operations
      if command -v git >/dev/null 2>&1; then
        # Verify git actually works (can run git --version)
        if git --version >/dev/null 2>&1; then
          printf '  %s✓%s Version control: git available\n' "$_green" "$_reset"
        else
          printf '  %s✗%s Version control: git found but not working\n' "$_red" "$_reset"
          return 1
        fi
      else
        printf '  %s✗%s Version control: git not found\n' "$_red" "$_reset"
        printf '    update-wizardry requires git for repository updates\n'
        if [ "$skip_heal" -eq 0 ]; then
          manage_system_command=""
          if command -v manage-system-command >/dev/null 2>&1; then
            manage_system_command="manage-system-command"
          elif [ -x "${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command" ]; then
            manage_system_command="${WIZARDRY_DIR}/spells/.arcana/core/manage-system-command"
          fi
          if [ -n "$manage_system_command" ]; then
            printf '    Attempting to install git...\n'
            "$manage_system_command" git git >/dev/null 2>&1 || :
            if command -v git >/dev/null 2>&1; then
              printf '    %s✓%s git installed\n' "$_green" "$_reset"
            else
              printf '    %s✗%s git installation failed\n' "$_red" "$_reset"
            fi
          fi
        fi
        if ! command -v git >/dev/null 2>&1; then
          return 1
        fi
      fi

      # Check available memory (git operations can be memory-intensive)
      # Large repositories need sufficient RAM for operations
      if [ -r /proc/meminfo ]; then
        mem_available_kb=$(grep MemAvailable /proc/meminfo 2>/dev/null | awk '{print $2}' || printf '0')
        mem_total_kb=$(grep MemTotal /proc/meminfo 2>/dev/null | awk '{print $2}' || printf '0')
        
        # Check for at least 100MB available memory
        if [ "$mem_available_kb" -gt 102400 ]; then
          printf '  %s✓%s Memory: Sufficient RAM available (%d MB)\n' "$_green" "$_reset" "$((mem_available_kb / 1024))"
        elif [ "$mem_available_kb" -gt 51200 ]; then
          printf '  %s✓%s Memory: Limited RAM (%d MB, git ops may be slow)\n' "$_green" "$_reset" "$((mem_available_kb / 1024))"
        else
          printf '  %s✗%s Memory: Low RAM (%d MB, git may fail)\n' "$_red" "$_reset" "$((mem_available_kb / 1024))"
        fi
      else
        # macOS or other systems without /proc/meminfo
        printf '  %s✓%s Memory: Cannot check (non-Linux system)\n' "$_green" "$_reset"
      fi

      # Check spells
      spell_list=$("$spell_levels_script" 12 spells)
      has_missing_spells=0
      if [ -n "$spell_list" ]; then
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || has_missing_spells=1
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
        
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          has_missing_spells=1
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" 12 imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      
      if [ "$has_missing_spells" -eq 1 ]; then
        return 1
      fi
      ;;
      
    *)
      # Levels 13-17, 19-20, 22, 25-28: Standard validation pattern
      
      # Check spells
      spell_list=$("$spell_levels_script" "$level" spells)
      has_missing_spells=0
      if [ -n "$spell_list" ]; then
        # Always show spell status (both available and missing)
        spell_output=$(eval ""$validate_spells" --show-status $spell_list" 2>&1) || has_missing_spells=1
        if [ -n "$spell_output" ]; then
          printf '%s\n' "$spell_output" | sed 's/^/  /'
        else
          printf '  %s(no spell status available)%s\n' "$_red" "$_reset"
        fi
        
        # Check if there were missing spells (will fail at the end)
        if ! eval ""$validate_spells" --quiet $spell_list" 2>/dev/null; then
          has_missing_spells=1
        fi
      fi

      # Check imps
      imp_list=$("$spell_levels_script" "$level" imps)
      had_imps=0
      if [ -n "$imp_list" ]; then
        had_imps=1
        new_imp_list=""
        for imp in $imp_list; do
          case " ${_banish_seen_imps} " in
            *" ${imp} "*) ;;
            *)
              new_imp_list="${new_imp_list}${new_imp_list:+ }${imp}"
              _banish_seen_imps="${_banish_seen_imps}${_banish_seen_imps:+ }${imp}"
              ;;
          esac
        done
        imp_list=$new_imp_list
      fi
      if [ -n "$imp_list" ]; then
        if ! eval ""$validate_spells" --quiet --imps $imp_list" 2>/dev/null; then
          missing=$(eval ""$validate_spells" --imps --missing-only $imp_list" 2>/dev/null || true)
          printf '  %s✗%s Missing imps: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        imp_output=$(eval ""$validate_spells" --imps --show-status $imp_list" 2>&1) || true
        if [ -n "$imp_output" ]; then
          printf '%s\n' "$imp_output" | sed 's/^/  /'
        else
          printf '  %s(no imp status available)%s\n' "$_red" "$_reset"
        fi
      elif [ "$had_imps" -eq 1 ]; then
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      else
        printf '  %s✓%s No new imps.\n' "$_green" "$_reset"
      fi
      
      # Return error if there were missing spells
      if [ "$has_missing_spells" -eq 1 ]; then
        return 1
      fi
      ;;
   esac
   
   return 0
}


# Main execution: Run levels 0 through target_level (or only target_level if --only)
if [ "$only_this_level" -eq 1 ]; then
  printf '\nValidating Level %d only: %s\n' "$target_level" "$("$spell_levels_script" "$target_level" name)"
else
  printf '\nValidating through Level %d: %s\n' "$target_level" "$("$spell_levels_script" "$target_level" name)"
fi

# Set up validate-spells command path
validate_spells="${WIZARDRY_DIR}/spells/.wizardry/validate-spells"
if [ ! -x "$validate_spells" ]; then
  printf '%s\n' "banish: validate-spells not found or not executable" >&2
  exit 1
fi

# Run each level from 0 to target_level (or just target_level if --only)
if [ "$only_this_level" -eq 1 ]; then
  current_level=$target_level
else
  current_level=0
fi

last_success_level=-1
while [ "$current_level" -le "$target_level" ]; do
  banish_process_level "$current_level" || {
    exit_code=$?
    if [ "$last_success_level" -ge 0 ]; then
      printf '\n%s✓%s Banished to Level %d\n' "$_green" "$_reset" "$last_success_level"
    fi
    printf '%s✗%s Failed to banish Level %d\n' "$_red" "$_reset" "$current_level"
    exit "$exit_code"
  }
  last_success_level=$current_level
  if [ "$only_this_level" -eq 1 ]; then
    break
  fi
  current_level=$((current_level + 1))
done

# Final success message
if [ "$run_all" -eq 1 ]; then
  printf '\n%s✓%s Banished all\n' "$_green" "$_reset"
else
  printf '\n%s✓%s Banished to Level %d\n' "$_green" "$_reset" "$last_success_level"
fi

exit 0
