#!/bin/sh

# Ward the system against common security vulnerabilities.
# Checks security configurations at three levels: recommended, advanced, and expert.
#
# NOTE: ward-system uses its own 3-level system (1-3) which is independent
# from wizardry's general spell-levels system. These levels represent
# security check severity, not spell complexity.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: ward-system [LEVEL] [OPTIONS]

Check and fix system security issues at different threat levels.
Supports Linux and macOS systems.

NOTE: ward-system levels (1-3) are independent from wizardry's spell-levels.
      These represent security check severity, not spell complexity.

Arguments:
  LEVEL                 Security level to check (1-3, all, default: 1)
                        1 = Recommended (essential security)
                        2 = Advanced (additional hardening)
                        3 = Expert (obscure/dangerous checks)
                        all = Run all levels (1, 2, and 3)

Options:
  -v, --verbose         Show full descriptions even for passing checks
  --no-fix              Only report issues, do not offer fixes

Levels:
  1 (Recommended)       Essential security checks for all systems
  2 (Advanced)          Additional hardening for security-conscious users
  3 (Expert)            Obscure and potentially dangerous checks

Examples:
  ward-system           # Check level 1 only (recommended)
  ward-system 2         # Check level 2 only (advanced)
  ward-system all       # Check all levels (1, 2, and 3)
  ward-system 3 -v      # Check level 3 only with verbose output
  ward-system 1 --no-fix # Only report level 1 issues
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Source required utilities
. colors

# Parse arguments
level=1
run_all=0
verbose=0
no_fix=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    1|2|3)
      level=$1
      shift
      ;;
    all)
      run_all=1
      shift
      ;;
    -v|--verbose)
      verbose=1
      shift
      ;;
    --no-fix)
      no_fix=1
      shift
      ;;
    *)
      die "ward-system: unknown option: $1"
      ;;
  esac
done

# Helper functions
ward_pass() {
  printf '%s✓%s %s\n' "${GREEN}" "${RESET}" "$1"
}

ward_fail() {
  printf '%s✗%s %s\n' "${RED}" "${RESET}" "$1"
}

ward_title() {
  printf '\n%s%s%s\n' "${BOLD}" "$1" "${RESET}"
}

ward_desc() {
  if [ "$verbose" -eq 1 ] || [ "$2" -eq 1 ]; then
    printf '%s\n' "$1"
  fi
}

ward_ask_fix() {
  if [ "$no_fix" -eq 1 ]; then
    return 1
  fi
  ask-yn "$1" no
}

# Level 1: Recommended security checks
check_level_1() {
  ward_title "Level 1: Recommended Security Checks"
  
  # Check umask
  current_umask=$(umask)
  if [ "$current_umask" = "0022" ] || [ "$current_umask" = "0027" ] || \
     [ "$current_umask" = "022" ] || [ "$current_umask" = "027" ]; then
    ward_pass "Umask is properly configured ($current_umask)"
    ward_desc "Umask controls default file permissions. Current setting is secure." 0
  else
    ward_fail "Umask is not secure (current: $current_umask, recommended: 0022 or 0027)"
    msg="Umask controls default file permissions for new files. "
    msg="${msg}A value of 0022 makes files readable by all but writable only by owner. "
    msg="${msg}This is a shell setting that should be configured in your profile."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on fixing the umask?"; then
      printf 'Add this line to your shell profile (~/.bashrc, ~/.zshrc, etc.):\n'
      printf '  umask 0022\n'
    fi
  fi
  
  # Check for current directory in PATH
  case ":$PATH:" in
    *::*|*:.:*)
      ward_fail "Current directory (.) is in PATH - security risk"
      msg="Having current directory in PATH allows attackers to trick you "
      msg="${msg}into running malicious executables. "
      msg="${msg}Remove '.' and empty entries from PATH."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like to see how to fix this?"; then
        printf 'Remove current directory from PATH in your shell profile:\n'
        printf '  export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n'
      fi
      ;;
    *)
      ward_pass "PATH does not contain current directory"
      ward_desc "PATH is configured securely without current directory." 0
      ;;
  esac
  
  # Check SSH directory permissions if it exists
  ssh_dir="${HOME}/.ssh"
  if [ -d "$ssh_dir" ]; then
    ssh_perms=$(ls -ld "$ssh_dir" 2>/dev/null | awk '{print $1}')
    case "$ssh_perms" in
      drwx------*|drwx--x---*)
        ward_pass "SSH directory permissions are secure (~/.ssh)"
        ward_desc "SSH directory should be readable only by owner (700)." 0
        ;;
      *)
        ward_fail "SSH directory has insecure permissions: $ssh_perms"
        msg="The ~/.ssh directory contains sensitive cryptographic keys. "
        msg="${msg}It must be readable only by you (permissions 700) "
        msg="${msg}to prevent unauthorized access."
        ward_desc "$msg" 1
        if ward_ask_fix "Fix SSH directory permissions?"; then
          chmod 700 "$ssh_dir" && success "Fixed ~/.ssh permissions to 700"
        fi
        ;;
    esac
    
    # Check for private keys with wrong permissions
    key_check_shown=0
    for key in "$ssh_dir"/id_* "$ssh_dir"/*_rsa \
               "$ssh_dir"/*_ed25519 "$ssh_dir"/*_ecdsa; do
      # Check if it's a private key (not .pub)
      if [ -f "$key" ] && ! printf '%s\n' "$key" | grep -q '\.pub$'; then
        key_perms=$(ls -l "$key" 2>/dev/null | awk '{print $1}')
        case "$key_perms" in
          -rw-------*)
            # Only show success message once for all secure keys
            if [ "$key_check_shown" -eq 0 ]; then
              ward_pass "SSH private keys have secure permissions"
              ward_desc "Private keys should be readable only by owner (600)." 0
              key_check_shown=1
            fi
            ;;
          *)
            key_name=$(basename "$key")
            ward_fail "SSH private key has insecure permissions: $key_name ($key_perms)"
            msg="Private SSH keys must have permissions 600 "
            msg="${msg}(readable/writable only by owner) "
            msg="${msg}to prevent unauthorized use."
            ward_desc "$msg" 1
            if ward_ask_fix "Fix permissions for $key_name?"; then
              chmod 600 "$key" && success "Fixed permissions for $key_name"
            fi
            # Mark that we've shown a message (don't show success after failures)
            key_check_shown=1
            ;;
        esac
      fi
    done
  fi
  
  # Check home directory permissions
  home_perms=$(ls -ld "$HOME" 2>/dev/null | awk '{print $1}')
  case "$home_perms" in
    drwx------*|drwxr-x---*|drwxr-xr-x*)
      ward_pass "Home directory permissions are acceptable"
      msg="Home directory should be 700 (private) or 755 "
      msg="${msg}(readable by others but not writable)."
      ward_desc "$msg" 0
      ;;
    *)
      ward_fail "Home directory has unusual permissions: $home_perms"
      msg="Your home directory should typically be mode 700 "
      msg="${msg}(completely private) or 755 (readable but not writable by others). "
      msg="${msg}Current permissions may allow unauthorized access."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing home directory permissions?"; then
        printf 'Consider setting your home directory to 700 (private):\n'
        printf '  chmod 700 %s\n' "$HOME"
        printf 'Or 755 (readable by others) if needed for your use case.\n'
      fi
      ;;
  esac
  
  # Check shell history file permissions
  for history_file in "$HOME/.bash_history" "$HOME/.zsh_history" \
                       "$HOME/.sh_history" "$HOME/.history"; do
    if [ -f "$history_file" ]; then
      history_perms=$(ls -l "$history_file" 2>/dev/null | awk '{print $1}')
      case "$history_perms" in
        -rw-------*)
          ward_pass "Shell history file has secure permissions"
          ward_desc "History files should be private (600) to protect sensitive commands." 0
          break
          ;;
        *)
          ward_fail "Shell history file has insecure permissions: $history_perms"
          msg="Shell history files may contain sensitive information like passwords. "
          msg="${msg}They should have permissions 600 (readable/writable only by owner)."
          ward_desc "$msg" 1
          if ward_ask_fix "Fix shell history file permissions?"; then
            chmod 600 "$history_file" && success "Fixed $history_file permissions to 600"
          fi
          break
          ;;
      esac
    fi
  done
  
  # Check /tmp directory permissions
  if [ -d /tmp ]; then
    tmp_perms=$(ls -ld /tmp 2>/dev/null | awk '{print $1}')
    if printf '%s' "$tmp_perms" | grep -q 't'; then
      ward_pass "/tmp has sticky bit set"
      ward_desc "Sticky bit on /tmp prevents users from deleting others' files." 0
    else
      ward_fail "/tmp does not have sticky bit set"
      msg="/tmp should have the sticky bit (t) set to prevent users from "
      msg="${msg}deleting files they don't own. This is a common security measure."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing /tmp permissions?"; then
        printf 'Set sticky bit on /tmp (requires root):\n'
        printf '  sudo chmod +t /tmp\n'
      fi
    fi
  fi
  
  # Check for .netrc file (stores passwords)
  if [ -f "$HOME/.netrc" ]; then
    netrc_perms=$(ls -l "$HOME/.netrc" 2>/dev/null | awk '{print $1}')
    case "$netrc_perms" in
      -rw-------*)
        ward_pass ".netrc file has secure permissions"
        ward_desc ".netrc stores credentials and should be private (600)." 0
        ;;
      *)
        ward_fail ".netrc file has insecure permissions: $netrc_perms"
        msg="The .netrc file stores login credentials and must have "
        msg="${msg}permissions 600 to prevent unauthorized access."
        ward_desc "$msg" 1
        if ward_ask_fix "Fix .netrc permissions?"; then
          chmod 600 "$HOME/.netrc" && success "Fixed .netrc permissions to 600"
        fi
        ;;
    esac
  fi
  
  # Check DNS configuration file permissions
  if [ -r /etc/resolv.conf ]; then
    resolv_perms=$(ls -l /etc/resolv.conf 2>/dev/null | awk '{print $1}')
    if printf '%s' "$resolv_perms" | grep -q 'w..w'; then
      ward_fail "/etc/resolv.conf is world-writable"
      msg="DNS configuration should not be writable by all users. "
      msg="${msg}This could allow DNS hijacking attacks."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing /etc/resolv.conf?"; then
        printf 'Fix /etc/resolv.conf permissions (requires root):\n'
        printf '  sudo chmod 644 /etc/resolv.conf\n'
      fi
    else
      ward_pass "/etc/resolv.conf has secure permissions"
      ward_desc "DNS configuration file is protected from unauthorized modification." 0
    fi
  fi
  
  # Check for suspicious entries in /etc/hosts
  if [ -r /etc/hosts ]; then
    # Look for common suspicious patterns (redirecting major sites)
    if has grep; then
      suspicious=$(grep -E "google\.com|facebook\.com|twitter\.com|github\.com|amazon\.com" \
                        /etc/hosts 2>/dev/null | grep -v "^#" | grep -v "^$" || printf '')
      if [ -n "$suspicious" ]; then
        ward_fail "Suspicious entries found in /etc/hosts"
        msg="/etc/hosts contains redirections for major websites. "
        msg="${msg}This could indicate DNS hijacking or malware."
        ward_desc "$msg" 1
        printf 'Suspicious entries:\n%s\n' "$suspicious"
      else
        ward_pass "/etc/hosts has no obvious suspicious entries"
        ward_desc "/etc/hosts file appears normal." "$verbose"
      fi
    fi
  fi
  
  # Check system timezone configuration
  if has timedatectl; then
    timezone=$(timedatectl 2>/dev/null | grep "Time zone" | awk '{print $3}' || printf 'unknown')
    ward_pass "System timezone: $timezone"
    ward_desc "Verify timezone is appropriate for your location." "$verbose"
  elif [ -r /etc/timezone ]; then
    timezone=$(cat /etc/timezone 2>/dev/null || printf 'unknown')
    ward_pass "System timezone: $timezone"
    ward_desc "Verify timezone is appropriate for your location." "$verbose"
  fi
}

# Level 2: Advanced security checks
check_level_2() {
  ward_title "Level 2: Advanced Security Checks"
  
  # Check if running as root
  if [ "$(id -u)" -eq 0 ]; then
    ward_fail "Running as root - not recommended for daily use"
    msg="Running as root (UID 0) bypasses all permission checks "
    msg="${msg}and increases security risk. "
    msg="${msg}Use sudo for administrative tasks instead of logging in as root."
    ward_desc "$msg" 1
  else
    ward_pass "Not running as root"
    ward_desc "Running as regular user is a security best practice." 0
  fi
  
  # Check for world-writable files in home
  if has find; then
    world_writable=$(find "$HOME" -type f -perm -002 2>/dev/null | head -5)
    if [ -n "$world_writable" ]; then
      ward_fail "Found world-writable files in home directory"
      msg="World-writable files can be modified by any user on the system, "
      msg="${msg}which is a security risk. "
      msg="${msg}Files should typically be writable only by their owner."
      ward_desc "$msg" 1
      printf 'First few world-writable files:\n%s\n' "$world_writable"
      if ward_ask_fix "Would you like to search for all world-writable files?"; then
        printf 'Run this command to find all world-writable files:\n'
        printf '  find %s -type f -perm -002\n' "$HOME"
      fi
    else
      ward_pass "No world-writable files in home directory"
      msg="Files are properly protected from unauthorized modification."
      ward_desc "$msg" 0
    fi
  fi
  
  # Check SSH daemon configuration if accessible
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      # Check PermitRootLogin
      if grep -q "^PermitRootLogin no" "$sshd_config" 2>/dev/null; then
        ward_pass "SSH root login is disabled"
        ward_desc "Disabling root login via SSH prevents direct root access over the network." 0
      elif grep -q "^PermitRootLogin" "$sshd_config" 2>/dev/null; then
        permit_root=$(grep "^PermitRootLogin" "$sshd_config" | awk '{print $2}')
        ward_fail "SSH allows root login: $permit_root"
        msg="Allowing root login via SSH is a security risk. "
        msg="${msg}Even with key-based authentication, "
        msg="${msg}it's better to use sudo for privilege escalation. "
        msg="${msg}Recommended: PermitRootLogin no"
        ward_desc "$msg" 1
        if ward_ask_fix "Disable root login via SSH?"; then
          info "Please run: ssh-barrier"
        fi
      fi
      
      # Check PasswordAuthentication
      if grep -q "^PasswordAuthentication no" "$sshd_config" 2>/dev/null; then
        ward_pass "SSH password authentication is disabled"
        ward_desc "Key-based authentication is more secure than passwords." 0
      elif grep -q "^PasswordAuthentication yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH allows password authentication"
        msg="Password authentication is vulnerable to brute-force attacks. "
        msg="${msg}Use key-based authentication instead. "
        msg="${msg}Recommended: PasswordAuthentication no"
        ward_desc "$msg" 1
        if ward_ask_fix "Disable password authentication?"; then
          info "Please run: ssh-barrier"
        fi
      fi
      break
    fi
  done
  
  # Check for SSH keys
  has_ssh_key=0
  for key_type in id_rsa id_ed25519 id_ecdsa; do
    if [ -f "${HOME}/.ssh/${key_type}" ]; then
      has_ssh_key=1
      ward_pass "SSH key exists: $key_type"
      ward_desc "SSH keys enable secure, password-less authentication." 0
      break
    fi
  done
  
  if [ "$has_ssh_key" -eq 0 ]; then
    ward_fail "No SSH keys found"
    msg="SSH keys provide secure authentication without passwords. "
    msg="${msg}Generate keys with: ssh-keygen -t ed25519"
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on creating SSH keys?"; then
      printf 'Generate an Ed25519 SSH key (recommended):\n'
      printf '  ssh-keygen -t ed25519 -C "your_email@example.com"\n'
      printf 'Or an RSA key (for compatibility):\n'
      printf '  ssh-keygen -t rsa -b 4096 -C "your_email@example.com"\n'
    fi
  fi
  
  # Check sudo configuration
  if [ -r /etc/sudoers ] || [ -d /etc/sudoers.d ]; then
    ward_pass "Sudo configuration files exist"
    msg="Review sudo configuration to ensure only authorized users "
    msg="${msg}have privileges."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for password in shell history
  if has grep; then
    for history_file in "$HOME/.bash_history" "$HOME/.zsh_history" \
                         "$HOME/.sh_history" "$HOME/.history"; do
      if [ -f "$history_file" ]; then
        # Look for common password-related patterns
        if grep -qi "password\|passwd\|pwd" "$history_file" 2>/dev/null | head -1 >/dev/null; then
          ward_fail "Possible passwords found in shell history"
          msg="Shell history contains password-related commands. "
          msg="${msg}Never include passwords in command-line arguments. "
          msg="${msg}Consider clearing sensitive history entries."
          ward_desc "$msg" 1
          if ward_ask_fix "Would you like guidance on cleaning history?"; then
            printf 'Edit your history file to remove sensitive entries:\n'
            printf '  $EDITOR %s\n' "$history_file"
            printf 'Or clear entire history (caution):\n'
            printf '  history -c && > %s\n' "$history_file"
          fi
          break
        fi
      fi
    done
  fi
  
  # Check for unattended-upgrades (Linux only)
  if has systemctl; then
    if systemctl is-enabled unattended-upgrades >/dev/null 2>&1 || \
       systemctl is-active unattended-upgrades >/dev/null 2>&1; then
      ward_pass "Automatic security updates are configured"
      ward_desc "Unattended-upgrades helps keep system secure with automatic updates." 0
    else
      ward_fail "Automatic security updates not configured"
      msg="Automatic security updates help protect against known vulnerabilities. "
      msg="${msg}Consider enabling unattended-upgrades."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling auto-updates?"; then
        printf 'On Ubuntu/Debian:\n'
        printf '  sudo apt install unattended-upgrades\n'
        printf '  sudo dpkg-reconfigure -plow unattended-upgrades\n'
      fi
    fi
  fi
  
  # Check authorized_keys permissions
  if [ -f "$HOME/.ssh/authorized_keys" ]; then
    auth_keys_perms=$(ls -l "$HOME/.ssh/authorized_keys" 2>/dev/null | awk '{print $1}')
    case "$auth_keys_perms" in
      -rw-------*|-rw-r--r--*)
        ward_pass "authorized_keys file has acceptable permissions"
        ward_desc "authorized_keys should be 600 or 644." 0
        ;;
      *)
        ward_fail "authorized_keys has insecure permissions: $auth_keys_perms"
        msg="The authorized_keys file controls SSH access. "
        msg="${msg}It should have permissions 600 or 644."
        ward_desc "$msg" 1
        if ward_ask_fix "Fix authorized_keys permissions?"; then
          chmod 600 "$HOME/.ssh/authorized_keys" && \
            success "Fixed authorized_keys permissions to 600"
        fi
        ;;
    esac
  fi
  
  # Check cron access control files
  if [ -f /etc/cron.allow ] || [ -f /etc/cron.deny ]; then
    ward_pass "Cron access control files exist"
    msg="cron.allow/cron.deny controls who can use cron. "
    msg="${msg}Review these files to ensure only authorized users have access."
    ward_desc "$msg" "$verbose"
  else
    ward_fail "No cron access control files found"
    msg="Without cron.allow or cron.deny, all users can create cron jobs. "
    msg="${msg}Consider creating /etc/cron.allow for better security."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on cron access control?"; then
      printf 'Create /etc/cron.allow to restrict cron access (requires root):\n'
      printf '  sudo touch /etc/cron.allow\n'
      printf '  sudo chmod 600 /etc/cron.allow\n'
      printf '  echo "root" | sudo tee /etc/cron.allow\n'
    fi
  fi
  
  # Check for X11 forwarding in SSH config
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      if grep -q "^X11Forwarding yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH X11 forwarding is enabled"
        msg="X11 forwarding can be a security risk if not needed. "
        msg="${msg}Disable with: X11Forwarding no in sshd_config"
        ward_desc "$msg" 1
      else
        ward_pass "SSH X11 forwarding is not explicitly enabled"
        ward_desc "X11 forwarding disabled or not configured." "$verbose"
      fi
      break
    fi
  done
  
  # Check for empty passwords in shadow file (if readable)
  if [ -r /etc/shadow ]; then
    if has awk; then
      empty_pass=$(awk -F: '($2 == "" || $2 == "!") {print $1}' \
                       /etc/shadow 2>/dev/null || printf '')
      if [ -n "$empty_pass" ]; then
        ward_fail "Users with empty or locked passwords found"
        msg="Empty passwords are a critical security risk. "
        msg="${msg}Review: $(printf '%s' "$empty_pass" | head -1)"
        ward_desc "$msg" 1
      else
        ward_pass "No users with empty passwords detected"
        ward_desc "All user accounts have password hashes." 0
      fi
    fi
  fi
  
  # Check NTP/time synchronization
  if has timedatectl; then
    if timedatectl status 2>/dev/null | grep -q "synchronized: yes"; then
      ward_pass "System time is synchronized"
      ward_desc "Time synchronization is critical for security logs and certificates." 0
    else
      ward_fail "System time is not synchronized"
      msg="Time synchronization is important for security logs and SSL/TLS. "
      msg="${msg}Enable with systemd-timesyncd or ntpd."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling time sync?"; then
        printf 'Enable time synchronization:\n'
        printf '  sudo timedatectl set-ntp true\n'
      fi
    fi
  elif has ntpq; then
    if ntpq -p >/dev/null 2>&1; then
      ward_pass "NTP is configured and running"
      ward_desc "Time synchronization via NTP is active." 0
    else
      ward_fail "NTP appears to be installed but not working"
      ward_desc "Check NTP configuration." 1
    fi
  fi
  
  # Check package manager repository security
  if [ -d /etc/apt/sources.list.d ]; then
    third_party=$(find /etc/apt/sources.list.d -name "*.list" 2>/dev/null | wc -l)
    if [ "$third_party" -gt 0 ]; then
      ward_pass "Found $third_party third-party repository files"
      msg="Review third-party repositories for legitimacy: "
      msg="${msg}ls -la /etc/apt/sources.list.d/"
      ward_desc "$msg" "$verbose"
    fi
  fi
}

# Level 3: Expert/obscure security checks
check_level_3() {
  ward_title "Level 3: Expert Security Checks"
  
  # Check for SUID binaries (security risk if compromised)
  if has find; then
    suid_count=$(find /usr/bin /usr/local/bin /bin 2>/dev/null \
                      -type f -perm -4000 | wc -l | tr -d ' ')
    ward_pass "Found $suid_count SUID binaries in standard locations"
    msg="SUID binaries run with elevated privileges. "
    msg="${msg}While some are necessary (sudo, passwd), "
    msg="${msg}excessive SUID binaries increase attack surface. "
    msg="${msg}Review with: find / -type f -perm -4000 2>/dev/null"
    ward_desc "$msg" "$verbose"
  fi
  
  # Check core dumps
  ulimit_core=$(ulimit -c 2>/dev/null || printf 'unknown')
  if [ "$ulimit_core" = "0" ]; then
    ward_pass "Core dumps are disabled"
    msg="Core dumps can contain sensitive information from memory. "
    msg="${msg}Disabling prevents information leakage."
    ward_desc "$msg" 0
  else
    ward_fail "Core dumps are enabled (limit: $ulimit_core)"
    msg="Core dumps contain process memory including passwords "
    msg="${msg}and sensitive data. "
    msg="${msg}Disable with: ulimit -c 0 in your shell profile."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on disabling core dumps?"; then
      printf 'Add to your shell profile (~/.bashrc, ~/.zshrc):\n'
      printf '  ulimit -c 0\n'
      printf 'For system-wide setting, edit /etc/security/limits.conf:\n'
      printf '  * hard core 0\n'
    fi
  fi
  
  # Check SELinux status (Linux only)
  if has getenforce; then
    selinux_status=$(getenforce 2>/dev/null || printf 'unknown')
    if [ "$selinux_status" = "Enforcing" ]; then
      ward_pass "SELinux is enforcing"
      ward_desc "SELinux provides mandatory access control for enhanced security." 0
    elif [ "$selinux_status" = "Permissive" ]; then
      ward_fail "SELinux is in permissive mode"
      msg="SELinux permissive mode logs violations but doesn't enforce them. "
      msg="${msg}Consider setting to enforcing mode with: setenforce 1"
      ward_desc "$msg" 1
    elif [ "$selinux_status" = "Disabled" ]; then
      ward_fail "SELinux is disabled"
      msg="SELinux provides kernel-level access control. "
      msg="${msg}Consider enabling for production systems."
      ward_desc "$msg" 1
    fi
  elif [ -d "/sys/kernel/security/apparmor" ]; then
    # Check AppArmor as alternative (Ubuntu/Debian)
    if has aa-status; then
      ward_pass "AppArmor is available"
      ward_desc "AppArmor provides application confinement for enhanced security." "$verbose"
    fi
  fi
  
  # Check firewall status (platform-specific)
  firewall_active=0
  if has ufw; then
    if ufw status 2>/dev/null | grep -q "Status: active"; then
      ward_pass "UFW firewall is active"
      ward_desc "Firewall protects against unauthorized network access." 0
      firewall_active=1
    fi
  elif has iptables; then
    if iptables -L -n 2>/dev/null | grep -q "Chain INPUT"; then
      ward_pass "iptables firewall is configured"
      ward_desc "Firewall rules are present in iptables." "$verbose"
      firewall_active=1
    fi
  elif [ -f "/usr/libexec/ApplicationFirewall/socketfilterfw" ]; then
    # macOS firewall
    fw_cmd="/usr/libexec/ApplicationFirewall/socketfilterfw"
    if "$fw_cmd" --getglobalstate 2>/dev/null | grep -q "enabled"; then
      ward_pass "macOS firewall is enabled"
      ward_desc "Application firewall is active on macOS." 0
      firewall_active=1
    fi
  fi
  
  if [ "$firewall_active" -eq 0 ]; then
    ward_fail "No active firewall detected"
    msg="A firewall blocks unauthorized network connections. "
    msg="${msg}Consider enabling ufw (Ubuntu), firewalld (Fedora), "
    msg="${msg}or your system's firewall."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on enabling a firewall?"; then
      printf 'On Ubuntu/Debian: sudo ufw enable\n'
      printf 'On Fedora/RHEL: sudo systemctl start firewalld\n'
      printf 'On macOS: System Preferences > Security & Privacy > Firewall\n'
    fi
  fi
  
  # Check for suspicious cron jobs
  if [ -r /var/spool/cron/crontabs/"$(id -un)" ] || [ -r /var/spool/cron/"$(id -un)" ]; then
    ward_pass "User crontab exists - review recommended"
    ward_desc "Cron jobs run automatically. Review with: crontab -l" "$verbose"
  fi
  
  # Check listening network services
  if has ss || has netstat; then
    if has ss; then
      listen_count=$(ss -tuln 2>/dev/null | grep -c LISTEN || printf '0')
    else
      listen_count=$(netstat -tuln 2>/dev/null | grep -c LISTEN || printf '0')
    fi
    ward_pass "Found $listen_count listening network services"
    msg="Network services listening for connections represent potential attack surface. "
    msg="${msg}Review with: ss -tuln (or netstat -tuln)"
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for known_hosts file size
  if [ -f "$HOME/.ssh/known_hosts" ]; then
    known_hosts_lines=$(wc -l < "$HOME/.ssh/known_hosts" 2>/dev/null || printf '0')
    if [ "$known_hosts_lines" -gt 0 ]; then
      ward_pass "SSH known_hosts contains $known_hosts_lines entries"
      msg="known_hosts tracks SSH server fingerprints to prevent MITM attacks."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check for IPv6 privacy extensions (Linux)
  if [ -r /proc/sys/net/ipv6/conf/all/use_tempaddr ]; then
    ipv6_privacy=$(cat /proc/sys/net/ipv6/conf/all/use_tempaddr 2>/dev/null || printf '0')
    if [ "$ipv6_privacy" -ge 2 ]; then
      ward_pass "IPv6 privacy extensions are enabled"
      ward_desc "Privacy extensions help prevent IPv6 address tracking." 0
    else
      ward_fail "IPv6 privacy extensions are disabled"
      msg="IPv6 privacy extensions prevent tracking via stable addresses. "
      msg="${msg}Enable with: sysctl -w net.ipv6.conf.all.use_tempaddr=2"
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling IPv6 privacy?"; then
        printf 'Enable IPv6 privacy extensions:\n'
        printf '  sudo sysctl -w net.ipv6.conf.all.use_tempaddr=2\n'
        printf 'Make permanent by adding to /etc/sysctl.conf:\n'
        printf '  net.ipv6.conf.all.use_tempaddr=2\n'
      fi
    fi
  fi
  
  # Check kernel parameters for security hardening
  if [ -r /proc/sys/kernel/dmesg_restrict ]; then
    dmesg_restrict=$(cat /proc/sys/kernel/dmesg_restrict 2>/dev/null || printf '0')
    if [ "$dmesg_restrict" -eq 1 ]; then
      ward_pass "Kernel dmesg access is restricted"
      ward_desc "Restricting dmesg prevents information disclosure to non-root users." "$verbose"
    else
      ward_fail "Kernel dmesg access is not restricted"
      msg="dmesg can reveal sensitive kernel information. "
      msg="${msg}Restrict with: sysctl -w kernel.dmesg_restrict=1"
      ward_desc "$msg" 1
    fi
  fi
  
  # Check for systemd-analyze security (if available)
  if has systemd-analyze && has systemctl; then
    ward_pass "systemd security analysis available"
    msg="Run 'systemd-analyze security' to review service security settings."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check /var/log permissions
  if [ -d /var/log ]; then
    log_perms=$(ls -ld /var/log 2>/dev/null | awk '{print $1}')
    if printf '%s' "$log_perms" | grep -qE '^drwxr-xr-x|^drwxrwx---'; then
      ward_pass "/var/log has reasonable permissions"
      ward_desc "Log directory permissions prevent unauthorized access to logs." "$verbose"
    else
      ward_fail "/var/log has unusual permissions: $log_perms"
      msg="Log files may contain sensitive information. "
      msg="${msg}Review /var/log permissions."
      ward_desc "$msg" 1
    fi
  fi
  
  # Check for failed login attempts
  if [ -r /var/log/auth.log ] || [ -r /var/log/secure ]; then
    auth_log="/var/log/auth.log"
    [ -r /var/log/secure ] && auth_log="/var/log/secure"
    
    if has grep; then
      failed_logins=$(grep "Failed password" "$auth_log" 2>/dev/null | wc -l)
      failed_logins=${failed_logins:-0}
      if [ "$failed_logins" -gt 0 ] 2>/dev/null; then
        ward_fail "Found $failed_logins failed login attempts in logs"
        msg="Failed login attempts may indicate brute-force attacks. "
        msg="${msg}Review with: grep 'Failed password' $auth_log"
        ward_desc "$msg" 1
      else
        ward_pass "No recent failed login attempts in auth logs"
        ward_desc "System shows no signs of brute-force login attempts." 0
      fi
    fi
  fi
  
  # Check for suspicious processes
  if has ps; then
    # Look for processes running from tmp directories (common attack vector)
    tmp_procs=$(ps aux 2>/dev/null | grep -E '/tmp/|/var/tmp/' | grep -v grep || printf '')
    if [ -n "$tmp_procs" ]; then
      ward_fail "Found processes running from /tmp directories"
      msg="Processes running from /tmp may be malicious. "
      msg="${msg}Review running processes carefully."
      ward_desc "$msg" 1
    else
      ward_pass "No suspicious processes from /tmp detected"
      ward_desc "No processes running from temporary directories." "$verbose"
    fi
  fi
  
  # Check kernel exploit mitigation (ASLR)
  if [ -r /proc/sys/kernel/randomize_va_space ]; then
    aslr=$(cat /proc/sys/kernel/randomize_va_space 2>/dev/null || printf '0')
    if [ "$aslr" -eq 2 ]; then
      ward_pass "ASLR (Address Space Layout Randomization) is fully enabled"
      ward_desc "ASLR helps protect against memory corruption exploits." 0
    else
      ward_fail "ASLR is not fully enabled (value: $aslr)"
      msg="ASLR should be set to 2 for full protection. "
      msg="${msg}Enable with: sysctl -w kernel.randomize_va_space=2"
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling ASLR?"; then
        printf 'Enable ASLR:\n'
        printf '  sudo sysctl -w kernel.randomize_va_space=2\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  kernel.randomize_va_space=2\n'
      fi
    fi
  fi
  
  # Check filesystem mount options for /tmp
  if has mount; then
    tmp_mount=$(mount | grep " /tmp " 2>/dev/null || printf '')
    if [ -n "$tmp_mount" ]; then
      if printf '%s' "$tmp_mount" | grep -q "noexec"; then
        ward_pass "/tmp is mounted with noexec option"
        ward_desc "noexec on /tmp prevents execution of binaries." 0
      else
        ward_fail "/tmp is not mounted with noexec option"
        msg="/tmp should be mounted with noexec,nosuid,nodev for security. "
        msg="${msg}Add to /etc/fstab: tmpfs /tmp tmpfs defaults,noexec,nosuid,nodev 0 0"
        ward_desc "$msg" 1
      fi
    else
      ward_pass "/tmp mount options: check manually"
      ward_desc "/tmp may not be a separate mount. Consider separate partition." "$verbose"
    fi
  fi
  
  # Check for loaded kernel modules
  if has lsmod; then
    modules_loaded=$(lsmod 2>/dev/null | wc -l)
    modules_loaded=$((modules_loaded - 1)) # Subtract header line
    ward_pass "$modules_loaded kernel modules currently loaded"
    msg="Review loaded modules with 'lsmod' for unexpected entries."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check if auditd is running (Linux audit system)
  if has systemctl; then
    if systemctl is-active auditd >/dev/null 2>&1; then
      ward_pass "Audit daemon (auditd) is running"
      ward_desc "auditd provides comprehensive system auditing for security." 0
    else
      ward_fail "Audit daemon (auditd) is not running"
      msg="auditd provides detailed security auditing. "
      msg="${msg}Install and enable: sudo apt install auditd && sudo systemctl enable auditd"
      ward_desc "$msg" 1
    fi
  fi
  
  # Check network interfaces for promiscuous mode (packet sniffing)
  if has ip; then
    promisc=$(ip link show 2>/dev/null | grep PROMISC || printf '')
    if [ -n "$promisc" ]; then
      ward_fail "Network interface in promiscuous mode detected"
      msg="Promiscuous mode allows packet sniffing. "
      msg="${msg}This may indicate monitoring tools or potential compromise."
      ward_desc "$msg" 1
      printf 'Interface in promiscuous mode:\n%s\n' "$promisc"
    else
      ward_pass "No network interfaces in promiscuous mode"
      ward_desc "Network interfaces not configured for packet capture." 0
    fi
  fi
  
  # Check for compiler tools on production systems
  if has gcc || has cc || has clang; then
    ward_fail "Compiler tools found on system"
    msg="Compilers (gcc, clang) on production systems can be used "
    msg="${msg}by attackers to compile exploits. Consider removing if not needed."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like to see compiler removal commands?"; then
      printf 'Remove compiler tools (Debian/Ubuntu):\n'
      printf '  sudo apt remove gcc g++ make\n'
      printf 'Remove compiler tools (RHEL/Fedora):\n'
      printf '  sudo yum remove gcc gcc-c++ make\n'
    fi
  else
    ward_pass "No compiler tools detected"
    ward_desc "System does not have development compilers installed." 0
  fi
  
  # Check system entropy for cryptography
  if [ -r /proc/sys/kernel/random/entropy_avail ]; then
    entropy=$(cat /proc/sys/kernel/random/entropy_avail 2>/dev/null || printf '0')
    if [ "$entropy" -gt 1000 ]; then
      ward_pass "System entropy is adequate ($entropy bits available)"
      ward_desc "Sufficient entropy for cryptographic operations." 0
    else
      ward_fail "System entropy is low ($entropy bits available)"
      msg="Low entropy can weaken cryptographic operations. "
      msg="${msg}Consider installing haveged or rng-tools."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on improving entropy?"; then
        printf 'Install haveged for better entropy:\n'
        printf '  sudo apt install haveged\n'
      fi
    fi
  fi
  
  # Check for suspicious systemd unit files
  if [ -d /etc/systemd/system ]; then
    user_units=$(find /etc/systemd/system -name "*.service" -type f 2>/dev/null | wc -l)
    if [ "$user_units" -gt 0 ]; then
      ward_pass "Found $user_units custom systemd unit files"
      msg="Review custom systemd units in /etc/systemd/system/ for legitimacy."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check for common rootkit indicators
  if has find; then
    # Check for hidden files in /dev (common rootkit location)
    hidden_dev=$(find /dev -name ".*" 2>/dev/null | grep -v "/dev/\." | head -5 || printf '')
    if [ -n "$hidden_dev" ]; then
      ward_fail "Hidden files found in /dev directory"
      msg="Hidden files in /dev may indicate rootkit. Investigate: "
      msg="${msg}$(printf '%s' "$hidden_dev" | head -1)"
      ward_desc "$msg" 1
    else
      ward_pass "No suspicious hidden files in /dev"
      ward_desc "/dev directory appears clean." "$verbose"
    fi
  fi
  
  # Check SSH agent forwarding
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      if grep -q "^AllowAgentForwarding yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH agent forwarding is enabled"
        msg="Agent forwarding can expose SSH keys on compromised servers. "
        msg="${msg}Disable unless specifically needed."
        ward_desc "$msg" 1
      else
        ward_pass "SSH agent forwarding is not explicitly enabled"
        ward_desc "Agent forwarding disabled or not configured." "$verbose"
      fi
      break
    fi
  done
}

# Main execution
info "Checking system security wards..."

# Run checks based on level
if [ "$run_all" -eq 1 ]; then
  check_level_1
  check_level_2
  check_level_3
  printf '\n'
  success "System ward check complete for all levels"
else
  case "$level" in
    1)
      check_level_1
      ;;
    2)
      check_level_2
      ;;
    3)
      check_level_3
      ;;
  esac
  printf '\n'
  success "System ward check complete at level $level"
fi
