#!/bin/sh

# Ward the system against common security vulnerabilities.
# Checks security configurations at three levels: recommended, advanced, and expert.
#
# NOTE: ward-system uses its own 3-level system (1-3) which is independent
# from wizardry's general spell-levels system. These levels represent
# security check severity, not spell complexity.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: ward-system [LEVEL] [OPTIONS]

Check and fix system security issues at different threat levels.
Supports Linux and macOS systems.

NOTE: ward-system levels (1-3) are independent from wizardry's spell-levels.
      These represent security check severity, not spell complexity.

Arguments:
  LEVEL                 Security level to check (1-3, all, default: 1)
                        1 = Recommended (essential security)
                        2 = Advanced (additional hardening)
                        3 = Expert (obscure/dangerous checks)
                        all = Run all levels (1, 2, and 3)

Options:
  -v, --verbose         Show full descriptions even for passing checks
  --no-fix              Only report issues, do not offer fixes

Levels:
  1 (Recommended)       Essential security checks for all systems
  2 (Advanced)          Additional hardening for security-conscious users
  3 (Expert)            Obscure and potentially dangerous checks

Examples:
  ward-system           # Check level 1 only (recommended)
  ward-system 2         # Check level 2 only (advanced)
  ward-system all       # Check all levels (1, 2, and 3)
  ward-system 3 -v      # Check level 3 only with verbose output
  ward-system 1 --no-fix # Only report level 1 issues
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Source required utilities
. colors

# Parse arguments
level=1
run_all=0
verbose=0
no_fix=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    1|2|3)
      level=$1
      shift
      ;;
    all)
      run_all=1
      shift
      ;;
    -v|--verbose)
      verbose=1
      shift
      ;;
    --no-fix)
      no_fix=1
      shift
      ;;
    *)
      die "ward-system: unknown option: $1"
      ;;
  esac
done

# Helper functions
# Track statistics
total_checks=0
passed_checks=0
failed_checks=0

ward_pass() {
  printf '%s✓%s %s\n' "${GREEN}" "${RESET}" "$1"
  total_checks=$((total_checks + 1))
  passed_checks=$((passed_checks + 1))
}

ward_fail() {
  printf '%s✗%s %s\n' "${RED}" "${RESET}" "$1"
  total_checks=$((total_checks + 1))
  failed_checks=$((failed_checks + 1))
}

ward_title() {
  printf '\n%s%s%s\n' "${BOLD}" "$1" "${RESET}"
}

ward_desc() {
  if [ "$verbose" -eq 1 ] || [ "$2" -eq 1 ]; then
    printf '%s\n' "$1"
  fi
}

ward_ask_fix() {
  if [ "$no_fix" -eq 1 ]; then
    return 1
  fi
  ask-yn "$1" no
}

# Level 1: Recommended security checks
check_level_1() {
  ward_title "Level 1: Recommended Security Checks"
  
  # Check umask
  current_umask=$(umask)
  if [ "$current_umask" = "0022" ] || [ "$current_umask" = "0027" ] || \
     [ "$current_umask" = "022" ] || [ "$current_umask" = "027" ]; then
    ward_pass "Umask is properly configured ($current_umask)"
    ward_desc "Umask controls default file permissions. Current setting is secure." 0
  else
    ward_fail "Umask is not secure (current: $current_umask, recommended: 0022 or 0027)"
    msg="WHAT THIS IS: Umask controls the default permissions for newly created files. "
    msg="${msg}It's a mask that removes permission bits when files are created. "
    msg="${msg}WHY IT MATTERS: A umask of 0022 sets new files to mode 644 (user read/write, others read-only) "
    msg="${msg}and directories to 755 (user read/write/execute, others read/execute). This prevents accidentally "
    msg="${msg}creating world-writable files that could be modified by any user on the system. "
    msg="${msg}HOW TO DECIDE: Use 0022 for general use, or 0027 if you need group-write restrictions. "
    msg="${msg}This setting goes in your shell startup file."
    ward_desc "$msg" 1
    if ward_ask_fix "Set umask to safe default of 0022? (recommended for most users)"; then
      printf 'Add this line to your shell profile (~/.bashrc, ~/.zshrc, etc.):\n'
      printf '  umask 0022\n'
      printf '\nThis sets default permissions: files=644 (rw-r--r--), directories=755 (rwxr-xr-x)\n'
    fi
  fi
  
  # Check for current directory in PATH
  case ":$PATH:" in
    *::*|*:.:*)
      ward_fail "Current directory (.) is in PATH - security risk"
      msg="WHAT THIS IS: PATH is an environment variable that lists directories where the shell searches "
      msg="${msg}for executable programs. Including '.' (current directory) or empty entries means the shell "
      msg="${msg}will look in your current working directory for commands. "
      msg="${msg}WHY IT MATTERS: This creates a command injection vulnerability. An attacker can place a "
      msg="${msg}malicious executable named 'ls' or 'sudo' in a directory, and when you run that command, "
      msg="${msg}you'll execute their code instead of the system binary. This is a common privilege escalation vector. "
      msg="${msg}HOW TO DECIDE: Remove all '.' and empty entries from PATH. To run programs in the current "
      msg="${msg}directory, explicitly use './program' which makes your intent clear and prevents accidents."
      ward_desc "$msg" 1
      if ward_ask_fix "Remove current directory from PATH? (strongly recommended)"; then
        printf 'Remove current directory from PATH in your shell profile:\n'
        printf '  export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n'
        printf '\nThis ensures commands only execute from trusted system directories.\n'
      fi
      ;;
    *)
      ward_pass "PATH does not contain current directory"
      ward_desc "Your PATH is secure - programs only run from trusted system directories." 0
      ;;
  esac
  
  # Check SSH directory permissions if it exists
  ssh_dir="${HOME}/.ssh"
  if [ -d "$ssh_dir" ]; then
    ssh_perms=$(ls -ld "$ssh_dir" 2>/dev/null | awk '{print $1}')
    case "$ssh_perms" in
      drwx------*|drwx--x---*)
        ward_pass "SSH directory permissions are secure (~/.ssh)"
        ward_desc "SSH directory should be readable only by owner (700)." 0
        ;;
      *)
        ward_fail "SSH directory has insecure permissions: $ssh_perms"
        msg="WHAT THIS IS: The ~/.ssh directory stores SSH private keys, which are cryptographic credentials "
        msg="${msg}used for authentication to remote systems. "
        msg="${msg}WHY IT MATTERS: If other users can read this directory, they can copy your private keys. "
        msg="${msg}With your private key, an attacker can authenticate as you to any server where you've installed "
        msg="${msg}the corresponding public key, gaining unauthorized access to those systems. "
        msg="${msg}HOW TO DECIDE: Set permissions to 700 (drwx------) to ensure only the owner can access this directory. "
        msg="${msg}Current permissions: $ssh_perms"
        ward_desc "$msg" 1
        if ward_ask_fix "Fix SSH directory permissions to 700? (recommended)"; then
          chmod 700 "$ssh_dir" && success "Fixed ~/.ssh permissions to 700"
        fi
        ;;
    esac
    
    # Check for private keys with wrong permissions
    key_check_shown=0
    for key in "$ssh_dir"/id_* "$ssh_dir"/*_rsa \
               "$ssh_dir"/*_ed25519 "$ssh_dir"/*_ecdsa; do
      # Check if it's a private key (not .pub)
      if [ -f "$key" ] && ! printf '%s\n' "$key" | grep -q '\.pub$'; then
        key_perms=$(ls -l "$key" 2>/dev/null | awk '{print $1}')
        case "$key_perms" in
          -rw-------*)
            # Only show success message once for all secure keys
            if [ "$key_check_shown" -eq 0 ]; then
              ward_pass "SSH private keys have secure permissions"
              ward_desc "Private keys should be readable only by owner (600)." 0
              key_check_shown=1
            fi
            ;;
          *)
            key_name=$(basename "$key")
            ward_fail "SSH private key has insecure permissions: $key_name ($key_perms)"
            msg="Private SSH keys must have permissions 600 "
            msg="${msg}(readable/writable only by owner) "
            msg="${msg}to prevent unauthorized use."
            ward_desc "$msg" 1
            if ward_ask_fix "Fix permissions for $key_name?"; then
              chmod 600 "$key" && success "Fixed permissions for $key_name"
            fi
            # Mark that we've shown a message (don't show success after failures)
            key_check_shown=1
            ;;
        esac
      fi
    done
  fi
  
  # Check home directory permissions
  home_perms=$(ls -ld "$HOME" 2>/dev/null | awk '{print $1}')
  case "$home_perms" in
    drwx------*|drwxr-x---*|drwxr-xr-x*)
      ward_pass "Home directory permissions are acceptable"
      msg="Home directory should be 700 (private) or 755 "
      msg="${msg}(readable by others but not writable)."
      ward_desc "$msg" 0
      ;;
    *)
      ward_fail "Home directory has unusual permissions: $home_perms"
      msg="Your home directory should typically be mode 700 "
      msg="${msg}(completely private) or 755 (readable but not writable by others). "
      msg="${msg}Current permissions may allow unauthorized access."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing home directory permissions?"; then
        printf 'Consider setting your home directory to 700 (private):\n'
        printf '  chmod 700 %s\n' "$HOME"
        printf 'Or 755 (readable by others) if needed for your use case.\n'
      fi
      ;;
  esac
  
  # Check shell history file permissions
  for history_file in "$HOME/.bash_history" "$HOME/.zsh_history" \
                       "$HOME/.sh_history" "$HOME/.history"; do
    if [ -f "$history_file" ]; then
      history_perms=$(ls -l "$history_file" 2>/dev/null | awk '{print $1}')
      case "$history_perms" in
        -rw-------*)
          ward_pass "Shell history file has secure permissions"
          ward_desc "History files should be private (600) to protect sensitive commands." 0
          break
          ;;
        *)
          ward_fail "Shell history file has insecure permissions: $history_perms"
          msg="Shell history files may contain sensitive information like passwords. "
          msg="${msg}They should have permissions 600 (readable/writable only by owner)."
          ward_desc "$msg" 1
          if ward_ask_fix "Fix shell history file permissions?"; then
            chmod 600 "$history_file" && success "Fixed $history_file permissions to 600"
          fi
          break
          ;;
      esac
    fi
  done
  
  # Check /tmp directory permissions
  if [ -d /tmp ]; then
    tmp_perms=$(ls -ld /tmp 2>/dev/null | awk '{print $1}')
    if printf '%s' "$tmp_perms" | grep -q 't'; then
      ward_pass "/tmp has sticky bit set"
      ward_desc "Sticky bit on /tmp prevents users from deleting others' files." 0
    else
      ward_fail "/tmp does not have sticky bit set"
      msg="/tmp should have the sticky bit (t) set to prevent users from "
      msg="${msg}deleting files they don't own. This is a common security measure."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing /tmp permissions?"; then
        printf 'Set sticky bit on /tmp (requires root):\n'
        printf '  sudo chmod +t /tmp\n'
      fi
    fi
  fi
  
  # Check for .netrc file (stores passwords)
  if [ -f "$HOME/.netrc" ]; then
    netrc_perms=$(ls -l "$HOME/.netrc" 2>/dev/null | awk '{print $1}')
    case "$netrc_perms" in
      -rw-------*)
        ward_pass ".netrc file has secure permissions"
        ward_desc ".netrc stores credentials and should be private (600)." 0
        ;;
      *)
        ward_fail ".netrc file has insecure permissions: $netrc_perms"
        msg="The .netrc file stores login credentials and must have "
        msg="${msg}permissions 600 to prevent unauthorized access."
        ward_desc "$msg" 1
        if ward_ask_fix "Fix .netrc permissions?"; then
          chmod 600 "$HOME/.netrc" && success "Fixed .netrc permissions to 600"
        fi
        ;;
    esac
  fi
  
  # Check DNS configuration file permissions
  if [ -r /etc/resolv.conf ]; then
    resolv_perms=$(ls -l /etc/resolv.conf 2>/dev/null | awk '{print $1}')
    if printf '%s' "$resolv_perms" | grep -q 'w..w'; then
      ward_fail "/etc/resolv.conf is world-writable"
      msg="DNS configuration should not be writable by all users. "
      msg="${msg}This could allow DNS hijacking attacks."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on fixing /etc/resolv.conf?"; then
        printf 'Fix /etc/resolv.conf permissions (requires root):\n'
        printf '  sudo chmod 644 /etc/resolv.conf\n'
      fi
    else
      ward_pass "/etc/resolv.conf has secure permissions"
      ward_desc "DNS configuration file is protected from unauthorized modification." 0
    fi
  fi
  
  # Check for suspicious entries in /etc/hosts
  if [ -r /etc/hosts ]; then
    # Look for common suspicious patterns (redirecting major sites)
    if has grep; then
      suspicious=$(grep -E "google\.com|facebook\.com|twitter\.com|github\.com|amazon\.com" \
                        /etc/hosts 2>/dev/null | grep -v "^#" | grep -v "^$" || printf '')
      if [ -n "$suspicious" ]; then
        ward_fail "Suspicious entries found in /etc/hosts"
        msg="/etc/hosts contains redirections for major websites. "
        msg="${msg}This could indicate DNS hijacking or malware."
        ward_desc "$msg" 1
        printf 'Suspicious entries:\n%s\n' "$suspicious"
      else
        ward_pass "/etc/hosts has no obvious suspicious entries"
        ward_desc "/etc/hosts file appears normal." "$verbose"
      fi
    fi
  fi
  
  # Check system timezone configuration
  if has timedatectl; then
    timezone=$(timedatectl 2>/dev/null | grep "Time zone" | awk '{print $3}' || printf 'unknown')
    ward_pass "System timezone: $timezone"
    ward_desc "Verify timezone is appropriate for your location." "$verbose"
  elif [ -r /etc/timezone ]; then
    timezone=$(cat /etc/timezone 2>/dev/null || printf 'unknown')
    ward_pass "System timezone: $timezone"
    ward_desc "Verify timezone is appropriate for your location." "$verbose"
  fi
  
  # Check shared memory permissions (/dev/shm)
  if [ -d /dev/shm ]; then
    shm_perms=$(ls -ld /dev/shm 2>/dev/null | awk '{print $1}')
    if printf '%s' "$shm_perms" | grep -q 'rwxrwxrwt'; then
      ward_pass "/dev/shm has sticky bit set"
      msg="/dev/shm sticky bit prevents users from deleting others' files."
      ward_desc "$msg" 0
    else
      ward_fail "/dev/shm missing sticky bit (current: $shm_perms)"
      msg="/dev/shm should have sticky bit for multi-user security. "
      msg="${msg}Recommended permissions: 1777 (drwxrwxrwt)"
      ward_desc "$msg" 1
      if ward_ask_fix "Fix /dev/shm permissions? (recommended)"; then
        printf 'Fix /dev/shm permissions (requires root):\n'
        printf '  sudo chmod 1777 /dev/shm\n'
      fi
    fi
  fi
  
  # Check kernel parameters for IP forwarding (should be off for workstations)
  if [ -r /proc/sys/net/ipv4/ip_forward ]; then
    ip_forward=$(cat /proc/sys/net/ipv4/ip_forward 2>/dev/null || printf '0')
    if [ "$ip_forward" -eq 0 ]; then
      ward_pass "IP forwarding is disabled"
      ward_desc "IP forwarding off is correct for workstations." 0
    else
      ward_fail "IP forwarding is enabled"
      msg="IP forwarding should be disabled on workstations. "
      msg="${msg}Only enable on routers. Disable with: sysctl -w net.ipv4.ip_forward=0"
      ward_desc "$msg" 1
      if ward_ask_fix "Disable IP forwarding? (recommended for workstations)"; then
        printf 'WARNING: Only disable if this is not a router/gateway.\n'
        printf 'Disable IP forwarding:\n'
        printf '  sudo sysctl -w net.ipv4.ip_forward=0\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  net.ipv4.ip_forward=0\n'
      fi
    fi
  fi
  
  # Check ICMP redirect acceptance (should be off)
  if [ -r /proc/sys/net/ipv4/conf/all/accept_redirects ]; then
    icmp_redir=$(cat /proc/sys/net/ipv4/conf/all/accept_redirects 2>/dev/null || printf '1')
    if [ "$icmp_redir" -eq 0 ]; then
      ward_pass "ICMP redirects are disabled"
      ward_desc "Disabling ICMP redirects prevents routing table manipulation." 0
    else
      ward_fail "ICMP redirects are enabled"
      msg="ICMP redirects can be used to manipulate routing tables. "
      msg="${msg}Recommended to disable."
      ward_desc "$msg" 1
      if ward_ask_fix "Disable ICMP redirects? (recommended)"; then
        printf 'Disable ICMP redirects:\n'
        printf '  sudo sysctl -w net.ipv4.conf.all.accept_redirects=0\n'
        printf '  sudo sysctl -w net.ipv4.conf.default.accept_redirects=0\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  net.ipv4.conf.all.accept_redirects=0\n'
        printf '  net.ipv4.conf.default.accept_redirects=0\n'
      fi
    fi
  fi
  
  # Check password aging for current user
  if has chage && [ "$(id -u)" -ne 0 ]; then
    max_days=$(chage -l "$(id -un)" 2>/dev/null | \
               grep "Maximum number of days" | awk -F: '{print $2}' | tr -d ' ')
    if [ -n "$max_days" ] && [ "$max_days" != "99999" ] && [ "$max_days" != "-1" ]; then
      ward_pass "Password aging is configured (max: $max_days days)"
      msg="Password expiration helps ensure regular password updates."
      ward_desc "$msg" "$verbose"
    else
      ward_pass "Password aging: not configured (check if appropriate)"
      msg="Password aging can improve security but may not be needed for all systems."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Novel check: Environment variable security (LD_PRELOAD/LD_LIBRARY_PATH)
  if [ -n "${LD_PRELOAD-}" ] || [ -n "${LD_LIBRARY_PATH-}" ]; then
    ward_fail "Dangerous environment variables detected"
    msg="WHAT THIS IS: LD_PRELOAD and LD_LIBRARY_PATH control which shared libraries programs load at runtime. "
    msg="${msg}LD_PRELOAD forces programs to load specific libraries before all others. LD_LIBRARY_PATH adds "
    msg="${msg}directories to the library search path. "
    msg="${msg}WHY IT MATTERS: Attackers use these variables for code injection attacks. By setting LD_PRELOAD "
    msg="${msg}to a malicious library, every program you run will load and execute that code, allowing persistent "
    msg="${msg}compromise. This affects all dynamically linked programs on the system. "
    msg="${msg}HOW TO DECIDE: Unset these unless you're actively debugging software or have explicitly set them "
    msg="${msg}for development purposes. They should never be set in normal user environments."
    ward_desc "$msg" 1
    if ward_ask_fix "Unset dangerous environment variables? (recommended unless actively debugging)"; then
      printf 'Run these commands:\n'
      printf '  unset LD_PRELOAD\n'
      printf '  unset LD_LIBRARY_PATH\n'
      printf '\nAlso check your shell profile files to ensure they aren'\''t set permanently.\n'
    fi
  else
    ward_pass "No dangerous LD_* environment variables detected"
    msg="Environment clean - no library injection vectors present."
    ward_desc "$msg" "$verbose"
  fi
  
  # Novel check: Shell configuration injection vectors
  for shell_rc in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
    if [ -r "$shell_rc" ]; then
      # Check for suspicious patterns
      if grep -qE "(curl|wget).*\|.*sh|eval.*\$\(" "$shell_rc" 2>/dev/null; then
        ward_fail "Suspicious code in shell configuration: $(basename "$shell_rc")"
        msg="WHAT THIS IS: Your shell reads commands from files like .bashrc every time you open a terminal. "
        msg="${msg}WHY IT MATTERS: Found patterns like 'curl ... | sh' that download and run code from the internet "
        msg="${msg}automatically. This is how malware persists - running every time you log in. "
        msg="${msg}HOW TO DECIDE: Review $shell_rc carefully. Remove any 'curl|sh' or 'eval' commands you "
        msg="${msg}didn't add yourself. Legitimate software rarely asks you to add these."
        ward_desc "$msg" 1
        break
      fi
    fi
  done
  
  # Novel check: Clipboard/pasteboard security (Linux)
  if has xclip || has xsel; then
    clipboard_size=0
    if has xclip; then
      clipboard_size=$(xclip -o -selection clipboard 2>/dev/null | wc -c)
    elif has xsel; then
      clipboard_size=$(xsel -b 2>/dev/null | wc -c)
    fi
    
    if [ "$clipboard_size" -gt 10000 ]; then
      ward_fail "Large amount of data in clipboard ($clipboard_size bytes)"
      msg="WHAT THIS IS: Your clipboard (copy/paste buffer) currently holds a lot of data. "
      msg="${msg}WHY IT MATTERS: Any program you run can silently read your clipboard. If you recently "
      msg="${msg}copied passwords, API keys, or private documents, they're accessible to all applications. "
      msg="${msg}HOW TO DECIDE: Clear your clipboard if you've copied sensitive data. Don't copy passwords - "
      msg="${msg}use a password manager instead."
      ward_desc "$msg" 1
      if ward_ask_fix "Clear clipboard contents? (recommended if you copied sensitive data)"; then
        if has xclip; then
          printf '' | xclip -selection clipboard
          success "Clipboard cleared"
        elif has xsel; then
          printf '' | xsel -b
          success "Clipboard cleared"
        fi
      fi
    fi
  fi
  
  # Check /etc/shadow permissions (critical system file)
  if [ -r /etc/shadow ]; then
    shadow_perms=$(ls -l /etc/shadow 2>/dev/null | awk '{print $1}')
    if printf '%s' "$shadow_perms" | grep -qE '^-r--------' || \
       printf '%s' "$shadow_perms" | grep -qE '^-rw-------'; then
      ward_pass "/etc/shadow has secure permissions"
      msg="Password hashes file has correct restrictive permissions."
      ward_desc "$msg" "$verbose"
    else
      ward_fail "/etc/shadow has insecure permissions: $shadow_perms"
      msg="WHAT THIS IS: /etc/shadow stores encrypted password hashes for all user accounts. "
      msg="${msg}WHY IT MATTERS: If this file is readable by non-root users, attackers can copy the password "
      msg="${msg}hashes and attempt to crack them offline using tools like John the Ripper or hashcat. "
      msg="${msg}Even with modern hashing algorithms, weak passwords can be cracked. "
      msg="${msg}HOW TO DECIDE: This file must have permissions 640 or 600 (readable only by root). "
      msg="${msg}This is a critical security issue requiring immediate attention."
      ward_desc "$msg" 1
      if ward_ask_fix "Fix /etc/shadow permissions? (requires root, strongly recommended)"; then
        printf 'Fix /etc/shadow permissions (requires root):\n'
        printf '  sudo chmod 640 /etc/shadow\n'
        printf '  sudo chown root:shadow /etc/shadow\n'
      fi
    fi
  fi
  
  # Check for world-writable files in home directory
  world_writable=$(find "$HOME" -type f -perm -002 2>/dev/null | head -5)
  if [ -n "$world_writable" ]; then
    count=$(printf '%s\n' "$world_writable" | wc -l)
    ward_fail "Found $count world-writable files in home directory"
    msg="WHAT THIS IS: World-writable files (permission bit 002) can be modified by any user on the system. "
    msg="${msg}WHY IT MATTERS: Any user could modify these files to inject malicious code, alter data, or "
    msg="${msg}cause application malfunctions. This is particularly dangerous for scripts and configuration files. "
    msg="${msg}HOW TO DECIDE: Remove world-write permission from files. Use 'chmod o-w filename' to fix individual "
    msg="${msg}files, or 'chmod o-w \$(find \$HOME -type f -perm -002)' to fix all at once."
    ward_desc "$msg" 1
    printf 'First few world-writable files:\n%s\n' "$world_writable"
  fi
}

# Level 2: Advanced security checks
check_level_2() {
  ward_title "Level 2: Advanced Security Checks"
  
  # Check if running as root
  if [ "$(id -u)" -eq 0 ]; then
    ward_fail "Running as root - not recommended for daily use"
    msg="Running as root (UID 0) bypasses all permission checks "
    msg="${msg}and increases security risk. "
    msg="${msg}Use sudo for administrative tasks instead of logging in as root."
    ward_desc "$msg" 1
  else
    ward_pass "Not running as root"
    ward_desc "Running as regular user is a security best practice." 0
  fi
  
  # Check for world-writable files in home
  if has find; then
    world_writable=$(find "$HOME" -type f -perm -002 2>/dev/null | head -5)
    if [ -n "$world_writable" ]; then
      ward_fail "Found world-writable files in home directory"
      msg="World-writable files can be modified by any user on the system, "
      msg="${msg}which is a security risk. "
      msg="${msg}Files should typically be writable only by their owner."
      ward_desc "$msg" 1
      printf 'First few world-writable files:\n%s\n' "$world_writable"
      if ward_ask_fix "Would you like to search for all world-writable files?"; then
        printf 'Run this command to find all world-writable files:\n'
        printf '  find %s -type f -perm -002\n' "$HOME"
      fi
    else
      ward_pass "No world-writable files in home directory"
      msg="Files are properly protected from unauthorized modification."
      ward_desc "$msg" 0
    fi
  fi
  
  # Check SSH daemon configuration if accessible
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      # Check PermitRootLogin
      if grep -q "^PermitRootLogin no" "$sshd_config" 2>/dev/null; then
        ward_pass "SSH root login is disabled"
        ward_desc "Disabling root login via SSH prevents direct root access over the network." 0
      elif grep -q "^PermitRootLogin" "$sshd_config" 2>/dev/null; then
        permit_root=$(grep "^PermitRootLogin" "$sshd_config" | awk '{print $2}')
        ward_fail "SSH allows root login: $permit_root"
        msg="WHAT THIS IS: The SSH server configuration allows direct authentication as the root user. "
        msg="${msg}Root (UID 0) has complete system control with no permission restrictions. "
        msg="${msg}WHY IT MATTERS: Direct root access creates multiple security risks: (1) Attackers can directly "
        msg="${msg}target the most privileged account. (2) No audit trail distinguishes between different administrators. "
        msg="${msg}(3) One compromised credential grants complete system control. (4) No opportunity to catch "
        msg="${msg}mistakes before executing privileged commands. "
        msg="${msg}HOW TO DECIDE: Disable root SSH login. Instead, log in with personal accounts and use 'sudo' "
        msg="${msg}for administrative tasks. This provides accountability, sudo logging, and an extra verification step."
        ward_desc "$msg" 1
        if ward_ask_fix "Disable root login via SSH? (recommended)"; then
          info "Please run: ssh-barrier"
        fi
      fi
      
      # Check PasswordAuthentication
      if grep -q "^PasswordAuthentication no" "$sshd_config" 2>/dev/null; then
        ward_pass "SSH password authentication is disabled"
        ward_desc "Key-based authentication is more secure than passwords." 0
      elif grep -q "^PasswordAuthentication yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH allows password authentication"
        msg="Password authentication is vulnerable to brute-force attacks. "
        msg="${msg}Use key-based authentication instead. "
        msg="${msg}Recommended: PasswordAuthentication no"
        ward_desc "$msg" 1
        if ward_ask_fix "Disable password authentication?"; then
          info "Please run: ssh-barrier"
        fi
      fi
      break
    fi
  done
  
  # Check for SSH keys
  has_ssh_key=0
  for key_type in id_rsa id_ed25519 id_ecdsa; do
    if [ -f "${HOME}/.ssh/${key_type}" ]; then
      has_ssh_key=1
      ward_pass "SSH key exists: $key_type"
      ward_desc "SSH keys enable secure, password-less authentication." 0
      break
    fi
  done
  
  if [ "$has_ssh_key" -eq 0 ]; then
    ward_fail "No SSH keys found"
    msg="SSH keys provide secure authentication without passwords. "
    msg="${msg}Generate keys with: ssh-keygen -t ed25519"
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on creating SSH keys?"; then
      printf 'Generate an Ed25519 SSH key (recommended):\n'
      printf '  ssh-keygen -t ed25519 -C "your_email@example.com"\n'
      printf 'Or an RSA key (for compatibility):\n'
      printf '  ssh-keygen -t rsa -b 4096 -C "your_email@example.com"\n'
    fi
  fi
  
  # Check sudo configuration
  if [ -r /etc/sudoers ] || [ -d /etc/sudoers.d ]; then
    ward_pass "Sudo configuration files exist"
    msg="Review sudo configuration to ensure only authorized users "
    msg="${msg}have privileges."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for password in shell history
  if has grep; then
    for history_file in "$HOME/.bash_history" "$HOME/.zsh_history" \
                         "$HOME/.sh_history" "$HOME/.history"; do
      if [ -f "$history_file" ]; then
        # Look for common password-related patterns
        if grep -qi "password\|passwd\|pwd" "$history_file" 2>/dev/null | head -1 >/dev/null; then
          ward_fail "Possible passwords found in shell history"
          msg="Shell history contains password-related commands. "
          msg="${msg}Never include passwords in command-line arguments. "
          msg="${msg}Consider clearing sensitive history entries."
          ward_desc "$msg" 1
          if ward_ask_fix "Would you like guidance on cleaning history?"; then
            printf 'Edit your history file to remove sensitive entries:\n'
            printf '  $EDITOR %s\n' "$history_file"
            printf 'Or clear entire history (caution):\n'
            printf '  history -c && > %s\n' "$history_file"
          fi
          break
        fi
      fi
    done
  fi
  
  # Check for unattended-upgrades (Linux only)
  if has systemctl; then
    if systemctl is-enabled unattended-upgrades >/dev/null 2>&1 || \
       systemctl is-active unattended-upgrades >/dev/null 2>&1; then
      ward_pass "Automatic security updates are configured"
      ward_desc "Unattended-upgrades helps keep system secure with automatic updates." 0
    else
      ward_fail "Automatic security updates not configured"
      msg="Automatic security updates help protect against known vulnerabilities. "
      msg="${msg}Consider enabling unattended-upgrades."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling auto-updates?"; then
        printf 'On Ubuntu/Debian:\n'
        printf '  sudo apt install unattended-upgrades\n'
        printf '  sudo dpkg-reconfigure -plow unattended-upgrades\n'
      fi
    fi
  fi
  
  # Check authorized_keys permissions
  if [ -f "$HOME/.ssh/authorized_keys" ]; then
    auth_keys_perms=$(ls -l "$HOME/.ssh/authorized_keys" 2>/dev/null | awk '{print $1}')
    case "$auth_keys_perms" in
      -rw-------*|-rw-r--r--*)
        ward_pass "authorized_keys file has acceptable permissions"
        ward_desc "authorized_keys should be 600 or 644." 0
        ;;
      *)
        ward_fail "authorized_keys has insecure permissions: $auth_keys_perms"
        msg="The authorized_keys file controls SSH access. "
        msg="${msg}It should have permissions 600 or 644."
        ward_desc "$msg" 1
        if ward_ask_fix "Fix authorized_keys permissions?"; then
          chmod 600 "$HOME/.ssh/authorized_keys" && \
            success "Fixed authorized_keys permissions to 600"
        fi
        ;;
    esac
  fi
  
  # Check cron access control files
  if [ -f /etc/cron.allow ] || [ -f /etc/cron.deny ]; then
    ward_pass "Cron access control files exist"
    msg="cron.allow/cron.deny controls who can use cron. "
    msg="${msg}Review these files to ensure only authorized users have access."
    ward_desc "$msg" "$verbose"
  else
    ward_fail "No cron access control files found"
    msg="Without cron.allow or cron.deny, all users can create cron jobs. "
    msg="${msg}Consider creating /etc/cron.allow for better security."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on cron access control?"; then
      printf 'Create /etc/cron.allow to restrict cron access (requires root):\n'
      printf '  sudo touch /etc/cron.allow\n'
      printf '  sudo chmod 600 /etc/cron.allow\n'
      printf '  echo "root" | sudo tee /etc/cron.allow\n'
    fi
  fi
  
  # Check for X11 forwarding in SSH config
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      if grep -q "^X11Forwarding yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH X11 forwarding is enabled"
        msg="X11 forwarding can be a security risk if not needed. "
        msg="${msg}Disable with: X11Forwarding no in sshd_config"
        ward_desc "$msg" 1
      else
        ward_pass "SSH X11 forwarding is not explicitly enabled"
        ward_desc "X11 forwarding disabled or not configured." "$verbose"
      fi
      break
    fi
  done
  
  # Check for empty passwords in shadow file (if readable)
  if [ -r /etc/shadow ]; then
    if has awk; then
      empty_pass=$(awk -F: '($2 == "" || $2 == "!") {print $1}' \
                       /etc/shadow 2>/dev/null || printf '')
      if [ -n "$empty_pass" ]; then
        ward_fail "Users with empty or locked passwords found"
        msg="Empty passwords are a critical security risk. "
        msg="${msg}Review: $(printf '%s' "$empty_pass" | head -1)"
        ward_desc "$msg" 1
      else
        ward_pass "No users with empty passwords detected"
        ward_desc "All user accounts have password hashes." 0
      fi
    fi
  fi
  
  # Check NTP/time synchronization
  if has timedatectl; then
    if timedatectl status 2>/dev/null | grep -q "synchronized: yes"; then
      ward_pass "System time is synchronized"
      ward_desc "Time synchronization is critical for security logs and certificates." 0
    else
      ward_fail "System time is not synchronized"
      msg="Time synchronization is important for security logs and SSL/TLS. "
      msg="${msg}Enable with systemd-timesyncd or ntpd."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling time sync?"; then
        printf 'Enable time synchronization:\n'
        printf '  sudo timedatectl set-ntp true\n'
      fi
    fi
  elif has ntpq; then
    if ntpq -p >/dev/null 2>&1; then
      ward_pass "NTP is configured and running"
      ward_desc "Time synchronization via NTP is active." 0
    else
      ward_fail "NTP appears to be installed but not working"
      ward_desc "Check NTP configuration." 1
    fi
  fi
  
  # Check package manager repository security
  if [ -d /etc/apt/sources.list.d ]; then
    third_party=$(find /etc/apt/sources.list.d -name "*.list" 2>/dev/null | wc -l)
    if [ "$third_party" -gt 0 ]; then
      ward_pass "Found $third_party third-party repository files"
      msg="Review third-party repositories for legitimacy: "
      msg="${msg}ls -la /etc/apt/sources.list.d/"
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check SSH strict host key checking
  ssh_config_file="$HOME/.ssh/config"
  if [ -f "$ssh_config_file" ]; then
    if grep -qi "StrictHostKeyChecking.*no" "$ssh_config_file" 2>/dev/null; then
      ward_fail "SSH strict host key checking is disabled"
      msg="StrictHostKeyChecking no allows MITM attacks. "
      msg="${msg}Remove or change to 'yes' in ~/.ssh/config"
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like to see safe SSH configuration?"; then
        printf 'Remove StrictHostKeyChecking no from ~/.ssh/config\n'
        printf 'Or set it to: StrictHostKeyChecking ask\n'
        printf 'WARNING: May prompt for unknown hosts.\n'
      fi
    else
      ward_pass "SSH strict host key checking appears safe"
      ward_desc "No dangerous SSH config override detected." "$verbose"
    fi
  fi
  
  # Check for Docker socket permissions (if Docker is installed)
  if [ -S /var/run/docker.sock ]; then
    docker_perms=$(ls -l /var/run/docker.sock 2>/dev/null | awk '{print $1}')
    docker_group=$(ls -l /var/run/docker.sock 2>/dev/null | awk '{print $4}')
    if printf '%s' "$docker_perms" | grep -q 'rw.*rw'; then
      ward_fail "Docker socket has group write access"
      msg="Docker socket group write access = root access. "
      msg="${msg}Ensure only trusted users are in docker group ($docker_group)."
      ward_desc "$msg" 1
    else
      ward_pass "Docker socket permissions: review docker group membership"
      msg="Users in docker group have root-equivalent access. "
      msg="${msg}Review: getent group docker"
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check log rotation
  if [ -d /etc/logrotate.d ] || [ -f /etc/logrotate.conf ]; then
    ward_pass "Log rotation appears configured"
    msg="Log rotation prevents disk space issues. Verify with: logrotate --debug /etc/logrotate.conf"
    ward_desc "$msg" "$verbose"
  else
    ward_fail "Log rotation not configured"
    msg="Without log rotation, logs can fill disk space. "
    msg="${msg}Install logrotate package."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on setting up log rotation?"; then
      printf 'Install logrotate:\n'
      printf '  Ubuntu/Debian: sudo apt install logrotate\n'
      printf '  RHEL/Fedora: sudo yum install logrotate\n'
    fi
  fi
  
  # Check Bluetooth status (if not needed, should be off)
  if has systemctl; then
    if systemctl is-enabled bluetooth >/dev/null 2>&1; then
      ward_pass "Bluetooth is enabled (verify if needed)"
      msg="If Bluetooth is not needed, disable it to reduce attack surface. "
      msg="${msg}Disable with: sudo systemctl disable bluetooth"
      ward_desc "$msg" "$verbose"
    fi
  elif has bluetoothctl; then
    ward_pass "Bluetooth tools installed (verify if needed)"
    msg="If Bluetooth is not needed, consider removing tools."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for USB storage restrictions
  if [ -r /etc/modprobe.d/blacklist.conf ]; then
    if grep -q "usb-storage" /etc/modprobe.d/blacklist.conf 2>/dev/null; then
      ward_pass "USB storage is blacklisted"
      ward_desc "USB storage restrictions help prevent data exfiltration." "$verbose"
    fi
  fi
  
  # Check for default database passwords (MySQL/MariaDB)
  if has mysql; then
    ward_pass "MySQL/MariaDB installed - verify root password is set"
    msg="Test MySQL security: mysqladmin -u root -p status "
    msg="${msg}(should require password)"
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for PostgreSQL listening configuration
  if [ -f /etc/postgresql/*/main/postgresql.conf ]; then
    pg_conf=$(find /etc/postgresql -name "postgresql.conf" 2>/dev/null | head -1)
    if [ -n "$pg_conf" ] && [ -r "$pg_conf" ]; then
      if grep -q "^listen_addresses.*'\*'" "$pg_conf" 2>/dev/null; then
        ward_fail "PostgreSQL listening on all interfaces"
        msg="PostgreSQL should only listen on needed interfaces. "
        msg="${msg}Set listen_addresses='localhost' if only local access needed."
        ward_desc "$msg" 1
      else
        ward_pass "PostgreSQL listen configuration appears safe"
        ward_desc "Verify listen_addresses in postgresql.conf." "$verbose"
      fi
    fi
  fi
  
  # Check nginx security headers (if nginx installed)
  if has nginx && [ -d /etc/nginx ]; then
    nginx_conf="/etc/nginx/nginx.conf"
    if [ -r "$nginx_conf" ]; then
      has_xframe=0
      has_xss=0
      if grep -qr "X-Frame-Options" /etc/nginx/ 2>/dev/null; then
        has_xframe=1
      fi
      if grep -qr "X-XSS-Protection" /etc/nginx/ 2>/dev/null; then
        has_xss=1
      fi
      
      if [ "$has_xframe" -eq 1 ] && [ "$has_xss" -eq 1 ]; then
        ward_pass "nginx has security headers configured"
        ward_desc "Security headers help protect against common web attacks." 0
      else
        ward_fail "nginx missing security headers"
        msg="Add security headers to nginx configuration. "
        msg="${msg}Example: add_header X-Frame-Options SAMEORIGIN;"
        ward_desc "$msg" 1
      fi
    fi
  fi
  
  # Check Apache security configuration (if Apache installed)
  if has apache2 || has httpd; then
    apache_loaded=0
    # Check for common Apache configs
    for conf_dir in /etc/apache2 /etc/httpd; do
      if [ -d "$conf_dir" ]; then
        apache_loaded=1
        # Check ServerTokens
        if grep -qr "ServerTokens.*Prod" "$conf_dir" 2>/dev/null; then
          ward_pass "Apache ServerTokens is set to Prod"
          ward_desc "ServerTokens Prod hides Apache version info." "$verbose"
        else
          ward_fail "Apache ServerTokens not set to Prod"
          msg="Set 'ServerTokens Prod' to hide server version. "
          msg="${msg}Add to apache2.conf or httpd.conf"
          ward_desc "$msg" 1
        fi
        break
      fi
    done
  fi
  
  # Check /etc/hosts.allow and /etc/hosts.deny (TCP wrappers)
  if [ -f /etc/hosts.allow ] || [ -f /etc/hosts.deny ]; then
    ward_pass "TCP wrappers configuration exists"
    msg="TCP wrappers provide additional access control. "
    msg="${msg}Review /etc/hosts.allow and /etc/hosts.deny"
    ward_desc "$msg" "$verbose"
  else
    ward_pass "TCP wrappers not configured (acceptable for most systems)"
    msg="TCP wrappers are optional and less common on modern systems."
    ward_desc "$msg" "$verbose"
  fi
  
  # Novel check: SSH agent socket chain risks
  if [ -n "${SSH_AUTH_SOCK-}" ]; then
    ward_pass "SSH agent is running (verify it's your own)"
    msg="WHAT THIS IS: SSH agent is a program that holds decrypted SSH private keys in memory, allowing you "
    msg="${msg}to authenticate to multiple servers without re-entering your passphrase each time. "
    msg="${msg}SSH_AUTH_SOCK is the Unix socket other programs use to communicate with the agent. "
    msg="${msg}WHY IT MATTERS: Any process with access to SSH_AUTH_SOCK can use your keys to authenticate "
    msg="${msg}without knowing your passphrase. This includes: (1) Other users on the system if socket permissions "
    msg="${msg}are wrong. (2) Remote systems you SSH into with agent forwarding enabled - they can use your keys "
    msg="${msg}to connect to other servers, potentially compromising your infrastructure. "
    msg="${msg}HOW TO DECIDE: Using ssh-agent is standard practice. Verify the socket belongs to your ssh-agent "
    msg="${msg}process. Avoid agent forwarding (-A flag) unless necessary. Current socket: $SSH_AUTH_SOCK"
    ward_desc "$msg" "$verbose"
  fi
  
  # Novel check: Resource limit bombs
  if has ulimit; then
    max_processes=$(ulimit -u 2>/dev/null || printf 'unlimited')
    max_files=$(ulimit -n 2>/dev/null || printf 'unlimited')
    
    if [ "$max_processes" = "unlimited" ]; then
      ward_fail "No limit on number of processes (fork bomb risk)"
      msg="WHAT THIS IS: The system currently has no limit on the number of processes a user can create. "
      msg="${msg}The 'ulimit -u' setting controls maximum processes per user. "
      msg="${msg}WHY IT MATTERS: Without limits, a fork bomb attack can occur - a program that recursively "
      msg="${msg}spawns copies of itself until system resources are exhausted. This causes system-wide denial "
      msg="${msg}of service, making the system unresponsive and requiring hard reboot. Even accidental infinite "
      msg="${msg}loops in scripts can cause this. "
      msg="${msg}HOW TO DECIDE: Set a reasonable limit like 4096 processes per user to prevent resource exhaustion "
      msg="${msg}while allowing normal operations."
      ward_desc "$msg" 1
      if ward_ask_fix "Set process limit? (recommended)"; then
        printf 'Add to /etc/security/limits.conf:\n'
        printf '  * hard nproc 4096\n'
        printf '\nThis limits each user to 4096 processes, preventing fork bombs.\n'
      fi
    fi
  fi
  
  # Novel check: Browser security (check for common browser profile locations)
  browser_profiles_found=0
  for browser_dir in "$HOME/.mozilla/firefox" "$HOME/.config/google-chrome" \
                      "$HOME/.config/chromium" "$HOME/Library/Application Support/Google/Chrome" \
                      "$HOME/Library/Application Support/Firefox"; do
    if [ -d "$browser_dir" ]; then
      browser_profiles_found=1
      dir_perms=$(ls -ld "$browser_dir" 2>/dev/null | awk '{print $1}')
      if ! printf '%s' "$dir_perms" | grep -q '^drwx------'; then
        ward_fail "Browser profile directory not fully private: $(basename "$browser_dir")"
        msg="WHAT THIS IS: Your browser stores cookies, saved passwords, and history in these folders. "
        msg="${msg}WHY IT MATTERS: If others can read these files, they can steal your login sessions, "
        msg="${msg}see your browsing history, and possibly decrypt saved passwords. "
        msg="${msg}HOW TO DECIDE: Fix this - only you should access your browser data. "
        msg="${msg}Path: $browser_dir (permissions: $dir_perms)"
        ward_desc "$msg" 1
        if ward_ask_fix "Secure browser profile permissions? (recommended)"; then
          chmod 700 "$browser_dir" && success "Secured $(basename "$browser_dir")"
        fi
        break
      fi
    fi
  done
  
  if [ "$browser_profiles_found" -eq 0 ]; then
    ward_pass "No browser profiles found (or browsers not installed)"
    ward_desc "Browser security check skipped - no common browsers detected." "$verbose"
  fi
  
  # Check EDITOR and VISUAL environment variables
  for env_var in EDITOR VISUAL; do
    env_val=$(eval "printf '%s' \"\${${env_var}-}\"")
    if [ -n "$env_val" ]; then
      # Check if it points to a writable location
      if has "$env_val" 2>/dev/null; then
        editor_path=$(command -v "$env_val" 2>/dev/null || printf '')
        if [ -n "$editor_path" ] && [ -w "$editor_path" ]; then
          ward_fail "$env_var points to writable executable: $editor_path"
          msg="WHAT THIS IS: The $env_var environment variable specifies which text editor programs use. "
          msg="${msg}WHY IT MATTERS: If an attacker can modify the editor executable, they can inject code that "
          msg="${msg}runs whenever you edit files (especially with sudo/root privileges). Programs like visudo, "
          msg="${msg}crontab -e, and git rely on this variable. "
          msg="${msg}HOW TO DECIDE: Ensure your editor points to a system location that only root can modify, "
          msg="${msg}such as /usr/bin/vi or /usr/bin/nano."
          ward_desc "$msg" 1
          break
        fi
      fi
    fi
  done
  
  # Check for SSH key types (warn about weak algorithms)
  if [ -d "$HOME/.ssh" ]; then
    weak_keys_found=0
    for key in "$HOME/.ssh"/id_dsa* "$HOME/.ssh"/*_dsa; do
      if [ -f "$key" ] && ! printf '%s\n' "$key" | grep -q '\.pub$'; then
        if [ "$weak_keys_found" -eq 0 ]; then
          ward_fail "Weak SSH key algorithm detected (DSA)"
          msg="WHAT THIS IS: DSA (Digital Signature Algorithm) SSH keys use an outdated cryptographic algorithm. "
          msg="${msg}WHY IT MATTERS: DSA keys are limited to 1024 bits, which is now considered insecure. Modern "
          msg="${msg}attacks can potentially compromise these keys. DSA support is deprecated in newer SSH versions. "
          msg="${msg}HOW TO DECIDE: Generate new keys using Ed25519 (recommended) or RSA 4096-bit. Update your "
          msg="${msg}authorized_keys on remote servers, then delete the old DSA keys."
          ward_desc "$msg" 1
          if ward_ask_fix "See how to generate secure SSH keys?"; then
            printf 'Generate modern SSH keys:\n'
            printf '  ssh-keygen -t ed25519 -C "your_email@example.com"  # Recommended\n'
            printf '  ssh-keygen -t rsa -b 4096 -C "your_email@example.com"  # Alternative\n'
            printf '\nThen update authorized_keys on servers and remove old DSA keys.\n'
          fi
          weak_keys_found=1
        fi
        break
      fi
    done
  fi
  
  # Check shell history size limits
  histsize="${HISTSIZE-}"
  histfilesize="${HISTFILESIZE-}"
  if [ -n "$histsize" ] && [ "$histsize" -gt 10000 ] 2>/dev/null; then
    ward_fail "Very large shell history size: HISTSIZE=$histsize"
    msg="WHAT THIS IS: HISTSIZE controls how many commands are kept in memory during your shell session. "
    msg="${msg}WHY IT MATTERS: Extremely large history sizes consume memory and may preserve sensitive "
    msg="${msg}information (passwords, API keys) that you accidentally typed. Attackers gaining access to "
    msg="${msg}your account could mine your history for credentials. "
    msg="${msg}HOW TO DECIDE: Set HISTSIZE to a reasonable value like 1000-5000 commands. Set HISTFILESIZE "
    msg="${msg}similarly to limit on-disk history."
    ward_desc "$msg" 1
    if ward_ask_fix "See how to set reasonable history limits?"; then
      printf 'Add to your shell profile (~/.bashrc, ~/.zshrc):\n'
      printf '  export HISTSIZE=5000\n'
      printf '  export HISTFILESIZE=5000\n'
    fi
  fi
}

# Level 3: Expert/obscure security checks
check_level_3() {
  ward_title "Level 3: Expert Security Checks"
  
  # Check for SUID binaries (security risk if compromised)
  if has find; then
    suid_count=$(find /usr/bin /usr/local/bin /bin 2>/dev/null \
                      -type f -perm -4000 | wc -l | tr -d ' ')
    ward_pass "Found $suid_count SUID binaries in standard locations"
    msg="SUID binaries run with elevated privileges. "
    msg="${msg}While some are necessary (sudo, passwd), "
    msg="${msg}excessive SUID binaries increase attack surface. "
    msg="${msg}Review with: find / -type f -perm -4000 2>/dev/null"
    ward_desc "$msg" "$verbose"
  fi
  
  # Check core dumps
  ulimit_core=$(ulimit -c 2>/dev/null || printf 'unknown')
  if [ "$ulimit_core" = "0" ]; then
    ward_pass "Core dumps are disabled"
    msg="Core dumps can contain sensitive information from memory. "
    msg="${msg}Disabling prevents information leakage."
    ward_desc "$msg" 0
  else
    ward_fail "Core dumps are enabled (limit: $ulimit_core)"
    msg="WHAT THIS IS: When a program crashes, it can save its memory to disk as a 'core dump' for debugging. "
    msg="${msg}WHY IT MATTERS: This memory snapshot can contain passwords, encryption keys, or private data "
    msg="${msg}that was in the program when it crashed - like a photograph of everything the program knew. "
    msg="${msg}HOW TO DECIDE: Disable this unless you're actively debugging software. Any attacker who crashes "
    msg="${msg}a program could harvest secrets from the dump files."
    ward_desc "$msg" 1
    if ward_ask_fix "Disable core dumps? (recommended unless debugging software)"; then
      printf 'Add to your shell profile (~/.bashrc, ~/.zshrc):\n'
      printf '  ulimit -c 0\n'
      printf 'For system-wide setting, edit /etc/security/limits.conf:\n'
      printf '  * hard core 0\n'
      printf '\nThis prevents programs from writing memory dumps when they crash.\n'
    fi
  fi
  
  # Check SELinux status (Linux only)
  if has getenforce; then
    selinux_status=$(getenforce 2>/dev/null || printf 'unknown')
    if [ "$selinux_status" = "Enforcing" ]; then
      ward_pass "SELinux is enforcing"
      ward_desc "SELinux provides mandatory access control for enhanced security." 0
    elif [ "$selinux_status" = "Permissive" ]; then
      ward_fail "SELinux is in permissive mode"
      msg="SELinux permissive mode logs violations but doesn't enforce them. "
      msg="${msg}Consider setting to enforcing mode with: setenforce 1"
      ward_desc "$msg" 1
    elif [ "$selinux_status" = "Disabled" ]; then
      ward_fail "SELinux is disabled"
      msg="SELinux provides kernel-level access control. "
      msg="${msg}Consider enabling for production systems."
      ward_desc "$msg" 1
    fi
  elif [ -d "/sys/kernel/security/apparmor" ]; then
    # Check AppArmor as alternative (Ubuntu/Debian)
    if has aa-status; then
      ward_pass "AppArmor is available"
      ward_desc "AppArmor provides application confinement for enhanced security." "$verbose"
    fi
  fi
  
  # Check firewall status (platform-specific)
  firewall_active=0
  if has ufw; then
    if ufw status 2>/dev/null | grep -q "Status: active"; then
      ward_pass "UFW firewall is active"
      ward_desc "Firewall protects against unauthorized network access." 0
      firewall_active=1
    fi
  elif has iptables; then
    if iptables -L -n 2>/dev/null | grep -q "Chain INPUT"; then
      ward_pass "iptables firewall is configured"
      ward_desc "Firewall rules are present in iptables." "$verbose"
      firewall_active=1
    fi
  elif [ -f "/usr/libexec/ApplicationFirewall/socketfilterfw" ]; then
    # macOS firewall
    fw_cmd="/usr/libexec/ApplicationFirewall/socketfilterfw"
    if "$fw_cmd" --getglobalstate 2>/dev/null | grep -q "enabled"; then
      ward_pass "macOS firewall is enabled"
      ward_desc "Application firewall is active on macOS." 0
      firewall_active=1
    fi
  fi
  
  if [ "$firewall_active" -eq 0 ]; then
    ward_fail "No active firewall detected"
    msg="A firewall blocks unauthorized network connections. "
    msg="${msg}Consider enabling ufw (Ubuntu), firewalld (Fedora), "
    msg="${msg}or your system's firewall."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like guidance on enabling a firewall?"; then
      printf 'On Ubuntu/Debian: sudo ufw enable\n'
      printf 'On Fedora/RHEL: sudo systemctl start firewalld\n'
      printf 'On macOS: System Preferences > Security & Privacy > Firewall\n'
    fi
  fi
  
  # Check for suspicious cron jobs
  if [ -r /var/spool/cron/crontabs/"$(id -un)" ] || [ -r /var/spool/cron/"$(id -un)" ]; then
    ward_pass "User crontab exists - review recommended"
    ward_desc "Cron jobs run automatically. Review with: crontab -l" "$verbose"
  fi
  
  # Check listening network services
  if has ss || has netstat; then
    if has ss; then
      listen_count=$(ss -tuln 2>/dev/null | grep -c LISTEN || printf '0')
    else
      listen_count=$(netstat -tuln 2>/dev/null | grep -c LISTEN || printf '0')
    fi
    ward_pass "Found $listen_count listening network services"
    msg="Network services listening for connections represent potential attack surface. "
    msg="${msg}Review with: ss -tuln (or netstat -tuln)"
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for known_hosts file size
  if [ -f "$HOME/.ssh/known_hosts" ]; then
    known_hosts_lines=$(wc -l < "$HOME/.ssh/known_hosts" 2>/dev/null || printf '0')
    if [ "$known_hosts_lines" -gt 0 ]; then
      ward_pass "SSH known_hosts contains $known_hosts_lines entries"
      msg="known_hosts tracks SSH server fingerprints to prevent MITM attacks."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check for IPv6 privacy extensions (Linux)
  if [ -r /proc/sys/net/ipv6/conf/all/use_tempaddr ]; then
    ipv6_privacy=$(cat /proc/sys/net/ipv6/conf/all/use_tempaddr 2>/dev/null || printf '0')
    if [ "$ipv6_privacy" -ge 2 ]; then
      ward_pass "IPv6 privacy extensions are enabled"
      ward_desc "Privacy extensions help prevent IPv6 address tracking." 0
    else
      ward_fail "IPv6 privacy extensions are disabled"
      msg="IPv6 privacy extensions prevent tracking via stable addresses. "
      msg="${msg}Enable with: sysctl -w net.ipv6.conf.all.use_tempaddr=2"
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling IPv6 privacy?"; then
        printf 'Enable IPv6 privacy extensions:\n'
        printf '  sudo sysctl -w net.ipv6.conf.all.use_tempaddr=2\n'
        printf 'Make permanent by adding to /etc/sysctl.conf:\n'
        printf '  net.ipv6.conf.all.use_tempaddr=2\n'
      fi
    fi
  fi
  
  # Check kernel parameters for security hardening
  if [ -r /proc/sys/kernel/dmesg_restrict ]; then
    dmesg_restrict=$(cat /proc/sys/kernel/dmesg_restrict 2>/dev/null || printf '0')
    if [ "$dmesg_restrict" -eq 1 ]; then
      ward_pass "Kernel dmesg access is restricted"
      ward_desc "Restricting dmesg prevents information disclosure to non-root users." "$verbose"
    else
      ward_fail "Kernel dmesg access is not restricted"
      msg="dmesg can reveal sensitive kernel information. "
      msg="${msg}Restrict with: sysctl -w kernel.dmesg_restrict=1"
      ward_desc "$msg" 1
    fi
  fi
  
  # Check for systemd-analyze security (if available)
  if has systemd-analyze && has systemctl; then
    ward_pass "systemd security analysis available"
    msg="Run 'systemd-analyze security' to review service security settings."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check /var/log permissions
  if [ -d /var/log ]; then
    log_perms=$(ls -ld /var/log 2>/dev/null | awk '{print $1}')
    if printf '%s' "$log_perms" | grep -qE '^drwxr-xr-x|^drwxrwx---'; then
      ward_pass "/var/log has reasonable permissions"
      ward_desc "Log directory permissions prevent unauthorized access to logs." "$verbose"
    else
      ward_fail "/var/log has unusual permissions: $log_perms"
      msg="Log files may contain sensitive information. "
      msg="${msg}Review /var/log permissions."
      ward_desc "$msg" 1
    fi
  fi
  
  # Check for failed login attempts
  if [ -r /var/log/auth.log ] || [ -r /var/log/secure ]; then
    auth_log="/var/log/auth.log"
    [ -r /var/log/secure ] && auth_log="/var/log/secure"
    
    if has grep; then
      failed_logins=$(grep "Failed password" "$auth_log" 2>/dev/null | wc -l)
      failed_logins=${failed_logins:-0}
      if [ "$failed_logins" -gt 0 ] 2>/dev/null; then
        ward_fail "Found $failed_logins failed login attempts in logs"
        msg="Failed login attempts may indicate brute-force attacks. "
        msg="${msg}Review with: grep 'Failed password' $auth_log"
        ward_desc "$msg" 1
      else
        ward_pass "No recent failed login attempts in auth logs"
        ward_desc "System shows no signs of brute-force login attempts." 0
      fi
    fi
  fi
  
  # Check for suspicious processes
  if has ps; then
    # Look for processes running from tmp directories (common attack vector)
    tmp_procs=$(ps aux 2>/dev/null | grep -E '/tmp/|/var/tmp/' | grep -v grep || printf '')
    if [ -n "$tmp_procs" ]; then
      ward_fail "Found processes running from /tmp directories"
      msg="Processes running from /tmp may be malicious. "
      msg="${msg}Review running processes carefully."
      ward_desc "$msg" 1
    else
      ward_pass "No suspicious processes from /tmp detected"
      ward_desc "No processes running from temporary directories." "$verbose"
    fi
  fi
  
  # Check kernel exploit mitigation (ASLR)
  if [ -r /proc/sys/kernel/randomize_va_space ]; then
    aslr=$(cat /proc/sys/kernel/randomize_va_space 2>/dev/null || printf '0')
    if [ "$aslr" -eq 2 ]; then
      ward_pass "ASLR (Address Space Layout Randomization) is fully enabled"
      ward_desc "ASLR helps protect against memory corruption exploits." 0
    else
      ward_fail "ASLR is not fully enabled (value: $aslr)"
      msg="ASLR should be set to 2 for full protection. "
      msg="${msg}Enable with: sysctl -w kernel.randomize_va_space=2"
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on enabling ASLR?"; then
        printf 'Enable ASLR:\n'
        printf '  sudo sysctl -w kernel.randomize_va_space=2\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  kernel.randomize_va_space=2\n'
      fi
    fi
  fi
  
  # Check filesystem mount options for /tmp
  if has mount; then
    tmp_mount=$(mount | grep " /tmp " 2>/dev/null || printf '')
    if [ -n "$tmp_mount" ]; then
      if printf '%s' "$tmp_mount" | grep -q "noexec"; then
        ward_pass "/tmp is mounted with noexec option"
        ward_desc "noexec on /tmp prevents execution of binaries." 0
      else
        ward_fail "/tmp is not mounted with noexec option"
        msg="/tmp should be mounted with noexec,nosuid,nodev for security. "
        msg="${msg}Add to /etc/fstab: tmpfs /tmp tmpfs defaults,noexec,nosuid,nodev 0 0"
        ward_desc "$msg" 1
      fi
    else
      ward_pass "/tmp mount options: check manually"
      ward_desc "/tmp may not be a separate mount. Consider separate partition." "$verbose"
    fi
  fi
  
  # Check for loaded kernel modules
  if has lsmod; then
    modules_loaded=$(lsmod 2>/dev/null | wc -l)
    modules_loaded=$((modules_loaded - 1)) # Subtract header line
    ward_pass "$modules_loaded kernel modules currently loaded"
    msg="Review loaded modules with 'lsmod' for unexpected entries."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check if auditd is running (Linux audit system)
  if has systemctl; then
    if systemctl is-active auditd >/dev/null 2>&1; then
      ward_pass "Audit daemon (auditd) is running"
      ward_desc "auditd provides comprehensive system auditing for security." 0
    else
      ward_fail "Audit daemon (auditd) is not running"
      msg="auditd provides detailed security auditing. "
      msg="${msg}Install and enable: sudo apt install auditd && sudo systemctl enable auditd"
      ward_desc "$msg" 1
    fi
  fi
  
  # Check network interfaces for promiscuous mode (packet sniffing)
  if has ip; then
    promisc=$(ip link show 2>/dev/null | grep PROMISC || printf '')
    if [ -n "$promisc" ]; then
      ward_fail "Network interface in promiscuous mode detected"
      msg="Promiscuous mode allows packet sniffing. "
      msg="${msg}This may indicate monitoring tools or potential compromise."
      ward_desc "$msg" 1
      printf 'Interface in promiscuous mode:\n%s\n' "$promisc"
    else
      ward_pass "No network interfaces in promiscuous mode"
      ward_desc "Network interfaces not configured for packet capture." 0
    fi
  fi
  
  # Check for compiler tools on production systems
  if has gcc || has cc || has clang; then
    ward_fail "Compiler tools found on system"
    msg="Compilers (gcc, clang) on production systems can be used "
    msg="${msg}by attackers to compile exploits. Consider removing if not needed."
    ward_desc "$msg" 1
    if ward_ask_fix "Would you like to see compiler removal commands?"; then
      printf 'Remove compiler tools (Debian/Ubuntu):\n'
      printf '  sudo apt remove gcc g++ make\n'
      printf 'Remove compiler tools (RHEL/Fedora):\n'
      printf '  sudo yum remove gcc gcc-c++ make\n'
    fi
  else
    ward_pass "No compiler tools detected"
    ward_desc "System does not have development compilers installed." 0
  fi
  
  # Check system entropy for cryptography
  if [ -r /proc/sys/kernel/random/entropy_avail ]; then
    entropy=$(cat /proc/sys/kernel/random/entropy_avail 2>/dev/null || printf '0')
    if [ "$entropy" -gt 1000 ]; then
      ward_pass "System entropy is adequate ($entropy bits available)"
      ward_desc "Sufficient entropy for cryptographic operations." 0
    else
      ward_fail "System entropy is low ($entropy bits available)"
      msg="Low entropy can weaken cryptographic operations. "
      msg="${msg}Consider installing haveged or rng-tools."
      ward_desc "$msg" 1
      if ward_ask_fix "Would you like guidance on improving entropy?"; then
        printf 'Install haveged for better entropy:\n'
        printf '  sudo apt install haveged\n'
      fi
    fi
  fi
  
  # Check for suspicious systemd unit files
  if [ -d /etc/systemd/system ]; then
    user_units=$(find /etc/systemd/system -name "*.service" -type f 2>/dev/null | wc -l)
    if [ "$user_units" -gt 0 ]; then
      ward_pass "Found $user_units custom systemd unit files"
      msg="Review custom systemd units in /etc/systemd/system/ for legitimacy."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check for common rootkit indicators
  if has find; then
    # Check for hidden files in /dev (common rootkit location)
    hidden_dev=$(find /dev -name ".*" 2>/dev/null | grep -v "/dev/\." | head -5 || printf '')
    if [ -n "$hidden_dev" ]; then
      ward_fail "Hidden files found in /dev directory"
      msg="Hidden files in /dev may indicate rootkit. Investigate: "
      msg="${msg}$(printf '%s' "$hidden_dev" | head -1)"
      ward_desc "$msg" 1
    else
      ward_pass "No suspicious hidden files in /dev"
      ward_desc "/dev directory appears clean." "$verbose"
    fi
  fi
  
  # Check SSH agent forwarding
  for sshd_config in /etc/ssh/sshd_config /private/etc/ssh/sshd_config; do
    if [ -r "$sshd_config" ]; then
      if grep -q "^AllowAgentForwarding yes" "$sshd_config" 2>/dev/null; then
        ward_fail "SSH agent forwarding is enabled"
        msg="Agent forwarding can expose SSH keys on compromised servers. "
        msg="${msg}Disable unless specifically needed."
        ward_desc "$msg" 1
      else
        ward_pass "SSH agent forwarding is not explicitly enabled"
        ward_desc "Agent forwarding disabled or not configured." "$verbose"
      fi
      break
    fi
  done
  
  # Check for secure boot status (UEFI systems)
  if [ -d /sys/firmware/efi ]; then
    if has mokutil; then
      if mokutil --sb-state 2>/dev/null | grep -q "SecureBoot enabled"; then
        ward_pass "Secure Boot is enabled"
        msg="Secure Boot helps prevent rootkits and bootloader tampering."
        ward_desc "$msg" 0
      else
        ward_fail "Secure Boot is disabled"
        msg="Secure Boot prevents unsigned bootloaders from running. "
        msg="${msg}Enable in UEFI/BIOS settings. WARNING: May require configuration."
        ward_desc "$msg" 1
      fi
    fi
  fi
  
  # Check swap encryption (if swap exists)
  if has swapon; then
    swap_devices=$(swapon --show=NAME --noheadings 2>/dev/null || printf '')
    if [ -n "$swap_devices" ]; then
      # Check if swap is on encrypted device
      encrypted_swap=0
      for swap_dev in $swap_devices; do
        if printf '%s' "$swap_dev" | grep -q "dm-crypt\|/dev/mapper"; then
          encrypted_swap=1
          break
        fi
      done
      
      if [ "$encrypted_swap" -eq 1 ]; then
        ward_pass "Swap appears to be encrypted"
        ward_desc "Encrypted swap protects sensitive data in memory dumps." 0
      else
        ward_fail "Swap is not encrypted"
        msg="Unencrypted swap can contain passwords and keys. "
        msg="${msg}Consider using encrypted swap. WARNING: Complex to set up."
        ward_desc "$msg" 1
      fi
    fi
  fi
  
  # Check disk encryption status
  if has lsblk; then
    encrypted_root=$(lsblk -o NAME,TYPE,MOUNTPOINT 2>/dev/null | \
                      grep -E "/$" | grep -q "crypt" && printf '1' || printf '0')
    if [ "$encrypted_root" -eq 1 ]; then
      ward_pass "Root filesystem appears to be encrypted"
      ward_desc "Full disk encryption protects data if device is stolen." 0
    else
      ward_pass "Root filesystem encryption: not detected (check manually)"
      msg="Disk encryption protects against physical theft but is complex to add later."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Check source IP verification (reverse path filtering)
  if [ -r /proc/sys/net/ipv4/conf/all/rp_filter ]; then
    rp_filter=$(cat /proc/sys/net/ipv4/conf/all/rp_filter 2>/dev/null || printf '0')
    if [ "$rp_filter" -ge 1 ]; then
      ward_pass "Reverse path filtering is enabled (level $rp_filter)"
      msg="rp_filter helps prevent IP spoofing attacks."
      ward_desc "$msg" "$verbose"
    else
      ward_fail "Reverse path filtering is disabled"
      msg="Reverse path filtering helps prevent spoofed packets. "
      msg="${msg}Enable with: sysctl -w net.ipv4.conf.all.rp_filter=1"
      ward_desc "$msg" 1
      if ward_ask_fix "Enable reverse path filtering? (recommended)"; then
        printf 'Enable reverse path filtering:\n'
        printf '  sudo sysctl -w net.ipv4.conf.all.rp_filter=1\n'
        printf '  sudo sysctl -w net.ipv4.conf.default.rp_filter=1\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  net.ipv4.conf.all.rp_filter=1\n'
      fi
    fi
  fi
  
  # Check SYN cookie protection
  if [ -r /proc/sys/net/ipv4/tcp_syncookies ]; then
    syncookies=$(cat /proc/sys/net/ipv4/tcp_syncookies 2>/dev/null || printf '0')
    if [ "$syncookies" -eq 1 ]; then
      ward_pass "SYN cookie protection is enabled"
      ward_desc "SYN cookies help protect against SYN flood attacks." 0
    else
      ward_fail "SYN cookie protection is disabled"
      msg="SYN cookies protect against DoS attacks. "
      msg="${msg}Enable with: sysctl -w net.ipv4.tcp_syncookies=1"
      ward_desc "$msg" 1
      if ward_ask_fix "Enable SYN cookie protection? (recommended)"; then
        printf 'Enable SYN cookies:\n'
        printf '  sudo sysctl -w net.ipv4.tcp_syncookies=1\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  net.ipv4.tcp_syncookies=1\n'
      fi
    fi
  fi
  
  # Check for AppArmor/SELinux profile coverage
  if has aa-status; then
    profiles_enforced=$(aa-status 2>/dev/null | grep "profiles are in enforce mode" | \
                         awk '{print $1}' || printf '0')
    profiles_enforced=${profiles_enforced:-0}
    if [ "$profiles_enforced" -gt 0 ] 2>/dev/null; then
      ward_pass "$profiles_enforced AppArmor profiles in enforce mode"
      ward_desc "AppArmor profiles provide application confinement." "$verbose"
    fi
  fi
  
  # Check kernel.kptr_restrict (hide kernel pointers)
  if [ -r /proc/sys/kernel/kptr_restrict ]; then
    kptr=$(cat /proc/sys/kernel/kptr_restrict 2>/dev/null || printf '0')
    if [ "$kptr" -ge 1 ]; then
      ward_pass "Kernel pointer restriction is enabled (level $kptr)"
      msg="kptr_restrict hides kernel addresses from unprivileged users."
      ward_desc "$msg" "$verbose"
    else
      ward_fail "Kernel pointers are not restricted"
      msg="Hiding kernel pointers helps prevent exploits. "
      msg="${msg}Enable with: sysctl -w kernel.kptr_restrict=1"
      ward_desc "$msg" 1
      if ward_ask_fix "Enable kernel pointer restriction? (recommended)"; then
        printf 'Enable kernel pointer restriction:\n'
        printf '  sudo sysctl -w kernel.kptr_restrict=1\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  kernel.kptr_restrict=1\n'
      fi
    fi
  fi
  
  # Check ptrace_scope (restrict ptrace to child processes)
  if [ -r /proc/sys/kernel/yama/ptrace_scope ]; then
    ptrace=$(cat /proc/sys/kernel/yama/ptrace_scope 2>/dev/null || printf '0')
    if [ "$ptrace" -ge 1 ]; then
      ward_pass "ptrace is restricted to child processes (level $ptrace)"
      msg="ptrace restrictions prevent debugging of unrelated processes."
      ward_desc "$msg" "$verbose"
    else
      ward_fail "ptrace is not restricted"
      msg="Restricting ptrace prevents some debugging-based attacks. "
      msg="${msg}Enable with: sysctl -w kernel.yama.ptrace_scope=1"
      ward_desc "$msg" 1
      if ward_ask_fix "Restrict ptrace? (recommended)"; then
        printf 'Restrict ptrace:\n'
        printf '  sudo sysctl -w kernel.yama.ptrace_scope=1\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  kernel.yama.ptrace_scope=1\n'
      fi
    fi
  fi
  
  # Check for exec-shield or similar protections
  if [ -r /proc/sys/kernel/exec-shield ]; then
    exec_shield=$(cat /proc/sys/kernel/exec-shield 2>/dev/null || printf '0')
    if [ "$exec_shield" -eq 1 ]; then
      ward_pass "Exec-shield is enabled"
      ward_desc "Exec-shield provides additional buffer overflow protection." 0
    fi
  fi
  
  # Check perf_event paranoid (prevent performance monitoring abuse)
  if [ -r /proc/sys/kernel/perf_event_paranoid ]; then
    perf=$(cat /proc/sys/kernel/perf_event_paranoid 2>/dev/null || printf '0')
    if [ "$perf" -ge 2 ]; then
      ward_pass "Performance event monitoring is restricted (level $perf)"
      msg="Restricts perf_event to reduce info leakage."
      ward_desc "$msg" "$verbose"
    else
      ward_fail "Performance event monitoring not fully restricted"
      msg="Set perf_event_paranoid to 2 or higher. "
      msg="${msg}Enable with: sysctl -w kernel.perf_event_paranoid=2"
      ward_desc "$msg" 1
    fi
  fi
  
  # Check unprivileged BPF (should be disabled for security)
  if [ -r /proc/sys/kernel/unprivileged_bpf_disabled ]; then
    bpf=$(cat /proc/sys/kernel/unprivileged_bpf_disabled 2>/dev/null || printf '0')
    if [ "$bpf" -eq 1 ]; then
      ward_pass "Unprivileged BPF is disabled"
      msg="Disabling unprivileged BPF prevents exploitation via eBPF."
      ward_desc "$msg" 0
    else
      ward_fail "Unprivileged BPF is enabled"
      msg="eBPF can be used for attacks. Disable with: "
      msg="${msg}sysctl -w kernel.unprivileged_bpf_disabled=1"
      ward_desc "$msg" 1
      if ward_ask_fix "Disable unprivileged BPF? (recommended)"; then
        printf 'Disable unprivileged BPF:\n'
        printf '  sudo sysctl -w kernel.unprivileged_bpf_disabled=1\n'
        printf 'Make permanent in /etc/sysctl.conf:\n'
        printf '  kernel.unprivileged_bpf_disabled=1\n'
      fi
    fi
  fi
  
  # Check for mail aliases that could be exploited
  if [ -r /etc/aliases ]; then
    dangerous_aliases=$(grep -E "^(decode|uudecode):" /etc/aliases 2>/dev/null || printf '')
    if [ -n "$dangerous_aliases" ]; then
      ward_fail "Dangerous mail aliases found in /etc/aliases"
      msg="decode and uudecode aliases can be exploited. Remove them."
      ward_desc "$msg" 1
    else
      ward_pass "No obvious dangerous mail aliases found"
      ward_desc "Mail aliases file appears safe." "$verbose"
    fi
  fi
  
  # Check /etc/securetty (restricts root login locations)
  if [ -r /etc/securetty ]; then
    ward_pass "/etc/securetty exists"
    msg="/etc/securetty restricts where root can login from. "
    msg="${msg}Verify it's properly configured."
    ward_desc "$msg" "$verbose"
  fi
  
  # Check for nodev on /home (if separate partition)
  if has mount; then
    home_mount=$(mount | grep " /home " 2>/dev/null || printf '')
    if [ -n "$home_mount" ]; then
      if printf '%s' "$home_mount" | grep -q "nodev"; then
        ward_pass "/home is mounted with nodev option"
        msg="nodev on /home prevents device file creation."
        ward_desc "$msg" 0
      else
        ward_fail "/home is not mounted with nodev option"
        msg="/home should be mounted with nodev for security. "
        msg="${msg}Add to /etc/fstab"
        ward_desc "$msg" 1
      fi
    fi
  fi
  
  # Check kernel module signing
  if [ -r /proc/sys/kernel/modules_disabled ]; then
    modules_disabled=$(cat /proc/sys/kernel/modules_disabled 2>/dev/null || printf '0')
    if [ "$modules_disabled" -eq 1 ]; then
      ward_pass "Kernel module loading is disabled"
      msg="Disabling module loading prevents runtime kernel modification. "
      msg="${msg}WARNING: Very restrictive, only for locked-down systems."
      ward_desc "$msg" 0
    fi
  fi
  
  # Novel check: Locale/character encoding attacks
  if [ -n "${LC_ALL-}" ] && printf '%s' "$LC_ALL" | grep -qiE "(utf-?7|utf-?32)"; then
    ward_fail "Potentially dangerous locale setting: $LC_ALL"
    msg="WHAT THIS IS: Your locale (LC_ALL) controls how text is interpreted. UTF-7 and UTF-32 are uncommon. "
    msg="${msg}WHY IT MATTERS: Attackers use exotic character encodings to bypass security filters - like "
    msg="${msg}writing a forbidden word in a different alphabet so automated checkers miss it. "
    msg="${msg}HOW TO DECIDE: Use standard encodings like en_US.UTF-8. Change this unless you have a specific "
    msg="${msg}reason for unusual encoding."
    ward_desc "$msg" 1
    if ward_ask_fix "Change to standard locale? (recommended)"; then
      printf 'Set a standard locale in your shell profile:\n'
      printf '  export LC_ALL=en_US.UTF-8\n'
      printf '  export LANG=en_US.UTF-8\n'
    fi
  fi
  
  # Novel check: Filesystem case-sensitivity security implications
  if has mount; then
    # Check if any mounts are case-insensitive (potential security issue)
    case_insensitive=$(mount | grep -i "case.*insensitive" || printf '')
    if [ -n "$case_insensitive" ]; then
      ward_fail "Case-insensitive filesystem detected"
      msg="WHAT THIS IS: A case-insensitive filesystem treats filenames with different capitalization as "
      msg="${msg}identical (e.g., 'File.txt', 'file.txt', and 'FILE.TXT' all refer to the same file). "
      msg="${msg}WHY IT MATTERS: This can bypass filename-based security controls. If a security policy blocks "
      msg="${msg}files matching 'exploit.exe', an attacker could use 'Exploit.EXE' or 'EXPLOIT.exe' to evade "
      msg="${msg}detection. Some applications and scripts assume case-sensitive filesystem behavior, leading to "
      msg="${msg}security vulnerabilities when deployed on case-insensitive systems. "
      msg="${msg}HOW TO DECIDE: macOS default filesystems (APFS, HFS+) are case-insensitive by design. "
      msg="${msg}Linux systems should use case-sensitive filesystems (ext4, xfs) for security-critical data. "
      msg="${msg}Affected mount: $(printf '%s' "$case_insensitive" | head -1)"
      ward_desc "$msg" 1
    fi
  fi
  
  # Novel check: Temporary file cleanup on logout
  if [ -d "$HOME/.cache" ] || [ -d "/tmp" ]; then
    cache_size=0
    if [ -d "$HOME/.cache" ]; then
      cache_size=$(du -s "$HOME/.cache" 2>/dev/null | awk '{print $1}')
      cache_size=${cache_size:-0}
    fi
    
    # Check if systemd-tmpfiles is managing cleanup
    tmp_cleanup_configured=0
    if has systemctl && systemctl list-timers 2>/dev/null | grep -q "systemd-tmpfiles"; then
      tmp_cleanup_configured=1
    fi
    
    if [ "$tmp_cleanup_configured" -eq 0 ] && [ "$cache_size" -gt 1048576 ]; then
      ward_fail "Large cache directory and no automatic cleanup ($cache_size KB)"
      msg="WHAT THIS IS: The ~/.cache directory stores temporary application data. Without automatic cleanup, "
      msg="${msg}this directory grows indefinitely. Current size: $cache_size KB (>1GB). "
      msg="${msg}WHY IT MATTERS: Cache files can contain sensitive information from application memory, including: "
      msg="${msg}(1) Browser cache with private browsing data. (2) Application credentials and session tokens. "
      msg="${msg}(3) Temporary files from crashed programs that failed to clean up. This data persists indefinitely "
      msg="${msg}and remains accessible even after the source application is removed. "
      msg="${msg}HOW TO DECIDE: Configure automatic cleanup with systemd-tmpfiles or similar, or periodically "
      msg="${msg}review and manually remove old cache data."
      ward_desc "$msg" 1
      if ward_ask_fix "See how to configure automatic cleanup?"; then
        printf 'Enable systemd tmpfiles cleanup:\n'
        printf '  sudo systemctl enable systemd-tmpfiles-clean.timer\n'
        printf 'Or manually clear cache:\n'
        printf '  rm -rf ~/.cache/*\n'
      fi
    fi
  fi
  
  # Novel check: ARP cache inspection for MITM
  if has arp || has ip; then
    arp_count=0
    if has arp; then
      arp_count=$(arp -a 2>/dev/null | wc -l)
    elif has ip; then
      arp_count=$(ip neigh show 2>/dev/null | wc -l)
    fi
    
    if [ "$arp_count" -gt 50 ]; then
      ward_fail "Unusually large ARP cache ($arp_count entries)"
      msg="WHAT THIS IS: The ARP (Address Resolution Protocol) cache stores mappings between IP addresses "
      msg="${msg}and MAC (hardware) addresses on the local network. It's used to route packets on Ethernet networks. "
      msg="${msg}WHY IT MATTERS: An abnormally large ARP cache can indicate ARP poisoning/spoofing attacks. "
      msg="${msg}In this attack, a malicious host sends forged ARP replies to associate the attacker's MAC address "
      msg="${msg}with the IP address of legitimate hosts (like your router), intercepting all network traffic "
      msg="${msg}in a man-in-the-middle attack. "
      msg="${msg}HOW TO DECIDE: This is normal for enterprise networks with many hosts. On small networks (home, "
      msg="${msg}small office), investigate. Use 'arp -a' or 'ip neigh show' to inspect entries. Look for duplicate "
      msg="${msg}IP addresses with different MAC addresses or entries that change frequently."
      ward_desc "$msg" 1
    else
      ward_pass "ARP cache size appears normal ($arp_count entries)"
      msg="Network address cache is reasonable for your network size."
      ward_desc "$msg" "$verbose"
    fi
  fi
  
  # Novel check: DNS cache inspection
  if has systemd-resolve; then
    dns_stats=$(systemd-resolve --statistics 2>/dev/null | grep -i "cache" || printf '')
    if [ -n "$dns_stats" ]; then
      cache_hit_rate=$(printf '%s' "$dns_stats" | grep -i "hit" | awk '{print $NF}' | tr -d '%')
      if [ -n "$cache_hit_rate" ] && [ "$cache_hit_rate" -gt 95 ] 2>/dev/null; then
        ward_fail "Suspiciously high DNS cache hit rate ($cache_hit_rate%)"
        msg="WHAT THIS IS: DNS translates names (google.com) to numbers (IP addresses). A cache stores recent lookups. "
        msg="${msg}WHY IT MATTERS: A >95% hit rate might mean you're only visiting the same few sites repeatedly "
        msg="${msg}(normal for some users) OR your DNS cache has been poisoned to redirect many sites to attacker IPs. "
        msg="${msg}HOW TO DECIDE: If you browse varied sites but keep getting redirected, investigate. Clear DNS cache "
        msg="${msg}and see if unexpected redirects stop. View stats: systemd-resolve --statistics"
        ward_desc "$msg" 1
      fi
    fi
  fi
}

# Main execution
info "Checking system security wards..."

# Run checks based on level
if [ "$run_all" -eq 1 ]; then
  check_level_1
  check_level_2
  check_level_3
  printf '\n'
  success "System ward check complete for all levels"
else
  case "$level" in
    1)
      check_level_1
      ;;
    2)
      check_level_2
      ;;
    3)
      check_level_3
      ;;
  esac
  printf '\n'
  success "System ward check complete at level $level"
fi

# Print summary
printf '\n%s=== Security Check Summary ===%s\n' "${BOLD}" "${RESET}"
printf 'Total checks: %d\n' "$total_checks"
printf '%s✓%s Passed: %d\n' "${GREEN}" "${RESET}" "$passed_checks"
printf '%s✗%s Failed: %d\n' "${RED}" "${RESET}" "$failed_checks"

if [ "$failed_checks" -gt 0 ]; then
  printf '\n%sRecommendation:%s Review and address the failed checks above.\n' \
         "${YELLOW}" "${RESET}"
  printf 'Re-run ward-system after making changes to verify fixes.\n'
fi
