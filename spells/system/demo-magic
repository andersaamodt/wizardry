#!/bin/sh

# Demonstrate wizardry spells at specified levels with narrated output.
# Each demo level corresponds to a banish level and demonstrates the spells
# that are validated and tested by that banish level.

demo_magic_usage() {
  cat <<'USAGE'
Usage: demo-magic [LEVEL]

Demonstrate wizardry features by running checks on spells and narrating results.
Each level demonstrates spells validated by the corresponding banish level.

Arguments:
  LEVEL         Demonstration level (0-29, default: 1)
                Level 0: POSIX & platform foundation
                Level 1: Wizardry installation
                Level 2: Glossary system
                Level 3: Menu system
                Level 4+: Higher-level spells (see SPELL_LEVELS.md)
USAGE
}

# Demo a single level using spell-levels data
demo_level() {
  level=$1
  
  # Get level name and spell list
  level_name=$(banish_level_name "$level")
  spell_list=$(get_level_spells "$level")
  imp_list=$(get_level_imps "$level")
  
  printf '\n'
  printf '=== Level %d: %s ===\n' "$level" "$level_name"
  printf '\n'
  
  # Add level-specific narration and demonstrations
  case "$level" in
    0)
      printf 'The wizard examines the foundation of reality itself...\n'
      printf '\n'
      
      # Actually run detect-posix
      if [ -f "${WIZARDRY_DIR}/spells/divination/detect-posix" ]; then
        printf 'The wizard casts detect-posix...\n'
        "${WIZARDRY_DIR}/spells/divination/detect-posix" 2>&1 | head -5
        printf '\n'
      fi
      
      # Run detect-distro
      if [ -f "${WIZARDRY_DIR}/spells/divination/detect-distro" ]; then
        printf 'The wizard casts detect-distro...\n'
        printf 'Distribution: %s\n' "$("${WIZARDRY_DIR}/spells/divination/detect-distro")"
        printf '\n'
      fi
      
      # Check infrastructure
      if [ -f "${WIZARDRY_DIR}/spells/.imps/sys/invoke-wizardry" ]; then
        printf 'The invoke-wizardry ritual: ready\n'
      fi
      
      if [ -d "${WIZARDRY_DIR}/spells" ]; then
        spell_count=$(find "${WIZARDRY_DIR}/spells" -type f -executable 2>/dev/null | wc -l)
        printf 'The spells grimoire: %d spells inscribed\n' "$spell_count"
      fi
      
      if [ -d "${WIZARDRY_DIR}/spells/.imps" ]; then
        imp_count=$(find "${WIZARDRY_DIR}/spells/.imps" -type f 2>/dev/null | wc -l)
        printf 'The imp summoning circles: %d imps bound\n' "$imp_count"
      fi
      ;;
      
    1)
      printf 'The wizard gathers the core components of wizardry...\n'
      printf '\n'
      
      # Demonstrate validate-spells
      if [ -f "${WIZARDRY_DIR}/spells/system/validate-spells" ]; then
        printf 'The wizard casts validate-spells on core infrastructure...\n'
        "${WIZARDRY_DIR}/spells/system/validate-spells" banish:system validate-spells:system 2>&1 | head -3
        printf '\n'
      fi
      
      # Show core imps
      printf 'Core imps summoned: %d foundational helpers\n' "$(printf '%s' "$imp_list" | wc -w)"
      printf 'Including: has, there, is, say, warn, die, temp-file, and more...\n'
      ;;
      
    2)
      printf 'The wizard conjures the glossary system...\n'
      printf '\n'
      
      if [ -f "${WIZARDRY_DIR}/spells/system/generate-glosses" ]; then
        printf 'The wizard has the power to cast generate-glosses...\n'
        printf '(Glossary generation extracts help text from all spells)\n'
      fi
      ;;
      
    3)
      printf 'The wizard weaves interactive menus from pure thought...\n'
      printf '\n'
      
      # Demonstrate fathom-terminal
      if [ -f "${WIZARDRY_DIR}/spells/cantrips/fathom-terminal" ]; then
        printf 'The wizard casts fathom-terminal...\n'
        term_size=$("${WIZARDRY_DIR}/spells/cantrips/fathom-terminal")
        printf 'Terminal dimensions discovered: %s\n' "$term_size"
        printf '\n'
      fi
      
      # List menu capabilities
      printf 'Menu system capabilities unlocked:\n'
      printf '  • Interactive menu navigation\n'
      printf '  • Terminal size detection\n'
      printf '  • Cursor positioning\n'
      printf '  • Keypress detection\n'
      printf '  • Color support\n'
      ;;
      
    4)
      printf 'The wizard enters the realm of MUD...\n'
      printf '\n'
      
      # Demonstrate look on current directory
      if [ -f "${WIZARDRY_DIR}/spells/mud/look" ]; then
        printf 'The wizard casts look on the current location...\n'
        "${WIZARDRY_DIR}/spells/mud/look" . 2>&1 | head -10
      fi
      ;;
      
    7)
      printf 'The wizard masters arcane file operations...\n'
      printf '\n'
      
      # Demonstrate read-magic
      if [ -f "${WIZARDRY_DIR}/spells/arcane/read-magic" ]; then
        printf 'The wizard casts read-magic...\n'
        printf '(Reads extended attributes from files)\n'
        if [ -f "${WIZARDRY_DIR}/spells/arcane/read-magic" ]; then
          printf 'Reading the read-magic spell itself:\n'
          "${WIZARDRY_DIR}/spells/arcane/read-magic" "${WIZARDRY_DIR}/spells/arcane/read-magic" 2>&1 | head -5 || printf '  (No attributes set)\n'
        fi
        printf '\n'
      fi
      
      printf 'File operations available:\n'
      printf '  • copy - Copy files with optional extended attributes\n'
      printf '  • trash - Move files to trash instead of deleting\n'
      printf '  • read-magic - Read extended attributes\n'
      printf '  • forall - Execute commands on multiple files\n'
      ;;
      
    8)
      printf 'The wizard learns basic cantrips...\n'
      printf '\n'
      
      # Demonstrate ask-yn (with auto-response via pipe)
      if [ -f "${WIZARDRY_DIR}/spells/cantrips/ask-yn" ]; then
        printf 'The wizard casts ask-yn "Is this a demonstration?" yes\n'
        printf 'y\n' | "${WIZARDRY_DIR}/spells/cantrips/ask-yn" "Is this a demonstration?" yes 2>&1 || true
        printf '\n'
      fi
      ;;
      
    12)
      printf 'The wizard establishes the testing framework...\n'
      printf '\n'
      
      if [ -f "${WIZARDRY_DIR}/spells/system/test-magic" ]; then
        printf 'The wizard has established test-magic...\n'
        printf '(Testing framework enables spell validation)\n'
        printf 'Tests available: %d test files\n' "$(find "${WIZARDRY_DIR}/.tests" -name "test-*.sh" 2>/dev/null | wc -l)"
      fi
      ;;
      
    14)
      printf 'The wizard demonstrates the demonstration itself...\n'
      printf 'Recursion: demo-magic demonstrating demo-magic!\n'
      printf '\n'
      ;;
      
    *)
      # For other levels, show a summary
      printf 'The wizard channels level %d energies...\n' "$level"
      printf '\n'
      
      # Count and display spells
      if [ -n "$spell_list" ]; then
        spell_count=$(printf '%s' "$spell_list" | wc -w)
        printf 'Spells at this level: %d\n' "$spell_count"
        
        # Show first few spells
        first_spells=$(printf '%s' "$spell_list" | tr ' ' '\n' | head -5 | sed 's/:.*//; s/^/  • /')
        printf '%s\n' "$first_spells"
        
        remaining=$((spell_count - 5))
        if [ "$remaining" -gt 0 ]; then
          printf '  ... and %d more\n' "$remaining"
        fi
        printf '\n'
      fi
      
      # Count imps
      if [ -n "$imp_list" ]; then
        imp_count=$(printf '%s' "$imp_list" | wc -w)
        printf 'Imps summoned: %d micro-helpers\n' "$imp_count"
      fi
      ;;
  esac
}

demo_magic() {
case "${1-}" in
--help|--usage|-h)
  demo_magic_usage
  return 0
  ;;
esac

set -eu

# Detect WIZARDRY_DIR if not set (for direct execution)
if [ -z "${WIZARDRY_DIR-}" ]; then
  # Try to detect from script location
  if command -v dirname >/dev/null 2>&1 && command -v cd >/dev/null 2>&1 \
     && command -v pwd >/dev/null 2>&1; then
    _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || _script_dir=""
    if [ -n "$_script_dir" ]; then
      _wiz_root=$(CDPATH= cd -- "$_script_dir/../.." 2>/dev/null && pwd -P) || _wiz_root=""
      if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
        WIZARDRY_DIR=$_wiz_root
        export WIZARDRY_DIR
      fi
    fi
  fi
  
  # Fallback to standard location
  if [ -z "${WIZARDRY_DIR-}" ] && [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
    WIZARDRY_DIR="${HOME}/.wizardry"
    export WIZARDRY_DIR
  fi
fi

# Source env-clear after WIZARDRY_DIR is established
if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/env-clear" ]; then
  . "${WIZARDRY_DIR}/spells/.imps/sys/env-clear"
fi

# Add imps to PATH for spell demonstrations
if [ -n "${WIZARDRY_DIR-}" ]; then
  # Build imp path
  _imp_path="${WIZARDRY_DIR}/spells/.imps/sys"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/cond"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/out"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/fs"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/str"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/paths"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/text"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/input"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/lex"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/menu"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/pkg"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/test"
  _imp_path="$_imp_path:${WIZARDRY_DIR}/spells/.imps/lang"
  PATH="$_imp_path:$PATH"
  export PATH
fi

# Source spell-levels from sys imp
if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels" ]; then
  . "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels"
else
  printf 'demo-magic: spell-levels imp not found\n' >&2
  return 1
fi

# Load validate_spells function if not already available
if ! command -v validate_spells >/dev/null 2>&1; then
  if [ -f "${WIZARDRY_DIR}/spells/system/validate-spells" ]; then
    # Prevent castable from executing when sourced
    _WIZARDRY_SOURCING_SPELL=1
    # shellcheck source=/dev/null
    . "${WIZARDRY_DIR}/spells/system/validate-spells"
    unset _WIZARDRY_SOURCING_SPELL
  else
    printf 'demo-magic: validate-spells not found\n' >&2
    return 1
  fi
  
  if ! command -v validate_spells >/dev/null 2>&1; then
    printf 'demo-magic: failed to load validate-spells\n' >&2
    return 1
  fi
fi

# Parse level argument
demo_level=1
if [ "$#" -gt 0 ]; then
  case "$1" in
    [0-9]|[0-9][0-9])
      demo_level=$1
      shift
      ;;
    *)
      printf 'demo-magic: invalid level: %s\n' "$1" >&2
      demo_magic_usage >&2
      return 2
      ;;
  esac
fi

# Sandbox with bwrap if not in GitHub Actions and not already sandboxed
if [ "${WIZARDRY_DEMO_IN_BWRAP-0}" -ne 1 ] && [ "${WIZARDRY_DEMO_NO_BWRAP-0}" -ne 1 ]; then
  # Skip bwrap in GitHub Actions (already isolated)
  if [ -z "${GITHUB_ACTIONS-}" ] || [ "${GITHUB_ACTIONS}" != "true" ]; then
    if command -v bwrap >/dev/null 2>&1; then
      # Re-exec with bwrap sandbox
      exec bwrap --unshare-user --ro-bind / / --dev-bind /dev /dev --bind /proc /proc \
        --bind /tmp /tmp --setenv PATH "$PATH" --setenv WIZARDRY_DEMO_IN_BWRAP 1 -- \
        "$0" "$@"
    else
      # bwrap not available - offer to install
      printf 'demo-magic: bubblewrap (bwrap) not found\n' >&2
      printf 'demo-magic: Running demos in an isolated sandbox is recommended for safety.\n' >&2
      
      # Check if we can install it
      if command -v pkg-install >/dev/null 2>&1; then
        if command -v ask_yn >/dev/null 2>&1; then
          if ask_yn "Install bubblewrap now?" yes; then
            printf 'Installing bubblewrap...\n' >&2
            if pkg-install bubblewrap 2>/dev/null || pkg-install bwrap 2>/dev/null; then
              printf 'Bubblewrap installed successfully. Re-running demo-magic...\n' >&2
              exec "$0" "$@"
            else
              printf 'demo-magic: failed to install bubblewrap\n' >&2
            fi
          fi
        fi
      fi
      
      # Either install failed or user declined - ask to continue
      if command -v ask_yn >/dev/null 2>&1; then
        if ! ask_yn "Continue without sandbox?" no; then
          printf 'demo-magic: aborting\n' >&2
          return 1
        fi
      else
        printf 'demo-magic: continuing without sandbox (set WIZARDRY_DEMO_NO_BWRAP=1 to skip this check)\n' >&2
      fi
    fi
  fi
fi

printf '\n'
printf '╔═══════════════════════════════════════════════════════════╗\n'
printf '║         WIZARDRY DEMONSTRATION OF MAGICAL ARTS            ║\n'
printf '╚═══════════════════════════════════════════════════════════╝\n'
printf '\n'
printf 'A circle of chalk flares into view.\n'
printf 'The apprentice wizard prepares to demonstrate mastery.\n'

# Run all levels from 0 to target level
current_level=0
while [ "$current_level" -le "$demo_level" ]; do
  demo_level "$current_level"
  current_level=$((current_level + 1))
done

printf '\n'
printf '═══════════════════════════════════════════════════════════\n'
printf '\n'
printf 'The demonstration concludes.\n'
printf 'The circle closes. Wizardry stands ready.\n'
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
