#!/bin/sh

# Demonstrate wizardry spells at specified levels with narrated output.
# Each demo level corresponds to a banish level and demonstrates the spells
# that are validated and tested by that banish level.

demo_magic_usage() {
  cat <<'USAGE'
Usage: demo-magic [LEVEL]

Demonstrate wizardry features by running checks on spells and narrating results.
Each level demonstrates spells validated by the corresponding banish level.

Arguments:
  LEVEL         Demonstration level (0-29, default: 1)
                Level 0: POSIX & platform foundation
                Level 1: Wizardry installation
                Level 2: Glossary system
                Level 3: Menu system
                Level 4+: Higher-level spells (see SPELL_LEVELS.md)
USAGE
}

# Demo a single level using spell-levels data
demo_level() {
  level=$1
  
  # Get level name and spell list
  level_name=$(banish_level_name "$level")
  spell_list=$(get_level_spells "$level")
  imp_list=$(get_level_imps "$level")
  
  printf 'Level %d: %s\n' "$level" "$level_name"
  
  # Special case for level 0 - infrastructure checks
  if [ "$level" -eq 0 ]; then
    printf 'Checking POSIX environment and wizardry structure...\n'
    [ -f "${WIZARDRY_DIR}/spells/.imps/sys/invoke-wizardry" ] && \
      printf 'invoke-wizardry: ready\n' || printf 'Warning: invoke-wizardry check failed\n' >&2
    [ -d "${WIZARDRY_DIR}/spells" ] && \
      printf 'spells directory: ready\n' || printf 'Warning: spells directory check failed\n' >&2
    [ -d "${WIZARDRY_DIR}/spells/.imps" ] && \
      printf 'imps directory: ready\n' || printf 'Warning: imps directory check failed\n' >&2
  fi
  
  # Check spells for this level (note: spell_list is intentionally unquoted for word splitting)
  if [ -n "$spell_list" ]; then
    # shellcheck disable=SC2086
    validate_spells --quiet $spell_list 2>&1 | sed 's/✓ Found spell://; s/^  *//; s/$/:ready/'
    
    # Report missing spells if any
    # shellcheck disable=SC2086
    if ! validate_spells $spell_list >/dev/null 2>&1; then
      # shellcheck disable=SC2086
      missing=$(validate_spells --missing-only $spell_list)
      printf 'Warning: missing spells: %s\n' "$missing" >&2
    fi
  fi
  
  # Check imps for this level (note: imp_list is intentionally unquoted for word splitting)
  if [ -n "$imp_list" ]; then
    # shellcheck disable=SC2086
    validate_spells --quiet --imps $imp_list 2>&1 | sed 's/✓ Found imp://; s/^  *//; s/$/  (imp):ready/'
    
    # Report missing imps if any
    # shellcheck disable=SC2086
    if ! validate_spells --imps $imp_list >/dev/null 2>&1; then
      # shellcheck disable=SC2086
      missing=$(validate_spells --imps --missing-only $imp_list)
      printf 'Warning: missing imps: %s\n' "$missing" >&2
    fi
  fi
  
  # Special checks for level 29 (arcana)
  if [ "$level" -eq 29 ]; then
    [ -d "${WIZARDRY_DIR}/spells/.arcana" ] && \
      printf 'arcana directory: ready\n' || printf 'Warning: arcana directory check failed\n' >&2
  fi
}

demo_magic() {
case "${1-}" in
--help|--usage|-h)
  demo_magic_usage
  return 0
  ;;
esac

set -eu

# Detect WIZARDRY_DIR if not set (for direct execution)
if [ -z "${WIZARDRY_DIR-}" ]; then
  # Try to detect from script location
  if command -v dirname >/dev/null 2>&1 && command -v cd >/dev/null 2>&1 \
     && command -v pwd >/dev/null 2>&1; then
    _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || _script_dir=""
    if [ -n "$_script_dir" ]; then
      _wiz_root=$(CDPATH= cd -- "$_script_dir/../.." 2>/dev/null && pwd -P) || _wiz_root=""
      if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
        WIZARDRY_DIR=$_wiz_root
        export WIZARDRY_DIR
      fi
    fi
  fi
  
  # Fallback to standard location
  if [ -z "${WIZARDRY_DIR-}" ] && [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
    WIZARDRY_DIR="${HOME}/.wizardry"
    export WIZARDRY_DIR
  fi
fi

# Source spell-levels from sys imp
if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels" ]; then
  . "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels"
else
  printf 'demo-magic: spell-levels imp not found\n' >&2
  return 1
fi

# Load validate_spells function if not already available
if ! command -v validate_spells >/dev/null 2>&1; then
  if [ -f "${WIZARDRY_DIR}/spells/system/validate-spells" ]; then
    # Prevent castable from executing when sourced
    _WIZARDRY_SOURCING_SPELL=1
    # shellcheck source=/dev/null
    . "${WIZARDRY_DIR}/spells/system/validate-spells"
    unset _WIZARDRY_SOURCING_SPELL
  else
    printf 'demo-magic: validate-spells not found\n' >&2
    return 1
  fi
  
  if ! command -v validate_spells >/dev/null 2>&1; then
    printf 'demo-magic: failed to load validate-spells\n' >&2
    return 1
  fi
fi

# Parse level argument
demo_level=1
if [ "$#" -gt 0 ]; then
  case "$1" in
    [0-9]|[0-9][0-9])
      demo_level=$1
      shift
      ;;
    *)
      printf 'demo-magic: invalid level: %s\n' "$1" >&2
      demo_magic_usage >&2
      return 2
      ;;
  esac
fi

# Sandbox with bwrap if not in GitHub Actions and not already sandboxed
if [ "${WIZARDRY_DEMO_IN_BWRAP-0}" -ne 1 ] && [ "${WIZARDRY_DEMO_NO_BWRAP-0}" -ne 1 ]; then
  # Skip bwrap in GitHub Actions (already isolated)
  if [ -z "${GITHUB_ACTIONS-}" ] || [ "${GITHUB_ACTIONS}" != "true" ]; then
    if command -v bwrap >/dev/null 2>&1; then
      # Re-exec with bwrap sandbox
      exec bwrap --unshare-user --ro-bind / / --dev-bind /dev /dev --bind /proc /proc \
        --bind /tmp /tmp --setenv PATH "$PATH" --setenv WIZARDRY_DEMO_IN_BWRAP 1 -- \
        "$0" "$@"
    else
      # bwrap not available - offer to install
      printf 'demo-magic: bubblewrap (bwrap) not found\n' >&2
      printf 'demo-magic: Running demos in an isolated sandbox is recommended for safety.\n' >&2
      
      # Check if we can install it
      if command -v pkg-install >/dev/null 2>&1; then
        if command -v ask_yn >/dev/null 2>&1; then
          if ask_yn "Install bubblewrap now?" yes; then
            printf 'Installing bubblewrap...\n' >&2
            if pkg-install bubblewrap 2>/dev/null || pkg-install bwrap 2>/dev/null; then
              printf 'Bubblewrap installed successfully. Re-running demo-magic...\n' >&2
              exec "$0" "$@"
            else
              printf 'demo-magic: failed to install bubblewrap\n' >&2
            fi
          fi
        fi
      fi
      
      # Either install failed or user declined - ask to continue
      if command -v ask_yn >/dev/null 2>&1; then
        if ! ask_yn "Continue without sandbox?" no; then
          printf 'demo-magic: aborting\n' >&2
          return 1
        fi
      else
        printf 'demo-magic: continuing without sandbox (set WIZARDRY_DEMO_NO_BWRAP=1 to skip this check)\n' >&2
      fi
    fi
  fi
fi

printf 'A circle of chalk flares into view.\n'
printf 'The wizardry demonstration begins.\n'
printf '\n'

# Run all levels from 0 to target level
current_level=0
while [ "$current_level" -le "$demo_level" ]; do
  demo_level "$current_level"
  
  if [ "$current_level" -lt "$demo_level" ]; then
    printf '\n'
  fi
  
  current_level=$((current_level + 1))
done

printf '\n'
printf 'The circle closes. Wizardry stands ready.\n'
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
