#!/bin/sh

# This spell refreshes the wizardry repository alongside other managed sources.
# Pass --verbose to narrate each update step.

show_usage() {
  cat <<'EOF'
Usage: update-all [-v|--verbose]

Options:
  -v, --verbose   Print all command output while updating
  -h, --help      Show this help message and exit
EOF
}

VERBOSE=0

while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    --help|--usage|-h)
      show_usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      show_usage >&2
      exit 1
      ;;
    *)
      break
      ;;
  esac
done

set -eu

if [ "$#" -ne 0 ]; then
  printf 'Unexpected argument: %s\n' "$1" >&2
  show_usage >&2
  exit 1
fi

script_dir=$(cd "$(dirname "$0")" && pwd)
repo_dir=$(cd "$script_dir/../.." && pwd)

# Add imps to PATH so we can use temp-file and cleanup-file directly
if [ -d "$repo_dir/spells/.imps" ]; then
  PATH="$repo_dir/spells/.imps:$PATH"
  for impdir in "$repo_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

if has colors; then
  # shellcheck source=/dev/null
  . "$(command -v colors)"
else
  GREY=''
  RESET=''
fi

# Detect distro first
if is set "${WIZARDRY_UPDATE_ALL_DISTRO:-}"; then
  distro=$WIZARDRY_UPDATE_ALL_DISTRO
elif has detect-distro && distro=$(detect-distro 2>/dev/null); then
  :
else
  printf '%s\n' 'Unable to detect operating system.' >&2
  exit 1
fi

printf 'Detected platform: %s\n' "$distro"

# Confirm updates with user
case ${WIZARDRY_UPDATE_ALL_ASSUME_YES:-} in
  1|[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee])
    # Assume yes, proceed
    ;;
  *)
    lacks ask-yn && fail 'ask-yn spell is missing; cannot confirm updates.'
    printf '%s\n' 'Proceed with system updates?'
    ASK_CANTRIP_INPUT=stdin
    export ASK_CANTRIP_INPUT
    if ! printf '\n' | ask-yn 'Proceed with system updates?' yes >/dev/null; then
      printf '%s\n' 'cancelled by user' >&2
      exit 1
    fi
    ;;
esac

# Inline run_quiet and run_with_progress functionality
case $distro in
  debian)
    has sudo || fail "Required command not found: sudo"
    has apt-get || fail "Required command not found: apt-get"
    
    printf '%s\n' '• Refreshing apt package lists'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo apt-get update" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo apt-get update
    else
      sudo apt-get update >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Installing upgrades'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y full-upgrade" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y full-upgrade
    else
      progress_tmp=$(temp-file update-all) || exit 1
      trap 'cleanup-file "$progress_tmp"' EXIT HUP INT TERM
      (
        set +e
        sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y full-upgrade 2>&1
        printf '%s\n' "$?" >"$progress_tmp"
        exit 0
      ) | tr '\r' '\n' | {
        last_progress=''
        while IFS= read -r line || nonempty "$line"; do
          case $line in
            Progress:*)
              last_progress=$line
              printf '\r%s' "$line"
              ;;
            *)
              if [ -n "$last_progress" ]; then
                printf '\r%s\n' "$last_progress"
                last_progress=''
              fi
              [ -n "$line" ] && printf '%s\n' "$line"
              ;;
          esac
        done
        [ -n "$last_progress" ] && printf '\r%s\n' "$last_progress"
      }
      status=$(cat "$progress_tmp" 2>/dev/null || printf '1')
      trap - EXIT HUP INT TERM
      rm -f "$progress_tmp"
      [ "${status:-1}" -eq 0 ] || exit "${status:-1}"
    fi
    
    printf '%s\n' '• Removing unused packages'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y autoremove" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y autoremove
    else
      progress_tmp=$(temp-file update-all) || exit 1
      trap 'cleanup-file "$progress_tmp"' EXIT HUP INT TERM
      (
        set +e
        sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y autoremove 2>&1
        printf '%s\n' "$?" >"$progress_tmp"
        exit 0
      ) | tr '\r' '\n' | {
        last_progress=''
        while IFS= read -r line || nonempty "$line"; do
          case $line in
            Progress:*)
              last_progress=$line
              printf '\r%s' "$line"
              ;;
            *)
              if [ -n "$last_progress" ]; then
                printf '\r%s\n' "$last_progress"
                last_progress=''
              fi
              [ -n "$line" ] && printf '%s\n' "$line"
              ;;
          esac
        done
        [ -n "$last_progress" ] && printf '\r%s\n' "$last_progress"
      }
      status=$(cat "$progress_tmp" 2>/dev/null || printf '1')
      trap - EXIT HUP INT TERM
      rm -f "$progress_tmp"
      [ "${status:-1}" -eq 0 ] || exit "${status:-1}"
    fi
    ;;
    
  arch)
    has sudo || fail "Required command not found: sudo"
    has pacman || fail "Required command not found: pacman"
    has pamac || fail "Required command not found: pamac"
    
    printf '%s\n' '• Synchronising pacman packages'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo pacman -Syu --noconfirm" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo pacman -Syu --noconfirm
    else
      sudo pacman -Syu --noconfirm >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Refreshing Pamac-managed packages'
    printf '%b  $ %s%b\n' "${GREY:-}" "pamac update --no-confirm" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      pamac update --no-confirm
    else
      pamac update --no-confirm >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Rebuilding Pamac AUR packages'
    printf '%b  $ %s%b\n' "${GREY:-}" "pamac build --no-confirm" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      pamac build --no-confirm
    else
      pamac build --no-confirm >/dev/null 2>&1
    fi
    ;;
    
  nixos)
    has sudo || fail "Required command not found: sudo"
    has nix-channel || fail "Required command not found: nix-channel"
    has nixos-rebuild || fail "Required command not found: nixos-rebuild"
    has nix-env || fail "Required command not found: nix-env"
    
    printf '%s\n' '• Refreshing system channels'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo nix-channel --update" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo nix-channel --update
    else
      sudo nix-channel --update >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Rebuilding system configuration'
    printf '%b  $ %s%b\n' "${GREY:-}" "sudo nixos-rebuild switch --upgrade" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      sudo nixos-rebuild switch --upgrade
    else
      sudo nixos-rebuild switch --upgrade >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Refreshing user channels'
    printf '%b  $ %s%b\n' "${GREY:-}" "nix-channel --update" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      nix-channel --update
    else
      nix-channel --update >/dev/null 2>&1
    fi
    
    printf '%s\n' '• Upgrading user packages'
    printf '%b  $ %s%b\n' "${GREY:-}" "nix-env -u --always" "${RESET:-}"
    if [ "$VERBOSE" -eq 1 ]; then
      nix-env -u --always
    else
      nix-env -u --always >/dev/null 2>&1
    fi
    ;;
    
  *)
    printf 'Unsupported platform: %s\n' "$distro" >&2
    exit 2
    ;;
esac

printf '%s\n' 'All updates complete.'
