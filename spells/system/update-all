#!/bin/sh

# This spell refreshes the wizardry repository alongside other managed sources.
# Pass --verbose to narrate each update step.

update_all_usage() {
  cat <<'EOF'
Usage: update-all [-v|--verbose]

Options:
  -v, --verbose   Print all command output while updating
  -h, --help      Show this help message and exit
EOF
}



update_all() {
case "${1-}" in
--help|--usage|-h)
  update_all_usage
  return 0
  ;;
esac

require-wizardry || exit 1

set -eu
. env-clear

verbose=0

while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose)
      verbose=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      update_all_usage >&2
      return 2
      ;;
    *)
      break
      ;;
  esac
done

if [ "$#" -ne 0 ]; then
  update_all_usage >&2
  return 2
fi

# Load color palette if available
if has colors; then
  # shellcheck source=/dev/null
  . "$(command -v colors)"
else
  GREY=''
  RESET=''
fi

# Detect distro (inline resolve_distro)
if is set "${WIZARDRY_UPDATE_ALL_DISTRO:-}"; then
  distro=$WIZARDRY_UPDATE_ALL_DISTRO
elif has detect-distro && distro=$(detect-distro 2>/dev/null); then
  :
else
  die 'update-all: unable to detect operating system.'
fi

say "Detected platform: $distro"

# Confirm updates (inline confirm_updates and assume_yes)
case ${WIZARDRY_UPDATE_ALL_ASSUME_YES:-} in
  1|[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee])
    # Assume yes, proceed
    ;;
  *)
    # Ask for confirmation
    has ask-yn || fail 'ask-yn spell is missing; cannot confirm updates.'
    say 'Proceed with system updates?'
    ASK_CANTRIP_INPUT=stdin
    export ASK_CANTRIP_INPUT
    if ! printf '\n' | ask-yn 'Proceed with system updates?' yes >/dev/null; then
      die 1 'update-all: cancelled by user'
    fi
    ;;
esac

# Helper for running commands with progress display
# This is the only additional function beyond update_all_usage()
# Inlines: progress_filter, print_command, format_command
run_with_progress() {
  if [ "$#" -eq 0 ]; then
    return 0
  fi

  # Print command being run (inline format_command and print_command)
  _cmd_display="$1"
  shift
  for _arg in "$@"; do
    _cmd_display="$_cmd_display $_arg"
  done
  printf '%b  $ %s%b\n' "${GREY:-}" "$_cmd_display" "${RESET:-}"

  if [ "$verbose" -eq 1 ]; then
    "$@"
    return $?
  fi

  # Run with progress filtering (inline progress_filter)
  _progress_tmp=$(temp-file update-all) || return 1
  on-exit cleanup-file "$_progress_tmp"
  
  (
    set +e
    "$@" 2>&1
    _cmd_status=$?
    set -e
    printf '%s\n' "$_cmd_status" >"$_progress_tmp"
    return 0
  ) | tr '\r' '\n' | {
    _last_progress=''
    while IFS= read -r _line || nonempty "$_line"; do
      case $_line in
        Progress:*)
          _last_progress=$_line
          printf '\r%s' "$_line"
          ;;
        *)
          if [ -n "$_last_progress" ]; then
            printf '\r%s\n' "$_last_progress"
            _last_progress=''
          fi
          if [ -n "$_line" ]; then
            printf '%s\n' "$_line"
          fi
          ;;
      esac
    done
    if [ -n "$_last_progress" ]; then
      printf '\r%s\n' "$_last_progress"
    fi
  }

  _status=$(cat "$_progress_tmp" 2>/dev/null || printf '1\n')
  clear-traps
  rm -f "$_progress_tmp"

  case ${_status:-} in
    '' ) _status=1 ;;
  esac

  return "$_status"
}

# Main update logic - inline all simple helpers
case $distro in
  debian)
    # Inline require_command - use must has pattern
    must has sudo 'Required command not found: sudo' || return 1
    must has apt-get 'Required command not found: apt-get' || return 1
    
    # Use step imp instead of print_step
    step '• Refreshing apt package lists'
    # Inline run_quiet - direct execution with output control
    if [ "$verbose" -eq 1 ]; then
      sudo apt-get update
    else
      sudo apt-get update >/dev/null 2>&1
    fi
    
    step '• Installing upgrades'
    run_with_progress sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y full-upgrade
    
    step '• Removing unused packages'
    run_with_progress sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y autoremove
    ;;
    
  arch)
    must has sudo 'Required command not found: sudo' || return 1
    must has pacman 'Required command not found: pacman' || return 1
    must has pamac 'Required command not found: pamac' || return 1
    
    step '• Synchronising pacman packages'
    if [ "$verbose" -eq 1 ]; then
      sudo pacman -Syu --noconfirm
    else
      sudo pacman -Syu --noconfirm >/dev/null 2>&1
    fi
    
    step '• Refreshing Pamac-managed packages'
    if [ "$verbose" -eq 1 ]; then
      pamac update --no-confirm
    else
      pamac update --no-confirm >/dev/null 2>&1
    fi
    
    step '• Rebuilding Pamac AUR packages'
    if [ "$verbose" -eq 1 ]; then
      pamac build --no-confirm
    else
      pamac build --no-confirm >/dev/null 2>&1
    fi
    ;;
    
  nixos)
    must has sudo 'Required command not found: sudo' || return 1
    must has nix-channel 'Required command not found: nix-channel' || return 1
    must has nixos-rebuild 'Required command not found: nixos-rebuild' || return 1
    must has nix-env 'Required command not found: nix-env' || return 1
    
    step '• Refreshing system channels'
    if [ "$verbose" -eq 1 ]; then
      sudo nix-channel --update
    else
      sudo nix-channel --update >/dev/null 2>&1
    fi
    
    step '• Rebuilding system configuration'
    if [ "$verbose" -eq 1 ]; then
      sudo nixos-rebuild switch --upgrade
    else
      sudo nixos-rebuild switch --upgrade >/dev/null 2>&1
    fi
    
    step '• Refreshing user channels'
    if [ "$verbose" -eq 1 ]; then
      nix-channel --update
    else
      nix-channel --update >/dev/null 2>&1
    fi
    
    step '• Upgrading user packages'
    if [ "$verbose" -eq 1 ]; then
      nix-env -u --always
    else
      nix-env -u --always >/dev/null 2>&1
    fi
    ;;
    
  *)
    die "update-all: Unsupported platform: $distro"
    ;;
esac

step 'All updates complete.'
}

# Self-execute when run directly (not sourced)
case "$0" in
  */update-all) [ "${_WIZARDRY_SOURCING:-}" != "1" ] && update_all "$@" ;; esac
