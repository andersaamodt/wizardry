#!/bin/sh

# This spell finds the wizardry installation path and updates PATH accordingly.
# It resolves helper scripts alongside itself before delegating to menu.

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        resolved=$(command -v "$SCRIPT_SOURCE" 2>/dev/null || printf '%s' "$SCRIPT_SOURCE")
        SCRIPT_DIR=${resolved%/*}
        SCRIPT_SOURCE=$resolved
        ;;
esac
if [ -z "$SCRIPT_DIR" ] || [ "$SCRIPT_DIR" = "$SCRIPT_SOURCE" ]; then
        SCRIPT_DIR=.
fi
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
DETECT_RC_FILE_DEFAULT="$SCRIPT_DIR/../divination/detect-rc-file"
SCRIBE_SPELL_DEFAULT="$SCRIPT_DIR/../spellcraft/scribe-spell"

detect_override=0
if [ -n "${DETECT_RC_FILE-}" ]; then
        detect_override=1
else
        DETECT_RC_FILE=$DETECT_RC_FILE_DEFAULT
fi

scribe_override=0
if [ -n "${SCRIBE_SPELL-}" ]; then
        scribe_override=1
else
        SCRIBE_SPELL=$SCRIBE_SPELL_DEFAULT
fi

if [ ! -x "$DETECT_RC_FILE" ]; then
        if [ "$detect_override" -eq 1 ]; then
                printf '%s\n' "path-wizard: required helper '$DETECT_RC_FILE' is missing or not executable." >&2
                exit 1
        fi

        if command -v detect-rc-file >/dev/null 2>&1; then
                DETECT_RC_FILE=$(command -v detect-rc-file)
        else
                printf '%s\n' "path-wizard: required helper '$DETECT_RC_FILE' is missing or not executable." >&2
                exit 1
        fi
fi

if [ ! -x "$SCRIBE_SPELL" ]; then
        if [ "$scribe_override" -eq 1 ]; then
                printf '%s\n' "path-wizard: required helper '$SCRIBE_SPELL' is missing or not executable." >&2
                exit 1
        fi

        if command -v scribe-spell >/dev/null 2>&1; then
                SCRIBE_SPELL=$(command -v scribe-spell)
        else
                printf '%s\n' "path-wizard: required helper '$SCRIBE_SPELL' is missing or not executable." >&2
                exit 1
        fi
fi

usage() {
        cat <<'USAGE' >&2
Usage: path-wizard [-r|--recursive] [--dry-run] [--rc-file FILE] [--format FORMAT] [--platform PLATFORM] add [DIRECTORY]
       path-wizard [-r|--recursive] [--rc-file FILE] [--format FORMAT] [--platform PLATFORM] remove DIRECTORY
       path-wizard [-r|--recursive] [--rc-file FILE] [--format FORMAT] [--platform PLATFORM] status DIRECTORY

Options:
  --dry-run    List paths that would be added without modifying any files

Formats: auto (default), shell, nix
Platforms: debian, arch, fedora, mac, nixos, unknown
USAGE
}

# shellcheck disable=SC2039 # POSIX compliant but we rely on some utilities like awk.

# Track optional overrides for the file we edit, the output format we emit,
# and the platform we are targeting. The defaults match the original behaviour
# so existing callers keep working even if they do not pass new flags.
rc_file_override=""
format="auto"
platform="${PATH_WIZARD_PLATFORM-}"
recursive=0
batch_add_file=""
dry_run=0

while [ "$#" -gt 0 ]; do
        case $1 in
        -r|--recursive)
                recursive=1
                shift
                ;;
        --dry-run)
                dry_run=1
                shift
                ;;
        --recursive=*)
                recursive=1
                shift
                ;;
        --rc-file)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "path-wizard: --rc-file expects a file path" >&2
                        usage
                        exit 1
                fi
                rc_file_override=$2
                shift 2
                ;;
        --rc-file=*)
                rc_file_override=${1#*=}
                shift
                ;;
        --format)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "path-wizard: --format expects a value" >&2
                        usage
                        exit 1
                fi
                format=$2
                shift 2
                ;;
        --format=*)
                format=${1#*=}
                shift
                ;;
        --platform)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "path-wizard: --platform expects a value" >&2
                        usage
                        exit 1
                fi
                platform=$2
                shift 2
                ;;
        --platform=*)
                platform=${1#*=}
                shift
                ;;
        --batch-add-from-file)
                # Internal flag: add all directories listed in file in single operation
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "path-wizard: --batch-add-from-file expects a file path" >&2
                        exit 1
                fi
                batch_add_file=$2
                shift 2
                ;;
        --help|-h)
                usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "path-wizard: unknown option '$1'" >&2
                usage
                exit 1
                ;;
        *)
                break
                ;;
        esac
done

# Handle batch add mode specially - it doesn't need action/directory arguments
if [ -n "$batch_add_file" ]; then
        action="add"
        directory=""
        batch_mode=1
else
        batch_mode=0
        
        # We require at least one argument to decide whether we are adding, removing,
        # or checking the PATH entry. Showing usage keeps the interface self-documenting
        # for new Wizards-in-training.
        if [ "$#" -eq 0 ]; then
                usage
                exit 1
        fi
        
        action=$1
        shift
        
        case $action in
        add|remove|status) : ;;
        *)
                printf '%s\n' "Error: The first argument must be 'add', 'remove', or 'status'." >&2
                exit 1
                ;;
        esac
        
        if [ "$action" = "status" ] && [ "$#" -eq 0 ]; then
                printf '%s\n' "Error: The 'status' action expects a directory argument." >&2
                exit 1
        fi
fi

# Resolve the provided directory so that PATH entries are always absolute.
# Normalising here means the rc files never contain brittle relative paths.
normalize_directory() {
        directory=$1
        case $directory in
        "~")
                directory=$HOME
                ;;
        "~"/*)
                directory=$HOME/${directory#\~/}
                ;;
        esac

        if [ "$directory" = "" ]; then
                printf '%s\n' "Error: The directory does not exist." >&2
                exit 1
        fi

        if [ ! -d "$directory" ]; then
                printf '%s\n' "Error: The directory does not exist." >&2
                exit 1
        fi

        case $directory in
        /*) : ;;
        .)
                directory=$(pwd -P)
                ;;
        ..|../*|./*)
                directory=$(cd "$directory" && pwd -P)
                ;;
        *)
                directory=$(cd "$directory" && pwd -P)
                ;;
        esac

        printf '%s' "$directory"
}

# Skip directory normalization for batch mode
if [ "$batch_mode" -eq 0 ]; then
        if [ "$action" = "add" ]; then
                if [ "$#" -eq 0 ]; then
                        directory=$(normalize_directory "$(pwd -P)")
                else
                        directory=$(normalize_directory "$1")
                fi
        elif [ "$action" = "remove" ] || [ "$action" = "status" ]; then
                if [ "$#" -eq 0 ]; then
                        printf '%s\n' "Error: The '$action' action expects a directory argument." >&2
                        exit 1
                fi
                directory=$(normalize_directory "$1")
        fi
        
        if [ "$action" != "status" ] && [ "$#" -gt 1 ]; then
                shift
        else
                if [ "$#" -gt 0 ]; then
                        shift
                fi
        fi
fi

# Generate a timestamp for backup file naming. Tries date formats first,
# falls back to epoch seconds, then process ID prefixed with 'pid' for clarity.
generate_backup_timestamp() {
        date +%Y%m%d%H%M%S 2>/dev/null || date +%s 2>/dev/null || printf 'pid%s' "$$"
}

# Validate batch add file if specified
if [ "$batch_mode" -eq 1 ] && [ ! -f "$batch_add_file" ]; then
        printf '%s\n' "Error: Batch file '$batch_add_file' not found." >&2
        exit 1
fi

# When requested, operate recursively by invoking path-wizard on each
# discovered directory.  This leverages the existing single-directory
# implementation so we keep behaviour consistent across formats.
if [ "$recursive" -eq 1 ]; then
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/path-wizard.XXXXXX") || {
                printf '%s\n' "Error: Unable to enumerate directories under '$directory'." >&2
                exit 1
        }
        if ! find "$directory" -type d -print | sort >"$tmp_file"; then
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to enumerate directories under '$directory'." >&2
                exit 1
        fi

        cleanup_tmp() {
                rm -f "$tmp_file"
        }

        trap 'cleanup_tmp' EXIT HUP INT TERM

        # In dry-run mode, just print paths that would be added
        if [ "$dry_run" -eq 1 ] && [ "$action" = "add" ]; then
                cat "$tmp_file"
                trap - EXIT HUP INT TERM
                cleanup_tmp
                exit 0
        fi

        # Detect format early for optimized recursive handling
        recursive_format=$format
        if [ "$recursive_format" = "auto" ]; then
                if [ -n "$rc_file_override" ]; then
                        case $rc_file_override in
                        *.nix) recursive_format=nix ;;
                        *) recursive_format=shell ;;
                        esac
                else
                        recursive_detect=$("$DETECT_RC_FILE" ${platform:+--platform "$platform"} 2>/dev/null) || true
                        recursive_format=$(printf '%s\n' "$recursive_detect" | while IFS='=' read -r k v; do
                                [ "$k" = "format" ] && printf '%s' "$v"
                        done)
                        [ -z "$recursive_format" ] && recursive_format=shell
                fi
        fi

        # For nix format, collect all directories and add them in a single operation.
        # This is more efficient than invoking nix_add per directory since nix_add
        # already rewrites the entire block each time.
        if [ "$recursive_format" = "nix" ] && [ "$action" = "add" ]; then
                # Collect all directories into a list
                all_dirs=""
                while IFS= read -r subdir; do
                        if [ -z "$all_dirs" ]; then
                                all_dirs="$subdir"
                        else
                                all_dirs="$all_dirs
$subdir"
                        fi
                done <"$tmp_file"
                
                # Run single invocation with all directories passed as arguments
                # (We pass them through a temp file since command line length limits)
                run_nix_batch_add() {
                        set -- "$0"
                        if [ -n "$rc_file_override" ]; then
                                set -- "$@" --rc-file "$rc_file_override"
                        fi
                        set -- "$@" --format nix
                        if [ -n "$platform" ]; then
                                set -- "$@" --platform "$platform"
                        fi
                        set -- "$@" --batch-add-from-file "$tmp_file"
                        "$@"
                }
                
                if run_nix_batch_add; then
                        trap - EXIT HUP INT TERM
                        cleanup_tmp
                        exit 0
                else
                        status=$?
                        trap - EXIT HUP INT TERM
                        cleanup_tmp
                        exit $status
                fi
        fi

        run_recursive_action() {
                subdir=$1
                set -- "$0"
                if [ -n "$rc_file_override" ]; then
                        set -- "$@" --rc-file "$rc_file_override"
                fi
                if [ -n "$format" ]; then
                        set -- "$@" --format "$format"
                fi
                if [ -n "$platform" ]; then
                        set -- "$@" --platform "$platform"
                fi
                set -- "$@" "$action" "$subdir"
                "$@"
        }

        result=0
        while IFS= read -r subdir; do
                if run_recursive_action "$subdir"; then
                        :
                else
                        status=$?
                        if [ "$result" -eq 0 ]; then
                                result=$status
                        fi
                        if [ "$action" = "status" ]; then
                                break
                        fi
                fi
        done <"$tmp_file"

        trap - EXIT HUP INT TERM
        cleanup_tmp
        exit $result
fi

# Use detect-rc-file to derive sane defaults when callers do not provide
# explicit overrides. This keeps the CLI consistent with the installer and any
# other spell that edits shell start-up files.
detected_platform=""
detected_rc_file=""
detected_format=""
needs_detection=0
if [ -z "$platform" ] || [ -z "$rc_file_override" ] || [ "$format" = "auto" ]; then
        needs_detection=1
fi

if [ "$needs_detection" -eq 1 ]; then
        if [ -n "$platform" ]; then
                detect_output=$("$DETECT_RC_FILE" --platform "$platform")
        else
                detect_output=$("$DETECT_RC_FILE")
        fi
        while IFS='=' read -r key value; do
                case $key in
                platform)
                        detected_platform=$value
                        ;;
                rc_file)
                        detected_rc_file=$value
                        ;;
                format)
                        detected_format=$value
                        ;;
                esac
        done <<EOF
$detect_output
EOF
fi

if [ -z "$platform" ] && [ -n "$detected_platform" ]; then
        platform=$detected_platform
fi

rc_file=$rc_file_override
if [ -z "$rc_file" ]; then
        rc_file=$detected_rc_file
fi

if [ -z "$rc_file" ]; then
        printf '%s\n' "path-wizard: unable to determine a startup file." >&2
        exit 1
fi

if [ "$format" = "auto" ]; then
        if [ -n "$detected_format" ] && [ -z "$rc_file_override" ]; then
                        format=$detected_format
        else
                case $rc_file in
                *.nix)
                        format=nix
                        ;;
                *)
                        format=shell
                        ;;
                esac
        fi
fi

if [ -z "$platform" ]; then
        platform=unknown
fi

case $format in
shell|nix) : ;;
*)
        printf '%s\n' "Error: Unsupported format '$format'." >&2
        exit 1
        ;;
esac

# Determine if the rc file requires elevated privileges to modify.
# System-level files like /etc/nixos/configuration.nix need sudo.
needs_sudo=0
case $rc_file in
/etc/*)
        if [ ! -w "$rc_file" ] 2>/dev/null && [ ! -w "$(dirname "$rc_file")" ] 2>/dev/null; then
                needs_sudo=1
        fi
        ;;
esac

# Helper to run a command, optionally with sudo for system-level files.
# Usage: run_maybe_sudo command [args...]
run_maybe_sudo() {
        if [ "$needs_sudo" -eq 1 ]; then
                if command -v sudo >/dev/null 2>&1; then
                        sudo "$@"
                elif command -v doas >/dev/null 2>&1; then
                        doas "$@"
                else
                        printf '%s\n' "path-wizard: sudo or doas required to modify '$rc_file'." >&2
                        exit 1
                fi
        else
                "$@"
        fi
}

# Track whether a backup has been created. In recursive mode, the parent
# handles backup before spawning children that pass --nix-setup-done.
nix_backup_created=0

# These literal export lines represent how we manage PATH entries inside shell
# rc files. The quoted variant is the format we now write, while the legacy
# string tracks the buggy form that escaped "$PATH" and therefore replaced the
# variable with a literal. Retaining both lets us tidy older installs while
# keeping removals idempotent. Variables are only populated when a directory
# argument is provided (add/remove/status actions require a directory).
managed_export_line=""
legacy_export_line=""
legacy_quoted_export_line=""
if [ -n "${directory-}" ]; then
        managed_export_line=$(printf 'export PATH="%s:$PATH"' "$directory")
        legacy_export_line=$(printf 'export PATH=%s:\\$PATH' "$directory")
        legacy_quoted_export_line=$(printf 'export PATH="%s:\\$PATH"' "$directory")
fi

# Track whether we refreshed a legacy export line so the caller can surface an
# appropriate message to the user.
legacy_export_refreshed=0

spell_identifier_for_directory() {
        dir=$1
        checksum=$(printf '%s' "$dir" | cksum | awk '{print $1}')
        safe=$(printf '%s' "$dir" | tr -c 'A-Za-z0-9._-' '_')
        printf 'path-%s-%s' "$safe" "$checksum"
}

# Create the parent directory for the rc file when it does not already exist.
# This lets us initialise fresh environments without manual scaffolding.
ensure_rc_directory() {
        rc_dir=${rc_file%/*}
        if [ "$rc_dir" != "$rc_file" ] && [ ! -d "$rc_dir" ]; then
                run_maybe_sudo mkdir -p "$rc_dir"
        fi
}

# configuration.nix deserves extra care: before we rewrite anything, stash a
# timestamped backup so users can inspect or restore the previous version.
# In recursive mode, the parent handles this before spawning children.
backup_rc_file_once() {
        if [ "$format" != "nix" ]; then
                return 0
        fi
        if [ "$nix_backup_created" -eq 1 ]; then
                return 0
        fi
        if [ ! -f "$rc_file" ]; then
                return 0
        fi

        timestamp=$(generate_backup_timestamp)
        backup="$rc_file.wizardry.$timestamp"

        if ! run_maybe_sudo cp "$rc_file" "$backup"; then
                printf '%s\n' "path-wizard: unable to back up '$rc_file'." >&2
                exit 1
        fi

        printf '%s\n' "path-wizard: backed up '$rc_file' to '$backup'." >&2
        nix_backup_created=1
        return 0
}

# Replace the historical buggy export line with the corrected form.  When no
# legacy entry exists we leave the rc file untouched. The caller can consult
# the legacy_export_refreshed flag to decide which message to print.
refresh_legacy_shell_export() {
        legacy_export_refreshed=0
        if [ ! -f "$rc_file" ]; then
                return 0
        fi

        tmp_file="$rc_file.wizardry.$$"
        : >"$tmp_file"
        changed=0

        while IFS= read -r line; do
                case $line in
                "$legacy_export_line"|"$legacy_quoted_export_line")
                        changed=1
                        printf '%s\n' "$managed_export_line" >>"$tmp_file"
                        ;;
                *)
                        printf '%s\n' "$line" >>"$tmp_file"
                        ;;
                esac
        done <"$rc_file"

        if [ "$changed" -eq 0 ]; then
                rm -f "$tmp_file"
                return 0
        fi

        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to refresh '$rc_file'." >&2
                exit 1
        fi

        legacy_export_refreshed=1
        return 0
}

# Append the export line to POSIX shell rc files when it is not already
# present. Each branch prints guidance so users know what changed.
shell_add() {
        ensure_rc_directory
        if [ ! -f "$rc_file" ]; then
                : >"$rc_file"
        fi
        refresh_legacy_shell_export
        if [ "$legacy_export_refreshed" -eq 1 ]; then
                printf '%s\n' "Refreshed the existing wizardry PATH entry in '$rc_file' so '$directory' stays reachable; open a new shell or source the file to load it."
                return 0
        fi
        if shell_status; then
                printf '%s\n' "'$directory' is already exported in '$rc_file'; nothing changed."
                return 0
        fi
        spell_name=$(spell_identifier_for_directory "$directory")
        if ! printf '%s\n' "$managed_export_line" | "$SCRIBE_SPELL" --rc-file "$rc_file" --spell "$spell_name" add; then
                printf '%s\n' "path-wizard: unable to record the PATH entry." >&2
                exit 1
        fi
        printf '%s\n' "Added '$directory' to PATH via '$rc_file'. Open a new shell or run '. %s' to pick up the change." "$rc_file"
}

# Remove a previously added export line from shell rc files.
shell_remove() {
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "Error: The startup file '$rc_file' does not exist." >&2
                exit 1
        fi
        spell_name=$(spell_identifier_for_directory "$directory")
        if "$SCRIBE_SPELL" --rc-file "$rc_file" --spell "$spell_name" status >/dev/null 2>&1; then
                "$SCRIBE_SPELL" --rc-file "$rc_file" --spell "$spell_name" remove
                printf '%s\n' "Removed '$directory' from PATH entries recorded in '$rc_file'. Open a new shell or source the file to drop it."
                return 0
        fi
        has_managed=0
        if grep -Fqx "$managed_export_line" "$rc_file" 2>/dev/null; then
                has_managed=1
        fi
        has_legacy=0
        if grep -Fqx "$legacy_export_line" "$rc_file" 2>/dev/null; then
                has_legacy=1
        fi
        if grep -Fqx "$legacy_quoted_export_line" "$rc_file" 2>/dev/null; then
                has_legacy=1
        fi
        if [ "$has_managed" -eq 0 ] && [ "$has_legacy" -eq 0 ]; then
                printf '%s\n' "Error: The directory is not in your PATH." >&2
                exit 1
        fi
        tmp_file="$rc_file.wizardry.$$"
        : >"$tmp_file"
        while IFS= read -r line; do
                case $line in
                "$managed_export_line"|"$legacy_export_line"|"$legacy_quoted_export_line")
                        ;;
                *)
                        printf '%s\n' "$line" >>"$tmp_file"
                        ;;
                esac
        done <"$rc_file"
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to replace '$rc_file'." >&2
                exit 1
        fi
        printf '%s\n' "Removed '$directory' from PATH entries recorded in '$rc_file'. Open a new shell or source the file to drop it."
}

# Identify whether the requested directory already appears in an export line
# within the provided rc file.  This mirrors how the installer reasons about
# idempotence so that every caller (installer, manual invocation, tests) shares
# exactly the same definition of “already present”.
shell_path_contains_directory() {
        file=$1
        target_dir=$2

        if [ ! -f "$file" ]; then
                return 1
        fi

        home_hint=""
        tilde_hint=""

        if [ -n "${HOME-}" ]; then
                case $target_dir in
                "$HOME"/*)
                        rel_path=${target_dir#"$HOME"/}
                        home_hint=$(printf '%s' "\$HOME/$rel_path")
                        tilde_hint=$(printf '%s' "~/$rel_path")
                        ;;
                esac
        fi

        awk -v dir="$target_dir" -v home_hint="$home_hint" -v tilde_hint="$tilde_hint" '
        /^[[:space:]]*#/ { next }
        {
                if ($0 ~ /(^|[[:space:]])PATH=/) {
                        if (index($0, dir)) {
                                found = 1
                                exit
                        }
                        if (home_hint != "" && index($0, home_hint)) {
                                found = 1
                                exit
                        }
                        if (tilde_hint != "" && index($0, tilde_hint)) {
                                found = 1
                                exit
                        }
                }
        }
        END {
                if (found) {
                        exit 0
                }
                exit 1
        }
        ' "$file"
}

# status returns success when the directory is already exported, allowing
# callers to avoid duplicate additions. It simply defers to the shared helper
# above so that every shell PATH check behaves the same way.
shell_status() {
        shell_path_contains_directory "$rc_file" "$directory"
}

# Check if configuration.nix already has an environment.sessionVariables.PATH
# definition outside of the wizardry managed block. This would cause a conflict
# if we add our own PATH definition.
# Returns 0 if existing PATH definition found, 1 otherwise.
has_existing_nix_path_definition() {
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Look for PATH definitions outside the wizardry block
        # This awk script:
        # 1. Tracks when we're inside the wizardry block (skip those lines)
        # 2. Looks for environment.sessionVariables.PATH outside the block
        awk '
        /# wizardry PATH begin/ {in_block=1; next}
        /# wizardry PATH end/ {in_block=0; next}
        in_block {next}
        /environment\.sessionVariables\.PATH[[:space:]]*=/ {found=1; exit}
        END {exit (found ? 0 : 1)}
        ' "$rc_file"
}

# Check for conflicting PATH definitions before modifying the nix file.
# Returns 0 if we can proceed (either no existing PATH or we can modify it).
# If there's an existing PATH definition we haven't touched, we'll modify it
# instead of adding a new block.
validate_no_nix_path_conflict() {
        # If we already have a wizardry block, we can safely update it
        if grep -Fq '# wizardry PATH begin' "$rc_file" 2>/dev/null; then
                return 0
        fi
        # If there's an existing PATH definition, we'll modify it (handled by nix_add)
        return 0
}

# Extract the original PATH value from a wizardry-modified block.
# Returns the original PATH expression (e.g., "/usr/local/bin:$PATH") or empty.
extract_original_nix_path() {
        if [ ! -f "$rc_file" ]; then
                return
        fi
        awk '
        /# wizardry PATH begin/ {in_block=1; next}
        /# wizardry PATH end/ {in_block=0}
        in_block && /originalPath[[:space:]]*=/ {
                match($0, /=[[:space:]]*/)
                value = substr($0, RSTART + RLENGTH)
                gsub(/;[[:space:]]*$/, "", value)
                print value
                exit
        }
        ' "$rc_file"
}

# Modify an existing environment.sessionVariables.PATH definition to include
# our wizardry paths. This preserves the user's original PATH value.
# Arguments: $@ = list of directories to add
modify_existing_nix_path() {
        backup_rc_file_once
        tmp_file="${TMPDIR:-/tmp}/wizardry-nix.$$"
        
        # Build the wizardry paths list for Nix (each on its own line)
        paths_nix=""
        for dir in "$@"; do
                paths_nix="$paths_nix        \"$dir\"
"
        done
        
        # Use awk to find and modify the existing PATH definition
        # We wrap the original value with our paths prepended
        run_maybe_sudo cat "$rc_file" | awk -v wizardry_paths="$paths_nix" '
        /environment\.sessionVariables\.PATH[[:space:]]*=/ && !modified {
                # Found the PATH definition line
                # Extract the original value (everything after the =)
                match($0, /=[[:space:]]*/)
                prefix = substr($0, 1, RSTART)
                original_value = substr($0, RSTART + RLENGTH)
                # Remove trailing semicolon if present
                gsub(/;[[:space:]]*$/, "", original_value)
                
                # Print the modified block with wizardry paths prepended
                print "  # wizardry PATH begin"
                print "  environment.sessionVariables.PATH ="
                print "    let"
                print "      wizardryPaths = ["
                printf "%s", wizardry_paths
                print "      ];"
                print "      originalPath = " original_value ";"
                print "    in pkgs.lib.concatStringsSep \":\" ("
                print "      wizardryPaths"
                print "      ++ pkgs.lib.optional (originalPath != \"\") originalPath"
                print "    );"
                print "  # wizardry PATH end"
                modified = 1
                next
        }
        {print}
        ' >"$tmp_file"
        
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
                rm -f "$tmp_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
}

# Parse the managed block in configuration.nix and echo each tracked path. The
# caller can then compare or merge entries without re-reading the file.
extract_nix_paths() {
        if [ ! -f "$rc_file" ]; then
                return
        fi
        # Note: We don't use run_maybe_sudo for reading since system config files
        # like /etc/nixos/configuration.nix are typically world-readable. Using
        # sudo for reads would prompt the user unnecessarily before they've seen
        # the installation plan.
        awk '
        /# wizardry PATH begin/ {in_block=1; next}
        /# wizardry PATH end/ {in_block=0}
        in_block && $0 ~ /^[[:space:]]*"[^"]*"[[:space:]]*$/ {
                path=$0
                gsub(/^[[:space:]]*"/, "", path)
                gsub(/"[[:space:]]*$/, "", path)
                print path
        }
        ' "$rc_file"
}

# Delete the managed block from configuration.nix while keeping the rest of
# the file untouched. This simplifies removal and ensures idempotence.
remove_nix_block() {
        backup_rc_file_once
        # Use /tmp for temp files to avoid permission issues with system config directories
        tmp_file="${TMPDIR:-/tmp}/wizardry-nix.$$"
        run_maybe_sudo cat "$rc_file" | awk '
        /# wizardry PATH begin/ {skip=1; next}
        /# wizardry PATH end/ {skip=0; next}
        skip {next}
        {print}
        ' >"$tmp_file"
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
                rm -f "$tmp_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
}

# Insert the generated Nix block just before the closing brace of the
# configuration. Falling back to appending keeps the file valid even when the
# layout is unusual.
insert_block_before_closing_brace() {
        block_file=$1
        # Use /tmp for temp files to avoid permission issues with system config directories
        tmp_file="${TMPDIR:-/tmp}/wizardry-nix.$$"
        run_maybe_sudo cat "$rc_file" | awk -v blockfile="$block_file" '
        BEGIN {
                while ((getline line < blockfile) > 0) {
                        block_lines[++block_count] = line
                }
                close(blockfile)
        }
        {
                lines[NR] = $0
        }
        END {
                if (NR == 0) {
                        for (i = 1; i <= block_count; i++) print block_lines[i]
                        exit
                }
                last = NR
                while (last > 0 && lines[last] ~ /^[[:space:]]*$/) {
                        last--
                }
                if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
                        for (i = 1; i < last; i++) print lines[i]
                        if (last > 1 && lines[last-1] !~ /^[[:space:]]*$/) {
                                print ""
                        }
                        for (i = 1; i <= block_count; i++) print block_lines[i]
                        print lines[last]
                        for (i = last + 1; i <= NR; i++) print lines[i]
                } else {
                        for (i = 1; i <= NR; i++) print lines[i]
                        if (NR > 0 && lines[NR] !~ /^[[:space:]]*$/) {
                                print ""
                        }
                        for (i = 1; i <= block_count; i++) print block_lines[i]
                }
        }
        ' >"$tmp_file"
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
                rm -f "$tmp_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
}

# Create a temporary file containing the declarative block we manage. The
# helper keeps the formatting consistent every time we rewrite the file.
# First argument is the output file, then optional --original-path VALUE,
# then the list of directories.
generate_nix_block_file() {
        block_file=$1
        shift
        
        original_path=""
        if [ "$1" = "--original-path" ]; then
                shift
                original_path=$1
                shift
        fi
        
        {
                printf '  # wizardry PATH begin\n'
                printf '  environment.sessionVariables.PATH =\n'
                printf '    let\n'
                printf '      wizardryPaths = [\n'
                for dir in "$@"; do
                        printf '        "%s"\n' "$dir"
                done
                printf '      ];\n'
                if [ -n "$original_path" ]; then
                        # Preserve the user's original PATH expression
                        printf '      originalPath = %s;\n' "$original_path"
                else
                        # Check for any PATH at runtime
                        printf '      originalPath = if config.environment.sessionVariables ? PATH\n'
                        printf '        then config.environment.sessionVariables.PATH\n'
                        printf '        else "";\n'
                fi
                printf '    in pkgs.lib.concatStringsSep ":" (\n'
                printf '      wizardryPaths\n'
                printf '      ++ pkgs.lib.optional (originalPath != "") originalPath\n'
                printf '    );\n'
                printf '  # wizardry PATH end\n'
        } >"$block_file"
}

# Replace (or create) the managed block in configuration.nix with the provided
# list of directories. If the current block has an originalPath, preserve it.
write_nix_paths() {
        ensure_rc_directory
        backup_rc_file_once
        if [ "$#" -eq 0 ]; then
                if [ -f "$rc_file" ] && grep -Fq '# wizardry PATH begin' "$rc_file" 2>/dev/null; then
                        remove_nix_block
                fi
                return 0
        fi
        
        # Check if there's an originalPath to preserve
        original_path_value="$(extract_original_nix_path)"
        
        # Use /tmp for temp files to avoid permission issues with system config directories
        block_tmp="${TMPDIR:-/tmp}/wizardry-block.$$"
        if [ -n "$original_path_value" ]; then
                generate_nix_block_file "$block_tmp" --original-path "$original_path_value" "$@"
        else
                generate_nix_block_file "$block_tmp" "$@"
        fi
        if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
                new_content_tmp="${TMPDIR:-/tmp}/wizardry-new.$$"
                {
                        printf '{ config, pkgs, ... }:\n'
                        printf '\n'
                        printf '{\n'
                        cat "$block_tmp"
                        printf '}\n'
                } >"$new_content_tmp"
                if [ "$needs_sudo" -eq 1 ]; then
                        run_maybe_sudo cp "$new_content_tmp" "$rc_file"
                        rm -f "$new_content_tmp"
                else
                        mv "$new_content_tmp" "$rc_file"
                fi
                rm -f "$block_tmp"
                return 0
        fi
        if grep -Fq '# wizardry PATH begin' "$rc_file" 2>/dev/null; then
                remove_nix_block
        fi
        insert_block_before_closing_brace "$block_tmp"
        rm -f "$block_tmp"
}

# Add a directory to the managed list inside configuration.nix. Duplicates are
# ignored so repeated runs stay harmless.
nix_add() {
        ensure_rc_directory
        
        # Check for conflicting PATH definitions
        validate_no_nix_path_conflict
        
        # Check if there's an existing PATH definition (outside our block) that we need to modify
        if has_existing_nix_path_definition && ! grep -Fq '# wizardry PATH begin' "$rc_file" 2>/dev/null; then
                # Modify the existing PATH definition to include our path
                modify_existing_nix_path "$directory"
                printf '%s\n' "Modified existing PATH definition in '$rc_file' to include '$directory'. Rebuild your Nix environment to activate the change."
                return 0
        fi
        
        existing_paths="$(extract_nix_paths)"
        old_ifs=$IFS
        IFS='
'
        # shellcheck disable=SC2086
        set -- $existing_paths
        IFS=$old_ifs
        for path_entry in "$@"; do
                if [ "$path_entry" = "$directory" ]; then
                        printf '%s\n' "'$directory' is already listed in '$rc_file'; nothing changed."
                        return 0
                fi
        done
        set -- "$@" "$directory"
        write_nix_paths "$@"
        printf '%s\n' "Recorded '$directory' in '$rc_file'. Rebuild your Nix environment to activate the change."
}

# Remove a directory from configuration.nix. When the last entry is removed we
# delete the managed block entirely to avoid leaving empty scaffolding.
nix_remove() {
        if [ ! -f "$rc_file" ]; then
                        printf '%s\n' "Error: The startup file '$rc_file' does not exist." >&2
                        exit 1
        fi
        existing_paths="$(extract_nix_paths)"
        old_ifs=$IFS
        IFS='
'
        # shellcheck disable=SC2086
        set -- $existing_paths
        IFS=$old_ifs
        found=0
        new_paths=""
        for path_entry in "$@"; do
                if [ "$path_entry" = "$directory" ]; then
                        found=1
                        continue
                fi
                if [ -z "$new_paths" ]; then
                        new_paths=$path_entry
                else
                        new_paths="$new_paths\n$path_entry"
                fi
        done
        if [ "$found" -eq 0 ]; then
                printf '%s\n' "Error: The directory is not in your PATH." >&2
                exit 1
        fi
        if [ -z "$new_paths" ]; then
                write_nix_paths
        else
                old_ifs=$IFS
                IFS='
'
                # shellcheck disable=SC2086
                set -- $new_paths
                IFS=$old_ifs
                write_nix_paths "$@"
        fi
        printf '%s\n' "Removed '$directory' from '$rc_file'. Rebuild your Nix environment to activate the change."
}

# status for configuration.nix mirrors the shell variant, returning success
# only when the directory is already present.
nix_status() {
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        existing_paths="$(extract_nix_paths)"
        old_ifs=$IFS
        IFS='
'
        # shellcheck disable=SC2086
        set -- $existing_paths
        IFS=$old_ifs
        for path_entry in "$@"; do
                if [ "$path_entry" = "$directory" ]; then
                        return 0
                fi
        done
        return 1
}

# Handle batch add mode - process all directories from file at once
if [ "$batch_mode" -eq 1 ]; then
        if [ "$format" != "nix" ]; then
                printf '%s\n' "Error: Batch add mode is only supported for nix format." >&2
                exit 1
        fi
        
        # Check for conflicting PATH definitions
        validate_no_nix_path_conflict
        
        # Read all directories and normalize them
        batch_dirs=""
        while IFS= read -r dir; do
                [ -d "$dir" ] || continue
                case $dir in
                /*) : ;;
                *) dir=$(cd "$dir" 2>/dev/null && pwd -P) || continue ;;
                esac
                if [ -z "$batch_dirs" ]; then
                        batch_dirs="$dir"
                else
                        batch_dirs="$batch_dirs
$dir"
                fi
        done <"$batch_add_file"
        
        # Check if there's an existing PATH definition that we need to modify
        if has_existing_nix_path_definition && ! grep -Fq '# wizardry PATH begin' "$rc_file" 2>/dev/null; then
                # Modify the existing PATH definition to include all our paths
                # shellcheck disable=SC2086
                modify_existing_nix_path $batch_dirs
                printf '%s\n' "Modified existing PATH definition in '$rc_file'. Rebuild your Nix environment to activate the change."
                exit 0
        fi
        
        # Get existing paths and merge with new ones, using sort for dedup
        existing_paths="$(extract_nix_paths)"
        
        # Combine existing and new paths, remove duplicates using sort -u
        {
                printf '%s\n' "$existing_paths"
                printf '%s\n' "$batch_dirs"
        } | grep -v '^$' | sort -u > "${batch_add_file}.merged"
        
        # shellcheck disable=SC2046
        set -- $(cat "${batch_add_file}.merged")
        rm -f "${batch_add_file}.merged"
        write_nix_paths "$@"
        printf '%s\n' "Recorded %d directories in '$rc_file'. Rebuild your Nix environment to activate the change." "$#"
        exit 0
fi

# Handle dry-run mode for single directory (non-recursive case)
if [ "$dry_run" -eq 1 ] && [ "$action" = "add" ]; then
        printf '%s\n' "$directory"
        exit 0
fi

case $format in
shell)
        case $action in
        add)
                shell_add
                ;;
        remove)
                shell_remove
                ;;
        status)
                shell_status
                ;;
        esac
        ;;
nix)
        case $action in
        add)
                nix_add
                ;;
        remove)
                nix_remove
                ;;
        status)
                nix_status
                ;;
        esac
        ;;
esac
