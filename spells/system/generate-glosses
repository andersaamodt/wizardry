#!/bin/sh
# Generate glosses (lightweight wrappers) for all wizardry spells to enable PATH-based interception

generate_glosses_usage() {
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss wrapper scripts for all wizardry spells in $SPELLBOOK_DIR/.glossary/.
Each gloss executes: exec parse "spell-name" "$@"

This enables the glossary-based interception paradigm where PATH is prepended with the
glossary directory, giving the parse spell first shot at all commands. The glossary
makes all spells shine and accessible, handles parsing, and (future) spell-checking.

Options:
  --force    Regenerate all glosses even if they already exist
  --quiet    Suppress progress messages

Examples:
  generate-glosses          # Generate missing glosses
  generate-glosses --force  # Regenerate all glosses
USAGE
}

case "${1-}" in
--help|--usage|-h)
  generate_glosses_usage
  exit 0
  ;;
esac

require-wizardry || return 1

set -eu
. env-clear

generate_glosses() {
  # Parse arguments
  force=0
  quiet=0
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force=1 ;;
      --quiet) quiet=1 ;;
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        return 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  glossary_dir="$spell_home/.glossary"
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  
  # Create glossary directory
  if ! mkdir -p "$glossary_dir" 2>/dev/null; then
    die "generate-glosses: cannot create glossary directory: $glossary_dir"
  fi
  
  # Find all spells (exclude imps and arcana)
  spell_count=0
  created_count=0
  updated_count=0
  skipped_count=0
  
  [ "$quiet" -eq 0 ] && info "Scanning for spells in $wizardry_dir/spells..."
  
  # Use find to get all executable spell files
  find "$wizardry_dir/spells" -type f -executable \
    -not -path "$wizardry_dir/spells/.imps/*" \
    -not -path "$wizardry_dir/spells/.arcana/*" | \
  while IFS= read -r spell_path; do
    # Extract spell name from path (basename)
    spell_name=$(basename "$spell_path")
    
    # Skip if name is empty or starts with dot
    case "$spell_name" in
      ''|.*) continue ;;
    esac
    
    spell_count=$((spell_count + 1))
    gloss_path="$glossary_dir/$spell_name"
    
    # Check if gloss already exists and is current
    if [ -f "$gloss_path" ] && [ "$force" -eq 0 ]; then
      # Verify gloss content is correct
      if grep -q "exec parse \"$spell_name\"" "$gloss_path" 2>/dev/null; then
        skipped_count=$((skipped_count + 1))
        continue
      else
        updated_count=$((updated_count + 1))
      fi
    else
      created_count=$((created_count + 1))
    fi
    
    # Create the gloss
    cat > "$gloss_path" << GLOSS
#!/bin/sh
# Gloss wrapper for wizardry spell: $spell_name
# Generated by generate-glosses on $(date -u +%Y-%m-%dT%H:%M:%SZ)
exec parse "$spell_name" "\$@"
GLOSS
    
    # Make executable
    chmod +x "$gloss_path" 2>/dev/null || {
      warn "generate-glosses: cannot make executable: $gloss_path"
      continue
    }
    
    [ "$quiet" -eq 0 ] && [ $((spell_count % 50)) -eq 0 ] && \
      step "Processed $spell_count spells..."
  done
  
  # Count total actually created (read back from directory)
  total_glosses=$(find "$glossary_dir" -type f -executable 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$quiet" -eq 0 ]; then
    success "Gloss generation complete"
    info "  Total glosses: $total_glosses"
    [ "$force" -eq 1 ] && info "  Regenerated all glosses (--force)"
  fi
  
  return 0
}


# Load castable imp for direct execution (AFTER all functions defined)
# CRITICAL: Always source, never use from PATH
# The imp must be sourced to define the castable function
if true; then  # Always source castable, ensures consistency
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
