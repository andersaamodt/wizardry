#!/bin/sh
# Generate glosses (lightweight wrappers) for all wizardry spells to enable PATH-based interception

generate_glosses_usage() {
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss wrapper scripts for all wizardry spells in $SPELLBOOK_DIR/.glossary/.
Each gloss executes: exec parse "spell-name" "$@"

This enables the glossary-based interception paradigm where PATH is prepended with the
glossary directory, giving the parse spell first shot at all commands. The glossary
makes all spells shine and accessible, handles parsing, and (future) spell-checking.

Glosses are generated from:
  - All wizardry spells
  - User synonyms (.synonyms file)
  - Default synonyms (.default-synonyms file)
  - (FUTURE) System commands (when --system enabled)

Options:
  --force    Regenerate all glosses even if they already exist
  --quiet    Suppress progress messages
  --system   Also create glosses for system commands (INACTIVE - for future use)

Examples:
  generate-glosses          # Generate missing glosses
  generate-glosses --force  # Regenerate all glosses
USAGE
}

generate_glosses() {
case "${1-}" in
--help|--usage|-h)
  generate_glosses_usage
  return 0
  ;;
esac

require-wizardry || return 1

set -eu
. env-clear

  # Parse arguments
  force=0
  quiet=0
  include_system=0  # INACTIVE - for future feature to gloss system commands
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force=1 ;;
      --quiet) quiet=1 ;;
      --system) include_system=1 ;;  # Parsed but not used yet
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        return 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  glossary_dir="$spell_home/.glossary"
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  
  # Verify wizardry directory exists and is valid
  if [ ! -d "$wizardry_dir" ]; then
    die "generate-glosses: WIZARDRY_DIR not found: $wizardry_dir"
  fi
  
  if [ ! -d "$wizardry_dir/spells" ]; then
    die "generate-glosses: WIZARDRY_DIR does not contain spells directory: $wizardry_dir"
  fi
  
  # Create glossary directory
  if ! mkdir -p "$glossary_dir" 2>/dev/null; then
    die "generate-glosses: cannot create glossary directory: $glossary_dir"
  fi
  
  # Track counts across all sources
  total_generated=0
  total_skipped=0
  
  # ============================================================================
  # CENTRALIZED GLOSS CREATION FUNCTION
  # ============================================================================
  # Creates a gloss file with proper headers and content.
  # Arguments: gloss_name, target_command, source_description
  # ============================================================================
  _create_gloss() {
    _gloss_name=$1
    _target_cmd=$2
    _source_desc=${3:-"wizardry spell"}
    _gloss_path="$glossary_dir/$_gloss_name"
    
    # Skip if gloss exists and is current (unless --force)
    if [ -f "$_gloss_path" ] && [ "$force" -eq 0 ]; then
      if grep -q "exec parse \"$_target_cmd\"" "$_gloss_path" 2>/dev/null || \
         grep -q "exec \"$_target_cmd\"" "$_gloss_path" 2>/dev/null; then
        total_skipped=$((total_skipped + 1))
        return 0
      fi
    fi
    
    # Create the gloss - check if parse is available
    # If parse is not available, use passthrough mode (direct execution)
    if command -v parse >/dev/null 2>&1; then
      # Parse is available - use it for potential future parsing features
      {
        printf '#!/bin/sh\n'
        printf '# Gloss for %s: %s -> %s\n' "$_source_desc" "$_gloss_name" "$_target_cmd"
        printf '# Generated by generate-glosses\n'
        printf '# DO NOT EDIT - This file is auto-generated\n'
        printf 'exec parse "%s" "$@"\n' "$_target_cmd"
      } > "$_gloss_path"
    else
      # Parse not available - use passthrough mode (direct execution)
      {
        printf '#!/bin/sh\n'
        printf '# Gloss for %s: %s -> %s (passthrough mode)\n' "$_source_desc" "$_gloss_name" "$_target_cmd"
        printf '# Generated by generate-glosses\n'
        printf '# DO NOT EDIT - This file is auto-generated\n'
        printf '# NOTE: parse imp not available - using direct execution\n'
        printf 'exec "%s" "$@"\n' "$_target_cmd"
      } > "$_gloss_path"
    fi
    
    # Make executable
    if chmod +x "$_gloss_path" 2>/dev/null; then
      total_generated=$((total_generated + 1))
      return 0
    else
      warn "generate-glosses: cannot make executable: $_gloss_path"
      return 1
    fi
  }
  
  # ============================================================================
  # GLOSS GENERATION FROM ALL SOURCES (unified, elegant)
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && info "Generating glosses from all sources..."
  
  # Source 1: Wizardry spells (including imps and arcana)
  # Generate glosses for all wizardry files recursively
  # This includes:
  # - User-facing spells in spells/*/
  # - Imps in spells/.imps/*/
  # - Arcana in spells/.arcana/*/
  if [ -d "$wizardry_dir/spells" ]; then
    [ "$quiet" -eq 0 ] && debug "Scanning $wizardry_dir/spells for executable files..."
    
    # Use temp file to avoid subshell issues with pipeline
    _spell_list=$(temp-file)
    # Use -perm /111 instead of -executable for better cross-platform compatibility
    # (BSD find on older macOS doesn't support -executable)
    find "$wizardry_dir/spells" -type f -perm /111 2>/dev/null > "$_spell_list"
    
    # Count files found
    _spell_count=$(wc -l < "$_spell_list")
    [ "$quiet" -eq 0 ] && debug "Found $_spell_count executable files in wizardry"
    
    while IFS= read -r spell_path; do
      # Skip empty paths or invalid files
      [ -n "$spell_path" ] && [ -f "$spell_path" ] || continue
      spell_name=$(basename "$spell_path")
      
      # Skip invalid names
      case "$spell_name" in
        ''|.*) continue ;;
      esac
      
      # Determine the source description
      case "$spell_path" in
        */.imps/*) source_desc="wizardry imp" ;;
        */.arcana/*) source_desc="wizardry arcana" ;;
        *) source_desc="wizardry spell" ;;
      esac
      
      # Create gloss for this spell/imp/arcana
      _create_gloss "$spell_name" "$spell_name" "$source_desc"
    done < "$_spell_list"
    
    cleanup-file "$_spell_list"
  else
    [ "$quiet" -eq 0 ] && warn "generate-glosses: spells directory not found: $wizardry_dir/spells"
  fi
  
  # Source 2: User synonyms (.synonyms file)
  # Parse aliases and create corresponding glosses
  synonym_file="$spell_home/.synonyms"
  if [ -f "$synonym_file" ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Parse alias format: alias name='command' or alias name="command"
      if ! printf '%s' "$line" | grep -q "^alias "; then
        continue
      fi
      
      # Extract synonym name and target
      syn_name=$(printf '%s' "$line" | sed "s/^alias \([^=]*\)=.*/\1/" | tr -d "'" | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      syn_target=$(printf '%s' "$line" | sed "s/^alias [^=]*=['\"]\\(.*\\)['\"]/\\1/")
      
      # Skip if couldn't parse
      if [ -z "$syn_name" ] || [ -z "$syn_target" ]; then
        continue
      fi
      
      # Create gloss for this synonym
      _create_gloss "$syn_name" "$syn_target" "user synonym"
    done < "$synonym_file"
  fi
  
  # Source 3: Default synonyms (.default-synonyms file)
  # Parse aliases and create corresponding glosses
  default_synonym_file="$spell_home/.default-synonyms"
  if [ -f "$default_synonym_file" ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Parse alias format: alias name='command' or alias name="command"
      if ! printf '%s' "$line" | grep -q "^alias "; then
        continue
      fi
      
      # Extract synonym name and target
      syn_name=$(printf '%s' "$line" | sed "s/^alias \([^=]*\)=.*/\1/" | tr -d "'" | tr -d '"' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      syn_target=$(printf '%s' "$line" | sed "s/^alias [^=]*=['\"]\\(.*\\)['\"]/\\1/")
      
      # Skip if couldn't parse
      if [ -z "$syn_name" ] || [ -z "$syn_target" ]; then
        continue
      fi
      
      # Create gloss for this synonym
      _create_gloss "$syn_name" "$syn_target" "default synonym"
    done < "$default_synonym_file"
  fi
  
  # Source 4: System commands (FUTURE FEATURE - currently inactive)
  # When enabled with --system flag, this will create glosses for common system commands
  # to enable natural language parsing and spell-checking for all commands.
  #
  # DESIGN NOTES FOR FUTURE IMPLEMENTATION:
  # - Only gloss "safe" commands that won't cause issues when intercepted
  # - Skip shell builtins and critical system utilities (cd, exec, eval, etc.)
  # - Use a whitelist or blacklist approach to control which commands get glossed
  # - Consider performance impact of glossing high-frequency commands
  #
  # COMMENTED OUT - Uncomment and customize when ready to enable:
  #
  # if [ "$include_system" -eq 1 ]; then
  #   [ "$quiet" -eq 0 ] && info "Generating glosses for system commands (--system)..."
  #   
  #   # Whitelist of safe system commands to gloss (example list)
  #   _system_commands="ls cat grep find sort sed awk cut head tail wc df du ps top git vim nano"
  #   
  #   # Blacklist of commands to NEVER gloss (critical shell functionality)
  #   _blacklist="cd exec eval source . test [ export unset set shift exit return builtin command"
  #   
  #   for cmd in $_system_commands; do
  #     # Check if command exists and is not blacklisted
  #     if command -v "$cmd" >/dev/null 2>&1; then
  #       case " $_blacklist " in
  #         *" $cmd "*) continue ;;
  #       esac
  #       
  #       # Create gloss for this system command
  #       _create_gloss "$cmd" "$cmd" "system command"
  #     fi
  #   done
  # fi
  
  # Count total glosses in directory
  # Use -perm /111 for cross-platform compatibility (BSD find on older macOS)
  total_glosses=$(find "$glossary_dir" -type f -perm /111 2>/dev/null | wc -l | tr -d ' ')
  
  # Report results
  if [ "$quiet" -eq 0 ]; then
    success "Gloss generation complete"
    info "  Total glosses in glossary: $total_glosses"
    info "  Generated/updated: $total_generated"
    info "  Skipped (current): $total_skipped"
    [ "$force" -eq 1 ] && info "  Mode: --force (regenerate all)"
  fi
  
  return 0
}

# Load castable imp for direct execution (AFTER all functions defined)
# CRITICAL: Always source, never use from PATH
# The imp must be sourced to define the castable function
if true; then  # Always source castable, ensures consistency
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
