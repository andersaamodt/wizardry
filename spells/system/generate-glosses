#!/bin/sh
# Generate glosses (lightweight wrappers) for all wizardry spells to enable PATH-based interception

generate_glosses_usage() {
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss wrapper scripts for all wizardry spells in $SPELLBOOK_DIR/.glossary/.
Each gloss executes: exec parse "spell-name" "$@"

This enables the glossary-based interception paradigm where PATH is prepended with the
glossary directory, giving the parse spell first shot at all commands. The glossary
makes all spells shine and accessible, handles parsing, and (future) spell-checking.

Options:
  --force    Regenerate all glosses even if they already exist
  --quiet    Suppress progress messages
  --system   Also create glosses for system commands (INACTIVE - for future use)

Examples:
  generate-glosses          # Generate missing glosses
  generate-glosses --force  # Regenerate all glosses
USAGE
}

generate_glosses() {
case "${1-}" in
--help|--usage|-h)
  generate_glosses_usage
  return 0
  ;;
esac

require-wizardry || return 1

set -eu
. env-clear

  # Parse arguments
  force=0
  quiet=0
  include_system=0  # INACTIVE - for future feature to gloss system commands
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force=1 ;;
      --quiet) quiet=1 ;;
      --system) include_system=1 ;;  # Parsed but not used yet
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        return 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  glossary_dir="$spell_home/.glossary"
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  synonym_file="$spell_home/.synonyms"
  default_synonym_file="$spell_home/.default-synonyms"
  
  # Create glossary directory
  if ! mkdir -p "$glossary_dir" 2>/dev/null; then
    die "generate-glosses: cannot create glossary directory: $glossary_dir"
  fi
  
  # Track counts
  spell_count=0
  created_count=0
  updated_count=0
  skipped_count=0
  duplicate_count=0
  synonym_count=0
  
  # Build cache of system commands to avoid conflicts
  # We'll check against PATH to see if a command already exists
  _gloss_system_commands=""
  
  [ "$quiet" -eq 0 ] && info "Scanning for spells in $wizardry_dir/spells..."
  
  # Helper function to check if a gloss would conflict
  _check_gloss_conflict() {
    _gloss_name=$1
    _gloss_path="$glossary_dir/$_gloss_name"
    
    # Allow if it's already a gloss (we can update it)
    if [ -f "$_gloss_path" ]; then
      return 0  # Not a conflict, can update
    fi
    
    # Check if it's a system command (outside glossary)
    # We remove glossary from PATH temporarily to check
    _old_path="$PATH"
    PATH=$(printf '%s' "$PATH" | sed "s|$glossary_dir:||g" | sed "s|:$glossary_dir||g")
    
    if command -v "$_gloss_name" >/dev/null 2>&1; then
      # It's a system command - this is actually OK, we're glossing it
      PATH="$_old_path"
      return 0
    fi
    
    PATH="$_old_path"
    return 0
  }
  
  # Generate glosses for wizardry spells
  find "$wizardry_dir/spells" -type f -executable \
    -not -path "$wizardry_dir/spells/.imps/*" \
    -not -path "$wizardry_dir/spells/.arcana/*" | \
  while IFS= read -r spell_path; do
    # Extract spell name from path (basename)
    spell_name=$(basename "$spell_path")
    
    # Skip if name is empty or starts with dot
    case "$spell_name" in
      ''|.*) continue ;;
    esac
    
    spell_count=$((spell_count + 1))
    gloss_path="$glossary_dir/$spell_name"
    
    # Check for conflicts
    if ! _check_gloss_conflict "$spell_name"; then
      duplicate_count=$((duplicate_count + 1))
      [ "$quiet" -eq 0 ] && warn "Skipping duplicate: $spell_name"
      continue
    fi
    
    # Check if gloss already exists and is current
    if [ -f "$gloss_path" ] && [ "$force" -eq 0 ]; then
      # Verify gloss content is correct
      if grep -q "exec parse \"$spell_name\"" "$gloss_path" 2>/dev/null; then
        skipped_count=$((skipped_count + 1))
        continue
      else
        updated_count=$((updated_count + 1))
      fi
    else
      created_count=$((created_count + 1))
    fi
    
    # Create the gloss
    cat > "$gloss_path" << GLOSS
#!/bin/sh
# Gloss wrapper for wizardry spell: $spell_name
# Generated by generate-glosses on $(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date)
# DO NOT EDIT - This file is auto-generated
exec parse "$spell_name" "\$@"
GLOSS
    
    # Make executable
    chmod +x "$gloss_path" 2>/dev/null || {
      warn "generate-glosses: cannot make executable: $gloss_path"
      continue
    }
    
    [ "$quiet" -eq 0 ] && [ $((spell_count % 50)) -eq 0 ] && \
      step "Processed $spell_count spells..."
  done
  
  # Generate glosses for synonyms defined in .synonyms and .default-synonyms
  _generate_synonym_glosses() {
    _syn_file=$1
    _syn_type=$2
    
    if [ ! -f "$_syn_file" ]; then
      return 0
    fi
    
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Parse alias format: alias name='command'
      # Extract: name and command
      if ! printf '%s' "$line" | grep -q "^alias "; then
        continue
      fi
      
      # Extract synonym name and target
      syn_name=$(printf '%s' "$line" | sed "s/^alias \([^=]*\)=.*/\1/" | tr -d "'" | tr -d '"')
      syn_target=$(printf '%s' "$line" | sed "s/^alias [^=]*='\(.*\)'/\1/" | sed "s/^alias [^=]*=\"\(.*\)\"/\1/")
      
      # Skip if couldn't parse
      if [ -z "$syn_name" ] || [ -z "$syn_target" ]; then
        continue
      fi
      
      synonym_count=$((synonym_count + 1))
      gloss_path="$glossary_dir/$syn_name"
      
      # Create synonym gloss
      cat > "$gloss_path" << SYNGLOSS
#!/bin/sh
# Gloss for ${_syn_type} synonym: $syn_name -> $syn_target
# Generated by generate-glosses on $(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date)
# Source: $_syn_file
# DO NOT EDIT - Regenerate by editing synonym file and running generate-glosses
exec parse "$syn_target" "\$@"
SYNGLOSS
      
      chmod +x "$gloss_path" 2>/dev/null
    done < "$_syn_file"
  }
  
  [ "$quiet" -eq 0 ] && info "Generating glosses for synonyms..."
  _generate_synonym_glosses "$default_synonym_file" "default"
  _generate_synonym_glosses "$synonym_file" "custom"
  
  # Count total actually created (read back from directory)
  total_glosses=$(find "$glossary_dir" -type f -executable 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$quiet" -eq 0 ]; then
    success "Gloss generation complete"
    info "  Total glosses: $total_glosses"
    info "  From spells: $spell_count"
    info "  From synonyms: $synonym_count"
    [ "$duplicate_count" -gt 0 ] && info "  Duplicates skipped: $duplicate_count"
    [ "$force" -eq 1 ] && info "  Regenerated all glosses (--force)"
  fi
  
  return 0
}

# Load castable imp for direct execution (AFTER all functions defined)
# CRITICAL: Always source, never use from PATH
# The imp must be sourced to define the castable function
if true; then  # Always source castable, ensures consistency
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
