#!/bin/sh

# Validate that specified spells and imps exist in wizardry installation.
# Used by banish, test-magic, and demo-magic to verify spell availability.

show_usage() {
  cat <<'USAGE'
Usage: validate-spells [OPTIONS] SPELL...

Validate that specified spells or imps exist in the wizardry installation.

Arguments:
  SPELL...              One or more spells to validate
                        Format: "spell" or "spell:dir" or "imp:.imps/family/name"

Options:
  --quiet, -q           Only report missing spells (no success messages)
  --missing-only        Return list of missing spells on stdout
  --imps                Validate imps instead of spells
  --show-status         Show detailed status (loaded vs available)

Examples:
  validate-spells ask-yn menu                    # Check cantrips
  validate-spells hash:crypto evoke-hash:crypto  # Check crypto spells  
  validate-spells --imps sys/has cond/there      # Check imps
  missing=$(validate-spells --missing-only ask-yn menu)  # Get missing list

Exit Codes:
  0  All spells/imps found
  1  One or more spells/imps missing
  2  Invalid usage
USAGE
}

validate_spells() {
case "${1-}" in
--help|--usage|-h)
  show_usage
  return 0
  ;;
esac

# Use conditional strictness based on execution context
# See .github/CODE_POLICY_SET_EU.md for details
case "$0" in
  */validate-spells)
    # Executed as script - use full strict mode
    set -eu
    ;;
  *)
    # Called as function (sourced) - only undefined variable protection
    # This prevents interactive shell exit while maintaining safety
    set -u
    ;;
esac

# Validate WIZARDRY_DIR is set and valid
# Don't use require-wizardry here because it may not be loaded yet
# (banish calls this before all imps are available)
if [ -z "${WIZARDRY_DIR-}" ]; then
  printf 'validate-spells: WIZARDRY_DIR not set\n' >&2
  printf 'Run this from banish or set WIZARDRY_DIR explicitly\n' >&2
  return 1
fi

if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
  printf 'validate-spells: invalid WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  return 1
fi

# Parse options
quiet=0
missing_only=0
validate_imps=0
show_status=0
default_dir="cantrips"

while [ "$#" -gt 0 ]; do
  case "$1" in
    --quiet|-q)
      quiet=1
      shift
      ;;
    --missing-only)
      missing_only=1
      quiet=1
      shift
      ;;
    --imps)
      validate_imps=1
      default_dir=".imps"
      shift
      ;;
    --show-status)
      show_status=1
      shift
      ;;
    -*)
      printf 'validate-spells: unknown option: %s\n' "$1" >&2
      return 2
      ;;
    *)
      break
      ;;
  esac
done

if [ "$#" -eq 0 ]; then
  printf 'validate-spells: no spells specified\n' >&2
  return 2
fi

# Validate each spell
missing=""
found_count=0
loaded_count=0
available_count=0

# For imps with --show-status, we'll collect results for category-based output
# Store results as space-separated lists instead of using eval-based dynamic variables
imp_results=""

for spell_info in "$@"; do
  # Parse spell:dir format
  case "$spell_info" in
    *:*)
      spell=$(printf '%s' "$spell_info" | cut -d: -f1)
      dir=$(printf '%s' "$spell_info" | cut -d: -f2)
      ;;
    *)
      spell=$spell_info
      dir=$default_dir
      ;;
  esac
  
  # Check if spell/imp exists
  if [ "$validate_imps" -eq 1 ]; then
    spell_path="${WIZARDRY_DIR}/spells/.imps/$spell"
  else
    spell_path="${WIZARDRY_DIR}/spells/$dir/$spell"
  fi
  
  # Determine function name
  if [ "$validate_imps" -eq 1 ]; then
    # For imps, extract just the name part after the family/
    # Keep hyphens as-is (imps use hyphenated names)
    func_name=$(printf '%s' "$spell" | sed 's|.*/||')
  else
    # For spells, use hyphenated name as-is
    func_name=$(printf '%s' "$spell" | sed 's|.*/||')
  fi
  
  # Check if loaded as function (try both hyphenated and underscored versions)
  is_loaded=0
  for name_variant in "$func_name" "$(printf '%s' "$func_name" | tr '-' '_')"; do
    if command -v "$name_variant" >/dev/null 2>&1; then
      func_type=$(type "$name_variant" 2>/dev/null || true)
      case "$func_type" in
        *"function"*|*"shell function"*)
          is_loaded=1
          break
          ;;
      esac
    fi
  done
  
  if [ -f "$spell_path" ]; then
    found_count=$((found_count + 1))
    
    if [ "$is_loaded" -eq 1 ]; then
      loaded_count=$((loaded_count + 1))
      
      # For imps with --show-status, store result for later category-based output
      if [ "$validate_imps" -eq 1 ] && [ "$show_status" -eq 1 ]; then
        category=$(printf '%s' "$spell" | cut -d/ -f1)
        imp_name=$(printf '%s' "$spell" | sed 's|.*/||')
        # Format: category:status:name (status: L=loaded, A=available)
        imp_results="${imp_results}${imp_results:+ }${category}:L:${imp_name}"
      elif [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
        # For spells, show individually
        printf '\033[32m✓\033[0m Loaded spell: %s\n' "$spell"
      fi
    else
      available_count=$((available_count + 1))
      
      # For imps with --show-status, store result for later category-based output
      if [ "$validate_imps" -eq 1 ] && [ "$show_status" -eq 1 ]; then
        category=$(printf '%s' "$spell" | cut -d/ -f1)
        imp_name=$(printf '%s' "$spell" | sed 's|.*/||')
        # Format: category:status:name (status: L=loaded, A=available)
        imp_results="${imp_results}${imp_results:+ }${category}:A:${imp_name}"
      elif [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
        # For spells, show individually
        printf '\033[34m●\033[0m Available spell: %s\n' "$spell"
      fi
    fi
    
    if [ "$quiet" -eq 0 ] && [ "$show_status" -eq 0 ]; then
      if [ "$validate_imps" -eq 1 ]; then
        printf '✓ Found imp: %s\n' "$spell"
      else
        printf '✓ Found spell: %s\n' "$spell"
      fi
    fi
  else
    missing="${missing:+$missing }$spell"
  fi
done

# Output grouped results for imps with --show-status
if [ "$validate_imps" -eq 1 ] && [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
  if [ -n "$imp_results" ]; then
  # Get all unique categories
  categories=""
  for result in $imp_results; do
    category=$(printf '%s' "$result" | cut -d: -f1)
    # Add category to list if not already present
    case " $categories " in
      *" $category "*) ;;
      *) categories="${categories:+$categories }$category" ;;
    esac
  done
  
  # Output each category
  for category in $categories; do
    loaded_imps=""
    available_imps=""
    
    # Collect imps for this category
    for result in $imp_results; do
      result_category=$(printf '%s' "$result" | cut -d: -f1)
      result_status=$(printf '%s' "$result" | cut -d: -f2)
      result_name=$(printf '%s' "$result" | cut -d: -f3-)
      
      if [ "$result_category" = "$category" ]; then
        if [ "$result_status" = "L" ]; then
          loaded_imps="${loaded_imps}${loaded_imps:+ }${result_name}"
        else
          available_imps="${available_imps}${available_imps:+ }${result_name}"
        fi
      fi
    done
    
    # Count and output loaded imps with proper pluralization
    if [ -n "$loaded_imps" ]; then
      loaded_count_cat=0
      for imp in $loaded_imps; do
        loaded_count_cat=$((loaded_count_cat + 1))
      done
      
      if [ "$loaded_count_cat" -eq 1 ]; then
        printf '\033[32m✓\033[0m Loaded %s imp: %s\n' "$category" "$loaded_imps"
      else
        printf '\033[32m✓\033[0m Loaded %s imps: %s\n' "$category" "$loaded_imps"
      fi
    fi
    
    # Count and output available imps with proper pluralization
    if [ -n "$available_imps" ]; then
      available_count_cat=0
      for imp in $available_imps; do
        available_count_cat=$((available_count_cat + 1))
      done
      
      if [ "$available_count_cat" -eq 1 ]; then
        printf '\033[34m●\033[0m Available %s imp: %s\n' "$category" "$available_imps"
      else
        printf '\033[34m●\033[0m Available %s imps: %s\n' "$category" "$available_imps"
      fi
    fi
  done
  fi
fi

# Output results
if [ "$missing_only" -eq 1 ]; then
  printf '%s' "$missing"
  [ -n "$missing" ] && return 1
  return 0
fi

if [ -n "$missing" ]; then
  if [ "$validate_imps" -eq 1 ]; then
    printf 'Missing imps: %s\n' "$missing" >&2
  else
    printf 'Missing spells: %s\n' "$missing" >&2
  fi
  return 1
fi

return 0
}

# Load castable imp for direct execution
if true; then
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
