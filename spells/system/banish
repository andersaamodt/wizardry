#!/bin/sh

# Banish environmental chaos and validate wizardry readiness at different levels.
# This spell assumption-checks, self-heals, and tests the environment,
# ensuring all prerequisites are met for each spell level.

show_usage() {
  cat <<'USAGE'
Usage: banish [LEVEL] [OPTIONS]

Validate wizardry at the specified spell level, checking assumptions, 
self-healing issues, and running tests. Each level builds on previous levels.

NOTE: Banish requires wizardry to be installed. Run ./install first.
See .github/SPELL_LEVELS.md for complete level documentation.

Arguments:
  LEVEL                 Spell level to validate (0-27, default: 1)
                        Level 0: POSIX & platform foundation
                        Level 1: Wizardry installation
                        Level 2: Menu system
                        Level 3: MUD basics (cd-hook, look)
                        Level 4: Navigation (jump-to-marker, mark-location)
                        Level 5: Arcane file operations
                        Level 6: Basic cantrips
                        Level 7: Validation helpers
                        Level 8: Advanced cantrips
                        Level 9: System configuration
                        Level 10: Testing infrastructure
                        Level 11: System maintenance
                        Level 12: Advanced system tools
                        Level 13: Divination
                        Level 14: Advanced MUD
                        Level 15-20: Specialized domains (crypto, SSH, priorities, wards, enchant, PSI, spellcraft)
                        Level 21-25: Menus (core, system, MUD, domain)
                        Level 26: System services
                        Level 27: Optional arcana & third-party integrations

Options:
  --no-heal             Skip self-healing (only report issues)
  --no-tests            Skip running tests (only check assumptions)
  --only                Only validate this specific level (don't run lower levels)

Environment Variables:
  WIZARDRY_DIR          Target wizardry installation directory

Exit Codes:
  0  Level is ready (all checks passed, tests passed)
  1  Critical issues found (cannot continue)
  2  Invalid usage

Examples:
  banish                    # Validate through level 1 (default - levels 0-1: POSIX + wizardry)
  banish 0                  # Validate level 0 only (POSIX foundation)
  banish 2                  # Validate through level 2 (levels 0-2: POSIX + wizardry + menu)
  banish 4 --no-tests       # Validate through level 4, skip tests
  banish 1 --no-heal        # Validate through level 1, only report issues
USAGE
}

banish() {
case "${1-}" in
--help|--usage|-h)
  show_usage
  return 0
  ;;
esac

# Debug: Log when banish is called
if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
  printf '[banish] Function called\n' >&2
fi

set -eu

# Detect WIZARDRY_DIR if not already set
# When sourced by invoke-wizardry, WIZARDRY_DIR will already be set
# When run directly, we need to detect it from script location
if [ -z "${WIZARDRY_DIR-}" ]; then
  # Check if we're being run as a function (sourced context)
  # In this case, $0 is the shell name (bash, zsh, etc.), not the script path
  case "$0" in
    sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
      # We're sourced but WIZARDRY_DIR not set - this shouldn't happen if
      # invoke-wizardry loaded us, but try common locations as fallback
      if [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
        WIZARDRY_DIR="${HOME}/.wizardry"
      fi
      ;;
    *)
      # We're being executed directly - detect from script location
      _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || _script_dir=""
      if [ -n "$_script_dir" ]; then
        _wiz_root=$(CDPATH= cd -- "$_script_dir/../.." 2>/dev/null && pwd -P) || _wiz_root=""
        if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
          WIZARDRY_DIR=$_wiz_root
        fi
      fi
      ;;
  esac
fi

# Validate WIZARDRY_DIR is set and valid
if [ -z "${WIZARDRY_DIR-}" ]; then
  printf 'banish: WIZARDRY_DIR not set and could not be detected\n' >&2
  printf 'Run from wizardry installation or set WIZARDRY_DIR environment variable\n' >&2
  return 1
fi

if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
  printf 'banish: invalid WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  return 1
fi

export WIZARDRY_DIR

# Parse arguments
target_level=1
skip_tests=0
skip_heal=0
only_this_level=0

# First, check if first arg is a number (the level)
if [ "$#" -gt 0 ]; then
  case "$1" in
    [0-9]|[0-9][0-9])
      target_level=$1
      shift
      ;;
  esac
fi

while [ "$#" -gt 0 ]; do
  case $1 in
    --no-heal)
      skip_heal=1
      shift
      ;;
    --no-tests)
      skip_tests=1
      shift
      ;;
    --only)
      only_this_level=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf 'Error: unknown option: %s\n' "$1" >&2
      show_usage >&2
      return 2
      ;;
    *)
      # Check if it's a valid level number
      case "$1" in
        [0-9]|[0-9][0-9])
          target_level=$1
          shift
          ;;
        *)
          printf 'Error: unexpected argument: %s\n' "$1" >&2
          show_usage >&2
          return 2
          ;;
      esac
      ;;
  esac
done

# Validate level
if [ "$target_level" -lt 0 ] || [ "$target_level" -gt 27 ]; then
  printf 'Error: level must be 0-27, got: %s\n' "$target_level" >&2
  show_usage >&2
  return 2
fi

# Source shared spell level definitions from sys imp
# This file is shared by banish, test-magic, and demo-magic
if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels" ]; then
  . "${WIZARDRY_DIR}/spells/.imps/sys/spell-levels"
else
  # Fallback: try to find from script location
  _banish_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _wiz_root=$(CDPATH= cd -- "$_banish_dir/../.." && pwd -P)
  if [ -f "$_wiz_root/spells/.imps/sys/spell-levels" ]; then
    . "$_wiz_root/spells/.imps/sys/spell-levels"
  else
    # Final fallback: define inline if spell-levels not found
    get_level_spells() { printf '' ; }
    get_level_imps() { printf '' ; }
    banish_level_name() { printf 'Unknown' ; }
  fi
fi

# Color codes (inline to avoid dependency)
_esc=$(printf '\033')
_green="${_esc}[32m"
_red="${_esc}[31m"
_reset="${_esc}[0m"

# Run level-specific checks and actions using case statement
banish_process_level() {
  level=$1
  level_name=$(banish_level_name "$level")
  
  printf '\nLevel %d: %s\n' "$level" "$level_name"
  
  # Special handling per level
  case "$level" in
    0)
      # Level 0: System Foundation
      
      # Check WIZARDRY_DIR (single item - combine on one line)
      wizardry_not_installed=0
      
      if [ -n "${WIZARDRY_DIR-}" ]; then
        printf '  %s✓%s Wizardry directory: WIZARDRY_DIR is set\n' "$_green" "$_reset"
      else
        printf '  Wizardry directory:\n'
        printf '    Checking for wizardry installation...\n'
        
        has_dirname=$(command -v dirname >/dev/null 2>&1 && echo 1 || echo 0)
        has_cd=$(command -v cd >/dev/null 2>&1 && echo 1 || echo 0)
        has_pwd=$(command -v pwd >/dev/null 2>&1 && echo 1 || echo 0)
        if [ "$has_dirname" = "1" ] && [ "$has_cd" = "1" ] && [ "$has_pwd" = "1" ]; then
          script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || true
          if [ -n "$script_dir" ]; then
            _potential_dir=$(CDPATH= cd -- "$script_dir/../.." 2>/dev/null && pwd -P) || true
            if [ -n "$_potential_dir" ] && [ -d "$_potential_dir/spells" ]; then
              WIZARDRY_DIR=$_potential_dir
              printf '    %s✓%s Detected from script location\n' "$_green" "$_reset"
            fi
          fi
        fi
        
        if [ -z "${WIZARDRY_DIR-}" ]; then
          if [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
            WIZARDRY_DIR="${HOME}/.wizardry"
            printf '    %s✓%s Found at standard location\n' "$_green" "$_reset"
          else
            wizardry_not_installed=1
            printf '    %s✗%s Not found\n' "$_red" "$_reset"
          fi
        fi
      fi
      
      if [ "$wizardry_not_installed" -eq 1 ]; then
        printf 'Error: Wizardry not installed - run ./install first\n'
        return 1
      fi
      
      export WIZARDRY_DIR
      
      # Check POSIX commands (multiple items - check topic when all pass)
      posix_failed=0
      for cmd in sh test printf cat; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
          posix_failed=1
          break
        fi
      done
      
      if [ "$posix_failed" -eq 0 ]; then
        printf '  %s✓%s POSIX foundation:\n' "$_green" "$_reset"
        for cmd in sh test printf cat; do
          printf '    %s✓%s %s\n' "$_green" "$_reset" "$cmd"
        done
      else
        printf '  %s✗%s POSIX foundation:\n' "$_red" "$_reset"
        for cmd in sh test printf cat; do
          if command -v "$cmd" >/dev/null 2>&1; then
            printf '    %s✓%s %s\n' "$_green" "$_reset" "$cmd"
          else
            printf '    %s✗%s %s not found\n' "$_red" "$_reset" "$cmd"
          fi
        done
        return 1
      fi
      ;;
      
    1)
      # Level 1: Wizardry Installation
      
      # Check wizardry structure (single item - combine on one line)
      if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
        printf '  %s✗%s Wizardry structure: Spells directory not found\n' "$_red" "$_reset"
        return 1
      fi
      printf '  %s✓%s Wizardry structure: Spells directory exists\n' "$_green" "$_reset"
      
      # Validate spells (single item - combine on one line)
      spell_list=$(get_level_spells 1)
      if [ -n "$spell_list" ]; then
        if ! validate-spells --quiet $spell_list 2>/dev/null; then
          missing=$(validate-spells --missing-only $spell_list)
          printf '  %s✗%s Required spells: Missing: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        printf '  %s✓%s Required spells: All found\n' "$_green" "$_reset"
      fi
      
      # Validate imps (single item - combine on one line)
      imp_list=$(get_level_imps 1)
      if [ -n "$imp_list" ]; then
        if ! validate-spells --quiet --imps $imp_list 2>/dev/null; then
          missing=$(validate-spells --imps --missing-only $imp_list)
          printf '  %s✗%s Required imps: Missing: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        printf '  %s✓%s Required imps: All found\n' "$_green" "$_reset"
      fi
      ;;
      
    2)
      # Level 2: Menu System
      
      # Check spells (single item - combine on one line)
      spell_list=$(get_level_spells 2)
      if [ -n "$spell_list" ]; then
        if ! validate-spells --quiet $spell_list 2>/dev/null; then
          missing=$(validate-spells --missing-only $spell_list)
          printf '  %s✗%s Menu spells: Missing: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        printf '  %s✓%s Menu spells: All found\n' "$_green" "$_reset"
      fi
      
      # Check stty (single item - combine on one line)
      if ! command -v stty >/dev/null 2>&1; then
        printf '  %s✗%s Terminal control: stty not found\n' "$_red" "$_reset"
        if [ "$skip_heal" -eq 0 ]; then
          if [ -x "${WIZARDRY_DIR}/spells/.arcana/core/install-stty" ]; then
            printf '    Installing stty...\n'
            if "${WIZARDRY_DIR}/spells/.arcana/core/install-stty" 2>/dev/null; then
              if command -v stty >/dev/null 2>&1; then
                printf '    %s✓%s stty installed\n' "$_green" "$_reset"
              else
                printf '    %s✗%s Install failed\n' "$_red" "$_reset"
              fi
            else
              printf '    %s✗%s Install failed\n' "$_red" "$_reset"
            fi
          else
            printf '    Cannot auto-install stty\n'
          fi
        fi
      else
        printf '  %s✓%s Terminal control: stty available\n' "$_green" "$_reset"
      fi
      ;;
      
    27)
      # Level 27: Optional Arcana (single item - combine on one line)
      if [ -d "${WIZARDRY_DIR}/spells/.arcana" ]; then
        arcana_count=$(find "${WIZARDRY_DIR}/spells/.arcana" -type f 2>/dev/null | wc -l)
        printf '  %s✓%s Arcana (optional): Found %d scripts\n' "$_green" "$_reset" "$arcana_count"
      else
        printf '  Arcana (optional): Not installed\n'
      fi
      ;;
      
    *)
      # Levels 3-26: Standard validation pattern
      
      # Check spells (single item - combine on one line)
      spell_list=$(get_level_spells "$level")
      if [ -n "$spell_list" ]; then
        if ! validate-spells --quiet $spell_list 2>/dev/null; then
          missing=$(validate-spells --missing-only $spell_list)
          printf '  %s✗%s Spells: Missing: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        printf '  %s✓%s Spells: All found\n' "$_green" "$_reset"
      fi
      
      # Check imps (single item - combine on one line)
      imp_list=$(get_level_imps "$level")
      if [ -n "$imp_list" ]; then
        if ! validate-spells --quiet --imps $imp_list 2>/dev/null; then
          missing=$(validate-spells --imps --missing-only $imp_list)
          printf '  %s✗%s Imps: Missing: %s\n' "$_red" "$_reset" "$missing"
          return 1
        fi
        printf '  %s✓%s Imps: All found\n' "$_green" "$_reset"
      fi
      ;;
  esac
  
  return 0
}


# Main execution: Run levels 0 through target_level (or only target_level if --only)
if [ "$only_this_level" -eq 1 ]; then
  printf '\nValidating Level %d only: %s\n' "$target_level" "$(banish_level_name "$target_level")"
else
  printf '\nValidating through Level %d: %s\n' "$target_level" "$(banish_level_name "$target_level")"
fi

# Run each level from 0 to target_level (or just target_level if --only)
if [ "$only_this_level" -eq 1 ]; then
  current_level=$target_level
else
  current_level=0
fi

while [ "$current_level" -le "$target_level" ]; do
  banish_process_level "$current_level" || {
    exit_code=$?
    printf '\n%s✗%s Validation failed at Level %d\n' "$_red" "$_reset" "$current_level"
    return "$exit_code"
  }
  if [ "$only_this_level" -eq 1 ]; then
    break
  fi
  current_level=$((current_level + 1))
done

# Final success message
printf '\n%s✓%s All validation checks passed\n' "$_green" "$_reset"

return 0
}


# Load castable imp for direct execution (AFTER all functions defined)
# CRITICAL: Always source, never use from PATH
# The imp must be sourced to define the castable function
if true; then  # Always source castable, ensures consistency
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
