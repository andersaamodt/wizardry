#!/bin/sh
# Generate shim wrappers for all wizardry spells to enable PATH-based interception

generate_shims_usage() {
  cat <<'USAGE'
Usage: generate-shims [OPTIONS]

Generate shim wrapper scripts for all wizardry spells in $SPELLBOOK_DIR/.synonyms/spells/.
Each shim executes: exec parse "spell-name" "$@"

This enables the shim-based interception paradigm where PATH is prepended with the
shim directory, giving the parse spell first shot at all commands.

Options:
  --force    Regenerate all shims even if they already exist
  --quiet    Suppress progress messages

Examples:
  generate-shims          # Generate missing shims
  generate-shims --force  # Regenerate all shims
USAGE
}

case "${1-}" in
--help|--usage|-h)
  generate_shims_usage
  exit 0
  ;;
esac

require-wizardry || return 1

set -eu
. env-clear

generate_shims() {
  # Parse arguments
  force=0
  quiet=0
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force=1 ;;
      --quiet) quiet=1 ;;
      *)
        printf '%s\n' "generate-shims: unknown option: $1" >&2
        return 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  shim_dir="$spell_home/.synonyms/spells"
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  
  # Create shim directory
  if ! mkdir -p "$shim_dir" 2>/dev/null; then
    die "generate-shims: cannot create shim directory: $shim_dir"
  fi
  
  # Find all spells (exclude imps and arcana)
  spell_count=0
  created_count=0
  updated_count=0
  skipped_count=0
  
  [ "$quiet" -eq 0 ] && info "Scanning for spells in $wizardry_dir/spells..."
  
  # Use find to get all executable spell files
  find "$wizardry_dir/spells" -type f -executable \
    -not -path "$wizardry_dir/spells/.imps/*" \
    -not -path "$wizardry_dir/spells/.arcana/*" | \
  while IFS= read -r spell_path; do
    # Extract spell name from path (basename)
    spell_name=$(basename "$spell_path")
    
    # Skip if name is empty or starts with dot
    case "$spell_name" in
      ''|.*) continue ;;
    esac
    
    spell_count=$((spell_count + 1))
    shim_path="$shim_dir/$spell_name"
    
    # Check if shim already exists and is current
    if [ -f "$shim_path" ] && [ "$force" -eq 0 ]; then
      # Verify shim content is correct
      if grep -q "exec parse \"$spell_name\"" "$shim_path" 2>/dev/null; then
        skipped_count=$((skipped_count + 1))
        continue
      else
        updated_count=$((updated_count + 1))
      fi
    else
      created_count=$((created_count + 1))
    fi
    
    # Create the shim
    cat > "$shim_path" << SHIM
#!/bin/sh
# Shim wrapper for wizardry spell: $spell_name
# Generated by generate-shims on $(date -u +%Y-%m-%dT%H:%M:%SZ)
exec parse "$spell_name" "\$@"
SHIM
    
    # Make executable
    chmod +x "$shim_path" 2>/dev/null || {
      warn "generate-shims: cannot make executable: $shim_path"
      continue
    }
    
    [ "$quiet" -eq 0 ] && [ $((spell_count % 50)) -eq 0 ] && \
      step "Processed $spell_count spells..."
  done
  
  # Count total actually created (read back from directory)
  total_shims=$(find "$shim_dir" -type f -executable 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$quiet" -eq 0 ]; then
    success "Shim generation complete"
    info "  Total shims: $total_shims"
    [ "$force" -eq 1 ] && info "  Regenerated all shims (--force)"
  fi
  
  return 0
}


# Load castable imp for direct execution (AFTER all functions defined)
# CRITICAL: Always source, never use from PATH
# The imp must be sourced to define the castable function
if true; then  # Always source castable, ensures consistency
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
