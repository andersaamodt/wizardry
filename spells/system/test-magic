#!/bin/sh
# Level-based test runner - tests spells by wizardry level (0-27)
#
# Responsibilities:
# - Run tests organized by spell level (following banish structure)
# - Auto-derive which tests to run from spell lists
# - Report failures in same format as banish output
# - Support banish → test-magic → demo-magic triad

# CRITICAL: Seed a baseline PATH BEFORE set -eu
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac

test_magic_usage() {
  cat <<'USAGE'
Usage: test-magic [LEVEL] [OPTIONS]

Execute behavior-driven shell tests organized by spell level.

Arguments:
  LEVEL                 Test through level N (0-27, default: 27)
  all                   Test all available levels

Options:
  --only                Only test this specific level (don't run lower levels)
  --verbose             Show per-test output

Examples:
  test-magic            # Test all levels (0-27)
  test-magic 5          # Test levels 0-5
  test-magic 10 --only  # Test only level 10

Environment variables:
  WIZARDRY_TEST_TIMEOUT    Timeout in seconds for each test (default: 180)
USAGE
}

test_magic() {
case "${1-}" in
--help|--usage|-h)
  test_magic_usage
  return 0
  ;;
esac

# Use conditional strictness based on execution context
case "$0" in
  */test-magic)
    set -eu
    ;;
  *)
    set -u
    ;;
esac

# Detect WIZARDRY_DIR if not already set
if [ -z "${WIZARDRY_DIR-}" ]; then
  case "$0" in
    sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
      if [ -n "${HOME-}" ] && [ -d "${HOME}/.wizardry/spells" ]; then
        WIZARDRY_DIR="${HOME}/.wizardry"
      fi
      ;;
    *)
      _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || _script_dir=""
      if [ -n "$_script_dir" ]; then
        _wiz_root=$(CDPATH= cd -- "$_script_dir/../.." 2>/dev/null && pwd -P) || _wiz_root=""
        if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
          WIZARDRY_DIR="$_wiz_root"
        fi
      fi
      ;;
  esac
fi

if [ -z "${WIZARDRY_DIR-}" ]; then
  printf 'test-magic: WIZARDRY_DIR not set and could not be detected\n' >&2
  printf 'Run from wizardry installation or set WIZARDRY_DIR environment variable\n' >&2
  return 1
fi

if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
  printf 'test-magic: invalid WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  return 1
fi

export WIZARDRY_DIR

cmd_name=$(basename "$0")
root_dir=$WIZARDRY_DIR
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

# Parse arguments
target_level=27
max_level=27
only_this_level=0
verbose=0
run_all=0

if [ "$#" -gt 0 ]; then
  case "$1" in
    all)
      run_all=1
      target_level=$max_level
      shift
      ;;
    [0-9]|[0-9][0-9])
      target_level=$1
      shift
      ;;
  esac
fi

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      only_this_level=1
      shift
      ;;
    --verbose|-v)
      verbose=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -* )
      printf 'test-magic: unknown option: %s\n' "$1" >&2
      test_magic_usage >&2
      return 2
      ;;
    * )
      case "$1" in
        all)
          run_all=1
          target_level=$max_level
          shift
          ;;
        [0-9]|[0-9][0-9])
          target_level=$1
          shift
          ;;
        * )
          printf 'test-magic: unexpected argument: %s\n' "$1" >&2
          test_magic_usage >&2
          return 2
          ;;
      esac
      ;;
  esac
done

# Validate level range
if [ "$target_level" -lt 0 ] || [ "$target_level" -gt "$max_level" ]; then
  printf 'test-magic: level must be 0-%d\n' "$max_level" >&2
  return 2
fi

export PATH

# Run tests inside pocket-dimension unless in GitHub Actions (no isolation for speed)
if [ "${GITHUB_ACTIONS-}" != "true" ]; then
  if [ "${WIZARDRY_TEST_IN_POCKET-0}" -ne 1 ]; then
    if command -v pocket-dimension >/dev/null 2>&1; then
      if pocket-dimension --check >/dev/null 2>&1; then
        exec pocket-dimension --network closed -- "$0" "$@"
      else
        printf 'test-magic: pocket-dimension unavailable\n' >&2
        return 1
      fi
    else
      printf 'test-magic: pocket-dimension not found\n' >&2
      return 1
    fi
  fi
fi

# Pre-flight checks
missing_commands=""
for required_cmd in sh find grep awk sed sort cat printf; do
  if ! has "$required_cmd"; then
    missing_commands="${missing_commands:+$missing_commands, }$required_cmd"
  fi
done

if [ -n "$missing_commands" ]; then
  printf 'test-magic: required commands not found: %s\n' "$missing_commands" >&2
  return 1
fi

if [ ! -x "$root_dir/spells/system/test-spell" ]; then
  printf 'test-magic: test-spell not found\n' >&2
  return 1
fi

if [ ! -f "$root_dir/spells/.imps/sys/spell-levels" ]; then
  printf 'test-magic: spell-levels imp not found\n' >&2
  return 1
fi

. "$root_dir/spells/.imps/sys/spell-levels"

# Color codes (inline to avoid dependency)
_esc=$(printf '\033')
_green="${_esc}[32m"
_red="${_esc}[31m"
_reset="${_esc}[0m"

# Initialize counters
total_pass=0
total_fail=0
total_skip=0
failed_tests=""
failed_levels=""

test_timeout=${WIZARDRY_TEST_TIMEOUT:-180}

run_test_file() {
  test_path=$1
  if has timeout; then
    if timeout "$test_timeout" "$root_dir/spells/system/test-spell" \
      --skip-common "$test_path" </dev/null >/dev/null 2>&1; then
      return 0
    fi
    return 1
  fi

  if "$root_dir/spells/system/test-spell" --skip-common "$test_path" \
    </dev/null >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

test_level() {
  level=$1
  level_name=$(banish_level_name "$level")

  printf '\nLevel %d: %s\n' "$level" "$level_name"

  spell_list=$(get_level_spells "$level")
  imp_list=$(get_level_imps "$level" 2>/dev/null || printf '')

  level_pass=0
  level_fail=0
  level_skip=0
  level_total=0

  if [ -z "$spell_list" ] && [ -z "$imp_list" ]; then
    printf '  %s✓%s No spells or imps to test.\n' "$_green" "$_reset"
    return 0
  fi

  for spell_info in $spell_list; do
    case "$spell_info" in
      *:*)
        spell=$(printf '%s' "$spell_info" | cut -d: -f1)
        dir=$(printf '%s' "$spell_info" | cut -d: -f2)
        ;;
      *)
        spell=$spell_info
        dir="cantrips"
        ;;
    esac

    test_file="$test_dir/$dir/test-$spell.sh"
    if [ ! -f "$test_file" ]; then
      level_skip=$((level_skip + 1))
      if [ "$verbose" -eq 1 ]; then
        printf '  - %s (no tests)\n' "$spell"
      fi
      continue
    fi

    test_name=$(basename "$test_file")
    test_path="${test_file#$root_dir/.tests/}"
    level_total=$((level_total + 1))

    if [ "$verbose" -eq 1 ]; then
      printf '  Running %s...\n' "$test_name"
    fi

    if run_test_file "$test_path"; then
      level_pass=$((level_pass + 1))
      printf '  %s✓%s %s\n' "$_green" "$_reset" "$test_name"
    else
      level_fail=$((level_fail + 1))
      failed_tests="${failed_tests:+$failed_tests }$test_name"
      printf '  %s✗%s %s\n' "$_red" "$_reset" "$test_name"
    fi
  done

  for imp in $imp_list; do
    test_file="$test_dir/.imps/$imp"
    test_file="${test_file%/*}/test-$(basename "$imp").sh"

    if [ ! -f "$test_file" ]; then
      level_skip=$((level_skip + 1))
      if [ "$verbose" -eq 1 ]; then
        printf '  - %s (no tests)\n' "$imp"
      fi
      continue
    fi

    test_name=$(basename "$test_file")
    test_path="${test_file#$root_dir/.tests/}"
    level_total=$((level_total + 1))

    if [ "$verbose" -eq 1 ]; then
      printf '  Running %s...\n' "$test_name"
    fi

    if run_test_file "$test_path"; then
      level_pass=$((level_pass + 1))
      printf '  %s✓%s %s\n' "$_green" "$_reset" "$test_name"
    else
      level_fail=$((level_fail + 1))
      failed_tests="${failed_tests:+$failed_tests }$test_name"
      printf '  %s✗%s %s\n' "$_red" "$_reset" "$test_name"
    fi
  done

  if [ "$level_total" -gt 0 ]; then
    if [ "$level_fail" -eq 0 ]; then
      printf '  %s✓%s Level %d: %d/%d tests passed' "$_green" "$_reset" \
        "$level" "$level_pass" "$level_total"
    else
      printf '  %s✗%s Level %d: %d/%d tests passed (%d failed)' "$_red" "$_reset" \
        "$level" "$level_pass" "$level_total" "$level_fail"
      failed_levels="${failed_levels:+$failed_levels }$level"
    fi
    if [ "$level_skip" -gt 0 ]; then
      printf ' (%d skipped)\n' "$level_skip"
    else
      printf '\n'
    fi
  else
    if [ "$level_skip" -gt 0 ]; then
      printf '  %s✓%s No tests found (%d skipped)\n' "$_green" "$_reset" "$level_skip"
    else
      printf '  %s✓%s No tests found\n' "$_green" "$_reset"
    fi
  fi

  total_pass=$((total_pass + level_pass))
  total_fail=$((total_fail + level_fail))
  total_skip=$((total_skip + level_skip))

  return 0
}

if [ "$only_this_level" -eq 1 ]; then
  printf '\nTesting Level %d only: %s\n' "$target_level" "$(banish_level_name "$target_level")"
else
  printf '\nTesting through Level %d: %s\n' "$target_level" "$(banish_level_name "$target_level")"
fi

if [ "$only_this_level" -eq 1 ]; then
  current_level=$target_level
else
  current_level=0
fi

last_success_level=-1
while [ "$current_level" -le "$target_level" ]; do
  test_level "$current_level" || {
    exit_code=$?
    if [ "$last_success_level" -ge 0 ]; then
      printf '\n%s✓%s Tested to Level %d\n' "$_green" "$_reset" "$last_success_level"
    fi
    printf '%s✗%s Testing failed at Level %d\n' "$_red" "$_reset" "$current_level"
    return "$exit_code"
  }
  last_success_level=$current_level
  if [ "$only_this_level" -eq 1 ]; then
    break
  fi
  current_level=$((current_level + 1))
done

printf '\n=== Test Summary ===\n'
total=$((total_pass + total_fail))
if [ "$total" -gt 0 ]; then
  printf 'Total: %d/%d tests passed' "$total_pass" "$total"
  if [ "$total_skip" -gt 0 ]; then
    printf ' (%d skipped)\n' "$total_skip"
  else
    printf '\n'
  fi

  if [ "$total_fail" -gt 0 ]; then
    printf '\nFailed tests: %s\n' "$failed_tests"
    if [ -n "$failed_levels" ]; then
      printf 'Failed levels: %s\n' "$failed_levels"
    fi
    printf '%s✗%s Some tests failed\n' "$_red" "$_reset"
    return 1
  fi

  if [ "$run_all" -eq 1 ]; then
    printf '\n%s✓%s Tested all (Level %d)\n' "$_green" "$_reset" "$last_success_level"
  else
    printf '\n%s✓%s All tests passed\n' "$_green" "$_reset"
  fi
  return 0
fi

printf 'No tests were run\n'
return 0
}

# Load castable imp for direct execution
if true; then
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
