#!/bin/sh
# Level-based test runner - tests spells by wizardry level (0-27)
#
# Responsibilities:
# - Run tests organized by spell level (following banish structure)
# - Auto-derive which tests to run from spell lists
# - Report failures in same format as original test-magic
# - Support banish → test-magic → demo-magic triad

# CRITICAL: Seed a baseline PATH BEFORE set -eu
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac

test_magic_usage() {
  cat <<USAGE
Usage: test-magic [LEVEL] [--only] [--verbose]

Execute behavior-driven shell tests organized by spell level.

Arguments:
  LEVEL        Test through level N (0-27), default is 27 (all levels)
  --only       Test only the specified level, not 0 through N
  --verbose    Show detailed test output

Examples:
  test-magic          # Test all levels (0-27)
  test-magic 5        # Test levels 0-5
  test-magic 10 --only  # Test only level 10

Environment variables:
  WIZARDRY_TEST_TIMEOUT    Timeout in seconds for each test (default: 180)
USAGE
}

test_magic() {
cmd_name=$(basename "$0")
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

# Parse arguments
target_level=27
only_this_level=0
verbose=0

while [ $# -gt 0 ]; do
  case "$1" in
    --help|--usage|-h)
      test_magic_usage
      return 0
      ;;
    --only)
      only_this_level=1
      shift
      ;;
    --verbose|-v)
      verbose=1
      shift
      ;;
    [0-9]|[0-9][0-9])
      target_level=$1
      shift
      ;;
    *)
      printf 'test-magic: unknown option: %s\n' "$1" >&2
      return 2
      ;;
  esac
done

set -eu
export PATH

# Validate level range
if [ "$target_level" -lt 0 ] || [ "$target_level" -gt 27 ]; then
  die "test-magic: level must be 0-27"
fi

# Sandbox with bwrap if not in GitHub Actions and not already sandboxed
if [ "${WIZARDRY_TEST_IN_BWRAP-0}" -ne 1 ] && [ "${WIZARDRY_TEST_NO_BWRAP-0}" -ne 1 ]; then
  # Skip bwrap in GitHub Actions (already isolated)
  if [ -z "${GITHUB_ACTIONS-}" ] || [ "${GITHUB_ACTIONS}" != "true" ]; then
    if command -v bwrap >/dev/null 2>&1; then
      # Re-exec with bwrap sandbox
      exec bwrap --unshare-user --ro-bind / / --dev-bind /dev /dev --bind /proc /proc \
        --bind /tmp /tmp --setenv PATH "$PATH" --setenv WIZARDRY_TEST_IN_BWRAP 1 -- \
        "$0" "$@"
    else
      # bwrap not available - offer to install
      printf 'test-magic: bubblewrap (bwrap) not found\n' >&2
      printf 'test-magic: Running tests in an isolated sandbox is recommended for safety.\n' >&2
      
      # Check if we can install it
      if command -v pkg-install >/dev/null 2>&1; then
        if command -v ask-yn >/dev/null 2>&1; then
          if ask-yn "Install bubblewrap now?" yes; then
            printf 'Installing bubblewrap...\n' >&2
            if pkg-install bubblewrap 2>/dev/null || pkg-install bwrap 2>/dev/null; then
              printf 'Bubblewrap installed successfully. Re-running test-magic...\n' >&2
              exec "$0" "$@"
            else
              printf 'test-magic: failed to install bubblewrap\n' >&2
            fi
          fi
        fi
      fi
      
      # Either install failed or user declined - ask to continue
      if command -v ask-yn >/dev/null 2>&1; then
        if ! ask-yn "Continue without sandbox?" no; then
          printf 'test-magic: aborting\n' >&2
          return 1
        fi
      else
        printf 'test-magic: continuing without sandbox (set WIZARDRY_TEST_NO_BWRAP=1 to skip this check)\n' >&2
      fi
    fi
  fi
fi

# Pre-flight checks
missing_commands=""
for required_cmd in sh find grep awk sed sort cat printf; do
  if ! has "$required_cmd"; then
    missing_commands="${missing_commands:+$missing_commands, }$required_cmd"
  fi
done

if [ -n "$missing_commands" ]; then
  die "test-magic: required commands not found: $missing_commands"
fi

# Check for test-spell
if [ ! -x "$root_dir/spells/system/test-spell" ]; then
  die "test-magic: test-spell not found"
fi

# Source spell-levels from sys imp to get access to get_level_spells and get_level_imps
# These functions define which spells/imps are at each level
if [ ! -f "$root_dir/spells/.imps/sys/spell-levels" ]; then
  die "test-magic: spell-levels imp not found"
fi
. "$root_dir/spells/.imps/sys/spell-levels"

# Initialize counters
total_pass=0
total_fail=0
failed_tests=""
failed_levels=""

# Test timeout
test_timeout=${WIZARDRY_TEST_TIMEOUT:-180}

# Helper: Map spell to test file
# Usage: spell_to_test "spell:dir" or "spell"
spell_to_test() {
  spell_info=$1
  case "$spell_info" in
    *:*)
      spell=$(printf '%s' "$spell_info" | cut -d: -f1)
      dir=$(printf '%s' "$spell_info" | cut -d: -f2)
      ;;
    *)
      spell=$spell_info
      dir="cantrips"
      ;;
  esac
  
  # Construct test path
  test_file="$test_dir/$dir/test-$spell.sh"
  
  if [ -f "$test_file" ]; then
    printf '%s\n' "$test_file"
  fi
}

# Helper: Run tests for a spell level
test_level() {
  level=$1
  level_name=$(banish_level_name "$level")
  
  printf '\n=== Level %d: %s ===\n' "$level" "$level_name"
  
  # Get spell list for this level
  spell_list=$(get_level_spells "$level")
  
  if [ -z "$spell_list" ]; then
    printf '  No spells defined for Level %d\n' "$level"
    return 0
  fi
  
  # Get imp list for this level (if any)
  imp_list=$(get_level_imps "$level" 2>/dev/null || printf '')
  
  # Track level statistics
  level_pass=0
  level_fail=0
  level_tests=""
  
  # Test each spell
  for spell_info in $spell_list; do
    test_file=$(spell_to_test "$spell_info")
    
    if [ -z "$test_file" ]; then
      # No test for this spell - that's okay for some spells
      continue
    fi
    
    test_name=$(basename "$test_file")
    test_path="${test_file#$root_dir/.tests/}"
    
    level_tests="${level_tests:+$level_tests }$test_name"
    
    # Run the test
    if [ "$verbose" -eq 1 ]; then
      printf '  Running %s...\n' "$test_name"
    fi
    
    # Use timeout if available
    if has timeout; then
      if timeout "$test_timeout" "$root_dir/spells/system/test-spell" \
         --skip-common "$test_path" </dev/null >/dev/null 2>&1; then
        test_result=0
      else
        test_result=1
      fi
    else
      if "$root_dir/spells/system/test-spell" --skip-common "$test_path" \
         </dev/null >/dev/null 2>&1; then
        test_result=0
      else
        test_result=1
      fi
    fi
    
    if [ "$test_result" = "0" ]; then
      level_pass=$((level_pass + 1))
      if [ "$verbose" -eq 1 ]; then
        printf '    ✓ PASS\n'
      fi
    else
      level_fail=$((level_fail + 1))
      failed_tests="${failed_tests:+$failed_tests }$test_name"
      if [ "$verbose" -eq 1 ]; then
        printf '    ✗ FAIL\n'
      fi
    fi
  done
  
  # Test imps if any
  for imp in $imp_list; do
    # Imps are in .imps directory, need to find the family
    # Format is typically family/imp-name
    test_file="$test_dir/.imps/$imp"
    test_file="${test_file%/*}/test-$(basename "$imp").sh"
    
    if [ ! -f "$test_file" ]; then
      continue
    fi
    
    test_name=$(basename "$test_file")
    test_path="${test_file#$root_dir/.tests/}"
    
    level_tests="${level_tests:+$level_tests }$test_name"
    
    if [ "$verbose" -eq 1 ]; then
      printf '  Running %s...\n' "$test_name"
    fi
    
    # Use timeout if available
    if has timeout; then
      if timeout "$test_timeout" "$root_dir/spells/system/test-spell" \
         --skip-common "$test_path" </dev/null >/dev/null 2>&1; then
        test_result=0
      else
        test_result=1
      fi
    else
      if "$root_dir/spells/system/test-spell" --skip-common "$test_path" \
         </dev/null >/dev/null 2>&1; then
        test_result=0
      else
        test_result=1
      fi
    fi
    
    if [ "$test_result" = "0" ]; then
      level_pass=$((level_pass + 1))
      if [ "$verbose" -eq 1 ]; then
        printf '    ✓ PASS\n'
      fi
    else
      level_fail=$((level_fail + 1))
      failed_tests="${failed_tests:+$failed_tests }$test_name"
      if [ "$verbose" -eq 1 ]; then
        printf '    ✗ FAIL\n'
      fi
    fi
  done
  
  # Report level results
  level_total=$((level_pass + level_fail))
  if [ "$level_total" -gt 0 ]; then
    if [ "$level_fail" -eq 0 ]; then
      printf '  ✓ Level %d: %d/%d tests passed\n' "$level" "$level_pass" "$level_total"
    else
      printf '  ✗ Level %d: %d/%d tests passed (%d failed)\n' "$level" "$level_pass" "$level_total" "$level_fail"
      failed_levels="${failed_levels:+$failed_levels }$level"
    fi
    
    total_pass=$((total_pass + level_pass))
    total_fail=$((total_fail + level_fail))
  else
    printf '  No tests found for Level %d\n' "$level"
  fi
}

# Main execution
if [ "$only_this_level" -eq 1 ]; then
  printf '=== Testing Wizardry Level %d ===\n' "$target_level"
  test_level "$target_level"
else
  printf '=== Testing Wizardry Levels 0-%d ===\n' "$target_level"
  level=0
  while [ "$level" -le "$target_level" ]; do
    test_level "$level"
    level=$((level + 1))
  done
fi

# Final summary
printf '\n=== Test Summary ===\n'
total=$((total_pass + total_fail))
if [ "$total" -gt 0 ]; then
  printf 'Total: %d/%d tests passed\n' "$total_pass" "$total"
  
  if [ "$total_fail" -gt 0 ]; then
    printf '\nFailed tests: %s\n' "$failed_tests"
    if [ -n "$failed_levels" ]; then
      printf 'Failed levels: %s\n' "$failed_levels"
    fi
    return 1
  else
    printf '\n✓ All tests passed!\n'
    return 0
  fi
else
  printf 'No tests were run\n'
  return 0
fi
}

# Load castable imp for direct execution
if true; then
  _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
  _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
  [ -f "$_i/castable" ] && . "$_i/castable"
fi

castable "$@"
