#!/bin/sh
# Entrypoint for running the project test suite from the system menu, CLI, or CI.
#
# Responsibilities:
# - Provide the full test runner logic in a single spell.
# - Discover tests, filter them, and report coverage in the expected format.

# CRITICAL: Seed a baseline PATH BEFORE set -eu and before any commands
# On macOS GitHub Actions, PATH may be completely empty, causing immediate failure
# when we try to use basename, dirname, cd, pwd, find, sort, awk, etc.
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*)
    # Already has at least one standard directory
    ;;
  *)
    # PATH is empty or missing standard directories, prepend baseline
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac

show_usage() {
  cat <<USAGE
Usage: $cmd_name [--only PATTERN] [--list] [--verbose]

Execute the behavior-driven shell tests located in .tests/.
USAGE
}

cmd_name=$(basename "$0")
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH so we can use them directly
# This allows running test-magic directly without wizardry being installed
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

export PATH

# Source test boot imps for standardized output functions
for boot_imp in "$root_dir"/spells/.imps/test/boot/*; do
  [ -f "$boot_imp" ] || continue
  # shellcheck source=/dev/null
  . "$boot_imp"
done

only_patterns=""
list_only=0
verbose=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "$cmd_name: --only requires a pattern" >&2
        show_usage
        exit 1
      fi
      if [ -n "$only_patterns" ]; then
        only_patterns="$only_patterns\n$2"
      else
        only_patterns="$2"
      fi
      shift 2
      ;;
    --list)
      list_only=1
      shift
      ;;
    --verbose)
      verbose=1
      shift
      ;;
    --help|--usage|-h)
      show_usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "$cmd_name: unknown option '$1'" >&2
      show_usage
      exit 1
      ;;
  esac
done

find_tests() {
  # Return tests in prefix order: root-level tests first, then subdirectories
  # This ensures common-tests.sh runs before all other tests
  {
    find "$test_dir" -maxdepth 1 -type f \( -name 'test-*.sh' -o -name 'common-*.sh' \) | sort
    find "$test_dir" -mindepth 2 -type f -name 'test-*.sh' | sort
  }
}

pattern_has_match() {
  pattern=$1
  found=1
  while IFS= read -r path; do
    [ -n "$path" ] || continue
    rel=${path#"$test_dir/"}
    case $rel in
      $pattern)
        found=0
        break
        ;;
    esac
  done <<EOF_TESTS
$(find_tests)
EOF_TESTS
  return $found
}

matches_patterns() {
  rel=$1
  if [ -z "$only_patterns" ]; then
    return 0
  fi
  match=1
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    case $rel in
      $pat)
        match=0
        break
        ;;
    esac
  done <<EOF_PATS
$(printf '%b' "$only_patterns")
EOF_PATS
  return $match
}

test_files=""

if [ -n "$only_patterns" ]; then
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    if ! pattern_has_match "$pat"; then
      echo "$cmd_name: pattern '$pat' matched no tests" >&2
      exit 1
    fi
  done <<EOF_PATS
$(printf '%b' "$only_patterns")
EOF_PATS
fi

# Write test paths directly to a file to avoid shell variable size limitations  
test_list_file=$(temp-file test-magic-list) || exit 1

{
  while IFS= read -r path; do
    short=${path#"$test_dir/"}
    if matches_patterns "$short"; then
      printf '%s\n' "$short"
    fi
  done <<EOF_TESTS
$(find_tests)
EOF_TESTS
} > "$test_list_file"

if [ ! -s "$test_list_file" ]; then
  echo "$cmd_name: no tests discovered." >&2
  cleanup-file "$test_list_file"
  exit 1
fi

if [ "$list_only" -eq 1 ]; then
  cat "$test_list_file"
  cleanup-file "$test_list_file"
  exit 0
fi

spell_path_for_test() {
  test_path=$1
  rel=${test_path#"$test_dir/"}
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test-}
  base=${base%.*}
  printf '%s/%s/%s\n' "$root_dir" "spells/$dir" "$base"
}

record_subtests() {
  counts=$(printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      passed += parts[1]
      total += parts[2]
      next
    }
    /^FAIL_DETAIL:/ { next }
    END { print (passed+0) " " (total+0) }
  ')

  set -- $counts
  if [ "$#" -eq 2 ]; then
    subtests_passed=$((subtests_passed + $1))
    subtests_total=$((subtests_total + $2))
  fi
}

status=0
pass=0
fail=0
subtests_passed=0
subtests_total=0
global_subtest_num=0
failed_scripts=""
incomplete_tests=""
incomplete_count=0
test_number=0

# Initialize global subtest counter for all tests
WIZARDRY_GLOBAL_SUBTEST_NUM=0
export WIZARDRY_GLOBAL_SUBTEST_NUM

# test_list_file was already created and populated above
test_total=$(grep -c . "$test_list_file")

# Imps have no --help flag, so they need 2 subtests minimum.
# Spells have a --help flag which needs testing, plus 2 additional subtests.
MIN_SUBTESTS_IMP=2
MIN_SUBTESTS_SPELL=3
failure_output_file=$(temp-file test-magic) || exit 1
trap 'cleanup-file "$failure_output_file"; cleanup-file "$test_list_file"' EXIT HUP INT TERM

spell_name_for_test() {
  test_path=$1
  
  # Special case: common-tests.sh should display as "common tests"
  case "$test_path" in
    */common-tests.sh|common-tests.sh)
      printf '%s\n' "common tests"
      return
      ;;
  esac
  
  spell_path=$(spell_path_for_test "$test_path" 2>/dev/null || true)

  if [ -n "$spell_path" ]; then
    printf '%s\n' "$(basename "$spell_path")"
    return
  fi

  base=${test_path##*/}
  base=${base#test-}
  base=${base%.sh}
  printf '%s\n' "$base"
}

print_failure_debug() {
  test_path=$1
  output=$2

  spell_name=$(spell_name_for_test "$test_path")
  printf '=== %s ===\n' "$spell_name"
  # Only show FAIL lines and their debug output (skip PASS lines)
  printf '%s\n' "$output" | awk '
    /^PASS / { next }
    /^[0-9]+\/[0-9]+ tests passed/ { next }
    /^FAIL_DETAIL:/ { next }
    /^$/ { next }
    { print }
  '
}

record_failed_script() {
  script=$1
  numbers=$2

  name=$(spell_name_for_test "$script")

  if [ -n "$numbers" ]; then
    entry="$name ($numbers)"
  else
    entry="$name"
  fi

  if [ -n "$failed_scripts" ]; then
    failed_scripts="$failed_scripts, $entry"
  else
    failed_scripts="$entry"
  fi
}

# Extract the total subtest count from test output.
# $1 - test output containing "X/Y tests passed" summary line
# Returns the total (Y) from the summary, or 0 if no summary found.
get_subtest_total() {
  printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      print parts[2]
      exit
    }
    END { if (!NR) print 0 }
  '
}

# Check if test output contains a --help test case.
# Looks for test case lines (PASS/FAIL) that mention help or usage.
# $1 - test output
# Returns 0 if help test found, 1 otherwise.
has_help_test() {
  printf '%s\n' "$1" | grep -qiE "(PASS|FAIL).*(--help|-h|help|usage)"
}

# Record a test that has fewer than required subtests or is missing help test.
# $1 - test path
# $2 - reason (e.g., "2 subtests" or "missing --help test")
record_incomplete_test() {
  test_path=$1
  reason=$2
  name=$(spell_name_for_test "$test_path")
  entry="$name ($reason)"
  if [ -n "$incomplete_tests" ]; then
    incomplete_tests="$incomplete_tests, $entry"
  else
    incomplete_tests="$entry"
  fi
}

# Open file descriptor 3 for reading the test list
exec 3< "$test_list_file"

while IFS= read -r test_path <&3; do
  [ -n "$test_path" ] || continue
  abs="$test_dir/$test_path"
  test_number=$((test_number + 1))
  
  # Reset subtest counter for each new test
  WIZARDRY_GLOBAL_SUBTEST_NUM=0
  export WIZARDRY_GLOBAL_SUBTEST_NUM
  
  # Skip tests marked COMPILED_UNSUPPORTED when testing compiled spells
  if [ "${WIZARDRY_TEST_COMPILED-0}" = "1" ]; then
    if head -n 5 "$abs" 2>/dev/null | grep -q "^# COMPILED_UNSUPPORTED"; then
      spell_name=$(spell_name_for_test "$test_path")
      _test_heading "$test_number" "$test_total" "$spell_name (skipped: unsupported in compiled mode)"
      continue
    fi
  fi
  
  spell_name=$(spell_name_for_test "$test_path")
  _test_heading "$test_number" "$test_total" "$spell_name"

  # Always run test and collect full output
  if output=$(sh "$abs" 2>&1); then
    pass=$((pass + 1))
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    # In verbose mode, show all PASS lines
    if [ "$verbose" -eq 1 ]; then
      printf '%s\n' "$cleaned_output" | sed 's/^/  /'
    fi
  else
    status=1
    fail=$((fail + 1))
    numbers=$(printf '%s\n' "$output" | awk -F ':' '
      /^FAIL_DETAIL:/ {
        if (NF >= 2) {
          n = split($2, parts, ",")
          for (i = 1; i <= n; i++) {
            idx = parts[i]
            gsub(/^ +| +$/, "", idx)
            if (idx ~ /^[0-9]+$/) {
              order[++count] = idx
            }
          }
        }
        next
      }
      END {
        for (i = 1; i <= count; i++) {
          if (i > 1) {
            printf(", ")
          }
          printf("%s", order[i])
        }
        printf("\n")
      }
    ' | sed 's/[[:space:]]*$//')
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    record_failed_script "$test_path" "$numbers"
    
    # Store full output for later detailed display
    {
      printf '=== %s ===\n' "$test_path"
      printf '%s\n\n' "$cleaned_output"
    } >>"$failure_output_file"
    
    # In verbose mode, show only FAIL lines inline
    if [ "$verbose" -eq 1 ]; then
      printf '%s\n' "$cleaned_output" | awk '
        /^FAIL / { print "  " $0 }
        /^LACK / { print "  " $0 }
      '
    fi
  fi

  # Check minimum subtest requirements based on test type.
  # Imps (in .imps/): Need MIN_SUBTESTS_IMP subtests (no --help).
  # Spells: Need a --help test PLUS MIN_SUBTESTS_IMP additional behavioral subtests.
  # Global tests (test-install.sh, test-suite.sh): Exempt from --help requirement.
  test_subtest_count=$(get_subtest_total "$cleaned_output")
  test_incomplete_reasons=""
  case "$test_path" in
    .imps/*|*/.imps/*)
      # Imps have no --help, just need MIN_SUBTESTS_IMP subtests
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    test-install.sh|test-suite.sh)
      # Global/special tests don't need --help test
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    *)
      # Spells need a --help test plus additional behavioral subtests.
      # Total must be at least MIN_SUBTESTS_SPELL (1 help + 2 behavioral = 3).
      if ! has_help_test "$cleaned_output"; then
        record_incomplete_test "$test_path" "missing --help test"
        test_incomplete_reasons="missing --help test"
      fi
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_SPELL" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        if [ -n "$test_incomplete_reasons" ]; then
          test_incomplete_reasons="$test_incomplete_reasons; $test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        else
          test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        fi
      fi
      ;;
  esac

  # Print inline incomplete warning using LACK (not PASS/FAIL)
  if [ -n "$test_incomplete_reasons" ]; then
    incomplete_count=$((incomplete_count + 1))
    _test_lack "$(spell_name_for_test "$test_path")" "$test_incomplete_reasons"
  fi

  printf '\n'
done

# Close file descriptor 3
exec 3<&-

find_matching_test_for_spell() {
  spell=$1
  rel=${spell#"$root_dir/"}
  rel=${rel#spells/}
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  candidate_sh="$test_dir/$dir/test-${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi
  return 1
}

scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=""

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$root_dir/"}
    case $rel in
      spells/system/test-magic|spells/system/verify-posix)
        continue
        ;;
      *.service|*.gitkeep|*.gitignore)
        # Skip non-script files
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null 2>&1; then
      coverage_covered=$((coverage_covered + 1))
    else
      if [ -n "$uncovered_spells" ]; then
        uncovered_spells=$(printf '%s\n%s' "$uncovered_spells" "$rel")
      else
        uncovered_spells="$rel"
      fi
    fi
  done <<EOF_SPELLS
$(cd "$root_dir" && find spells -type f | sort)
EOF_SPELLS
}

scan_extraneous() {
  extraneous_files=""
  
  while IFS= read -r test_file; do
    [ -n "$test_file" ] || continue
    
    # Skip test-suite.sh
    case $test_file in
      */test-suite.sh) continue ;;
    esac
    
    # Extract spell path from test path
    rel=${test_file#"$test_dir/"}
    dir=$(dirname "$rel")
    base=$(basename "$rel")
    # Remove test- prefix and .sh suffix
    base=${base#test-}
    base=${base%.sh}
    
    # Handle special cases for install tests (test the root install script)
    # The install script is in the repo root (not spells/) so its test can be:
    # 1. .tests/test-install.sh (dir="." base="install") 
    # 2. .tests/install/test-install.sh (dir="install" base="install")
    case "$base" in
      install|install-with-old-version)
        if [ "$dir" = "install" ] || [ "$dir" = "." ]; then
          if [ -f "$root_dir/install" ]; then
            continue
          fi
        fi
        ;;
    esac
    
    spell_path="$root_dir/spells/$dir/$base"
    
    if [ ! -f "$spell_path" ]; then
      if [ -n "$extraneous_files" ]; then
        extraneous_files=$(printf '%s\n%s' "$extraneous_files" ".tests/$rel")
      else
        extraneous_files=".tests/$rel"
      fi
    fi
  done <<EOF_TESTS
$(find "$test_dir" -type f -name 'test-*.sh' | sort)
EOF_TESTS
}

scan_coverage
scan_extraneous
coverage_uncovered=$((coverage_total - coverage_covered))

total_scripts=$((pass + fail))

printf '\n'
heading-section "Summary"
printf 'Tests: %d passed, %d failed, %d total\n' "$pass" "$fail" "$total_scripts"
printf 'Subtests: %d passed, %d total\n' "$subtests_passed" "$subtests_total"
if [ "$coverage_uncovered" -gt 0 ]; then
  printf 'Coverage: %d uncovered\n' "$coverage_uncovered"
fi
if [ "$incomplete_count" -gt 0 ]; then
  printf 'Incomplete: %d tests\n' "$incomplete_count"
fi
printf '\n'

if [ "$coverage_uncovered" -gt 0 ]; then
  printf 'Uncovered spells:\n'
  printf '  %s\n' "$uncovered_spells"
  status=1
fi

if [ -n "$extraneous_files" ] && [ "${WIZARDRY_TEST_COMPILED-0}" != "1" ]; then
  printf 'Extraneous test files (no corresponding spell):\n'
  printf '  %s\n' "$extraneous_files"
  status=1
fi

if [ -n "$incomplete_tests" ] && [ "${WIZARDRY_TEST_COMPILED-0}" != "1" ]; then
  printf 'Incomplete tests (imps need %d+ subtests, spells need %d+ including --help):\n' "$MIN_SUBTESTS_IMP" "$MIN_SUBTESTS_SPELL"
  printf '  %s\n' "$incomplete_tests"
  status=1
fi

# Show detailed failure output for â‰¤12 failures
if [ "$status" -ne 0 ] && [ -n "$failed_scripts" ]; then
  show_failure_output=0
  if [ "$fail" -le 12 ] && [ -s "$failure_output_file" ]; then
    show_failure_output=1
  fi

  if [ "$show_failure_output" -eq 1 ]; then
    printf '\n'
    heading-section "Failure Details (showing $fail)"
    while IFS= read -r line; do
      case $line in
        "=== "*)
          # Extract test path from "=== test_path ===" format
          test_path=$(printf '%s' "$line" | sed 's/^=== //; s/ ===$//')
          spell_name=$(spell_name_for_test "$test_path")
          printf '\n=== %s ===\n' "$spell_name"
          ;;
        "PASS "*)
          # Skip PASS lines in detailed failure output
          ;;
        *[0-9]*/[0-9]*" tests passed"*)
          # Skip summary lines
          ;;
        "")
          # Skip empty lines
          ;;
        *)
          # Show FAIL lines and debug output
          printf '%s\n' "$line"
          ;;
      esac
    done <"$failure_output_file"
  elif [ "$fail" -gt 12 ]; then
    printf '\nToo many failures (%d > 12); detailed output suppressed.\n' "$fail"
  fi

  detect_os_label() {
    if [ -n "${WIZARDRY_OS_LABEL-}" ]; then
      printf '%s\n' "$WIZARDRY_OS_LABEL"
      return 0
    fi

    if [ -x "$root_dir/spells/divination/detect-distro" ]; then
      if label=$("$root_dir/spells/divination/detect-distro" 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v detect-distro >/dev/null 2>&1; then
      if label=$(detect-distro 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v uname >/dev/null 2>&1; then
      label=$(uname -s 2>/dev/null || true)
      label=$(printf '%s' "$label" | tr ' A-Z' '_a-z')
      if [ -n "$label" ]; then
        printf '%s\n' "$label"
        return 0
      fi
    fi

    printf 'unknown\n'
  }

  os_label=$(detect_os_label)
  printf '\nFailed tests (%s): %s\n' "$os_label" "$failed_scripts"
fi

trap - EXIT HUP INT TERM
cleanup-file "$failure_output_file"

exit $status
