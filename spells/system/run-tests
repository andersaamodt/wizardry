#!/bin/sh

set -eu

usage() {
  cat <<'USAGE'
Usage: run-tests [options]

Execute the behavior-driven shell tests located in tests/.
Options:
  --only PATTERN   Run tests whose path under tests/ matches PATTERN.
  --list           Print the resolved test files and exit.
  --verbose        Print per-test output while running.
  -h, --help       Show this help and exit.
USAGE
}

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/tests"

only_patterns=""
list_only=0
verbose=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "run-tests: --only requires a pattern" >&2
        usage
        exit 1
      fi
      if [ -n "$only_patterns" ]; then
        only_patterns="$only_patterns\n$2"
      else
        only_patterns="$2"
      fi
      shift 2
      ;;
    --list)
      list_only=1
      shift
      ;;
    --verbose)
      verbose=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "run-tests: unknown option '$1'" >&2
      usage
      exit 1
      ;;
  esac
done

find_tests() {
  find "$test_dir" -type f -name 'test_*.sh' | sort
}

pattern_has_match() {
  pattern=$1
  found=1
  while IFS= read -r path; do
    [ -n "$path" ] || continue
    case $path in
      */lib/*) continue ;;
    esac
    rel=${path#"$test_dir/"}
    case $rel in
      $pattern)
        found=0
        break
        ;;
    esac
  done <<EOF_TESTS
$(find_tests)
EOF_TESTS
  return $found
}

matches_patterns() {
  rel=$1
  if [ -z "$only_patterns" ]; then
    return 0
  fi
  match=1
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    case $rel in
      $pat)
        match=0
        break
        ;;
    esac
  done <<EOF_PATS
$only_patterns
EOF_PATS
  return $match
}

test_files=""

if [ -n "$only_patterns" ]; then
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    if ! pattern_has_match "$pat"; then
      echo "run-tests: pattern '$pat' matched no tests" >&2
      exit 1
    fi
  done <<EOF_PATS
$only_patterns
EOF_PATS
fi

while IFS= read -r path; do
  case $path in
    */lib/*) continue ;;
  esac
  short=${path#"$test_dir/"}
  case $short in
    test_common.sh) continue ;;
  esac
  if matches_patterns "$short"; then
    if [ -n "$test_files" ]; then
      test_files=$(printf '%s\n%s' "$test_files" "$short")
    else
      test_files="$short"
    fi
  fi
done <<EOF_TESTS
$(find_tests)
EOF_TESTS

if [ -z "$test_files" ]; then
  echo "run-tests: no tests discovered." >&2
  exit 1
fi

if [ "$list_only" -eq 1 ]; then
  printf '%s\n' "$test_files"
  exit 0
fi

spell_path_for_test() {
  test_path=$1
  rel=${test_path#"$test_dir/"}
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$root_dir" "spells/$dir" "$base"
}

record_subtests() {
  counts=$(printf '%s\n' "$1" | awk '
    /tests passed$/ {split($1,a,"/"); passed+=a[1]; total+=a[2]; next}
    /tests failed,/ {split($1,a,"/"); total+=a[2]; passed+=$4}
    END {print (passed+0) " " (total+0)}
  ')

  set -- $counts
  if [ "$#" -eq 2 ]; then
    subtests_passed=$((subtests_passed + $1))
    subtests_total=$((subtests_total + $2))
  fi
}

status=0
pass=0
fail=0
subtests_passed=0
subtests_total=0
failed_scripts=""

spell_name_for_test() {
  test_path=$1
  spell_path=$(spell_path_for_test "$test_path" 2>/dev/null || true)

  if [ -n "$spell_path" ]; then
    printf '%s\n' "$(basename "$spell_path")"
    return
  fi

  base=${test_path##*/}
  base=${base#test_}
  base=${base%.sh}
  printf '%s\n' "$base"
}

record_failed_script() {
  script=$1
  numbers=$2

  name=$(spell_name_for_test "$script")

  if [ -n "$numbers" ]; then
    entry="$name ($numbers)"
  else
    entry="$name"
  fi

  if [ -n "$failed_scripts" ]; then
    failed_scripts="$failed_scripts, $entry"
  else
    failed_scripts="$entry"
  fi
}

while IFS= read -r test_path; do
  [ -n "$test_path" ] || continue
  abs="$test_dir/$test_path"
  if [ "$verbose" -eq 1 ]; then
    printf 'Running %s\n' "$test_path"
  fi

  if output=$(sh "$abs" 2>&1); then
    pass=$((pass + 1))
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    [ "$verbose" -eq 1 ] && printf '%s\n' "$cleaned_output" | sed 's/^/  /'
  else
    status=1
    fail=$((fail + 1))
    numbers=$(printf '%s\n' "$output" | awk -F ':' '
      /^FAIL_DETAIL:/ {
        if (NF >= 2) {
          n = split($2, parts, ",")
          for (i = 1; i <= n; i++) {
            idx = parts[i]
            gsub(/^ +| +$/, "", idx)
            if (idx ~ /^[0-9]+$/) {
              order[++count] = idx
            }
          }
        }
        next
      }
      END {
        for (i = 1; i <= count; i++) {
          if (i > 1) {
            printf(", ")
          }
          printf("%s", order[i])
        }
        printf("\n")
      }
    ' | sed 's/[[:space:]]*$//')
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    record_failed_script "$test_path" "$numbers"
    printf '%s\n' "$cleaned_output" | sed 's/^/  /'
  fi
  printf '\n'
done <<EOF_TESTS
$test_files
EOF_TESTS

find_matching_test_for_spell() {
  spell=$1
  rel=${spell#"$root_dir/"}
  rel=${rel#spells/}
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  candidate_sh="$test_dir/$dir/test_${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi
  return 1
}

scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=""

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$root_dir/"}
    case $rel in
      spells/system/test-magic|spells/system/verify-posix|spells/system/run-tests)
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null 2>&1; then
      coverage_covered=$((coverage_covered + 1))
    else
      if [ -n "$uncovered_spells" ]; then
        uncovered_spells=$(printf '%s\n%s' "$uncovered_spells" "$rel")
      else
        uncovered_spells="$rel"
      fi
    fi
  done <<EOF_SPELLS
$(cd "$root_dir" && find spells -type f | sort)
EOF_SPELLS
}

scan_coverage
coverage_uncovered=$((coverage_total - coverage_covered))

total_scripts=$((pass + fail))
printf 'Summary: %d passed, %d failed, %d uncovered, subtests %d/%d.\n' \
  "$pass" "$fail" "$coverage_uncovered" "$subtests_passed" "$subtests_total"

if [ "$coverage_uncovered" -gt 0 ]; then
  printf 'Uncovered spells:\n'
  printf '  %s\n' "$uncovered_spells"
fi

if [ "$status" -ne 0 ] && [ -n "$failed_scripts" ]; then
  detect_os_label() {
    if [ -n "${WIZARDRY_OS_LABEL-}" ]; then
      printf '%s\n' "$WIZARDRY_OS_LABEL"
      return 0
    fi

    if [ -x "$root_dir/spells/divination/detect-distro" ]; then
      if label=$("$root_dir/spells/divination/detect-distro" 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v detect-distro >/dev/null 2>&1; then
      if label=$(detect-distro 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v uname >/dev/null 2>&1; then
      label=$(uname -s 2>/dev/null || true)
      label=$(printf '%s' "$label" | tr ' A-Z' '_a-z')
      if [ -n "$label" ]; then
        printf '%s\n' "$label"
        return 0
      fi
    fi

    printf 'unknown\n'
  }

  os_label=$(detect_os_label)
  printf 'Failed tests (%s): %s\n' "$os_label" "$failed_scripts"
fi

exit $status
