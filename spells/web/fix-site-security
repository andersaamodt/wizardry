#!/bin/sh

# Ensure per-site user exists and fix directory permissions.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: fix-site-security SITENAME

Ensures a per-site user exists and tightens permissions for:
  - site directory
  - .sitedata directory
  - allowlisted directories from site.allowlist

Example: web-fix-site-security mysite
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

site_name=${1-}
if [ -z "$site_name" ]; then
  die 2 "fix-site-security: SITENAME required"
fi

WEB_ROOT=${WEB_WIZARDRY_ROOT:-$HOME/sites}
SITES_DIR="$WEB_ROOT"
SITE_DIR="$SITES_DIR/$site_name"
SITE_DATA_DIR="$SITES_DIR/.sitedata/$site_name"
SITE_CONFIG="$SITE_DIR/site.conf"
ALLOWLIST_FILE="$SITE_DIR/site.allowlist"

if [ ! -d "$SITE_DIR" ]; then
  die "fix-site-security: site '$site_name' not found"
fi

run_priv() {
  if [ "$(id -u)" -eq 0 ]; then
    "$@"
    return
  fi

  if has sudo; then
    sudo "$@"
    return
  fi

  die "fix-site-security: root or sudo is required"
}

site_user_default="ww_$(printf '%s' "$site_name" | tr 'A-Z' 'a-z' | tr '-' '_')"
site_user=$(config-get "$SITE_CONFIG" site-user 2>/dev/null || printf '')
if [ -z "$site_user" ]; then
  site_user="$site_user_default"
  if [ -w "$SITE_CONFIG" ]; then
    config-set "$SITE_CONFIG" site-user "$site_user"
  elif [ "$(id -u)" -eq 0 ] || has sudo; then
    run_priv config-set "$SITE_CONFIG" site-user "$site_user"
  else
    warn "fix-site-security: cannot update site.conf without root or sudo"
  fi
fi
site_group="$site_user"

group_exists() {
  if [ "$(uname -s 2>/dev/null)" = "Darwin" ] && has dscl; then
    dscl . -read "/Groups/$1" >/dev/null 2>&1
    return $?
  fi
  if has getent; then
    getent group "$1" >/dev/null 2>&1
    return $?
  fi
  grep -q "^$1:" /etc/group 2>/dev/null
}

ensure_site_group() {
  if [ "$(uname -s 2>/dev/null)" != "Darwin" ] || ! has dscl; then
    return 0
  fi
  if group_exists "$site_group"; then
    return 0
  fi

  max_gid=$(dscl . -list /Groups PrimaryGroupID 2>/dev/null | awk '{print $2}' | sort -n | tail -1)
  case "$max_gid" in
    ''|*[!0-9]*) max_gid=500 ;;
  esac
  gid=$((max_gid + 1))

  run_priv dscl . -create "/Groups/$site_group"
  run_priv dscl . -create "/Groups/$site_group" PrimaryGroupID "$gid"
  run_priv dscl . -create "/Groups/$site_group" RealName "Wizardry Site $site_name"
  run_priv dscl . -create "/Groups/$site_group" GroupMembership "$site_user"
  run_priv dscl . -create "/Users/$site_user" PrimaryGroupID "$gid"
}

ensure_staff_membership() {
  if [ "$(uname -s 2>/dev/null)" != "Darwin" ] || ! has dscl; then
    return 0
  fi
  run_priv dscl . -append /Groups/staff GroupMembership "$site_user" >/dev/null 2>&1 || true
}

ensure_site_user() {
  if id -u "$site_user" >/dev/null 2>&1; then
    return 0
  fi

  if [ "$(uname -s 2>/dev/null)" = "Darwin" ] && has dscl; then
    max_uid=$(dscl . -list /Users UniqueID 2>/dev/null | awk '{print $2}' | sort -n | tail -1)
    case "$max_uid" in
      ''|*[!0-9]*) max_uid=500 ;;
    esac
    uid=$((max_uid + 1))
    max_gid=$(dscl . -list /Groups PrimaryGroupID 2>/dev/null | awk '{print $2}' | sort -n | tail -1)
    case "$max_gid" in
      ''|*[!0-9]*) max_gid=500 ;;
    esac
    gid=$((max_gid + 1))
    run_priv dscl . -create "/Users/$site_user"
    run_priv dscl . -create "/Users/$site_user" UserShell /usr/sbin/nologin
    run_priv dscl . -create "/Users/$site_user" RealName "Wizardry Site $site_name"
    run_priv dscl . -create "/Users/$site_user" UniqueID "$uid"
    run_priv dscl . -create "/Groups/$site_user"
    run_priv dscl . -create "/Groups/$site_user" PrimaryGroupID "$gid"
    run_priv dscl . -create "/Groups/$site_user" RealName "Wizardry Site $site_name"
    run_priv dscl . -create "/Groups/$site_user" GroupMembership "$site_user"
    run_priv dscl . -create "/Users/$site_user" PrimaryGroupID "$gid"
    run_priv dscl . -create "/Users/$site_user" NFSHomeDirectory /var/empty
    return 0
  fi

  useradd_supports() {
    flag=$1
    if useradd --help 2>&1 | grep -q -- " $flag"; then
      return 0
    fi
    useradd -h 2>&1 | grep -q -- " $flag"
  }

  if has useradd; then
    if useradd_supports -m && useradd_supports -s; then
      run_priv useradd -m -s /usr/sbin/nologin "$site_user"
    elif useradd_supports -m; then
      run_priv useradd -m "$site_user"
    elif useradd_supports -s; then
      run_priv useradd -s /usr/sbin/nologin "$site_user"
    else
      run_priv useradd "$site_user"
    fi
    return 0
  fi

  if has adduser; then
    run_priv adduser --disabled-login --gecos "" --shell /usr/sbin/nologin "$site_user"
    return 0
  fi

  die "fix-site-security: unable to create user '$site_user' (missing useradd/adduser)"
}

set_secure_perms() {
  target=$1
  if [ ! -e "$target" ]; then
    return 0
  fi

  run_priv find "$target" -type d -exec chmod 750 {} +
  run_priv find "$target" -type f -exec chmod 640 {} +
}

apply_allowlist() {
  if [ ! -f "$ALLOWLIST_FILE" ]; then
    return 0
  fi

  while IFS= read -r line || [ -n "$line" ]; do
    line=$(printf '%s' "$line" | sed 's/#.*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    [ -z "$line" ] && continue

    case "$line" in
      /*) ;;
      *)
        warn "fix-site-security: allowlist path must be absolute: $line"
        continue
        ;;
    esac

    if [ ! -e "$line" ]; then
      warn "fix-site-security: allowlist path not found: $line"
      continue
    fi

    run_priv chown -R "$site_user":"$site_group" "$line"
    set_secure_perms "$line"
  done < "$ALLOWLIST_FILE"
}

ensure_site_user
ensure_site_group
ensure_staff_membership
if [ "$(uname -s 2>/dev/null)" = "Darwin" ] && ! group_exists "$site_group"; then
  site_group=staff
fi

# Determine the actual user (non-site user) who should own source files
# If running via sudo, use SUDO_USER; otherwise use current user
actual_user="${SUDO_USER:-$(id -un)}"
# Don't use site user as actual user
if [ "$actual_user" = "$site_user" ]; then
  # If we can't determine actual user, check who owns site.conf
  if [ -f "$SITE_CONFIG" ]; then
    # Try stat (Linux and BSD/macOS have different syntax)
    if command -v stat >/dev/null 2>&1; then
      # Try GNU stat first (Linux)
      actual_user=$(stat -c '%U' "$SITE_CONFIG" 2>/dev/null) || \
        # Try BSD stat (macOS)
        actual_user=$(stat -f '%Su' "$SITE_CONFIG" 2>/dev/null) || \
        # Fallback to ls parsing if stat fails
        actual_user=$(ls -ld "$SITE_CONFIG" 2>/dev/null | awk '{print $3}')
    else
      # No stat available, use ls
      actual_user=$(ls -ld "$SITE_CONFIG" 2>/dev/null | awk '{print $3}')
    fi
  fi
fi

run_priv mkdir -p "$SITES_DIR/.sitedata" "$SITE_DATA_DIR"
run_priv mkdir -p "$SITE_DIR/build" "$SITE_DIR/nginx"

# Create .web-libs directory if it doesn't exist and make it writable by site user
if [ ! -d "$SITE_DIR/.web-libs" ]; then
  mkdir -p "$SITE_DIR/.web-libs" 2>/dev/null || run_priv mkdir -p "$SITE_DIR/.web-libs"
fi
# Set ownership on .web-libs if it exists
if [ -d "$SITE_DIR/.web-libs" ]; then
  run_priv chown -R "$site_user":"$site_group" "$SITE_DIR/.web-libs"
  run_priv chmod -R 755 "$SITE_DIR/.web-libs"
fi

# Set ownership based on who needs to write vs who needs to read
# - build/: actual user builds, site user (nginx) reads → actual user owns
# - nginx/: actual user (configure-nginx) writes, site user reads → actual user owns
# - .sitedata/: site user (CGI scripts) writes → site user owns
run_priv chown -R "$actual_user":"$site_group" "$SITE_DIR/build"
run_priv chown -R "$actual_user":"$site_group" "$SITE_DIR/nginx"
run_priv chown -R "$site_user":"$site_group" "$SITE_DATA_DIR"

# Set permissions on build directory - actual user writes, site user reads
if [ -d "$SITE_DIR/build" ]; then
  run_priv find "$SITE_DIR/build" -type d -exec chmod 755 {} + 2>/dev/null || true
  run_priv find "$SITE_DIR/build" -type f -exec chmod 644 {} + 2>/dev/null || true
fi

# Set permissions on nginx directory - actual user writes config, site user reads
# Create nginx temp directories if they don't exist (nginx writes to these)
if [ -d "$SITE_DIR/nginx" ]; then
  run_priv mkdir -p "$SITE_DIR/nginx/temp/client_body"
  run_priv mkdir -p "$SITE_DIR/nginx/temp/proxy"
  run_priv mkdir -p "$SITE_DIR/nginx/temp/fastcgi"
  run_priv mkdir -p "$SITE_DIR/nginx/temp/uwsgi"
  run_priv mkdir -p "$SITE_DIR/nginx/temp/scgi"
  
  # Set nginx/ directory and config files to 755/644 (actual user writes, site user reads)
  run_priv find "$SITE_DIR/nginx" -type d -not -path "*/temp*" \
    -exec chmod 755 {} + 2>/dev/null || true
  run_priv find "$SITE_DIR/nginx" -type f -exec chmod 644 {} + 2>/dev/null || true
  
  # Set temp directories to 775 so site user can write (nginx needs to write temp files)
  run_priv chmod 775 "$SITE_DIR/nginx/temp" 2>/dev/null || true
  run_priv find "$SITE_DIR/nginx/temp" -type d -exec chmod 775 {} + 2>/dev/null || true
fi

# Set permissions on site data directory - make it accessible to actual user
# so "Open site data" works. Use 755 for dirs so user can cd into it.
if [ -d "$SITE_DATA_DIR" ]; then
  run_priv find "$SITE_DATA_DIR" -type d -exec chmod 755 {} + 2>/dev/null || true
  run_priv find "$SITE_DATA_DIR" -type f -exec chmod 644 {} + 2>/dev/null || true
fi

# Ensure site directory itself is accessible (755) and owned by actual user
if [ -d "$SITE_DIR" ]; then
  run_priv chown "$actual_user":"$site_group" "$SITE_DIR"
  run_priv chmod 755 "$SITE_DIR"
fi

# Ensure source directories are owned by actual user and readable by site user
if [ -d "$SITE_DIR/site" ]; then
  run_priv chown -R "$actual_user":"$site_group" "$SITE_DIR/site"
  run_priv find "$SITE_DIR/site" -type d -exec chmod 755 {} + 2>/dev/null || true
  run_priv find "$SITE_DIR/site" -type f -exec chmod 644 {} + 2>/dev/null || true
fi

# Fix allowlist permissions BEFORE reading it in apply_allowlist
if [ -f "$ALLOWLIST_FILE" ]; then
  # Keep allowlist owned by actual user but readable by site user
  run_priv chown "$actual_user":"$site_group" "$ALLOWLIST_FILE"
  run_priv chmod 644 "$ALLOWLIST_FILE"
fi

# Now we can safely read the allowlist file
apply_allowlist

if [ -f "$SITE_CONFIG" ]; then
  # Keep config owned by actual user but readable by site user
  run_priv chown "$actual_user":"$site_group" "$SITE_CONFIG"
  run_priv chmod 644 "$SITE_CONFIG"
fi

success "Site security fixed for '$site_name' (user: $site_user)"
