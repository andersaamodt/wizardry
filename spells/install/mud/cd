#!/bin/sh
. declare-globals

# The cd cantrip keeps a tiny shell hook that immediately runs `look`
# after every successful directory change. The hook stays intentionally
# small so wizards can tweak it at a glance while still whispering just
# enough lore to keep the spell recognizable.

# When sourced via the wzcd function, just do the cd and look
if [ "${_WIZARDRY_CD_SOURCED-}" = "1" ] && [ "${0##*/}" != "cd" ]; then
        command cd "$@" && look 2>/dev/null || true
        return 0 2>/dev/null || exit 0
fi

set -eu

# Flags for testing - passed through to nix-shell-init
_cd_skip_rebuild=0
_cd_skip_confirm=0

show_usage() {
        cat <<'USAGE'
Usage: cd [DIRECTORY]
       cd {install|uninstall} [--skip-rebuild] [--skip-confirm]

Replace builtin cd to run 'look' after each directory change.
Use install/uninstall to manage the shell hook.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

warn() {
        printf '%s\n' "cd cantrip: $1" >&2
}

absolute_spell_path() {
        spell=${1:-$0}
        case $spell in
        /*)
                printf '%s\n' "$spell"
                return 0
                ;;
        *)
                printf '%s/%s\n' "${PWD:-.}" "$spell"
                ;;
        esac
}

# Cache for detect-rc-file output to avoid multiple calls
# This cache is intentionally global so that resolve_rc_file() and resolve_rc_format()
# can share the same detect-rc-file output without running the command multiple times.
_detect_rc_cache=""

_run_detect_rc_file() {
        if [ -n "$_detect_rc_cache" ]; then
                printf '%s\n' "$_detect_rc_cache"
                return 0
        fi
        if command -v detect-rc-file >/dev/null 2>&1; then
                if _detect_rc_cache=$(detect-rc-file 2>/dev/null); then
                        printf '%s\n' "$_detect_rc_cache"
                        return 0
                fi
        fi
        return 1
}

resolve_rc_file() {
        # Use LEARN_SPELL_RC_FILE if set (from learn-spell wrapper)
        if [ -n "${LEARN_SPELL_RC_FILE-}" ]; then
                printf '%s\n' "$LEARN_SPELL_RC_FILE"
                return 0
        fi
        
        # Try to use detect-rc-file for cross-platform support
        if detected=$(_run_detect_rc_file); then
                # Parse rc_file= line using shell parameter expansion
                while IFS= read -r line; do
                        case $line in
                        rc_file=*)
                                rc_file=${line#rc_file=}
                                if [ -n "$rc_file" ]; then
                                        printf '%s\n' "$rc_file"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi
        
        # Fallback to shell-specific defaults
        if [ -z "${HOME-}" ]; then
                warn "HOME is not set; cannot determine rc file."
                return 1
        fi
        
        shell_name=${SHELL-}
        case ${shell_name##*/} in
        zsh)
                printf '%s/.zshrc\n' "$HOME"
                ;;
        *)
                printf '%s/.bashrc\n' "$HOME"
                ;;
        esac
}

resolve_rc_format() {
        # Use LEARN_SPELL_RC_FORMAT if set (from learn-spell wrapper)
        if [ -n "${LEARN_SPELL_RC_FORMAT-}" ]; then
                printf '%s\n' "$LEARN_SPELL_RC_FORMAT"
                return 0
        fi
        
        # Try to get format from detect-rc-file output
        if detected=$(_run_detect_rc_file); then
                while IFS= read -r line; do
                        case $line in
                        format=*)
                                format=${line#format=}
                                if [ -n "$format" ]; then
                                        printf '%s\n' "$format"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi
        
        # Fallback: detect from file extension
        if rc_file=$(resolve_rc_file 2>/dev/null); then
                case $rc_file in
                *.nix) printf 'nix\n'; return 0 ;;
                esac
        fi
        
        printf 'shell\n'
}

cd_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Check for shell format marker
        if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file"; then
                return 0
        fi
        # Check for nix format marker (used by nix-shell-init)
        if grep -Fq '#wizardry: cd-cantrip' "$rc_file"; then
                return 0
        fi
        # Also check for wzcd function or legacy WIZARDRY_CD_CANTRIP
        if grep -Fq 'wzcd' "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        rc_dir=${target%/*}
        [ "$rc_dir" = "$target" ] && rc_dir=.
        if [ -d "$rc_dir" ]; then
                return 0
        fi
        if mkdir -p "$rc_dir"; then
                return 0
        fi
        warn "unable to create directory '$rc_dir'."
        return 1
}

install() {
        # Detect nix format from detect-rc-file output
        rc_format=$(resolve_rc_format)

        cd_spell=$(absolute_spell_path) || return 1
        rc_file=$(resolve_rc_file) || return 1
        
        # Create a simple function-based hook that calls 'look' after cd
        # The function sources the cd spell with a flag to trigger the short path
        # shellcheck disable=SC1078,SC1079
        hook_code=$(cat <<HOOK_END
wzcd() { _WIZARDRY_CD_SOURCED=1 . '$cd_spell' "\$@"; }
alias cd='wzcd'
HOOK_END
)
        
        # For nix format, use nix-shell-init imp to add shell init code
        if [ "$rc_format" = "nix" ]; then
                # Find nix-shell-init helper
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-init" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-init"
                elif command -v nix-shell-init >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-init)
                fi
                
                if [ -z "$nix_helper" ]; then
                        printf '%s\n' "cd cantrip: nix-shell-init imp not found for NixOS installation."
                        return 1
                fi
                
                nix_args=""
                [ "$_cd_skip_rebuild" -eq 1 ] && nix_args="$nix_args --skip-rebuild"
                [ "$_cd_skip_confirm" -eq 1 ] && nix_args="$nix_args --skip-confirm"
                # shellcheck disable=SC2086
                if printf '%s\n' "$hook_code" | "$nix_helper" add $nix_args --shell bash --name cd-cantrip --file "$rc_file"; then
                        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
                else
                        warn "unable to update '$rc_file'."
                        return 1
                fi
                return 0
        fi

        # Standard shell format installation
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        cat <<HOOK >>"$tmp_file"
# >>> wizardry cd cantrip >>>
$hook_code
# <<< wizardry cd cantrip <<<
HOOK
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
}

uninstall() {
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "cd cantrip: no rc file found at '$rc_file'."
                return 0
        fi
        if ! cd_block_present "$rc_file"; then
                printf '%s\n' "cd cantrip: not installed in '$rc_file'."
                return 0
        fi
        
        # For nix format, use nix-shell-init to remove the block
        if [ "$rc_format" = "nix" ]; then
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-init" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-init"
                elif command -v nix-shell-init >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-init)
                fi
                
                if [ -n "$nix_helper" ]; then
                        nix_args=""
                        [ "$_cd_skip_rebuild" -eq 1 ] && nix_args="$nix_args --skip-rebuild"
                        [ "$_cd_skip_confirm" -eq 1 ] && nix_args="$nix_args --skip-confirm"
                        # shellcheck disable=SC2086
                        if "$nix_helper" remove $nix_args --shell bash --name cd-cantrip --file "$rc_file"; then
                                printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
                                return 0
                        else
                                warn "unable to update '$rc_file'."
                                return 1
                        fi
                fi
                # nix-shell-init helper not found - warn and attempt shell method fallback
                # This may not work correctly for nix format files
                warn "nix-shell-init imp not found; attempting shell-style removal which may not work for nix files."
        fi
        
        # Shell format: use sed to remove the block
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
}

locate_ask_yn() {
        if command -v ask_yn >/dev/null 2>&1; then
                command -v ask_yn
                return 0
        fi
        if [ -x "$SCRIPT_DIR/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/ask_yn"
                return 0
        fi
        if [ -x "$SCRIPT_DIR/cantrips/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/cantrips/ask_yn"
                return 0
        fi
        warn "ask_yn spell is missing; skipping installation prompt."
        return 1
}

prompt_install_if_needed() {
        rc_file=$(resolve_rc_file) || return
        if cd_block_present "$rc_file"; then
                return
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                return
        fi
        spell_path=$(absolute_spell_path)
        rc_display=$(basename "$rc_file")
        printf '%s\n' "The cd cantrip can sprinkle the 'look' spell on every hop."
        if "$ask_yn_cmd" "Memorize the cd cantrip in $rc_display so each teleport reveals the room?" yes >/dev/null; then
                install || return
                printf '%s\n' "The hook is etched into $rc_display."
        else
                printf '%s\n' "Very wellâ€”cast 'memorize spells/cantrips/cd' when you crave automatic scouting."
        fi
}

wzcd_cast_look() {
        if command -v look >/dev/null 2>&1; then
                look "$@"
                return
        fi
        warn "look spell is not available."
}

wzcd_main() {
        # Use 'command cd' to call the builtin cd and avoid alias recursion
        command cd "$@" && wzcd_cast_look
}

# Parse flags for install/uninstall commands
while [ "$#" -gt 0 ]; do
        case "${1-}" in
        --skip-rebuild)
                _cd_skip_rebuild=1
                shift
                ;;
        --skip-confirm)
                _cd_skip_confirm=1
                shift
                ;;
        *)
                break
                ;;
        esac
done

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
        shift
        # Check for any remaining flags after install command
        while [ "$#" -gt 0 ]; do
                case "${1-}" in
                --skip-rebuild) _cd_skip_rebuild=1; shift ;;
                --skip-confirm) _cd_skip_confirm=1; shift ;;
                *) break ;;
                esac
        done
        install
        exit $?
        ;;
uninstall)
        shift
        # Check for any remaining flags after uninstall command
        while [ "$#" -gt 0 ]; do
                case "${1-}" in
                --skip-rebuild) _cd_skip_rebuild=1; shift ;;
                --skip-confirm) _cd_skip_confirm=1; shift ;;
                *) break ;;
                esac
        done
        uninstall
        exit $?
        ;;
esac

# If run directly (not sourced via the function and not install/uninstall),
# prompt to install and then run the cd
if [ -z "${LEARN_SPELL_TARGET-}" ]; then
        prompt_install_if_needed || true
        wzcd_main "$@"
fi
