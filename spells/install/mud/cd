#!/bin/sh

# The cd cantrip keeps a tiny shell hook that immediately runs `look`
# after every successful directory change. The hook stays intentionally
# small so wizards can tweak it at a glance while still whispering just
# enough lore to keep the spell recognizable.

show_usage() {
        cat <<'USAGE'
Usage: cd [DIRECTORY]
       cd install
       cd uninstall

Replace the builtin cd command to run 'look' after every successful
directory change, revealing the room description as you teleport around.

Commands:
  install    Add the cd hook to your shell rc file
  uninstall  Remove the cd hook from your shell rc file

When sourced as the cd alias, any valid DIRECTORY argument is passed
through to the real cd builtin, and 'look' runs automatically on success.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

warn() {
        printf '%s\n' "cd cantrip: $1" >&2
}

absolute_spell_path() {
        spell=${1:-$0}
        case $spell in
        /*)
                printf '%s\n' "$spell"
                return 0
                ;;
        *)
                printf '%s/%s\n' "${PWD:-.}" "$spell"
                ;;
        esac
}

resolve_rc_file() {
        if [ -n "${WIZARDRY_RC_FILE-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FILE"
                return 0
        fi
        
        # Try to use detect-rc-file for cross-platform support
        if command -v detect-rc-file >/dev/null 2>&1; then
                if detected=$(detect-rc-file 2>/dev/null); then
                        # Parse rc_file= line using shell parameter expansion
                        while IFS= read -r line; do
                                case $line in
                                rc_file=*)
                                        rc_file=${line#rc_file=}
                                        if [ -n "$rc_file" ]; then
                                                printf '%s\n' "$rc_file"
                                                return 0
                                        fi
                                        ;;
                                esac
                        done <<EOF
$detected
EOF
                fi
        fi
        
        # Fallback to shell-specific defaults
        if [ -z "${HOME-}" ]; then
                warn "HOME is not set; cannot determine rc file."
                return 1
        fi
        
        shell_name=${SHELL-}
        case ${shell_name##*/} in
        zsh)
                printf '%s/.zshrc\n' "$HOME"
                ;;
        *)
                printf '%s/.bashrc\n' "$HOME"
                ;;
        esac
}

cd_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file"; then
                return 0
        fi
        if grep -Fq 'WIZARDRY_CD_CANTRIP' "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        rc_dir=${target%/*}
        [ "$rc_dir" = "$target" ] && rc_dir=.
        if [ -d "$rc_dir" ]; then
                return 0
        fi
        if mkdir -p "$rc_dir"; then
                return 0
        fi
        warn "unable to create directory '$rc_dir'."
        return 1
}

install() {
        # Skip installation for nix format - shell code cannot be written to .nix files
        rc_format=${WIZARDRY_RC_FORMAT-}
        if [ -z "$rc_format" ]; then
                # Try to detect format from rc file extension
                if rc_file_hint=$(resolve_rc_file 2>/dev/null); then
                        case $rc_file_hint in
                        *.nix) rc_format=nix ;;
                        esac
                fi
        fi
        if [ "$rc_format" = "nix" ]; then
                printf '%s\n' "cd cantrip: skipping installation for NixOS (shell hooks cannot be written to .nix files)."
                printf '%s\n' "Hint: Add wizardry spells to your PATH through your NixOS configuration instead."
                return 0
        fi

        cd_spell=$(absolute_spell_path "${WIZARDRY_CD_CANTRIP-}") || return 1
        rc_file=$(resolve_rc_file) || return 1
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        cat <<HOOK >>"$tmp_file"
# >>> wizardry cd cantrip >>>
WIZARDRY_CD_CANTRIP='$cd_spell'
alias cd='. "$WIZARDRY_CD_CANTRIP"'
# <<< wizardry cd cantrip <<<
HOOK
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
}

uninstall() {
        rc_file=$(resolve_rc_file) || return 1
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "cd cantrip: no rc file found at '$rc_file'."
                return 0
        fi
        if ! cd_block_present "$rc_file"; then
                printf '%s\n' "cd cantrip: not installed in '$rc_file'."
                return 0
        fi
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
}

locate_ask_yn() {
        if command -v ask_yn >/dev/null 2>&1; then
                command -v ask_yn
                return 0
        fi
        if [ -x "$SCRIPT_DIR/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/ask_yn"
                return 0
        fi
        if [ -x "$SCRIPT_DIR/cantrips/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/cantrips/ask_yn"
                return 0
        fi
        warn "ask_yn spell is missing; skipping installation prompt."
        return 1
}

prompt_install_if_needed() {
        rc_file=$(resolve_rc_file) || return
        if cd_block_present "$rc_file"; then
                return
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                return
        fi
        spell_path=$(absolute_spell_path "${WIZARDRY_CD_CANTRIP-}")
        rc_display=$(basename "$rc_file")
        printf '%s\n' "The cd cantrip can sprinkle the 'look' spell on every hop."
        if "$ask_yn_cmd" "Memorize the cd cantrip in $rc_display so each teleport reveals the room?" yes >/dev/null; then
                WIZARDRY_CD_CANTRIP=$spell_path install || return
                printf '%s\n' "The hook is etched into $rc_display."
        else
                printf '%s\n' "Very wellâ€”cast 'memorize spells/cantrips/cd' when you crave automatic scouting."
        fi
}

wizardry_cd_cast_look() {
        if command -v look >/dev/null 2>&1; then
                look "$@"
                return
        fi
        warn "look spell is not available."
}

wizardry_cd_main() {
        \cd "$@" && wizardry_cd_cast_look
}

: "${WIZARDRY_CD_CANTRIP:=${WIZARDRY_MEMORIZE_TARGET:-$(absolute_spell_path)}}"

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
        install
        exit $?
        ;;
uninstall)
        uninstall
        exit $?
        ;;
esac

if [ -z "${WIZARDRY_MEMORIZE_TARGET-}" ]; then
        prompt_install_if_needed || true
        wizardry_cd_main "$@"
        exit $?
fi
