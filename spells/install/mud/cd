#!/bin/sh

# The cd cantrip keeps a tiny shell hook that immediately runs `look`
# after every successful directory change. The hook stays intentionally
# small so wizards can tweak it at a glance while still whispering just
# enough lore to keep the spell recognizable.

# When sourced via alias, only run the cd and look, then return early
# This avoids affecting the user's shell with set -eu or exit
if [ -n "${WIZARDRY_CD_CANTRIP-}" ] && [ "${0##*/}" != "cd" ]; then
        # Sourced via alias - just do the cd and look
        command cd "$@" && {
                if command -v look >/dev/null 2>&1; then
                        look 2>/dev/null || true
                fi
        }
        return 0 2>/dev/null || exit 0
fi

show_usage() {
        cat <<'USAGE'
Usage: cd [DIRECTORY]
       cd {install|uninstall}

Replace builtin cd to run 'look' after each directory change.
Use install/uninstall to manage the shell hook.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

warn() {
        printf '%s\n' "cd cantrip: $1" >&2
}

absolute_spell_path() {
        spell=${1:-$0}
        case $spell in
        /*)
                printf '%s\n' "$spell"
                return 0
                ;;
        *)
                printf '%s/%s\n' "${PWD:-.}" "$spell"
                ;;
        esac
}

# Cache for detect-rc-file output to avoid multiple calls
# This cache is intentionally global so that resolve_rc_file() and resolve_rc_format()
# can share the same detect-rc-file output without running the command multiple times.
_detect_rc_cache=""

_run_detect_rc_file() {
        if [ -n "$_detect_rc_cache" ]; then
                printf '%s\n' "$_detect_rc_cache"
                return 0
        fi
        if command -v detect-rc-file >/dev/null 2>&1; then
                if _detect_rc_cache=$(detect-rc-file 2>/dev/null); then
                        printf '%s\n' "$_detect_rc_cache"
                        return 0
                fi
        fi
        return 1
}

resolve_rc_file() {
        if [ -n "${WIZARDRY_RC_FILE-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FILE"
                return 0
        fi
        
        # Try to use detect-rc-file for cross-platform support
        if detected=$(_run_detect_rc_file); then
                # Parse rc_file= line using shell parameter expansion
                while IFS= read -r line; do
                        case $line in
                        rc_file=*)
                                rc_file=${line#rc_file=}
                                if [ -n "$rc_file" ]; then
                                        printf '%s\n' "$rc_file"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi
        
        # Fallback to shell-specific defaults
        if [ -z "${HOME-}" ]; then
                warn "HOME is not set; cannot determine rc file."
                return 1
        fi
        
        shell_name=${SHELL-}
        case ${shell_name##*/} in
        zsh)
                printf '%s/.zshrc\n' "$HOME"
                ;;
        *)
                printf '%s/.bashrc\n' "$HOME"
                ;;
        esac
}

resolve_rc_format() {
        # Check env var override first
        if [ -n "${WIZARDRY_RC_FORMAT-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FORMAT"
                return 0
        fi
        
        # Try to get format from detect-rc-file output
        if detected=$(_run_detect_rc_file); then
                while IFS= read -r line; do
                        case $line in
                        format=*)
                                format=${line#format=}
                                if [ -n "$format" ]; then
                                        printf '%s\n' "$format"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi
        
        # Fallback: detect from file extension
        if rc_file=$(resolve_rc_file 2>/dev/null); then
                case $rc_file in
                *.nix) printf 'nix\n'; return 0 ;;
                esac
        fi
        
        printf 'shell\n'
}

cd_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Check for shell format marker
        if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file"; then
                return 0
        fi
        # Check for nix format marker (used by nix-shell-init)
        if grep -Fq '# wizardry-shell: cd-cantrip' "$rc_file"; then
                return 0
        fi
        # Legacy check for WIZARDRY_CD_CANTRIP variable
        if grep -Fq 'WIZARDRY_CD_CANTRIP' "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        rc_dir=${target%/*}
        [ "$rc_dir" = "$target" ] && rc_dir=.
        if [ -d "$rc_dir" ]; then
                return 0
        fi
        if mkdir -p "$rc_dir"; then
                return 0
        fi
        warn "unable to create directory '$rc_dir'."
        return 1
}

install() {
        # Detect nix format from detect-rc-file output
        rc_format=$(resolve_rc_format)

        cd_spell=$(absolute_spell_path "${WIZARDRY_CD_CANTRIP-}") || return 1
        rc_file=$(resolve_rc_file) || return 1
        
        # For nix format, use nix-shell-init imp to add shell init code
        if [ "$rc_format" = "nix" ]; then
                # Find nix-shell-init helper
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-init" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-init"
                elif command -v nix-shell-init >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-init)
                fi
                
                if [ -z "$nix_helper" ]; then
                        printf '%s\n' "cd cantrip: nix-shell-init imp not found for NixOS installation."
                        return 1
                fi
                
                # Create the shell hook code
                hook_code="WIZARDRY_CD_CANTRIP='$cd_spell'
alias cd='. \"\$WIZARDRY_CD_CANTRIP\"'"
                
                if printf '%s\n' "$hook_code" | "$nix_helper" add --shell bash --name cd-cantrip --file "$rc_file"; then
                        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
                else
                        warn "unable to update '$rc_file'."
                        return 1
                fi
                return 0
        fi

        # Standard shell format installation
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        cat <<HOOK >>"$tmp_file"
# >>> wizardry cd cantrip >>>
WIZARDRY_CD_CANTRIP='$cd_spell'
alias cd='. "$WIZARDRY_CD_CANTRIP"'
# <<< wizardry cd cantrip <<<
HOOK
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
}

uninstall() {
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "cd cantrip: no rc file found at '$rc_file'."
                return 0
        fi
        if ! cd_block_present "$rc_file"; then
                printf '%s\n' "cd cantrip: not installed in '$rc_file'."
                return 0
        fi
        
        # For nix format, use nix-shell-init to remove the block
        if [ "$rc_format" = "nix" ]; then
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/nix-shell-init" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/nix-shell-init"
                elif command -v nix-shell-init >/dev/null 2>&1; then
                        nix_helper=$(command -v nix-shell-init)
                fi
                
                if [ -n "$nix_helper" ]; then
                        if "$nix_helper" remove --shell bash --name cd-cantrip --file "$rc_file"; then
                                printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
                                return 0
                        else
                                warn "unable to update '$rc_file'."
                                return 1
                        fi
                fi
                # nix-shell-init helper not found - warn and attempt shell method fallback
                # This may not work correctly for nix format files
                warn "nix-shell-init imp not found; attempting shell-style removal which may not work for nix files."
        fi
        
        # Shell format: use sed to remove the block
        tmp_file=$(mktemp "${TMPDIR:-/tmp}/wizardry-cd.XXXXXX") || return 1
        sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        if ! mv "$tmp_file" "$rc_file"; then
                rm -f "$tmp_file"
                warn "unable to update '$rc_file'."
                return 1
        fi
        printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
}

locate_ask_yn() {
        if command -v ask_yn >/dev/null 2>&1; then
                command -v ask_yn
                return 0
        fi
        if [ -x "$SCRIPT_DIR/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/ask_yn"
                return 0
        fi
        if [ -x "$SCRIPT_DIR/cantrips/ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/cantrips/ask_yn"
                return 0
        fi
        warn "ask_yn spell is missing; skipping installation prompt."
        return 1
}

prompt_install_if_needed() {
        rc_file=$(resolve_rc_file) || return
        if cd_block_present "$rc_file"; then
                return
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                return
        fi
        spell_path=$(absolute_spell_path "${WIZARDRY_CD_CANTRIP-}")
        rc_display=$(basename "$rc_file")
        printf '%s\n' "The cd cantrip can sprinkle the 'look' spell on every hop."
        if "$ask_yn_cmd" "Memorize the cd cantrip in $rc_display so each teleport reveals the room?" yes >/dev/null; then
                WIZARDRY_CD_CANTRIP=$spell_path install || return
                printf '%s\n' "The hook is etched into $rc_display."
        else
                printf '%s\n' "Very wellâ€”cast 'memorize spells/cantrips/cd' when you crave automatic scouting."
        fi
}

wizardry_cd_cast_look() {
        if command -v look >/dev/null 2>&1; then
                look "$@"
                return
        fi
        warn "look spell is not available."
}

wizardry_cd_main() {
        # Use 'command cd' to call the builtin cd and avoid alias recursion
        command cd "$@" && wizardry_cd_cast_look
}

: "${WIZARDRY_CD_CANTRIP:=${WIZARDRY_MEMORIZE_TARGET:-$(absolute_spell_path)}}"

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
        install
        exit $?
        ;;
uninstall)
        uninstall
        exit $?
        ;;
esac

# If run directly (not sourced via alias and not install/uninstall),
# prompt to install and then run the cd
if [ -z "${WIZARDRY_MEMORIZE_TARGET-}" ]; then
        prompt_install_if_needed || true
        wizardry_cd_main "$@"
fi
