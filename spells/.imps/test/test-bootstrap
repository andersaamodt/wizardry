#!/bin/sh
# test-bootstrap - set up wizardry shell test environment
# Sources all boot imps to provide test framework functions.

# CRITICAL: Seed a baseline PATH BEFORE set -eu and before any commands
# On macOS GitHub Actions, PATH may be completely empty, causing immediate failure
# when we try to use dirname, cd, pwd, etc. in find_repo_root
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*)
    # Already has at least one standard directory
    ;;
  *)
    # PATH is empty or missing standard directories, prepend baseline
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac
export PATH

set -eu

# Check if testing compiled spells
if [ "${WIZARDRY_TEST_COMPILED-0}" = "1" ]; then
  # When testing compiled spells, disable sandboxing and some features
  # that require full wizardry infrastructure
  WIZARDRY_DISABLE_SANDBOX=1
  export WIZARDRY_DISABLE_SANDBOX
fi

# Find the repository root
# We need ROOT_DIR before we can set up PATH to include boot imps
# So we inline this minimal logic here (no function, just inline code)
__bootstrap_dir=$(CDPATH= cd -- "$(dirname "${0:-$PWD}")" && pwd -P)
while [ "$__bootstrap_dir" != "/" ]; do
  if [ -d "$__bootstrap_dir/spells" ] && [ -d "$__bootstrap_dir/.tests" ]; then
    ROOT_DIR=$__bootstrap_dir
    break
  fi
  __bootstrap_dir=$(dirname "$__bootstrap_dir")
done
: "${ROOT_DIR:=$(pwd -P)}"
unset __bootstrap_dir
export ROOT_DIR

# The baseline PATH was already set at the top of this file.
# Now add wizardry spells directories to PATH.
initial_path=$PATH
PATH="$ROOT_DIR/spells"
# Include .imps and its subdirectories (for organized imp families like input/, fs/)
if [ -d "$ROOT_DIR/spells/.imps" ]; then
  PATH="$PATH:$ROOT_DIR/spells/.imps"
  for impdir in "$ROOT_DIR"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$PATH:$impdir"
    # Include nested subdirectories (daemonic complexes like test/boot/)
    for subdir in "$impdir"/*; do
      [ -d "$subdir" ] || continue
      PATH="$PATH:$subdir"
    done
  done
fi
for dir in "$ROOT_DIR"/spells/*; do
  [ -d "$dir" ] || continue
  PATH="$PATH:$dir"
done
PATH="$PATH:$initial_path"
export PATH
WIZARDRY_TEST_HELPERS_ONLY=1
export WIZARDRY_TEST_HELPERS_ONLY

# Export just the imps directories for tests that need to set a minimal PATH
# but still need access to imps (especially env_clear which spells source)
WIZARDRY_IMPS_PATH="$ROOT_DIR/spells/.imps"
if [ -d "$ROOT_DIR/spells/.imps" ]; then
  for impdir in "$ROOT_DIR"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    WIZARDRY_IMPS_PATH="$WIZARDRY_IMPS_PATH:$impdir"
    for subdir in "$impdir"/*; do
      [ -d "$subdir" ] || continue
      WIZARDRY_IMPS_PATH="$WIZARDRY_IMPS_PATH:$subdir"
    done
  done
fi
export WIZARDRY_IMPS_PATH

# Set WIZARDRY_DIR to the repository root for consistency with production environment
WIZARDRY_DIR=$ROOT_DIR
export WIZARDRY_DIR

# Detect and report test environment capabilities
# This runs early so tests can use TEST_ENV_* variables for intelligent skip decisions
# Output goes to stdout (visible in CI logs) and can be extracted by read-test-failures
if [ -x "$ROOT_DIR/spells/.imps/test/detect-test-environment" ]; then
  . "$ROOT_DIR/spells/.imps/test/detect-test-environment"
fi

# Check if invoke-wizardry is already loaded (from workflow or test-magic)
# If so, skip re-loading it for major performance improvement
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  # invoke-wizardry already loaded - reuse it (no-op, very fast)
  : # All functions already available
elif [ "${WIZARDRY_TEST_SKIP_INVOKE-0}" != "1" ] && [ -f "$ROOT_DIR/spells/.imps/sys/invoke-wizardry" ]; then
  # invoke-wizardry not loaded yet - load it once per test file
  # This makes all spell functions and underscore-named imp functions available
  # Tests can then call functions directly (e.g., validate_spells, generate_glosses)
  
  # Set flag to load all spells/imps
  WIZARDRY_LOAD_ALL=1
  export WIZARDRY_LOAD_ALL
  
  # Source invoke-wizardry (it sets +eu internally for permissive mode)
  # We source it directly without piping (to preserve environment variables)
  # Errors are suppressed since we check _WIZARDRY_INVOKED afterward
  . "$ROOT_DIR/spells/.imps/sys/invoke-wizardry" >/dev/null 2>&1 || true
  
  # Check if it loaded successfully by checking the flag it sets
  if [ "${_WIZARDRY_INVOKED-}" != "1" ]; then
    printf 'WARNING: invoke-wizardry failed to load in test-bootstrap\n' >&2
  fi
fi

# Use direct script execution (flat-file paradigm)
# Tests call spells/imps as scripts, not as sourced functions
WIZARDRY_USE_SOURCED_SPELL=0
export WIZARDRY_USE_SOURCED_SPELL

# Skip banish check in test-bootstrap for performance (runs on every test file)
# Banish is run once at test-magic level, not needed per-test
# Can enable with WIZARDRY_TEST_RUN_BANISH=1 if needed for debugging
if [ "${WIZARDRY_TEST_RUN_BANISH-0}" = "1" ] && [ -f "$ROOT_DIR/spells/system/banish" ]; then
  # Use in-ancestry imp to detect if we're already inside banish
  if ! "$ROOT_DIR/spells/.imps/cond/in-ancestry" banish 2>/dev/null; then
    # Run banish silently (log level 0) - it will only output warnings/errors
    if ! "$ROOT_DIR/spells/system/banish" </dev/null >/dev/null 2>&1; then
      # banish failed - environment has issues, but proceed with warning
      printf 'WARNING: banish detected environment issues (tests may fail)\n' >&2
    fi
  fi
fi

# Save the system PATH for run_cmd to use internally
# This ensures run_cmd can always find essential utilities like mktemp, mkdir, cat, rm
# even when tests intentionally set a restricted PATH to test error conditions
WIZARDRY_SYSTEM_PATH="$initial_path"
export WIZARDRY_SYSTEM_PATH

: "${WIZARDRY_TMPDIR:=$(mktemp -d "${TMPDIR:-/tmp}/wizardry-test.XXXXXX")}" || exit 1
# Normalize path for macOS compatibility (TMPDIR ends with /)
WIZARDRY_TMPDIR=$(printf '%s' "$WIZARDRY_TMPDIR" | sed 's|//|/|g')
export WIZARDRY_TMPDIR

# Detect platform for sandbox selection
SANDBOX_PLATFORM=$(uname -s 2>/dev/null || printf 'unknown')

# Initialize sandbox availability flags
BWRAP_AVAILABLE=1
BWRAP_VIA_SUDO=0
BWRAP_USE_UNSHARE=1
BWRAP_BIN=${BWRAP_BIN-}
MACOS_SANDBOX_AVAILABLE=0
# Save the real sudo path before tests might add a stub sudo to PATH
REAL_SUDO_BIN=$(command -v sudo 2>/dev/null || true)
SANDBOX_EXEC_BIN=""

# Allow disabling sandboxing via environment variable
if [ "${WIZARDRY_DISABLE_SANDBOX-0}" = "1" ]; then
  BWRAP_AVAILABLE=0
  BWRAP_REASON="sandboxing disabled by WIZARDRY_DISABLE_SANDBOX"
  MACOS_SANDBOX_AVAILABLE=0
else
  # macOS sandboxing is disabled by default due to compatibility issues
  # Enable with WIZARDRY_ENABLE_MACOS_SANDBOX=1 if needed
  if [ "$SANDBOX_PLATFORM" = "Darwin" ] && [ "${WIZARDRY_ENABLE_MACOS_SANDBOX-0}" = "1" ]; then
    if command -v sandbox-exec >/dev/null 2>&1; then
      SANDBOX_EXEC_BIN=$(command -v sandbox-exec)
      # Test if sandbox-exec works with a simple profile
      if "$SANDBOX_EXEC_BIN" -p '(version 1) (allow default)' /usr/bin/true 2>/dev/null; then
        MACOS_SANDBOX_AVAILABLE=1
        # On macOS, prefer sandbox-exec over attempting bubblewrap
        BWRAP_AVAILABLE=0
        BWRAP_REASON="using macOS sandbox-exec instead"
      fi
    fi
  fi
fi

# Check for Linux bubblewrap (only if not using macOS sandboxing)
if [ "$MACOS_SANDBOX_AVAILABLE" -eq 0 ]; then
  if [ -z "$BWRAP_BIN" ]; then
    if command -v bwrap >/dev/null 2>&1; then
      BWRAP_BIN=$(command -v bwrap)
    else
      BWRAP_AVAILABLE=0
      BWRAP_REASON="bubblewrap not installed"
    fi
  fi

  if [ "$BWRAP_AVAILABLE" -eq 1 ]; then
    if "$BWRAP_BIN" --unshare-user-try --ro-bind / / /bin/true 2>/dev/null; then
      :
    else
      # Running bwrap via sudo causes permission issues (files created as root)
      # so we disable sandboxing if user namespaces are not available
      BWRAP_AVAILABLE=0
      BWRAP_REASON="bubblewrap unusable (user namespaces likely disabled)"
    fi
  fi

  if [ "$BWRAP_AVAILABLE" -eq 1 ] && { [ -z "$BWRAP_BIN" ] || [ ! -x "$BWRAP_BIN" ]; }; then
    BWRAP_AVAILABLE=0
    BWRAP_REASON="bubblewrap not installed"
  fi
fi

warn_once_file=${WIZARDRY_BWRAP_WARN_FILE-${TMPDIR:-/tmp}/wizardry-sandbox-warning}

# Ensure the parent directory of warn_once_file exists before trying to create it
# This handles cases where TMPDIR points to a sandbox dir that doesn't fully exist yet
warn_once_dir=$(dirname "$warn_once_file")
mkdir -p "$warn_once_dir" 2>/dev/null || true

if [ "$BWRAP_AVAILABLE" -eq 0 ] && [ "$MACOS_SANDBOX_AVAILABLE" -eq 0 ] && [ ! -f "$warn_once_file" ] && [ "${WIZARDRY_BWRAP_WARNING-0}" -eq 0 ]; then
  printf '%s\n' "WARNING: proceeding without sandbox isolation: $BWRAP_REASON" >&2
  WIZARDRY_BWRAP_WARNING=1
  export WIZARDRY_BWRAP_WARNING
  : >"$warn_once_file" 2>/dev/null || true
elif [ "$MACOS_SANDBOX_AVAILABLE" -eq 1 ] && [ ! -f "$warn_once_file" ]; then
  printf '%s\n' "INFO: using macOS sandbox-exec for test isolation" >&2
  : >"$warn_once_file" 2>/dev/null || true
fi

# Boot imps are already in PATH (added above in the PATH construction)
# They are flat scripts called as commands with hyphens (assert-success, run-spell, etc.)
# Create underscore wrapper functions for convenience (assert-success calls assert-success)
# This allows tests to use natural shell function naming

# Special handling for run_test_case - it needs to access test functions in the calling context
# so it must be a real function, not just a wrapper to a command
run_test_case() {
  _desc=$1
  _func=$2
  _spell_path=${3-}
  
  # Increment subtest number for this test case (no globals - read from file, pass as arg)
  _test_index=$(cat "${WIZARDRY_TMPDIR}/_test_index")
  _test_index=$((_test_index + 1))
  printf '%s' "$_test_index" > "${WIZARDRY_TMPDIR}/_test_index"
  
  # Direct execution (fast, sufficient for most testing)
  # Run the test function and capture its exit status
  if "$_func"; then
    report-result "$_test_index" "$_desc" 0
  else
    _status=$?
    report-result "$_test_index" "$_desc" "$_status" "${TEST_FAILURE_REASON-test function failed}"
  fi
}

# Special handling for run_spell - it needs to set STATUS/OUTPUT/ERROR in parent shell
# run-cmd writes these to files, run_spell reads them back
run_spell() {
  # Call run-spell command which writes results to files
  # Use absolute path to ensure it's found even when tests set custom PATH
  "$ROOT_DIR/spells/.imps/test/boot/run-spell" "$@"
  
  # Read STATUS, OUTPUT, ERROR from files set by run-cmd
  if [ -f "${WIZARDRY_TMPDIR}/_test_status" ]; then
    STATUS=$(cat "${WIZARDRY_TMPDIR}/_test_status")
    # Limit output size to avoid ARG_MAX issues with large outputs
    # For large outputs, tests should read the file directly
    OUTPUT=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_output" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_output")
    ERROR=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_error" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_error")
    export STATUS OUTPUT ERROR
  fi
}

# Special handling for run_cmd - also needs to set STATUS/OUTPUT/ERROR in parent shell
# run-cmd writes these to files, run_cmd reads them back
run_cmd() {
  # Call run-cmd command which writes results to files
  # Use absolute path to ensure it's found even when tests set custom PATH
  "$ROOT_DIR/spells/.imps/test/boot/run-cmd" "$@"
  
  # Read STATUS, OUTPUT, ERROR from files set by run-cmd
  if [ -f "${WIZARDRY_TMPDIR}/_test_status" ]; then
    STATUS=$(cat "${WIZARDRY_TMPDIR}/_test_status")
    # Limit output size to avoid ARG_MAX issues with large outputs
    # For large outputs, tests should read the file directly
    OUTPUT=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_output" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_output")
    ERROR=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_error" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_error")
    export STATUS OUTPUT ERROR
  fi
}

# Special handling for run_spell_in_dir - also needs to set STATUS/OUTPUT/ERROR in parent shell
# run-spell-in-dir calls run-spell which writes these to files
run_spell_in_dir() {
  # Call run-spell-in-dir command which internally calls run-spell
  # Use absolute path to ensure it's found even when tests set custom PATH
  "$ROOT_DIR/spells/.imps/test/boot/run-spell-in-dir" "$@"
  
  # Read STATUS, OUTPUT, ERROR from files set by run-spell
  if [ -f "${WIZARDRY_TMPDIR}/_test_status" ]; then
    STATUS=$(cat "${WIZARDRY_TMPDIR}/_test_status")
    # Limit output size to avoid ARG_MAX issues with large outputs
    # For large outputs, tests should read the file directly
    OUTPUT=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_output" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_output")
    ERROR=$(head -c 102400 "${WIZARDRY_TMPDIR}/_test_error" 2>/dev/null || \
      cat "${WIZARDRY_TMPDIR}/_test_error")
    export STATUS OUTPUT ERROR
  fi
}

# List of boot imps that need underscore wrappers (excluding run-test-case and run-spell which are special)
# We generate these dynamically from the boot directory to avoid maintenance burden
for boot_imp in "$ROOT_DIR"/spells/.imps/test/boot/*; do
  [ -f "$boot_imp" ] || continue
  boot_name=$(basename "$boot_imp")
  
  # Skip run-test-case, run-spell, run-cmd, and run-spell-in-dir (handled specially above)
  [ "$boot_name" = "run-test-case" ] && continue
  [ "$boot_name" = "run-spell" ] && continue
  [ "$boot_name" = "run-cmd" ] && continue
  [ "$boot_name" = "run-spell-in-dir" ] && continue
  
  # Skip if name has no hyphens (already matches underscore version)
  case "$boot_name" in
    *-*)
      # Create underscore version: assert-success -> assert-success  
      underscore_name=$(printf '%s' "$boot_name" | tr '-' '_')
      
      # Define a shell function that calls the hyphenated command
      # We use eval to create the function dynamically
      eval "${underscore_name}() { ${boot_name} \"\$@\"; }"
      ;;
  esac
done

# Initialize test counters (creates counter files in WIZARDRY_TMPDIR)
init-test-counters
