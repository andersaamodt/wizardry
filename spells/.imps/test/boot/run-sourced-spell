#!/bin/sh
# run-sourced-spell SPELL_NAME [ARGS...] - test a spell via source-then-invoke pattern
# Sources invoke-wizardry in permissive mode, then calls the spell function.
# Captures stdout, stderr, and exit status into STATUS, OUTPUT, and ERROR.
# This tests the REAL user workflow: source invoke-wizardry â†’ call spell functions
set -eu

_run_sourced_spell() {
  spell_name=$1
  shift || true
  
  # Convert spell name to function name (replace hyphens with underscores)
  func_name=$(printf '%s' "$spell_name" | tr '-' '_')
  
  # Save the caller's PATH for cleanup operations
  _saved_path=$PATH
  PATH=${WIZARDRY_SYSTEM_PATH:-$PATH}
  
  _stdout=$(mktemp "${WIZARDRY_TMPDIR}/stdout.XXXXXX") || return 1
  _stderr=$(mktemp "${WIZARDRY_TMPDIR}/stderr.XXXXXX") || return 1
  
  workdir=${RUN_CMD_WORKDIR:-$(pwd)}
  mkdir -p "$workdir"
  
  # Restore caller's PATH for the test
  PATH=$_saved_path
  
  # Create a script that sources invoke-wizardry then calls the spell function
  test_script=$(mktemp "${WIZARDRY_TMPDIR}/sourced-test.XXXXXX")
  cat > "$test_script" <<'SCRIPT_TEMPLATE'
#!/bin/bash
# Test script: source invoke-wizardry then invoke spell function

# Enable alias expansion in non-interactive bash
shopt -s expand_aliases 2>/dev/null || true

# Disable strict mode for sourcing invoke-wizardry (it manages its own modes)
set +eu

# Export necessary variables for invoke-wizardry
export WIZARDRY_DIR="WIZARDRY_DIR_PLACEHOLDER"
export WIZARDRY_LOAD_ALL=1
export PATH="PATH_PLACEHOLDER"
export HOME="HOME_PLACEHOLDER"
export TMPDIR="TMPDIR_PLACEHOLDER"
export WIZARDRY_TMPDIR="WIZARDRY_TMPDIR_PLACEHOLDER"
export WIZARDRY_TEST_HELPERS_ONLY="WIZARDRY_TEST_HELPERS_ONLY_PLACEHOLDER"

# Source invoke-wizardry (redirects its diagnostic output to /dev/null)
. "$WIZARDRY_DIR/spells/.imps/sys/invoke-wizardry" >/dev/null 2>&1

# Now the spell function should be available - call it with the provided arguments
# Use the hyphenated spell name which should be aliased to the underscore function
# Enable strict mode for the spell execution  
set -eu  # strict mode for spell

# Execute the spell function (use underscore version since aliases don't work in scripts)
FUNC_NAME_PLACEHOLDER "$@"
SCRIPT_TEMPLATE
  
  # Replace placeholders with actual values
  sed -i "s|WIZARDRY_DIR_PLACEHOLDER|${WIZARDRY_DIR:-$ROOT_DIR}|g" "$test_script"
  sed -i "s|PATH_PLACEHOLDER|$PATH|g" "$test_script"
  sed -i "s|HOME_PLACEHOLDER|${HOME:-/tmp}|g" "$test_script"
  sed -i "s|TMPDIR_PLACEHOLDER|${TMPDIR:-/tmp}|g" "$test_script"
  sed -i "s|WIZARDRY_TMPDIR_PLACEHOLDER|${WIZARDRY_TMPDIR}|g" "$test_script"
  sed -i "s|WIZARDRY_TEST_HELPERS_ONLY_PLACEHOLDER|${WIZARDRY_TEST_HELPERS_ONLY:-0}|g" "$test_script"
  sed -i "s|SPELL_NAME_PLACEHOLDER|$spell_name|g" "$test_script"
  sed -i "s|FUNC_NAME_PLACEHOLDER|$func_name|g" "$test_script"
  
  chmod +x "$test_script"
  
  # Run the test script and capture output/error/status
  PATH=${WIZARDRY_SYSTEM_PATH:-$PATH}
  if (cd "$workdir" && "$test_script" "$@" >"$_stdout" 2>"$_stderr"); then
    STATUS=0
  else
    STATUS=$?
  fi
  
  OUTPUT=$(cat "$_stdout")
  ERROR=$(cat "$_stderr")
  
  # Cleanup
  # DEBUG: Save script for inspection
  if [ -n "${DEBUG_SOURCED_SPELL-}" ]; then
    cp "$test_script" "/tmp/last-sourced-test.sh" 2>/dev/null || true
  fi
  rm -f "$_stdout" "$_stderr" "$test_script"
  
  # Restore caller's PATH
  PATH=$_saved_path
}

# Self-execution when run directly (not sourced)
case "${0##*/}" in run-sourced-spell) _run_sourced_spell "$@" ;; esac
