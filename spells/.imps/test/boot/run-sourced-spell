#!/bin/sh
# run-sourced-spell SPELL_NAME [ARGS...] - test a spell via source-then-invoke pattern
# With invoke-wizardry preloaded, functions are already available.
# Captures stdout, stderr, and exit status into STATUS, OUTPUT, and ERROR.

run_sourced_spell() {
  set -eu
  spell_path=$1
  shift || true
  
  # Extract spell name from path and convert to function name
  # spell_path is like "spells/translocation/jump-to-marker"
  # We need just "jump-to-marker" -> "jump_to_marker"
  spell_name=$(basename "$spell_path")
  func_name=$(printf '%s' "$spell_name" | tr '-' '_')
  
  # Save the caller's PATH for cleanup operations
  _saved_path=$PATH
  PATH=${WIZARDRY_SYSTEM_PATH:-$PATH}
  
  _stdout=$(mktemp "${WIZARDRY_TMPDIR}/stdout.XXXXXX") || return 1
  _stderr=$(mktemp "${WIZARDRY_TMPDIR}/stderr.XXXXXX") || return 1
  
  workdir=${RUN_CMD_WORKDIR:-$(pwd)}
  mkdir -p "$workdir"
  
  # Restore caller's PATH for the test
  PATH=$_saved_path
  
  # Save current directory
  _saved_pwd=$(pwd)
  cd "$workdir" 2>/dev/null || :
  
  # Call the function directly - it's already loaded in the environment
  # Redirect output to temp files for capture
  STATUS=0
  if ! (
    # Execute in subshell to capture output and isolate side effects
    set +e
    "$func_name" "$@"
  ) >"$_stdout" 2>"$_stderr"; then
    STATUS=$?
  fi
  
  OUTPUT=$(cat "$_stdout")
  ERROR=$(cat "$_stderr")
  
  # Cleanup
  rm -f "$_stdout" "$_stderr"
  
  # Restore caller's PATH and directory
  PATH=$_saved_path
  cd "$_saved_pwd" 2>/dev/null || :
}

# Self-execution when run directly (not sourced)
case "${0##*/}" in run-sourced-spell) run_sourced_spell "$@" ;; esac
