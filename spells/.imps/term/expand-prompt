#!/bin/sh
# expand-prompt PROMPT - expand shell prompt escapes to actual text

set -eu

_ep_prompt="${1-}"

if [ -z "$_ep_prompt" ]; then
  printf '$ '
  exit 0
fi

# Detect if this is a zsh-format prompt (contains % escapes)
# Zsh prompts use %n, %m, %~, etc. while bash uses \u, \h, \w, etc.
case "$_ep_prompt" in
  *%[nmhHdDtwWcCT.~#?!j]*)
    # This looks like a zsh prompt - try to use zsh to expand it
    if command -v zsh >/dev/null 2>&1; then
      # Pass the prompt string as an argument to avoid shell expansion issues
      _ep_result=$(zsh -c 'print -P "$1"' -- "$_ep_prompt" 2>/dev/null) || _ep_result=""
      
      if [ -n "$_ep_result" ]; then
        printf '%s' "$_ep_result"
        exit 0
      fi
    fi
    # If zsh not available or expansion failed, fall through to bash logic
    ;;
esac

# For bash/sh, do manual expansion
_ep_user="${USER-}"
_ep_host="${HOSTNAME-$(hostname 2>/dev/null || printf 'localhost')}"
_ep_pwd="${PWD-}"
_ep_pwd_base=$(basename "$_ep_pwd" 2>/dev/null || printf '~')

# Simple sed-based expansion for bash prompts
_ep_result="$_ep_prompt"
_ep_result=$(printf '%s' "$_ep_result" | sed "s/\\\\u/$_ep_user/g")
_ep_result=$(printf '%s' "$_ep_result" | sed "s/\\\\h/${_ep_host%%.*}/g")
_ep_result=$(printf '%s' "$_ep_result" | sed "s/\\\\H/$_ep_host/g")
_ep_result=$(printf '%s' "$_ep_result" | sed "s|\\\\w|$_ep_pwd|g")
_ep_result=$(printf '%s' "$_ep_result" | sed "s|\\\\W|$_ep_pwd_base|g")
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\\\[$]/$/'g)
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\\\#/!/g')

# Remove ANSI codes and \[ \] markers  
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\033\[[0-9;]*m//g')
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\e\[[0-9;]*m//g')
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\\\[[[]//g')
_ep_result=$(printf '%s' "$_ep_result" | sed 's/\\\\[]]//g')

if [ -n "$_ep_result" ]; then
  printf '%s' "$_ep_result"
else
  printf '$ '
fi
