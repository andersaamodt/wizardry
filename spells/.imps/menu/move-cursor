#!/bin/sh
# move-cursor X Y - move terminal cursor to column X, row Y using ANSI escapes
# Clamps zero or negative values to first position
# Example: move-cursor 10 5

# Use conditional strictness based on execution context
# See .github/CODE_POLICY_SET_EU.md for details
set -eu

if [ "$#" -ne 2 ]; then
    printf '%s\n' "move-cursor: expected X Y arguments" >&2
    exit 2
fi

x=$1
y=$2

# Validate that both coordinates are purely numeric.
case "$x" in
    *[!0-9]*)
        fail "move-cursor: invalid column '$x'" || exit 1
        ;;
    *) : ;;
esac

case "$y" in
    *[!0-9]*)
        fail "move-cursor: invalid row '$y'" || exit 1
        ;;
    *) : ;;
esac

# ANSI escape sequences count from 1, so reject zero values early.
# The original menu spell passed 0 for the column. Treat that as a request to
# return to the first column so older spells continue to work. Clamp the row as
# well so callers that miscalculate never request an invalid position.
if [ "$x" -le 0 ]; then
    x=1
fi

if [ "$y" -le 0 ]; then
    y=1
fi

# Check if terminal supports cursor positioning
_supports_positioning=0
case ${TERM-} in
    ''|dumb|unknown)
        _supports_positioning=0
        ;;
    *)
        _supports_positioning=1
        ;;
esac

if [ "$_supports_positioning" -eq 0 ]; then
    # Skip emitting escape sequences when the terminal refuses them so menu
    # helpers degrade gracefully.
    exit 0
fi

# Emit the escape sequence that repositions the cursor.
printf '\033[%s;%sH' "$y" "$x"
