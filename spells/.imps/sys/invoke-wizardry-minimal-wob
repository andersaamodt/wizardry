#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use $0
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      _iw_script_path="$0"
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR
  
  # MINIMAL PHASE 1: Only set up command_not_found_handle
  # No spell/imp pre-loading, no cd hook, no synonyms
  # Everything loads on-demand via word-of-binding
  
  # Set up command_not_found_handle for bash
  if eval '[ -n "${BASH_VERSION+x}" ]' 2>/dev/null; then
    # Bash-specific command_not_found_handle
    command_not_found_handle() {
      # Prevent infinite recursion
      if [ "${_WIZARDRY_IN_CNF-}" = "1" ]; then
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _WIZARDRY_IN_CNF=1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -x "$_cnf_wob" ]; then
        if "$_cnf_wob" "$@" 2>/dev/null; then
          unset _WIZARDRY_IN_CNF
          return 0
        fi
      fi
      
      # Command truly not found
      unset _WIZARDRY_IN_CNF
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
  elif eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    # Zsh-specific command_not_found_handler
    command_not_found_handler() {
      # Prevent infinite recursion
      if [ "${_WIZARDRY_IN_CNF-}" = "1" ]; then
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _WIZARDRY_IN_CNF=1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -x "$_cnf_wob" ]; then
        if "$_cnf_wob" "$@" 2>/dev/null; then
          unset _WIZARDRY_IN_CNF
          return 0
        fi
      fi
      
      # Command truly not found
      unset _WIZARDRY_IN_CNF
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
  fi
  
  return 0
}

# Run the setup
_invoke_wizardry
_iw_status=$?
return $_iw_status
