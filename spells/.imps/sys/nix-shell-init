#!/bin/sh
# nix-shell-init ACTION --name NAME --file FILE - manage shell init code in nix config
# Actions: add (reads stdin), remove, status. Options: --shell bash|zsh (default: bash)
# Example: echo 'source "/spell"' | nix-shell-init add --shell bash --name myspell --file config.nix

set -eu

# Add imps to PATH so we can use temp-file and cleanup-file directly
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
imps_dir=$(CDPATH= cd -- "$script_dir/.." && pwd -P)
if [ -d "$imps_dir" ]; then
  PATH="$imps_dir:$PATH"
  for impdir in "$imps_dir"/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

action=""
shell_type="bash"
block_name=""
nix_file=""

while [ "$#" -gt 0 ]; do
  case $1 in
  add|remove|status)
    action=$1
    shift
    ;;
  --shell)
    [ "$#" -lt 2 ] && { printf '%s\n' "nix-shell-init: --shell requires value" >&2; exit 1; }
    shell_type=$2
    shift 2
    ;;
  --shell=*)
    shell_type=${1#*=}
    shift
    ;;
  --name)
    [ "$#" -lt 2 ] && { printf '%s\n' "nix-shell-init: --name requires value" >&2; exit 1; }
    block_name=$2
    shift 2
    ;;
  --name=*)
    block_name=${1#*=}
    shift
    ;;
  --file)
    [ "$#" -lt 2 ] && { printf '%s\n' "nix-shell-init: --file requires value" >&2; exit 1; }
    nix_file=$2
    shift 2
    ;;
  --file=*)
    nix_file=${1#*=}
    shift
    ;;
  *)
    printf '%s\n' "nix-shell-init: unknown argument '$1'" >&2
    exit 1
    ;;
  esac
done

if [ -z "$action" ] || [ -z "$block_name" ] || [ -z "$nix_file" ]; then
  printf '%s\n' "nix-shell-init: action, --name, and --file are required" >&2
  exit 1
fi

# Validate shell type
case $shell_type in
bash|zsh) : ;;
*)
  printf '%s\n' "nix-shell-init: shell must be 'bash' or 'zsh'" >&2
  exit 1
  ;;
esac

# Determine the nix option based on shell type and config file type
is_system_config=0
case $nix_file in
/etc/nixos/configuration.nix|/etc/nixos/*)
  is_system_config=1
  ;;
esac

if [ "$is_system_config" -eq 1 ]; then
  case $shell_type in
  bash) nix_option="programs.bash.interactiveShellInit" ;;
  zsh)  nix_option="programs.zsh.interactiveShellInit" ;;
  esac
else
  case $shell_type in
  bash) nix_option="programs.bash.initExtra" ;;
  zsh)  nix_option="programs.zsh.initExtra" ;;
  esac
fi

# Marker format: # wizardry: NAME
marker="# wizardry: $block_name"

# Check if file needs sudo
needs_sudo=0
if [ -f "$nix_file" ] && [ ! -w "$nix_file" ]; then
  needs_sudo=1
fi

# Handle status action (check if block exists)
if [ "$action" = "status" ]; then
  [ -f "$nix_file" ] && grep -Fq "$marker" "$nix_file" 2>/dev/null
  exit $?
fi

# Handle remove action
if [ "$action" = "remove" ]; then
  if [ ! -f "$nix_file" ]; then
    printf '%s\n' "nix-shell-init: file not found: $nix_file" >&2
    exit 1
  fi
  
  # Check if block exists
  if ! grep -Fq "$marker" "$nix_file" 2>/dev/null; then
    exit 0  # Nothing to remove
  fi
  
  # Back up the config file
  if ! backup-nix-config "$nix_file"; then
    printf '%s\n' "nix-shell-init: unable to back up '$nix_file'" >&2
    exit 1
  fi
  
  # Remove all lines containing our marker
  tmp_file=$(temp-file nix-shell-init) || exit 1
  trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
  
  if [ "$needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then
      sudo cat "$nix_file" | grep -v -F "$marker" > "$tmp_file"
      sudo cp "$tmp_file" "$nix_file"
    elif command -v doas >/dev/null 2>&1; then
      doas cat "$nix_file" | grep -v -F "$marker" > "$tmp_file"
      doas cp "$tmp_file" "$nix_file"
    else
      cat "$nix_file" | grep -v -F "$marker" > "$tmp_file"
      cp "$tmp_file" "$nix_file"
    fi
  else
    grep -v -F "$marker" "$nix_file" > "$tmp_file"
    mv "$tmp_file" "$nix_file"
  fi
  
  trap - EXIT HUP INT TERM
  rm -f "$tmp_file"
  exit 0
fi

# Handle add action
if [ "$action" = "add" ]; then
  # Check if block already exists
  if [ -f "$nix_file" ] && grep -Fq "$marker" "$nix_file" 2>/dev/null; then
    exit 0  # Already exists, nothing to do
  fi
  
  # Read shell code from stdin
  shell_code=""
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$shell_code" ]; then
      shell_code=$line
    else
      shell_code="$shell_code
$line"
    fi
  done
  
  if [ -z "$shell_code" ]; then
    printf '%s\n' "nix-shell-init: no shell code provided on stdin" >&2
    exit 1
  fi
  
  # Back up the config file
  if [ -f "$nix_file" ]; then
    if ! backup-nix-config "$nix_file"; then
      printf '%s\n' "nix-shell-init: unable to back up '$nix_file'" >&2
      exit 1
    fi
  fi
  
  # Escape shell code for nix '' multi-line string: '' -> ''' and ${ -> ''${
  escaped_code=$(printf '%s' "$shell_code" | sed "s/''/'''/g; s/\\\${/''\${/g")
  
  # Mark every content line with the wizardry marker
  marked_code=$(printf '%s' "$escaped_code" | sed "s/$/ $marker/")
  
  # Create file if it doesn't exist with minimal nix structure
  if [ ! -f "$nix_file" ]; then
    dir=${nix_file%/*}
    [ "$dir" != "$nix_file" ] && [ ! -d "$dir" ] && mkdir -p "$dir"
    printf '{ config, pkgs, ... }:\n\n{\n}\n' > "$nix_file"
  fi
  
  tmp_file=$(temp-file nix-shell-init) || exit 1
  input_file=''
  trap 'cleanup-file "$tmp_file"; [ -n "$input_file" ] && cleanup-file "$input_file"' EXIT HUP INT TERM
  
  # Helper to run commands with sudo if needed
  _run_sudo_cat() {
    if [ "$needs_sudo" -eq 1 ]; then
      if command -v sudo >/dev/null 2>&1; then
        sudo cat "$1"
      elif command -v doas >/dev/null 2>&1; then
        doas cat "$1"
      else
        cat "$1"
      fi
    else
      cat "$1"
    fi
  }
  
  # Check if an existing block for this nix_option exists
  if _run_sudo_cat "$nix_file" | grep -q "$nix_option[[:space:]]*="; then
    # Existing block found - insert our marked lines before the closing '';
    input_file=$(temp-file nix-shell-init-input) || exit 1
    _run_sudo_cat "$nix_file" > "$input_file"
    
    # Process line by line to find the right place to insert
    in_block=0
    while IFS= read -r line; do
      if printf '%s\n' "$line" | grep -q "$nix_option[[:space:]]*=" && printf '%s\n' "$line" | grep -q "''"; then
        in_block=1
        printf '%s\n' "$line"
        continue
      fi
      if [ "$in_block" -eq 1 ] && printf '%s\n' "$line" | grep -q "^[[:space:]]*'';" ; then
        printf '%s\n' "$marked_code"
        printf '%s\n' "$line"
        in_block=0
        continue
      fi
      printf '%s\n' "$line"
    done < "$input_file" > "$tmp_file"
  else
    # No existing block - create a new one
    nix_block="  $nix_option = ''
$marked_code
  '';"
    
    # Insert the block before the closing brace
    _run_sudo_cat "$nix_file" | awk -v block="$nix_block" '
    {
      lines[NR] = $0
    }
    END {
      last = NR
      while (last > 0 && lines[last] ~ /^[[:space:]]*$/) last--
      
      if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
        for (i = 1; i < last; i++) print lines[i]
        print ""
        print block
        print lines[last]
        for (i = last + 1; i <= NR; i++) print lines[i]
      } else {
        for (i = 1; i <= NR; i++) print lines[i]
        print ""
        print block
      }
    }
    ' > "$tmp_file"
  fi
  
  if [ "$needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then
      sudo cp "$tmp_file" "$nix_file"
    elif command -v doas >/dev/null 2>&1; then
      doas cp "$tmp_file" "$nix_file"
    else
      cp "$tmp_file" "$nix_file"
    fi
  else
    mv "$tmp_file" "$nix_file"
  fi
  
  trap - EXIT HUP INT TERM
  rm -f "$tmp_file"
  [ -n "$input_file" ] && rm -f "$input_file"
  exit 0
fi
