#!/bin/sh
# rc-migrate-marker MARKER RC_FILE LINE - migrate old separate-line marker to inline format
# Example: rc-migrate-marker cd-hook ~/.zshrc '. "/path/to/cd"'
# Converts:
#   # wizardry: cd-hook
#   . "/path/to/cd"
# To:
#   . "/path/to/cd" # wizardry: cd-hook
set -eu

_rc_migrate_marker() {
  _rmm_marker=${1:-}
  _rmm_rc_file=${2:-}
  _rmm_line=${3:-}

  if [ -z "$_rmm_marker" ] || [ -z "$_rmm_rc_file" ] || [ -z "$_rmm_line" ]; then
    printf '%s\n' "rc-migrate-marker: MARKER, RC_FILE, and LINE are required" >&2
    return 1
  fi

  if [ ! -f "$_rmm_rc_file" ]; then
    # File doesn't exist, nothing to migrate
    return 0
  fi

  _rmm_full_marker="# wizardry: $_rmm_marker"

  # Check if already in new inline format
  if grep -qF "$_rmm_line $_rmm_full_marker" "$_rmm_rc_file" 2>/dev/null; then
    # Already in new format, nothing to do
    return 0
  fi

  # Check if old format exists (marker on line before the command)
  # We need to check for the pattern where marker line is immediately followed by the command line
  _rmm_tmp_check=$(mktemp "${TMPDIR:-/tmp}/rc-migrate-check.XXXXXX") || return 1
  
  # Extract the marker line and the next line
  _rmm_found_old_format=0
  if grep -B 1 -F "$_rmm_line" "$_rmm_rc_file" 2>/dev/null > "$_rmm_tmp_check"; then
    # Check if marker appears right before our line
    if grep -q "^$_rmm_full_marker\$" "$_rmm_tmp_check" && grep -qF "$_rmm_line" "$_rmm_tmp_check"; then
      _rmm_found_old_format=1
    fi
  fi
  rm -f "$_rmm_tmp_check"

  if [ "$_rmm_found_old_format" -eq 0 ]; then
    # Old format not found, nothing to migrate
    return 0
  fi

  # Migrate: remove old format and add new inline format
  _rmm_tmp_file="${_rmm_rc_file}.wizardry.$$"
  
  # Remove both the marker line and the command line (old format)
  # Then add the new inline format at the end
  _rmm_state=0  # 0=looking, 1=found marker, skip next line
  while IFS= read -r _rmm_current_line || [ -n "$_rmm_current_line" ]; do
    if [ "$_rmm_state" -eq 1 ]; then
      # Skip this line (it's the line after the marker)
      _rmm_state=0
      continue
    fi
    
    if [ "$_rmm_current_line" = "$_rmm_full_marker" ]; then
      # Found marker, skip it and set state to skip next line
      _rmm_state=1
      continue
    fi
    
    printf '%s\n' "$_rmm_current_line"
  done < "$_rmm_rc_file" > "$_rmm_tmp_file"
  
  # Add the new inline format
  printf '%s %s\n' "$_rmm_line" "$_rmm_full_marker" >> "$_rmm_tmp_file"
  
  # Replace original file
  mv "$_rmm_tmp_file" "$_rmm_rc_file" || {
    rm -f "$_rmm_tmp_file"
    printf '%s\n' "rc-migrate-marker: failed to update $_rmm_rc_file" >&2
    return 1
  }
  
  return 0
}

# Self-execute when run directly (not sourced)
case "$0" in
  */rc-migrate-marker) _rc_migrate_marker "$@" ;;
esac
