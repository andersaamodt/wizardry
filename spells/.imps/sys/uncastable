#!/bin/sh
# uncastable [SPELL_NAME] [USAGE]
# Enforce sourced-only behavior for scripts that must not be executed.
# If SPELL_NAME is omitted, it is derived from $0.
# If USAGE is omitted, it defaults to "Usage: . <spell-name>".
# Example: uncastable invoke-thesaurus "Usage: . invoke-thesaurus"
#
# CRITICAL: This imp must be SOURCED, never executed.
# When sourced by a script, it checks if that script was sourced or executed.

# Guard: Prevent direct execution of uncastable itself
# Check if we're being sourced by examining $0
_uc_check_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _uc_check_sourced=1 ;;
  esac
else
  _uc_check_base=${0##*/}
  case "$_uc_check_base" in
    sh|dash|bash|zsh|ksh|mksh) _uc_check_sourced=1 ;;
    uncastable) _uc_check_sourced=0 ;;
    *) _uc_check_sourced=1 ;;
  esac
fi

if [ "$_uc_check_sourced" -eq 0 ]; then
  printf '%s\n' "uncastable: must be sourced, not executed" >&2
  printf '%s\n' "Usage: . uncastable" >&2
  printf '%s\n' "Then source it in scripts that need sourced-only enforcement" >&2
  exit 1
fi
unset _uc_check_sourced _uc_check_base

set -eu

_uncast_name=${1-}
if [ -n "$_uncast_name" ]; then
  shift
fi

# Determine if the calling script is being sourced or executed
_uncast_sourced=0

# ZSH detection
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _uncast_sourced=1 ;;
  esac
# BASH detection using BASH_SOURCE
elif [ -n "${BASH_VERSION-}" ] && [ -n "${BASH_SOURCE-}" ]; then
  # In bash, BASH_SOURCE[1] is the file that sourced uncastable (the calling spell)
  # and $0 is the top-level script being executed
  # If they have the same basename, the spell is being executed directly
  if [ "${#BASH_SOURCE[@]}" -gt 1 ]; then
    _caller_file="${BASH_SOURCE[1]}"
    _caller_base="${_caller_file##*/}"
    _zero_base="${0##*/}"
    
    if [ "$_caller_base" = "$_zero_base" ]; then
      # Caller file matches $0 - spell is being executed
      _uncast_sourced=0
      # Use the caller's basename for error messages
      [ -z "$_uncast_name" ] && _uncast_name=$_caller_base
    else
      # Caller file doesn't match $0 - spell is being sourced
      _uncast_sourced=1
    fi
  else
    # No caller info - fall back to shell name check
    case "${0##*/}" in
      sh|dash|bash|zsh|ksh|mksh) _uncast_sourced=1 ;;
      *) _uncast_sourced=1 ;;  # Default to sourced
    esac
  fi
# POSIX sh fallback
else
  _uncast_base=${0##*/}
  case "$_uncast_base" in
    sh|dash|bash|zsh|ksh|mksh) 
      # $0 is a shell name - definitely being sourced
      _uncast_sourced=1 
      ;;
    "$_uncast_name") 
      # $0 basename matches the provided spell name - being executed directly
      _uncast_sourced=0 
      ;;
    *) 
      # $0 is something else
      # In POSIX sh, we cannot reliably determine without additional info
      # Default to sourced (safer to allow than to incorrectly block)
      # Note: This means direct execution via `dash /path/to/spell` won't be caught
      # Users should use bash for better detection, or the spell can provide its name
      _uncast_sourced=1
      ;;
  esac
fi

# Set _uncast_name for error messages if not already set
if [ -z "$_uncast_name" ]; then
  _uncast_name=${0##*/}
fi

if [ "$_uncast_sourced" -eq 1 ]; then
  # Clear the message variable if it was set
  unset UNCASTABLE_MESSAGE
  return 0
else
  if [ -n "${UNCASTABLE_MESSAGE-}" ]; then
    printf '%s\n' "$UNCASTABLE_MESSAGE" >&2
    unset UNCASTABLE_MESSAGE
  else
    printf '%s\n' "${_uncast_name}: must be sourced, not executed" >&2
    if [ "$#" -gt 0 ]; then
      printf '%s\n' "$*" >&2
    elif [ -n "$_uncast_name" ]; then
      printf '%s\n' "Usage: . $_uncast_name" >&2
    fi
  fi
  return 1
fi
