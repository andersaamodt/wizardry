#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# Simple PATH-based invocation (no word-of-binding preloading)
# Source this script to enable wizardry spells and imps from PATH.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  [ "${WIZARDRY_DEBUG-}" = "1" ] && \
    printf '[invoke-wizardry] %s\n' "Already invoked, skipping" >&2
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

[ "${WIZARDRY_DEBUG-}" = "1" ] && \
  printf '[invoke-wizardry] %s\n' "Starting wizardry initialization" >&2

# Detect WIZARDRY_DIR
if [ -z "${WIZARDRY_DIR-}" ]; then
  # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
  _iw_script_path=""
  if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
    _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
  elif [ -n "${ZSH_VERSION-}" ]; then
    # In zsh, use %x expansion to get sourced file path
    _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
    # Fallback to %N if %x didn't work
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
    fi
  fi
  
  # Fallback to command -v
  if [ -z "$_iw_script_path" ]; then
    _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
  fi
  
  # Fallback to default location
  if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
    _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
  fi
  
  # Derive WIZARDRY_DIR from script path
  if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
    _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
    if [ -n "$_iw_script_dir" ]; then
      WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
    fi
  fi
fi

# Validate WIZARDRY_DIR
if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
  printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
  return 1
fi

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "WIZARDRY_DIR=$WIZARDRY_DIR" >&2
export WIZARDRY_DIR

# Set up SPELLBOOK_DIR
: "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
export SPELLBOOK_DIR

# ============================================================================
# PATH-BASED EXECUTION (Simple Paradigm)
# ============================================================================
# All spells and imps are added to PATH via learn-spellbook.
# No preloading, no glosses, no word-of-binding - just simple PATH execution.
# ============================================================================

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Adding wizardry directories to PATH..." >&2

# Add all spell category directories to PATH
for category_dir in "$WIZARDRY_DIR/spells"/*; do
  [ -d "$category_dir" ] || continue
  # Skip hidden directories (like .imps, .arcana, .wizardry)
  case "$category_dir" in
    */.*) continue ;;
  esac
  PATH="$category_dir:$PATH"
done

# Add all imp family directories to PATH
if [ -d "$WIZARDRY_DIR/spells/.imps" ]; then
  for imp_dir in "$WIZARDRY_DIR/spells/.imps"/*; do
    [ -d "$imp_dir" ] || continue
    PATH="$imp_dir:$PATH"
  done
fi

export PATH

# Optional: Generate first-word glosses for space-separated invocation
# This still allows "env or VAR DEFAULT" instead of just "env-or VAR DEFAULT"
# Skip in test mode (tests don't need glosses)
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  if command -v generate-glosses >/dev/null 2>&1; then
    [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Generating first-word glosses..." >&2
    
    # Generate glosses and eval them into current shell
    if _iw_gloss_output=$(generate-glosses --quiet 2>&1); then
      if [ -n "$_iw_gloss_output" ]; then
        eval "$_iw_gloss_output"
        [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Gloss functions loaded" >&2
      fi
    fi
  fi
fi

# Verify that menu command is available (skip in test mode)
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  if ! command -v menu >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - menu spell not found in PATH" >&2
    return 1
  fi
fi

# Wizardry initialization complete
[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Wizardry initialization complete" >&2
set +eu
return 0
