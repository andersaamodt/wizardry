#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# Simple PATH-based invocation (no word-of-binding preloading)
# Source this script to enable wizardry spells and imps from PATH.

# This script must be sourced, not executed
# Uncastable pattern - ensures spell is sourced, not executed
_iw_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _iw_sourced=1 ;;
  esac
else
  _iw_base=${0##*/}
  case "$_iw_base" in
    sh|dash|bash|zsh|ksh|mksh) _iw_sourced=1 ;;
    invoke-wizardry) _iw_sourced=0 ;;
    *) _iw_sourced=1 ;;
  esac
fi

if [ "$_iw_sourced" -eq 0 ]; then
  printf '%s\n' "This spell cannot be cast directly. Invoke it with: . invoke-wizardry" >&2
  return 1 2>/dev/null || exit 1
fi
printf '[DEBUG invoke-wizardry] Sourcing check passed\n' >&2
unset _iw_sourced _iw_base

# Ensure baseline PATH before anything else (macOS may have empty PATH)
printf '[DEBUG invoke-wizardry] Setting baseline PATH\n' >&2
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac
printf '[DEBUG invoke-wizardry] PATH set\n' >&2

# Permissive mode - this file is sourced into user's shell
printf '[DEBUG invoke-wizardry] Setting permissive mode\n' >&2
set +eu
printf '[DEBUG invoke-wizardry] Permissive mode set\n' >&2

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  printf '[DEBUG invoke-wizardry] Already invoked, skipping\n' >&2
  [ "${WIZARDRY_DEBUG-}" = "1" ] && \
    printf '[invoke-wizardry] %s\n' "Already invoked, skipping" >&2
  return 0
fi
printf '[DEBUG invoke-wizardry] First invocation\n' >&2
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED
printf '[DEBUG invoke-wizardry] _WIZARDRY_INVOKED exported\n' >&2
# Note: Exported so subprocesses (like test files) know wizardry is available

[ "${WIZARDRY_DEBUG-}" = "1" ] && \
  printf '[invoke-wizardry] %s\n' "Starting wizardry initialization" >&2

# Detect WIZARDRY_DIR
printf '[DEBUG invoke-wizardry] Detecting WIZARDRY_DIR\n' >&2
if [ -z "${WIZARDRY_DIR-}" ]; then
  printf '[DEBUG invoke-wizardry] WIZARDRY_DIR not set, detecting...\n' >&2
  # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
  _iw_script_path=""
  if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
    _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    printf '[DEBUG invoke-wizardry] Using BASH_SOURCE: %s\n' "$_iw_script_path" >&2
  elif [ -n "${ZSH_VERSION-}" ]; then
    # In zsh, use %x expansion to get sourced file path
    _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
    # Fallback to %N if %x didn't work
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
    fi
    printf '[DEBUG invoke-wizardry] Using ZSH expansion: %s\n' "$_iw_script_path" >&2
  fi
  
  # Fallback to command -v
  if [ -z "$_iw_script_path" ]; then
    printf '[DEBUG invoke-wizardry] Trying command -v fallback\n' >&2
    _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    printf '[DEBUG invoke-wizardry] command -v result: %s\n' "$_iw_script_path" >&2
  fi
  
  # Fallback to default location
  if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
    printf '[DEBUG invoke-wizardry] Trying HOME fallback\n' >&2
    _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
  fi
  
  # Derive WIZARDRY_DIR from script path
  printf '[DEBUG invoke-wizardry] Deriving WIZARDRY_DIR from: %s\n' "$_iw_script_path" >&2
  if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
    _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
    printf '[DEBUG invoke-wizardry] Script dir: %s\n' "$_iw_script_dir" >&2
    if [ -n "$_iw_script_dir" ]; then
      WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      printf '[DEBUG invoke-wizardry] Derived WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
    fi
  fi
  
  # Final fallback: if in a directory with spells subdirectory, use PWD
  if [ -z "${WIZARDRY_DIR-}" ] && [ -d "spells" ] && [ -d "spells/.imps" ]; then
    printf '[DEBUG invoke-wizardry] Using PWD fallback\n' >&2
    WIZARDRY_DIR=$(pwd -P)
    printf '[DEBUG invoke-wizardry] PWD-based WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  fi
fi
printf '[DEBUG invoke-wizardry] Final WIZARDRY_DIR: %s\n' "${WIZARDRY_DIR-EMPTY}" >&2

# Validate WIZARDRY_DIR
printf '[DEBUG invoke-wizardry] Validating WIZARDRY_DIR\n' >&2
if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
  printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
  printf '[DEBUG invoke-wizardry] WIZARDRY_DIR validation failed\n' >&2
  return 1
fi
printf '[DEBUG invoke-wizardry] WIZARDRY_DIR validated successfully\n' >&2

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "WIZARDRY_DIR=$WIZARDRY_DIR" >&2
export WIZARDRY_DIR
printf '[DEBUG invoke-wizardry] WIZARDRY_DIR exported\n' >&2

# Set up SPELLBOOK_DIR
: "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
export SPELLBOOK_DIR

# ============================================================================
# PATH-BASED EXECUTION (Simple Paradigm)
# ============================================================================
# All spells and imps are added to PATH via learn-spellbook.
# No preloading, no glosses, no word-of-binding - just simple PATH execution.
# ============================================================================

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Adding wizardry directories to PATH..." >&2
printf '[DEBUG invoke-wizardry] Starting PATH setup\n' >&2

# Add SPELLBOOK_DIR to PATH first (highest priority for user commands)
if [ -d "$SPELLBOOK_DIR" ]; then
  printf '[DEBUG invoke-wizardry] Adding SPELLBOOK_DIR to PATH: %s\n' "$SPELLBOOK_DIR" >&2
  PATH="$SPELLBOOK_DIR:$PATH"
  
  # Also add SPELLBOOK_DIR subdirectories (custom categories) recursively
  for subdir in "$SPELLBOOK_DIR"/*; do
    [ -d "$subdir" ] || continue
    # Skip hidden directories (check basename, not full path)
    _subdir_name=${subdir##*/}
    case "$_subdir_name" in
      .*) continue ;;
    esac
    PATH="$subdir:$PATH"
    
    # Also add subdirectories of subdirectories (match wizardry structure)
    for subsubdir in "$subdir"/*; do
      [ -d "$subsubdir" ] || continue
      PATH="$subsubdir:$PATH"
    done
  done
  printf '[DEBUG invoke-wizardry] SPELLBOOK_DIR added to PATH\n' >&2
fi

# Add all spell directories to PATH (including subdirectories)
printf '[DEBUG invoke-wizardry] Adding wizardry spell directories to PATH\n' >&2
for category_dir in "$WIZARDRY_DIR/spells"/* "$WIZARDRY_DIR/spells"/.*; do
  [ -d "$category_dir" ] || continue
  # Skip . and ..
  case "$category_dir" in
    */.|*/..) continue ;;
  esac
  PATH="$category_dir:$PATH"
  
  # Also add subdirectories to PATH
  for subdir in "$category_dir"/*; do
    [ -d "$subdir" ] || continue
    PATH="$subdir:$PATH"
  done
done
printf '[DEBUG invoke-wizardry] All spell directories added to PATH\n' >&2

export PATH
printf '[DEBUG invoke-wizardry] PATH exported\n' >&2

# Optional: Generate first-word glosses for space-separated invocation
# This still allows "env or VAR DEFAULT" instead of just "env-or VAR DEFAULT"
# Skip in test mode (tests don't need glosses)
printf '[DEBUG invoke-wizardry] Checking if gloss generation needed\n' >&2
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  printf '[DEBUG invoke-wizardry] Not in test mode, checking for generate-glosses\n' >&2
  if command -v generate-glosses >/dev/null 2>&1; then
    printf '[DEBUG invoke-wizardry] generate-glosses command found\n' >&2
    [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Loading first-word glosses..." >&2
    
    # PERFORMANCE OPTIMIZATION: Cache glosses to avoid regenerating on every shell startup
    # Glosses are ~640KB and take 0.07s to generate + 0.13s to eval
    # Caching reduces this to ~0.03s (sourcing from file)
    _iw_gloss_cache_dir="${TMPDIR:-/tmp}"
    
    # Use a persistent cache based on WIZARDRY_DIR to share across all shells
    # Include user ID to avoid permission issues in multi-user systems
    _iw_gloss_persistent="${_iw_gloss_cache_dir}/.wizardry-glosses-$(printf '%s' "$WIZARDRY_DIR" | cksum | cut -d' ' -f1)-$(id -u).sh"
    
    # CACHE INVALIDATION: Regenerate if any of these changed:
    # 1. Any spell file in spells/
    # 2. Synonym files in .spellbook/
    # 3. The generate-glosses script itself
    _iw_needs_regen=1
    if [ -f "$_iw_gloss_persistent" ]; then
      _iw_needs_regen=0
      
      # Check 1: generate-glosses script
      if command -v generate-glosses >/dev/null 2>&1; then
        _iw_gen_glosses_path=$(command -v generate-glosses)
        if [ -f "$_iw_gen_glosses_path" ] && [ "$_iw_gen_glosses_path" -nt "$_iw_gloss_persistent" ]; then
          _iw_needs_regen=1
        fi
      fi
      
      # Check 2: Any spell file newer than cache (find newest spell)
      if [ "$_iw_needs_regen" -eq 0 ] && [ -d "$WIZARDRY_DIR/spells" ]; then
        # Use find to check if any file in spells/ is newer than cache
        # Don't filter by -executable since touching a file removes the bit temporarily
        _iw_newest_spell=$(find "$WIZARDRY_DIR/spells" -type f -newer \
          "$_iw_gloss_persistent" -print -quit 2>/dev/null || true)
        if [ -n "$_iw_newest_spell" ]; then
          _iw_needs_regen=1
        fi
      fi
      
      # Check 3: Synonym files in .spellbook/
      if [ "$_iw_needs_regen" -eq 0 ]; then
        _iw_spellbook="${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}"
        for _iw_syn_file in "$_iw_spellbook/.synonyms" "$_iw_spellbook/.default-synonyms"; do
          if [ -f "$_iw_syn_file" ] && [ "$_iw_syn_file" -nt "$_iw_gloss_persistent" ]; then
            _iw_needs_regen=1
            break
          fi
        done
      fi
    fi
    
    # Regenerate cache if needed
    if [ "$_iw_needs_regen" -eq 1 ]; then
      [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Regenerating gloss cache..." >&2
      if generate-glosses --quiet > "$_iw_gloss_persistent.tmp" 2>&1; then
        mv "$_iw_gloss_persistent.tmp" "$_iw_gloss_persistent"
      else
        # If generation fails, clean up and fall back to direct eval
        rm -f "$_iw_gloss_persistent.tmp"
        _iw_gloss_persistent=""
      fi
    fi
    
    # Source cached glosses if available
    if [ -f "$_iw_gloss_persistent" ]; then
      . "$_iw_gloss_persistent"
      [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Gloss functions loaded from cache" >&2
    else
      # Fallback to direct generation if cache unavailable
      if _iw_gloss_output=$(generate-glosses --quiet 2>&1); then
        if [ -n "$_iw_gloss_output" ]; then
          eval "$_iw_gloss_output"
          [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Gloss functions loaded (uncached)" >&2
        fi
      fi
    fi
    
    unset _iw_gloss_cache_dir _iw_gloss_persistent _iw_needs_regen
    unset _iw_gen_glosses_path _iw_gloss_output _iw_newest_spell
    unset _iw_spellbook _iw_syn_file
    printf '[DEBUG invoke-wizardry] Gloss variables unset\n' >&2
  else
    printf '[DEBUG invoke-wizardry] generate-glosses command not found, skipping gloss generation\n' >&2
  fi
else
  printf '[DEBUG invoke-wizardry] In test mode, skipping gloss generation\n' >&2
fi

# Load MUD cd hook if enabled in config
printf '[DEBUG invoke-wizardry] Checking for MUD cd hook\n' >&2
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  _iw_mud_config="${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}/.mud"
  if [ -f "$_iw_mud_config" ] && grep -q "^cd-hook=1$" "$_iw_mud_config" 2>/dev/null; then
    printf '[DEBUG invoke-wizardry] MUD cd hook enabled, loading\n' >&2
    _iw_cd_hook="$WIZARDRY_DIR/spells/.arcana/mud/cd"
    if [ -f "$_iw_cd_hook" ]; then
      [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Loading cd hook" >&2
      . "$_iw_cd_hook"
      printf '[DEBUG invoke-wizardry] MUD cd hook loaded\n' >&2
    fi
  else
    printf '[DEBUG invoke-wizardry] MUD cd hook not enabled\n' >&2
  fi
  unset _iw_mud_config _iw_cd_hook
  printf '[DEBUG invoke-wizardry] MUD config variables unset\n' >&2
else
  printf '[DEBUG invoke-wizardry] In test mode, skipping MUD cd hook\n' >&2
fi

# Verify that menu command is available (skip in test mode)
printf '[DEBUG invoke-wizardry] Verifying menu command\n' >&2
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  if ! command -v menu >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - menu spell not found in PATH" >&2
    printf '[DEBUG invoke-wizardry] menu command not found in PATH\n' >&2
    return 1
  fi
  printf '[DEBUG invoke-wizardry] menu command found\n' >&2
fi

# Wizardry initialization complete
printf '[DEBUG invoke-wizardry] Wizardry initialization complete\n' >&2
[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Wizardry initialization complete" >&2

# Debug: Check if banish command is available
printf '[DEBUG invoke-wizardry] Checking if banish command is available\n' >&2
if command -v banish >/dev/null 2>&1; then
  _banish_path=$(command -v banish 2>&1)
  printf '[DEBUG invoke-wizardry] banish command found at: %s\n' "$_banish_path" >&2
else
  printf '[DEBUG invoke-wizardry] WARNING: banish command not found in PATH\n' >&2
fi

set +eu
printf '[DEBUG invoke-wizardry] set +eu executed, about to return\n' >&2
printf '[DEBUG invoke-wizardry] Returning successfully from invoke-wizardry\n' >&2
return 0
