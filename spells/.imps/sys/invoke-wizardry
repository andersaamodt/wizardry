#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Debug mode (set WIZARDRY_DEBUG=1 to enable diagnostic output)
_iw_debug() {
  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    printf '[invoke-wizardry] %s\n' "$*" >&2
  fi
}

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  _iw_debug "Already invoked, skipping"
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_iw_debug "Starting wizardry initialization"

invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  _iw_debug "WIZARDRY_DIR=$WIZARDRY_DIR"
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR

  # ============================================================================
  # GLOSSARY-BASED INTERCEPTION SYSTEM (Phase 5)
  # ============================================================================
  # Glosses are auto-generated wrappers that make spells accessible via PATH.
  # They enable POSIX-compliant, hotloadable invocation for:
  # - All wizardry spells
  # - User-defined synonyms (.synonyms file)
  # - Default synonyms (.default-synonyms file)
  #
  # Each gloss is a minimal script: exec parse "spell-name" "$@"
  # The parse imp handles command resolution and recursion prevention.
  #
  # Glosses are regenerated automatically in the background to stay in sync
  # with spells and synonym definitions. This is transparent to users.
  # ============================================================================
  
  _iw_glossary="$SPELLBOOK_DIR/.glossary"
  
  # Create glossary directory if missing
  if [ ! -d "$_iw_glossary" ]; then
    mkdir -p "$_iw_glossary" 2>/dev/null || :
  fi
  
  # Prepend glossary to PATH (give parse first shot at all commands)
  PATH="$_iw_glossary:$PATH"
  export PATH
  
  _iw_debug "Glossary prepended to PATH: $_iw_glossary"
  
  # SPIRAL DEBUG PHASE 1: Minimal pre-loading (menu + dependencies only)
  # Future: ALL wizardry spells will be pre-loaded, hotloading only for ~/.spellbook
  # Current: Pre-load menu essentials, hotload other wizardry spells temporarily
  
  _iw_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
  if [ -r "$_iw_wob" ]; then
    WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_iw_wob" 2>/dev/null || :
    unset WIZARDRY_SOURCE_WORD_OF_BINDING
  fi
  if ! command -v word_of_binding >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load word-of-binding" >&2
    return 1
  fi
  
  # Pre-load essential imps needed by menu
  # These are from sys/, out/, fs/, cond/ families
  _iw_debug "Pre-loading essential imps"
  for _imp_name in \
    require \
    require-wizardry \
    castable \
    env-clear \
    env-or \
    temp-file \
    cleanup-file \
    has \
    die \
    warn \
    fail \
    info \
    say; do
    # Search for imp in all families
    for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
      [ -d "$_family_dir" ] || continue
      _imp_file="$_family_dir/$_imp_name"
      if [ -f "$_imp_file" ]; then
        if command -v word_of_binding >/dev/null 2>&1; then
          word_of_binding "$_imp_name" 2>/dev/null || :
        fi
        break
      fi
    done
  done
  
  # Centralized gloss generation: Automatically regenerate glosses for:
  # 1. All wizardry spells (in $WIZARDRY_DIR/spells/)
  # 2. Synonyms from $SPELLBOOK_DIR/.synonyms
  # 3. Default synonyms from $SPELLBOOK_DIR/.default-synonyms
  #
  # This runs asynchronously in the background to avoid delaying shell startup.
  # With 387+ glosses, async is essential for fast shell startup.
  # The generate-glosses spell handles unified generation from all sources.
  # Must run AFTER essential imps are loaded (needs require-wizardry, env-clear, env-or, etc.)
  if [ -x "$WIZARDRY_DIR/spells/system/generate-glosses" ]; then
    # Run as executable in background with full wizardry environment
    # Build comprehensive PATH including ALL imp families
    _gloss_imp_path=""
    for _imp_family in "$WIZARDRY_DIR"/spells/.imps/*; do
      [ -d "$_imp_family" ] || continue
      case "$_imp_family" in
        */test) continue ;;  # Skip test imps
      esac
      _gloss_imp_path="${_gloss_imp_path}${_gloss_imp_path:+:}${_imp_family}"
    done
    
    # Run in background with comprehensive PATH
    # If WIZARDRY_DEBUG is set, log errors to help diagnose issues
    if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
      {
        PATH="${_gloss_imp_path}:${PATH}" \
          "$WIZARDRY_DIR/spells/system/generate-glosses" --quiet \
          2>"${SPELLBOOK_DIR}/.glossary-errors.log" &
      }
      _iw_debug "Gloss generation errors (if any) logged to ${SPELLBOOK_DIR}/.glossary-errors.log"
    else
      {
        PATH="${_gloss_imp_path}:${PATH}" \
          "$WIZARDRY_DIR/spells/system/generate-glosses" --quiet &
      } 2>/dev/null
    fi
    
    _iw_debug "Started async gloss regeneration (spells + synonyms + imps + arcana)"
    # Show user-visible message about glossary startup
    if command -v info >/dev/null 2>&1; then
      info "Glossary regenerating in background..."
    fi
  fi
  
  # Pre-load menu and its helper spell dependencies
  _iw_debug "Pre-loading essential spells"
  for _spell_name in \
    menu \
    await-keypress \
    move-cursor \
    fathom-cursor \
    fathom-terminal \
    require-command \
    cursor-blink \
    colors \
    banish \
    validate-spells; do
    # Search for spell in all categories
    for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
      [ -d "$_spell_dir" ] || continue
      case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
      _spell_file="$_spell_dir/$_spell_name"
      if [ -f "$_spell_file" ]; then
        _iw_debug "Loading spell: $_spell_name"
        if command -v word_of_binding >/dev/null 2>&1 \
          && word_of_binding "$_spell_name" 2>/dev/null; then
          _iw_status="✓ Loaded"
        else
          _iw_status="✗ Failed"
        fi
        _iw_debug "  $_iw_status: $_spell_name"
        break
      fi
    done
  done

  _iw_menu_ok=0
  if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    if whence -v menu 2>/dev/null | grep -q 'shell function'; then
      _iw_menu_ok=1
    fi
  elif command -v type >/dev/null 2>&1; then
    if type menu 2>/dev/null | grep -q 'function'; then
      _iw_menu_ok=1
    fi
  elif command -v menu >/dev/null 2>&1; then
    _iw_menu_ok=1
  fi

  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
      _iw_debug "menu whence: $(whence -v menu 2>/dev/null)"
    elif command -v type >/dev/null 2>&1; then
      _iw_debug "menu type: $(type menu 2>/dev/null)"
    else
      _iw_debug "menu path: $(command -v menu 2>/dev/null)"
    fi
  fi

  if [ "$_iw_menu_ok" -ne 1 ]; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load menu spell" >&2
    return 1
  fi

  # Wizardry initialization complete
  _iw_debug "Wizardry initialization complete"
  return 0
}

# Run the setup
invoke_wizardry
_iw_status=$?
return $_iw_status
