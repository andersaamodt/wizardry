#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# Simple PATH-based invocation (no word-of-binding preloading)
# Source this script to enable wizardry spells and imps from PATH.

# This script must be sourced, not executed
# Guard against direct execution (inline check - PATH not set up yet for uncastable imp)
_iw_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _iw_sourced=1 ;;
  esac
else
  _iw_base=${0##*/}
  case "$_iw_base" in
    sh|dash|bash|zsh|ksh|mksh) _iw_sourced=1 ;;
    invoke-wizardry) _iw_sourced=0 ;;
    *) _iw_sourced=1 ;;
  esac
fi

if [ "$_iw_sourced" -eq 0 ]; then
  printf '%s\n' "invoke-wizardry: must be sourced, not executed" >&2
  printf '%s\n' "Usage: . invoke-wizardry" >&2
  exit 1
fi
unset _iw_sourced _iw_base

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  [ "${WIZARDRY_DEBUG-}" = "1" ] && \
    printf '[invoke-wizardry] %s\n' "Already invoked, skipping" >&2
  return 0
fi
_WIZARDRY_INVOKED=1
# Note: NOT exported - each subprocess should invoke wizardry independently

[ "${WIZARDRY_DEBUG-}" = "1" ] && \
  printf '[invoke-wizardry] %s\n' "Starting wizardry initialization" >&2

# Detect WIZARDRY_DIR
if [ -z "${WIZARDRY_DIR-}" ]; then
  # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
  _iw_script_path=""
  if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
    _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
  elif [ -n "${ZSH_VERSION-}" ]; then
    # In zsh, use %x expansion to get sourced file path
    _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
    # Fallback to %N if %x didn't work
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
    fi
  fi
  
  # Fallback to command -v
  if [ -z "$_iw_script_path" ]; then
    _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
  fi
  
  # Fallback to default location
  if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
    _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
  fi
  
  # Derive WIZARDRY_DIR from script path
  if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
    _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
    if [ -n "$_iw_script_dir" ]; then
      WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
    fi
  fi
  
  # Final fallback: if in a directory with spells subdirectory, use PWD
  if [ -z "${WIZARDRY_DIR-}" ] && [ -d "spells" ] && [ -d "spells/.imps" ]; then
    WIZARDRY_DIR=$(pwd -P)
  fi
fi

# Validate WIZARDRY_DIR
if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
  printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
  return 1
fi

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "WIZARDRY_DIR=$WIZARDRY_DIR" >&2
export WIZARDRY_DIR

# Set up SPELLBOOK_DIR
: "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
export SPELLBOOK_DIR

# ============================================================================
# PATH-BASED EXECUTION (Simple Paradigm)
# ============================================================================
# All spells and imps are added to PATH via learn-spellbook.
# No preloading, no glosses, no word-of-binding - just simple PATH execution.
# ============================================================================

[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Adding wizardry directories to PATH..." >&2

# Add all spell directories to PATH (including subdirectories)
for category_dir in "$WIZARDRY_DIR/spells"/* "$WIZARDRY_DIR/spells"/.*; do
  [ -d "$category_dir" ] || continue
  # Skip . and ..
  case "$category_dir" in
    */.|*/..) continue ;;
  esac
  PATH="$category_dir:$PATH"
  
  # Also add subdirectories to PATH
  for subdir in "$category_dir"/*; do
    [ -d "$subdir" ] || continue
    PATH="$subdir:$PATH"
  done
done

export PATH

# Optional: Generate first-word glosses for space-separated invocation
# This still allows "env or VAR DEFAULT" instead of just "env-or VAR DEFAULT"
# Skip in test mode (tests don't need glosses)
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  if command -v generate-glosses >/dev/null 2>&1; then
    [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Generating first-word glosses..." >&2
    
    # Generate glosses and eval them into current shell
    if _iw_gloss_output=$(generate-glosses --quiet 2>&1); then
      if [ -n "$_iw_gloss_output" ]; then
        eval "$_iw_gloss_output"
        [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Gloss functions loaded" >&2
      fi
    fi
  fi
fi

# Load MUD cd hook if enabled in config
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  _iw_mud_config="${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}/.mud"
  if [ -f "$_iw_mud_config" ] && grep -q "^cd-hook=1$" "$_iw_mud_config" 2>/dev/null; then
    _iw_cd_hook="$WIZARDRY_DIR/spells/.arcana/mud/cd"
    if [ -f "$_iw_cd_hook" ]; then
      [ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Loading cd hook" >&2
      . "$_iw_cd_hook"
    fi
  fi
  unset _iw_mud_config _iw_cd_hook
fi

# Verify that menu command is available (skip in test mode)
if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
  if ! command -v menu >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - menu spell not found in PATH" >&2
    return 1
  fi
fi

# Wizardry initialization complete
[ "${WIZARDRY_DEBUG-}" = "1" ] && printf '[invoke-wizardry] %s\n' "Wizardry initialization complete" >&2
set +eu
return 0
