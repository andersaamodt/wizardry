#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Debug mode (set WIZARDRY_DEBUG=1 to enable diagnostic output)
_iw_debug() {
  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    printf '[invoke-wizardry] %s\n' "$*" >&2
  fi
}

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  _iw_debug "Already invoked, skipping"
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_iw_debug "Starting wizardry initialization"

invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  _iw_debug "WIZARDRY_DIR=$WIZARDRY_DIR"
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR

  
  # SPIRAL DEBUG PHASE 1: Minimal pre-loading (menu + dependencies only)
  # Future: ALL wizardry spells will be pre-loaded, hotloading only for ~/.spellbook
  # Current: Pre-load menu essentials, hotload other wizardry spells temporarily
  
  _iw_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
  if [ -r "$_iw_wob" ]; then
    WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_iw_wob" 2>/dev/null || :
    unset WIZARDRY_SOURCE_WORD_OF_BINDING
  fi
  if ! command -v word_of_binding >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load word-of-binding" >&2
    return 1
  fi
  
  _iw_spell_levels="$WIZARDRY_DIR/spells/.imps/sys/spell-levels"
  if [ -r "$_iw_spell_levels" ]; then
    # shellcheck disable=SC1090
    . "$_iw_spell_levels"
  else
    printf '%s\n' "invoke-wizardry: ERROR - spell-levels not found" >&2
    return 1
  fi
  if ! command -v get_level_imps >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - get_level_imps unavailable" >&2
    return 1
  fi
  if ! command -v get_level_spells >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - get_level_spells unavailable" >&2
    return 1
  fi

  _iw_preload_max_level=1
  # Pre-load all spells/imps through level 1
  _iw_debug "Pre-loading spells and imps through level ${_iw_preload_max_level}"
  for _iw_level in 0 1; do
    _iw_level_imps=$(get_level_imps "$_iw_level")
    for _imp_entry in $_iw_level_imps; do
      _imp_name=${_imp_entry##*/}
      if command -v word_of_binding >/dev/null 2>&1; then
        word_of_binding "$_imp_name" 2>/dev/null || :
      fi
    done

    _iw_level_spells=$(get_level_spells "$_iw_level")
    for _spell_entry in $_iw_level_spells; do
      case "$_spell_entry" in
        *:*) _spell_name=${_spell_entry%%:*} ;;
        *) _spell_name=$_spell_entry ;;
      esac
      if command -v word_of_binding >/dev/null 2>&1; then
        word_of_binding "$_spell_name" 2>/dev/null || :
      fi
    done
  done

  if [ "$_iw_preload_max_level" -ge 2 ]; then
    _iw_menu_ok=0
    if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
      if whence -v menu 2>/dev/null | grep -q 'function'; then
        _iw_menu_ok=1
      fi
    elif command -v type >/dev/null 2>&1; then
      if type menu 2>/dev/null | grep -q 'function'; then
        _iw_menu_ok=1
      fi
    elif command -v menu >/dev/null 2>&1; then
      _iw_menu_ok=1
    fi

    if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
      if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
        _iw_debug "menu whence: $(whence -v menu 2>/dev/null)"
      elif command -v type >/dev/null 2>&1; then
        _iw_debug "menu type: $(type menu 2>/dev/null)"
      else
        _iw_debug "menu path: $(command -v menu 2>/dev/null)"
      fi
    fi

    if [ "$_iw_menu_ok" -ne 1 ]; then
      printf '%s\n' "invoke-wizardry: ERROR - failed to load menu spell" >&2
      return 1
    fi
  fi

  if [ "${WIZARDRY_SPIRAL_MINIMAL-}" = "1" ]; then
    _iw_debug "Spiral minimal mode: skipping command_not_found handlers"
    _iw_debug "Wizardry initialization complete"
    return 0
  fi
  
  # Set up command_not_found_handle for hotloading everything else
  _iw_debug "Setting up command_not_found handlers"
  # Set up command_not_found_handle for bash
  if eval '[ -n "${BASH_VERSION+x}" ]' 2>/dev/null; then
    # Bash-specific command_not_found_handle
    command_not_found_handle() {
      # Debug: Log entry to handler
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Called with: %s\n' "$1" >&2
      fi
      
      # Prevent infinite recursion for the same command while allowing nested lookups.
      if [ -n "${_WIZARDRY_IN_CNF-}" ] && [ "${_WIZARDRY_IN_CNF}" = "$1" ]; then
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Recursion detected for: %s\n' "$1" >&2
        fi
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _iw_prev_cnf="${_WIZARDRY_IN_CNF-}"
      _WIZARDRY_IN_CNF=$1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -r "$_cnf_wob" ]; then
        if [ "${_WIZARDRY_WOB_LOADED-}" != "1" ]; then
          WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_cnf_wob" 2>/dev/null || :
          unset WIZARDRY_SOURCE_WORD_OF_BINDING
          _WIZARDRY_WOB_LOADED=1
          export _WIZARDRY_WOB_LOADED
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Calling word_of_binding --run %s\n' "$1" >&2
        fi
        if command -v word_of_binding >/dev/null 2>&1 \
          && word_of_binding --run "$@" 2>/dev/null; then
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[handle-command-not-found] word_of_binding succeeded for: %s\n' "$1" >&2
          fi
          if [ -n "$_iw_prev_cnf" ]; then
            _WIZARDRY_IN_CNF="$_iw_prev_cnf"
          else
            unset _WIZARDRY_IN_CNF
          fi
          return 0
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] word_of_binding failed for: %s\n' "$1" >&2
        fi
      fi
      
      # Command truly not found
      if [ -n "$_iw_prev_cnf" ]; then
        _WIZARDRY_IN_CNF="$_iw_prev_cnf"
      else
        unset _WIZARDRY_IN_CNF
      fi
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Command truly not found: %s\n' "$1" >&2
      fi
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
    _iw_debug "  ✓ bash command_not_found_handle configured"
  elif eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    # Zsh-specific command_not_found_handler
    command_not_found_handler() {
      # Debug: Log entry to handler
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Called with: %s\n' "$1" >&2
      fi
      
      # Prevent infinite recursion for the same command while allowing nested lookups.
      if [ -n "${_WIZARDRY_IN_CNF-}" ] && [ "${_WIZARDRY_IN_CNF}" = "$1" ]; then
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Recursion detected for: %s\n' "$1" >&2
        fi
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _iw_prev_cnf="${_WIZARDRY_IN_CNF-}"
      _WIZARDRY_IN_CNF=$1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -r "$_cnf_wob" ]; then
        if [ "${_WIZARDRY_WOB_LOADED-}" != "1" ]; then
          WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_cnf_wob" 2>/dev/null || :
          unset WIZARDRY_SOURCE_WORD_OF_BINDING
          _WIZARDRY_WOB_LOADED=1
          export _WIZARDRY_WOB_LOADED
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Calling word_of_binding --run %s\n' "$1" >&2
        fi
        if command -v word_of_binding >/dev/null 2>&1 \
          && word_of_binding --run "$@" 2>/dev/null; then
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[handle-command-not-found] word_of_binding succeeded for: %s\n' "$1" >&2
          fi
          if [ -n "$_iw_prev_cnf" ]; then
            _WIZARDRY_IN_CNF="$_iw_prev_cnf"
          else
            unset _WIZARDRY_IN_CNF
          fi
          return 0
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] word_of_binding failed for: %s\n' "$1" >&2
        fi
      fi
      
      # Command truly not found
      if [ -n "$_iw_prev_cnf" ]; then
        _WIZARDRY_IN_CNF="$_iw_prev_cnf"
      else
        unset _WIZARDRY_IN_CNF
      fi
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Command truly not found: %s\n' "$1" >&2
      fi
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
    _iw_debug "  ✓ zsh command_not_found_handler configured"
  fi
  
  _iw_debug "Wizardry initialization complete"
  return 0
}

# Run the setup
invoke_wizardry
_iw_status=$?
return $_iw_status
