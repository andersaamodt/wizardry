#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR
  
  # MINIMAL PHASE 1: Pre-load menu and its imp dependencies + hotloading
  # Pre-load for immediate availability, hotload everything else on-demand
  
  # Helper function to extract and eval function bodies from spell/imp files
  _iw_load_module() {
    _module_file="$1"
    _module_name="$2"
    _is_imp="${3:-0}"
    
    # Determine true-name (imps use _underscore, spells don't)
    if [ "$_is_imp" -eq 1 ]; then
      _true_name=$(printf '_%s' "$_module_name" | sed 's/-/_/g')
    else
      _true_name=$(printf '%s' "$_module_name" | sed 's/-/_/g')
    fi
    
    # Check if has function
    _pattern="^[[:space:]]*${_true_name}[[:space:]]*\\(\\)"
    if ! grep -qE "$_pattern" "$_module_file" 2>/dev/null; then
      return 1
    fi
    
    # Extract function body with AWK
    _body=$(awk '
BEGIN {
  func_kw = "^[[:space:]]*function[[:space:]]+[A-Za-z_][A-Za-z0-9_]*"
  func_paren = "[[:space:]]*\\(\\)?[[:space:]]*\\{"
  func_simple = "^[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\(\\)[[:space:]]*\\{"
  func_header = "^[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\(\\)[[:space:]]*$"
}
function brace_delta(s, n, m) {
  n = gsub(/{/, "{", s)
  m = gsub(/}/, "}", s)
  return n - m
}
{
  if (!in_func) {
    if (match($0, func_kw func_paren)) {
      in_func = 1
      brace = brace_delta($0)
      print
      if (brace <= 0) { in_func = 0 }
      next
    }
    if (match($0, func_simple)) {
      in_func = 1
      brace = brace_delta($0)
      print
      if (brace <= 0) { in_func = 0 }
      next
    }
    if (match($0, func_header)) {
      in_func = 1
      brace = 0
      print
      next
    }
    next
  }
  brace += brace_delta($0)
  print
  if (brace <= 0) { in_func = 0 }
}
' "$_module_file") || return 1
    
    # Eval the function body
    if [ -n "$_body" ]; then
      if ! eval "$_body" 2>/dev/null; then
        return 1
      fi
    fi
    
    # Create alias if name differs from true-name
    if [ "$_module_name" != "$_true_name" ]; then
      alias "$_module_name=$_true_name" 2>/dev/null || :
    fi
    
    return 0
  }
  
  # Pre-load essential imps needed by menu
  # These are from sys/, out/, fs/, cond/ families
  _iw_essential_imps="require require-wizardry castable env-clear temp-file cleanup-file has die warn fail say"
  for _imp_name in $_iw_essential_imps; do
    # Search for imp in all families
    for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
      [ -d "$_family_dir" ] || continue
      _imp_file="$_family_dir/$_imp_name"
      if [ -f "$_imp_file" ]; then
        _iw_load_module "$_imp_file" "$_imp_name" 1 2>/dev/null || :
        break
      fi
    done
  done
  
  # Pre-load menu and its helper spell dependencies
  _iw_essential_spells="menu await-keypress move-cursor fathom-cursor fathom-terminal cursor-blink colors"
  for _spell_name in $_iw_essential_spells; do
    # Search for spell in all categories
    for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
      [ -d "$_spell_dir" ] || continue
      case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
      _spell_file="$_spell_dir/$_spell_name"
      if [ -f "$_spell_file" ]; then
        _iw_load_module "$_spell_file" "$_spell_name" 0 2>/dev/null || :
        break
      fi
    done
  done
  
  # Set up command_not_found_handle for hotloading everything else
  # Set up command_not_found_handle for bash
  if eval '[ -n "${BASH_VERSION+x}" ]' 2>/dev/null; then
    # Bash-specific command_not_found_handle
    command_not_found_handle() {
      # Prevent infinite recursion
      if [ "${_WIZARDRY_IN_CNF-}" = "1" ]; then
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _WIZARDRY_IN_CNF=1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -x "$_cnf_wob" ]; then
        if "$_cnf_wob" "$@" 2>/dev/null; then
          unset _WIZARDRY_IN_CNF
          return 0
        fi
      fi
      
      # Command truly not found
      unset _WIZARDRY_IN_CNF
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
  elif eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    # Zsh-specific command_not_found_handler
    command_not_found_handler() {
      # Prevent infinite recursion
      if [ "${_WIZARDRY_IN_CNF-}" = "1" ]; then
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _WIZARDRY_IN_CNF=1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -x "$_cnf_wob" ]; then
        if "$_cnf_wob" "$@" 2>/dev/null; then
          unset _WIZARDRY_IN_CNF
          return 0
        fi
      fi
      
      # Command truly not found
      unset _WIZARDRY_IN_CNF
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
  fi
  
  return 0
}

# Run the setup
_invoke_wizardry
_iw_status=$?
return $_iw_status
