#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Debug mode (set WIZARDRY_DEBUG=1 to enable diagnostic output)
_iw_debug() {
  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    printf '[invoke-wizardry] %s\n' "$*" >&2
  fi
}

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  _iw_debug "Already invoked, skipping"
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_iw_debug "Starting wizardry initialization"

invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  _iw_debug "WIZARDRY_DIR=$WIZARDRY_DIR"
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR

  # ============================================================================
  # GLOSSARY-BASED INTERCEPTION SYSTEM (Phase 5)
  # ============================================================================
  # Glosses are auto-generated wrappers that make spells accessible via PATH.
  # They enable POSIX-compliant, hotloadable invocation for:
  # - All wizardry spells
  # - User-defined synonyms (.synonyms file)
  # - Default synonyms (.default-synonyms file)
  #
  # Each gloss is a minimal script: exec parse "spell-name" "$@"
  # The parse imp handles command resolution and recursion prevention.
  #
  # Glosses are regenerated automatically in the background to stay in sync
  # with spells and synonym definitions. This is transparent to users.
  # ============================================================================
  
  _iw_glossary="$SPELLBOOK_DIR/.glossary"
  
  # Create glossary directory if missing
  if [ ! -d "$_iw_glossary" ]; then
    mkdir -p "$_iw_glossary" 2>/dev/null || :
  fi
  
  # Prepend glossary to PATH (give parse first shot at all commands)
  PATH="$_iw_glossary:$PATH"
  export PATH
  
  _iw_debug "Glossary prepended to PATH: $_iw_glossary"
  
  # Centralized gloss generation: Automatically regenerate glosses for:
  # 1. All wizardry spells (in $WIZARDRY_DIR/spells/)
  # 2. Synonyms from $SPELLBOOK_DIR/.synonyms
  # 3. Default synonyms from $SPELLBOOK_DIR/.default-synonyms
  #
  # This runs asynchronously in the background to avoid delaying shell startup.
  # The generate-glosses spell handles unified generation from all sources.
  if [ -x "$WIZARDRY_DIR/spells/system/generate-glosses" ]; then
    {
      # Run in background subshell - this is non-blocking
      "$WIZARDRY_DIR/spells/system/generate-glosses" --quiet 2>/dev/null &
    } 2>/dev/null
    _iw_debug "Started async gloss regeneration (spells + synonyms)"
  fi
  
  # SPIRAL DEBUG PHASE 1: Minimal pre-loading (menu + dependencies only)
  # Future: ALL wizardry spells will be pre-loaded, hotloading only for ~/.spellbook
  # Current: Pre-load menu essentials, hotload other wizardry spells temporarily
  
  _iw_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
  if [ -r "$_iw_wob" ]; then
    WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_iw_wob" 2>/dev/null || :
    unset WIZARDRY_SOURCE_WORD_OF_BINDING
  fi
  if ! command -v word_of_binding >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load word-of-binding" >&2
    return 1
  fi
  
  # Pre-load essential imps needed by menu
  # These are from sys/, out/, fs/, cond/ families
  _iw_debug "Pre-loading essential imps"
  for _imp_name in \
    require \
    require-wizardry \
    castable \
    env-clear \
    temp-file \
    cleanup-file \
    has \
    die \
    warn \
    fail \
    say; do
    # Search for imp in all families
    for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
      [ -d "$_family_dir" ] || continue
      _imp_file="$_family_dir/$_imp_name"
      if [ -f "$_imp_file" ]; then
        if command -v word_of_binding >/dev/null 2>&1; then
          word_of_binding "$_imp_name" 2>/dev/null || :
        fi
        break
      fi
    done
  done
  
  # Pre-load menu and its helper spell dependencies
  _iw_debug "Pre-loading essential spells"
  for _spell_name in \
    menu \
    await-keypress \
    move-cursor \
    fathom-cursor \
    fathom-terminal \
    require-command \
    cursor-blink \
    colors \
    banish \
    validate-spells; do
    # Search for spell in all categories
    for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
      [ -d "$_spell_dir" ] || continue
      case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
      _spell_file="$_spell_dir/$_spell_name"
      if [ -f "$_spell_file" ]; then
        _iw_debug "Loading spell: $_spell_name"
        if command -v word_of_binding >/dev/null 2>&1 \
          && word_of_binding "$_spell_name" 2>/dev/null; then
          _iw_status="✓ Loaded"
        else
          _iw_status="✗ Failed"
        fi
        _iw_debug "  $_iw_status: $_spell_name"
        break
      fi
    done
  done

  _iw_menu_ok=0
  if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    if whence -v menu 2>/dev/null | grep -q 'shell function'; then
      _iw_menu_ok=1
    fi
  elif command -v type >/dev/null 2>&1; then
    if type menu 2>/dev/null | grep -q 'function'; then
      _iw_menu_ok=1
    fi
  elif command -v menu >/dev/null 2>&1; then
    _iw_menu_ok=1
  fi

  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
      _iw_debug "menu whence: $(whence -v menu 2>/dev/null)"
    elif command -v type >/dev/null 2>&1; then
      _iw_debug "menu type: $(type menu 2>/dev/null)"
    else
      _iw_debug "menu path: $(command -v menu 2>/dev/null)"
    fi
  fi

  if [ "$_iw_menu_ok" -ne 1 ]; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load menu spell" >&2
    return 1
  fi

  if [ "${WIZARDRY_SPIRAL_MINIMAL-}" = "1" ]; then
    _iw_debug "Spiral minimal mode: skipping command_not_found handlers"
    _iw_debug "Wizardry initialization complete"
    return 0
  fi
  
  # Set up command_not_found_handle for hotloading everything else
  _iw_debug "Setting up command_not_found handlers"
  # Set up command_not_found_handle for bash
  if eval '[ -n "${BASH_VERSION+x}" ]' 2>/dev/null; then
    # Bash-specific command_not_found_handle
    command_not_found_handle() {
      # Debug: Log entry to handler
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Called with: %s\n' "$1" >&2
      fi
      
      # Prevent infinite recursion for the same command while allowing nested lookups.
      if [ -n "${_WIZARDRY_IN_CNF-}" ] && [ "${_WIZARDRY_IN_CNF}" = "$1" ]; then
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Recursion detected for: %s\n' "$1" >&2
        fi
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _iw_prev_cnf="${_WIZARDRY_IN_CNF-}"
      _WIZARDRY_IN_CNF=$1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -r "$_cnf_wob" ]; then
        if [ "${_WIZARDRY_WOB_LOADED-}" != "1" ]; then
          WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_cnf_wob" 2>/dev/null || :
          unset WIZARDRY_SOURCE_WORD_OF_BINDING
          _WIZARDRY_WOB_LOADED=1
          export _WIZARDRY_WOB_LOADED
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Calling word_of_binding --run %s\n' "$1" >&2
        fi
        if command -v word_of_binding >/dev/null 2>&1; then
          _cnf_exit=0
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            # Debug mode: show errors to help diagnose issues
            word_of_binding --run "$@" || _cnf_exit=$?
            if [ "$_cnf_exit" -eq 0 ]; then
              printf '[handle-command-not-found] word_of_binding succeeded for: %s\n' "$1" >&2
            fi
          else
            # Normal mode: silence errors to avoid noise
            word_of_binding --run "$@" 2>/dev/null || _cnf_exit=$?
          fi
          
          if [ -n "$_iw_prev_cnf" ]; then
            _WIZARDRY_IN_CNF="$_iw_prev_cnf"
          else
            unset _WIZARDRY_IN_CNF
          fi
          
          if [ "$_cnf_exit" -eq 0 ]; then
            # Command executed successfully
            return 0
          elif [ "$_cnf_exit" -ne 127 ]; then
            # Command was found and executed but returned non-zero
            # This is not a "command not found" error
            if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
              printf '[handle-command-not-found] Spell executed but returned %s\n' "$_cnf_exit" >&2
            fi
            return "$_cnf_exit"
          fi
          # Exit code 127 means command not found, fall through to error message
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[handle-command-not-found] word_of_binding could not find: %s\n' "$1" >&2
          fi
        fi
      fi
      
      # Command truly not found
      if [ -n "$_iw_prev_cnf" ]; then
        _WIZARDRY_IN_CNF="$_iw_prev_cnf"
      else
        unset _WIZARDRY_IN_CNF
      fi
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Command truly not found: %s\n' "$1" >&2
      fi
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
    _iw_debug "  ✓ bash command_not_found_handle configured"
  elif eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    # Zsh-specific command_not_found_handler
    command_not_found_handler() {
      # Debug: Log entry to handler
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Called with: %s\n' "$1" >&2
      fi
      
      # Prevent infinite recursion for the same command while allowing nested lookups.
      if [ -n "${_WIZARDRY_IN_CNF-}" ] && [ "${_WIZARDRY_IN_CNF}" = "$1" ]; then
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Recursion detected for: %s\n' "$1" >&2
        fi
        printf '%s: command not found\n' "$1" >&2
        return 127
      fi
      _iw_prev_cnf="${_WIZARDRY_IN_CNF-}"
      _WIZARDRY_IN_CNF=$1
      
      # Try word-of-binding
      _cnf_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
      if [ -n "${WIZARDRY_DIR-}" ] && [ -r "$_cnf_wob" ]; then
        if [ "${_WIZARDRY_WOB_LOADED-}" != "1" ]; then
          WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_cnf_wob" 2>/dev/null || :
          unset WIZARDRY_SOURCE_WORD_OF_BINDING
          _WIZARDRY_WOB_LOADED=1
          export _WIZARDRY_WOB_LOADED
        fi
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[handle-command-not-found] Calling word_of_binding --run %s\n' "$1" >&2
        fi
        if command -v word_of_binding >/dev/null 2>&1; then
          _cnf_exit=0
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            # Debug mode: show errors to help diagnose issues
            word_of_binding --run "$@" || _cnf_exit=$?
            if [ "$_cnf_exit" -eq 0 ]; then
              printf '[handle-command-not-found] word_of_binding succeeded for: %s\n' "$1" >&2
            fi
          else
            # Normal mode: silence errors to avoid noise
            word_of_binding --run "$@" 2>/dev/null || _cnf_exit=$?
          fi
          
          if [ -n "$_iw_prev_cnf" ]; then
            _WIZARDRY_IN_CNF="$_iw_prev_cnf"
          else
            unset _WIZARDRY_IN_CNF
          fi
          
          if [ "$_cnf_exit" -eq 0 ]; then
            # Command executed successfully
            return 0
          elif [ "$_cnf_exit" -ne 127 ]; then
            # Command was found and executed but returned non-zero
            # This is not a "command not found" error
            if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
              printf '[handle-command-not-found] Spell executed but returned %s\n' "$_cnf_exit" >&2
            fi
            return "$_cnf_exit"
          fi
          # Exit code 127 means command not found, fall through to error message
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[handle-command-not-found] word_of_binding could not find: %s\n' "$1" >&2
          fi
        fi
      fi
      
      # Command truly not found
      if [ -n "$_iw_prev_cnf" ]; then
        _WIZARDRY_IN_CNF="$_iw_prev_cnf"
      else
        unset _WIZARDRY_IN_CNF
      fi
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[handle-command-not-found] Command truly not found: %s\n' "$1" >&2
      fi
      printf '%s: command not found\n' "$1" >&2
      return 127
    }
    _iw_debug "  ✓ zsh command_not_found_handler configured"
  fi
  
  _iw_debug "Wizardry initialization complete"
  return 0
}

# Run the setup
invoke_wizardry
_iw_status=$?
return $_iw_status
