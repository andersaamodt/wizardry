#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Debug mode (set WIZARDRY_DEBUG=1 to enable diagnostic output)
_iw_debug() {
  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    printf '[invoke-wizardry] %s\n' "$*" >&2
  fi
}

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  _iw_debug "Already invoked, skipping"
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_iw_debug "Starting wizardry initialization"

invoke_wizardry() {
  # CRITICAL: Enable word splitting in zsh for all for-loops in this function
  # Zsh doesn't split on spaces by default (unlike sh/bash), which breaks iteration over
  # space-separated lists like $_level_imps and $_level_spells
  # Save the current state and restore it before any return
  _iw_saved_sh_word_split=""
  if [ -n "${ZSH_VERSION-}" ]; then
    # Check if SH_WORD_SPLIT is currently set (returns 0 if set, 1 if not)
    if setopt | grep -q "^shwordsplit$"; then
      _iw_saved_sh_word_split="yes"
    else
      _iw_saved_sh_word_split="no"
    fi
    setopt SH_WORD_SPLIT
  fi
  
  # Helper to restore zsh word splitting before returning
  _iw_restore_and_return() {
    _ret_code=${1:-0}
    if [ -n "${ZSH_VERSION-}" ] && [ "$_iw_saved_sh_word_split" = "no" ]; then
      unsetopt SH_WORD_SPLIT
    fi
    return "$_ret_code"
  }
  
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    _iw_restore_and_return 1
  fi
  
  _iw_debug "WIZARDRY_DIR=$WIZARDRY_DIR"
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR

  # ============================================================================
  # GLOSSARY-BASED INTERCEPTION SYSTEM (Phase 5)
  # ============================================================================
  # Glosses are auto-generated wrappers that make spells accessible via PATH.
  # They enable POSIX-compliant, hotloadable invocation for:
  # - All wizardry spells
  # - User-defined synonyms (.synonyms file)
  # - Default synonyms (.default-synonyms file)
  #
  # Each gloss is a minimal script: exec parse "spell-name" "$@"
  # The parse imp handles command resolution and recursion prevention.
  #
  # Glosses are regenerated automatically in the background to stay in sync
  # with spells and synonym definitions. This is transparent to users.
  # ============================================================================
  
  _iw_glossary="$SPELLBOOK_DIR/.glossary"
  
  # Create glossary directory if missing
  if [ ! -d "$_iw_glossary" ]; then
    mkdir -p "$_iw_glossary" 2>/dev/null || :
  fi
  
  # Prepend glossary to PATH (give parse first shot at all commands)
  PATH="$_iw_glossary:$PATH"
  export PATH
  
  _iw_debug "Glossary prepended to PATH: $_iw_glossary"
  
  # SPIRAL DEBUG PHASE 1: Minimal pre-loading (menu + dependencies only)
  # Future: ALL wizardry spells will be pre-loaded, hotloading only for ~/.spellbook
  # Current: Pre-load menu essentials, hotload other wizardry spells temporarily
  
  _iw_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
  if [ -r "$_iw_wob" ]; then
    WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_iw_wob" 2>/dev/null || :
    unset WIZARDRY_SOURCE_WORD_OF_BINDING
  fi
  if ! command -v word_of_binding >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load word-of-binding" >&2
    _iw_restore_and_return 1
  fi
  
  # Pre-load imps by level (Levels 0-3: POSIX + Wizardry + Glossary + Menu)
  # This provides all foundational imps needed for core wizardry functionality
  # Uses spell-levels imp to stay in sync with level definitions
  _iw_debug "Pre-loading imps (levels 0-3)"
  
  # Source spell-levels to get level definitions
  _spell_levels_imp="$WIZARDRY_DIR/spells/.imps/sys/spell-levels"
  if [ -f "$_spell_levels_imp" ]; then
    # shellcheck source=/dev/null
    . "$_spell_levels_imp"
    
    # Load imps for levels 1, 2, and 3 (Level 0 has no imps)
    for _level in 1 2 3; do
      _level_imps=$(get_level_imps "$_level")
      if [ -n "$_level_imps" ]; then
        _iw_debug "Loading Level $_level imps: $(banish_level_name "$_level")"
        for _imp_spec in $_level_imps; do
          # Extract imp name (may include family/ prefix)
          case "$_imp_spec" in
            */*)
              _imp_family=${_imp_spec%/*}
              _imp_name=${_imp_spec##*/}
              _imp_file="$WIZARDRY_DIR/spells/.imps/$_imp_spec"
              ;;
            *)
              _imp_name=$_imp_spec
              # Search for imp in all families
              _imp_file=""
              for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
                [ -d "$_family_dir" ] || continue
                if [ -f "$_family_dir/$_imp_name" ]; then
                  _imp_file="$_family_dir/$_imp_name"
                  break
                fi
              done
              ;;
          esac
          
          if [ -n "$_imp_file" ] && [ -f "$_imp_file" ]; then
            # Skip if already loaded as a function (optimization to avoid redundant awk/sed calls)
            # CRITICAL: Check specifically for functions, not commands (to avoid collision with system commands like 'info')
            _imp_func=$(printf '%s' "$_imp_name" | tr '-' '_')
            _is_function=0
            if [ -n "${ZSH_VERSION-}" ]; then
              # ZSH: Use whence -v and check for "shell function"
              if whence -v "$_imp_func" 2>/dev/null | grep -q "shell function"; then
                _is_function=1
              fi
            else
              # Bash/sh: Use type and check for "function"
              if type "$_imp_func" 2>/dev/null | grep -q "function"; then
                _is_function=1
              fi
            fi
            
            if [ "$_is_function" -eq 0 ]; then
              if command -v word_of_binding >/dev/null 2>&1; then
                word_of_binding "$_imp_name" 2>/dev/null || :
              fi
            fi
          fi
        done
      fi
    done
  else
    # Fallback if spell-levels not found - use minimal hardcoded list
    _iw_debug "Warning: spell-levels imp not found, using minimal preload"
    for _imp_name in require-wizardry castable env-clear has die warn fail info say temp-file cleanup-file; do
      for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
        [ -d "$_family_dir" ] || continue
        _imp_file="$_family_dir/$_imp_name"
        if [ -f "$_imp_file" ]; then
          if command -v word_of_binding >/dev/null 2>&1; then
            word_of_binding "$_imp_name" 2>/dev/null || :
          fi
          break
        fi
      done
    done
  fi
  
  # Pre-load spells by level (Levels 0-3: POSIX + Wizardry + Glossary + Menu)
  # This provides all foundational spells needed for core wizardry functionality
  # Uses spell-levels imp to stay in sync with level definitions
  _iw_debug "Pre-loading spells (levels 0-3)"
  
  if [ -f "$_spell_levels_imp" ]; then
    # Load spells for levels 0, 1, 2, and 3
    for _level in 0 1 2 3; do
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[invoke-wizardry] DEBUG: ========== STARTING LEVEL %d ==========\n' "$_level" >&2
      fi
      _level_spells=$(get_level_spells "$_level")
      if [ -n "$_level_spells" ]; then
        _iw_debug "Loading Level $_level spells: $(banish_level_name "$_level")"
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[invoke-wizardry] DEBUG: Level %d spell list: %s\n' "$_level" "$_level_spells" >&2
        fi
        _spell_count=0
        for _spell_spec in $_level_spells; do
          _spell_count=$((_spell_count + 1))
          if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[invoke-wizardry] DEBUG: Processing spell #%d in level %d: %s\n' "$_spell_count" "$_level" "$_spell_spec" >&2
          fi
          # Extract spell name (may include :category suffix)
          _spell_name=${_spell_spec%%:*}
          
          # Skip special bootstrap spells
          case "$_spell_name" in
            install) continue ;;  # Bootstrap only, not preloaded
          esac
          
          # Find and load the spell
          for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
            [ -d "$_spell_dir" ] || continue
            case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
            _spell_file="$_spell_dir/$_spell_name"
            if [ -f "$_spell_file" ]; then
              # Skip if already loaded as a function (optimization)
              # CRITICAL: Check specifically for functions, not commands
              _spell_func_name=$(printf '%s' "$_spell_name" | tr '-' '_')
              _is_function=0
              if [ -n "${ZSH_VERSION-}" ]; then
                # ZSH: Use whence -v and check for "shell function"
                if whence -v "$_spell_func_name" 2>/dev/null | grep -q "shell function"; then
                  _is_function=1
                fi
              else
                # Bash/sh: Use type and check for "function"
                if type "$_spell_func_name" 2>/dev/null | grep -q "function"; then
                  _is_function=1
                fi
              fi
              
              if [ "$_is_function" -eq 1 ]; then
                _iw_debug "  ↻ Cached: $_spell_name"
                break  # Exit spell directory search loop
              fi
              
              _iw_debug "Loading spell: $_spell_name"
              if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
                printf '[invoke-wizardry] DEBUG: BEFORE word_of_binding call for %s\n' "$_spell_name" >&2
                printf '[invoke-wizardry] DEBUG:   Spell file: %s\n' "$_spell_file" >&2
                printf '[invoke-wizardry] DEBUG:   Calling: word_of_binding "%s"\n' "$_spell_name" >&2
              fi
              if command -v word_of_binding >/dev/null 2>&1 \
                && word_of_binding "$_spell_name" 2>/dev/null; then
                _iw_status="✓ Loaded"
                if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
                  printf '[invoke-wizardry] DEBUG: AFTER word_of_binding call for %s (SUCCESS)\n' "$_spell_name" >&2
                  # Immediately check if function is available
                  if command -v "$_spell_func_name" >/dev/null 2>&1; then
                    printf '[invoke-wizardry] DEBUG: Function %s IS available immediately after word_of_binding\n' "$_spell_func_name" >&2
                  else
                    printf '[invoke-wizardry] DEBUG: WARNING - Function %s NOT available immediately after word_of_binding!\n' "$_spell_func_name" >&2
                  fi
                fi
              else
                _iw_status="✗ Failed"
                if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
                  printf '[invoke-wizardry] DEBUG: AFTER word_of_binding call for %s (FAILED)\n' "$_spell_name" >&2
                  printf '[invoke-wizardry] DEBUG: word_of_binding FAILED for %s\n' "$_spell_name" >&2
                fi
              fi
              _iw_debug "  $_iw_status: $_spell_name"
              if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
                printf '[invoke-wizardry] DEBUG: Completed processing spell: %s\n' "$_spell_name" >&2
              fi
              break
            fi
          done
        done
      fi
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[invoke-wizardry] DEBUG: ========== COMPLETED LEVEL %d ==========\n' "$_level" >&2
      fi
    done
  else
    _iw_debug "Warning: Cannot load spells from spell-levels imp, using minimal preload"
    # Fallback to minimal essential spells
    for _spell_name in banish menu; do
      for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_spell_dir" ] || continue
        case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
        _spell_file="$_spell_dir/$_spell_name"
        if [ -f "$_spell_file" ]; then
          _iw_debug "Loading spell: $_spell_name"
          if command -v word_of_binding >/dev/null 2>&1 \
            && word_of_binding "$_spell_name" 2>/dev/null; then
            _iw_status="✓ Loaded"
          else
            _iw_status="✗ Failed"
          fi
          _iw_debug "  $_iw_status: $_spell_name"
          break
        fi
      done
    done
  fi

  # Centralized gloss generation: Automatically regenerate glosses for:
  # 1. All wizardry spells (in $WIZARDRY_DIR/spells/)
  # 2. Synonyms from $SPELLBOOK_DIR/.synonyms
  # 3. Default synonyms from $SPELLBOOK_DIR/.default-synonyms
  #
  # This runs asynchronously in the background to avoid delaying shell startup.
  # With 387+ glosses, async is essential for fast shell startup.
  # The generate-glosses spell handles unified generation from all sources.
  # Must run AFTER essential imps and generate-glosses spell are loaded.
  # Skip gloss generation in test mode (tests don't need glosses)
  if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ]; then
    if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
      printf '[invoke-wizardry] DEBUG: About to check for generate_glosses function\n' >&2
    fi
    # Call the preloaded generate_glosses function in background
    # This allows it to access all the preloaded imp functions
    # The function was already loaded by word_of_binding above (in spell preloading)
    if command -v generate_glosses >/dev/null 2>&1; then
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[invoke-wizardry] DEBUG: generate_glosses function IS available, starting background job\n' >&2
      fi
      
      # Detect if running in zsh (which doesn't inherit functions to background jobs)
      # In zsh, we need to use a different approach: export function definitions
      _iw_shell_type="unknown"
      if [ -n "${ZSH_VERSION-}" ]; then
        _iw_shell_type="zsh"
      elif [ -n "${BASH_VERSION-}" ]; then
        _iw_shell_type="bash"
      fi
      
      # Run generate_glosses in background
      if [ "$_iw_shell_type" = "zsh" ]; then
        # ZSH: Export all preloaded functions to background job using zsh's functions syntax
        # List all function names that need to be exported
        _iw_export_funcs="generate_glosses require_wizardry env_or env_clear temp_file cleanup_file on_exit"
        _iw_export_funcs="$_iw_export_funcs die warn fail say success info step debug has there is yes no empty nonempty"
        _iw_export_funcs="$_iw_export_funcs cleanup_dir make_tempdir find_executable"
        
        # CRITICAL: Get function definitions in PARENT shell BEFORE entering subshell
        # In zsh subshells, functions aren't inherited, so command -v returns false
        # We must capture the function bodies here while they're still available
        _iw_func_defs=""
        _iw_captured_count=0
        
        for _func in $_iw_export_funcs; do
          # Use zsh's functions command directly - it returns empty string if function doesn't exist
          # Don't use command -v as it's unreliable for checking functions in zsh
          _iw_func_def="$(functions "$_func" 2>/dev/null || echo '')"
          if [ -n "$_iw_func_def" ]; then
            # Append with actual newline (not ANSI-C quote which doesn't work in sh)
            _iw_func_defs="${_iw_func_defs}${_iw_func_def}
"
            _iw_captured_count=$((_iw_captured_count + 1))
            if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
              printf '[invoke-wizardry] DEBUG:   Captured function: %s (%d bytes)\n' "$_func" "${#_iw_func_def}" >&2
            fi
          elif [ "${WIZARDRY_DEBUG-}" = "1" ]; then
            printf '[invoke-wizardry] DEBUG:   Function not found: %s\n' "$_func" >&2
          fi
        done
        
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          printf '[invoke-wizardry] DEBUG: Captured %d function definitions\n' "$_iw_captured_count" >&2
          printf '[invoke-wizardry] DEBUG: Total size of _iw_func_defs: %d bytes\n' "${#_iw_func_defs}" >&2
          printf '[invoke-wizardry] DEBUG: First 200 chars of _iw_func_defs: %s\n' "${_iw_func_defs:0:200}" >&2
        fi
        
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          # Debug mode: show function availability
          (
            printf '[generate_glosses bg] DEBUG: Starting background job (zsh mode)\n' >&2
            printf '[generate_glosses bg] DEBUG: Received %d bytes of function definitions\n' "${#_iw_func_defs}" >&2
            # Re-eval all function definitions captured from parent shell
            if [ -n "$_iw_func_defs" ]; then
              printf '[generate_glosses bg] DEBUG: Evaling function definitions...\n' >&2
              eval "$_iw_func_defs"
              printf '[generate_glosses bg] DEBUG: Eval completed\n' >&2
            else
              printf '[generate_glosses bg] DEBUG: ERROR: No function definitions to eval!\n' >&2
            fi
            printf '[generate_glosses bg] DEBUG: After re-eval, require_wizardry available: %s\n' "$(command -v require_wizardry 2>&1 || echo 'NO')" >&2
            printf '[generate_glosses bg] DEBUG: After re-eval, env_or available: %s\n' "$(command -v env_or 2>&1 || echo 'NO')" >&2
            printf '[generate_glosses bg] DEBUG: After re-eval, env_clear available: %s\n' "$(command -v env_clear 2>&1 || echo 'NO')" >&2
            printf '[generate_glosses bg] DEBUG: After re-eval, find_executable available: %s\n' "$(command -v find_executable 2>&1 || echo 'NO')" >&2
            printf '[generate_glosses bg] DEBUG: About to call generate_glosses --quiet\n' >&2
            generate_glosses --quiet
            _gg_exit=$?
            printf '[generate_glosses bg] DEBUG: generate_glosses completed with exit code: %d\n' "$_gg_exit" >&2
            if [ "$_gg_exit" -eq 0 ]; then
              printf '[wizardry] Glossary generation complete\n' >&2
            else
              printf '[wizardry] WARNING: Glossary generation failed with exit code %d\n' "$_gg_exit" >&2
            fi
          ) &
          _iw_debug "Gloss generation running in background (errors will appear on terminal)"
        else
          # Normal mode: silent operation
          (
            # Re-eval all function definitions captured from parent shell
            eval "$_iw_func_defs"
            generate_glosses --quiet
            _gg_exit=$?
            if [ "$_gg_exit" -eq 0 ]; then
              printf '[wizardry] Glossary generation complete\n' >&2
            fi
          ) 2>/dev/null &
        fi
      else
        # BASH/SH: Functions are inherited, use simple background job
        if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
          generate_glosses --quiet &
          _iw_debug "Gloss generation running in background (errors will appear on terminal)"
        else
          generate_glosses --quiet 2>/dev/null &
        fi
      fi
      _iw_debug "Started async gloss regeneration (spells + synonyms + imps + arcana)"
      # Show user-visible message about glossary startup
      if command -v info >/dev/null 2>&1; then
        info "Glossary regenerating in background..."
      fi
    else
      if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
        printf '[invoke-wizardry] DEBUG: generate_glosses function NOT available!\n' >&2
        printf '[invoke-wizardry] DEBUG: Checking what IS available:\n' >&2
        printf '[invoke-wizardry] DEBUG: type generate_glosses: %s\n' "$(type generate_glosses 2>&1)" >&2
        printf '[invoke-wizardry] DEBUG: command -v generate_glosses: %s\n' "$(command -v generate_glosses 2>&1)" >&2
      fi
      _iw_debug "Warning: generate_glosses function not available"
    fi
  fi

  _iw_menu_ok=0
  if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    if whence -v menu 2>/dev/null | grep -q 'shell function'; then
      _iw_menu_ok=1
    fi
  elif command -v type >/dev/null 2>&1; then
    if type menu 2>/dev/null | grep -q 'function'; then
      _iw_menu_ok=1
    fi
  elif command -v menu >/dev/null 2>&1; then
    _iw_menu_ok=1
  fi

  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
      _iw_debug "menu whence: $(whence -v menu 2>/dev/null)"
    elif command -v type >/dev/null 2>&1; then
      _iw_debug "menu type: $(type menu 2>/dev/null)"
    else
      _iw_debug "menu path: $(command -v menu 2>/dev/null)"
    fi
  fi

  if [ "$_iw_menu_ok" -ne 1 ]; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load menu spell" >&2
    _iw_restore_and_return 1
  fi

  # Wizardry initialization complete
  _iw_debug "Wizardry initialization complete"
  _iw_restore_and_return 0
}

# Run the setup
invoke_wizardry
_iw_status=$?
return $_iw_status
