#!/bin/sh
# invoke-wizardry - set up wizardry environment at shell startup
# MINIMAL word-of-binding implementation for spiral debug Phase 1
# Source this script to enable on-demand spell loading.

# Ensure baseline PATH before anything else (macOS may have empty PATH)
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *)
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    export PATH
    ;;
esac

# Permissive mode - this file is sourced into user's shell
set +eu

# Debug mode (set WIZARDRY_DEBUG=1 to enable diagnostic output)
_iw_debug() {
  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    printf '[invoke-wizardry] %s\n' "$*" >&2
  fi
}

# Prevent recursive sourcing
if [ "${_WIZARDRY_INVOKED-}" = "1" ]; then
  _iw_debug "Already invoked, skipping"
  return 0
fi
_WIZARDRY_INVOKED=1
export _WIZARDRY_INVOKED

_iw_debug "Starting wizardry initialization"

invoke_wizardry() {
  # Detect WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Capture script path - in bash use BASH_SOURCE, in zsh use ${(%):-%x}
    _iw_script_path=""
    if eval '[ -n "${BASH_VERSION-}" ]' 2>/dev/null; then
      _iw_script_path=$(eval 'printf "%s" "${BASH_SOURCE[0]-}"')
    elif [ -n "${ZSH_VERSION-}" ]; then
      # In zsh, use %x expansion to get sourced file path
      # Note: $0 contains the shell name when sourced, not the file path
      _iw_script_path=$(eval 'printf "%s" "${(%):-%x}"' 2>/dev/null) || :
      # Fallback to %N if %x didn't work
      if [ -z "$_iw_script_path" ]; then
        _iw_script_path=$(eval 'printf "%s" "${(%):-%N}"' 2>/dev/null) || :
      fi
    fi
    
    # Fallback to command -v
    if [ -z "$_iw_script_path" ]; then
      _iw_script_path=$(command -v invoke-wizardry 2>/dev/null | head -1) || :
    fi
    
    # Fallback to default location
    if [ -z "$_iw_script_path" ] && [ -n "${HOME-}" ]; then
      _iw_script_path="$HOME/.wizardry/spells/.imps/sys/invoke-wizardry"
    fi
    
    # Derive WIZARDRY_DIR from script path
    if [ -n "$_iw_script_path" ] && [ -f "$_iw_script_path" ]; then
      _iw_script_dir=$(CDPATH= cd -- "$(dirname "$_iw_script_path")" 2>/dev/null && pwd -P) || :
      if [ -n "$_iw_script_dir" ]; then
        WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || :
      fi
    fi
  fi
  
  # Validate WIZARDRY_DIR
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    printf '%s\n' "invoke-wizardry: ERROR - WIZARDRY_DIR not found" >&2
    return 1
  fi
  
  _iw_debug "WIZARDRY_DIR=$WIZARDRY_DIR"
  export WIZARDRY_DIR
  
  # Set up SPELLBOOK_DIR
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR

  # ============================================================================
  # GLOSSARY-BASED INTERCEPTION SYSTEM (Phase 5)
  # ============================================================================
  # Glosses are auto-generated wrappers that make spells accessible via PATH.
  # They enable POSIX-compliant, hotloadable invocation for:
  # - All wizardry spells
  # - User-defined synonyms (.synonyms file)
  # - Default synonyms (.default-synonyms file)
  #
  # Each gloss is a minimal script: exec parse "spell-name" "$@"
  # The parse imp handles command resolution and recursion prevention.
  #
  # Glosses are regenerated automatically in the background to stay in sync
  # with spells and synonym definitions. This is transparent to users.
  # ============================================================================
  
  _iw_glossary="$SPELLBOOK_DIR/.glossary"
  
  # Create glossary directory if missing
  if [ ! -d "$_iw_glossary" ]; then
    mkdir -p "$_iw_glossary" 2>/dev/null || :
  fi
  
  # Prepend glossary to PATH (give parse first shot at all commands)
  PATH="$_iw_glossary:$PATH"
  export PATH
  
  _iw_debug "Glossary prepended to PATH: $_iw_glossary"
  
  # SPIRAL DEBUG PHASE 1: Minimal pre-loading (menu + dependencies only)
  # Future: ALL wizardry spells will be pre-loaded, hotloading only for ~/.spellbook
  # Current: Pre-load menu essentials, hotload other wizardry spells temporarily
  
  _iw_wob="$WIZARDRY_DIR/spells/.imps/sys/word-of-binding"
  if [ -r "$_iw_wob" ]; then
    WIZARDRY_SOURCE_WORD_OF_BINDING=1 . "$_iw_wob" 2>/dev/null || :
    unset WIZARDRY_SOURCE_WORD_OF_BINDING
  fi
  if ! command -v word_of_binding >/dev/null 2>&1; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load word-of-binding" >&2
    return 1
  fi
  
  # Pre-load imps by level (Levels 0-3: POSIX + Wizardry + Glossary + Menu)
  # This provides all foundational imps needed for core wizardry functionality
  # Uses spell-levels imp to stay in sync with level definitions
  _iw_debug "Pre-loading imps (levels 0-3)"
  
  # Source spell-levels to get level definitions
  _spell_levels_imp="$WIZARDRY_DIR/spells/.imps/sys/spell-levels"
  if [ -f "$_spell_levels_imp" ]; then
    # shellcheck source=/dev/null
    . "$_spell_levels_imp"
    
    # Load imps for levels 1, 2, and 3 (Level 0 has no imps)
    for _level in 1 2 3; do
      _level_imps=$(get_level_imps "$_level")
      if [ -n "$_level_imps" ]; then
        _iw_debug "Loading Level $_level imps: $(banish_level_name "$_level")"
        for _imp_spec in $_level_imps; do
          # Extract imp name (may include family/ prefix)
          case "$_imp_spec" in
            */*)
              _imp_family=${_imp_spec%/*}
              _imp_name=${_imp_spec##*/}
              _imp_file="$WIZARDRY_DIR/spells/.imps/$_imp_spec"
              ;;
            *)
              _imp_name=$_imp_spec
              # Search for imp in all families
              _imp_file=""
              for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
                [ -d "$_family_dir" ] || continue
                if [ -f "$_family_dir/$_imp_name" ]; then
                  _imp_file="$_family_dir/$_imp_name"
                  break
                fi
              done
              ;;
          esac
          
          if [ -n "$_imp_file" ] && [ -f "$_imp_file" ]; then
            if command -v word_of_binding >/dev/null 2>&1; then
              word_of_binding "$_imp_name" 2>/dev/null || :
            fi
          fi
        done
      fi
    done
  else
    # Fallback if spell-levels not found - use minimal hardcoded list
    _iw_debug "Warning: spell-levels imp not found, using minimal preload"
    for _imp_name in require-wizardry castable env-clear has die warn fail info say temp-file cleanup-file; do
      for _family_dir in "$WIZARDRY_DIR"/spells/.imps/*; do
        [ -d "$_family_dir" ] || continue
        _imp_file="$_family_dir/$_imp_name"
        if [ -f "$_imp_file" ]; then
          if command -v word_of_binding >/dev/null 2>&1; then
            word_of_binding "$_imp_name" 2>/dev/null || :
          fi
          break
        fi
      done
    done
  fi
  
  # Centralized gloss generation: Automatically regenerate glosses for:
  # 1. All wizardry spells (in $WIZARDRY_DIR/spells/)
  # 2. Synonyms from $SPELLBOOK_DIR/.synonyms
  # 3. Default synonyms from $SPELLBOOK_DIR/.default-synonyms
  #
  # This runs asynchronously in the background to avoid delaying shell startup.
  # With 387+ glosses, async is essential for fast shell startup.
  # The generate-glosses spell handles unified generation from all sources.
  # Must run AFTER essential imps are loaded (needs require-wizardry, env-clear, env-or, etc.)
  # Skip gloss generation in test mode (tests don't need glosses)
  if [ "${WIZARDRY_TEST_HELPERS_ONLY:-0}" != "1" ] && [ -x "$WIZARDRY_DIR/spells/system/generate-glosses" ]; then
    # Run as executable in background with full wizardry environment
    # Build comprehensive PATH including ALL imp families
    _gloss_imp_path=""
    for _imp_family in "$WIZARDRY_DIR"/spells/.imps/*; do
      [ -d "$_imp_family" ] || continue
      case "$_imp_family" in
        */test) continue ;;  # Skip test imps
      esac
      _gloss_imp_path="${_gloss_imp_path}${_gloss_imp_path:+:}${_imp_family}"
    done
    
    # Run in background with comprehensive PATH and explicit environment
    # Explicitly pass critical environment variables to ensure background job has them
    # (macOS and some shells don't always inherit exports properly in background jobs)
    if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
      {
        env \
          WIZARDRY_DIR="$WIZARDRY_DIR" \
          SPELLBOOK_DIR="$SPELLBOOK_DIR" \
          PATH="${_gloss_imp_path}:${PATH}" \
          "$WIZARDRY_DIR/spells/system/generate-glosses" --quiet \
          2>"${SPELLBOOK_DIR}/.glossary-errors.log" &
      }
      _iw_debug "Gloss generation errors (if any) logged to ${SPELLBOOK_DIR}/.glossary-errors.log"
    else
      {
        env \
          WIZARDRY_DIR="$WIZARDRY_DIR" \
          SPELLBOOK_DIR="$SPELLBOOK_DIR" \
          PATH="${_gloss_imp_path}:${PATH}" \
          "$WIZARDRY_DIR/spells/system/generate-glosses" --quiet &
      } 2>/dev/null
    fi
    
    _iw_debug "Started async gloss regeneration (spells + synonyms + imps + arcana)"
    # Show user-visible message about glossary startup
    if command -v info >/dev/null 2>&1; then
      info "Glossary regenerating in background..."
    fi
  fi
  
  # Pre-load spells by level (Levels 0-3: POSIX + Wizardry + Glossary + Menu)
  # This provides all foundational spells needed for core wizardry functionality
  # Uses spell-levels imp to stay in sync with level definitions
  _iw_debug "Pre-loading spells (levels 0-3)"
  
  if [ -f "$_spell_levels_imp" ]; then
    # Load spells for levels 0, 1, 2, and 3
    for _level in 0 1 2 3; do
      _level_spells=$(get_level_spells "$_level")
      if [ -n "$_level_spells" ]; then
        _iw_debug "Loading Level $_level spells: $(banish_level_name "$_level")"
        for _spell_spec in $_level_spells; do
          # Extract spell name (may include :category suffix)
          _spell_name=${_spell_spec%%:*}
          
          # Skip special bootstrap spells
          case "$_spell_name" in
            install) continue ;;  # Bootstrap only, not preloaded
          esac
          
          # Find and load the spell
          for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
            [ -d "$_spell_dir" ] || continue
            case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
            _spell_file="$_spell_dir/$_spell_name"
            if [ -f "$_spell_file" ]; then
              _iw_debug "Loading spell: $_spell_name"
              if command -v word_of_binding >/dev/null 2>&1 \
                && word_of_binding "$_spell_name" 2>/dev/null; then
                _iw_status="✓ Loaded"
              else
                _iw_status="✗ Failed"
              fi
              _iw_debug "  $_iw_status: $_spell_name"
              break
            fi
          done
        done
      fi
    done
  else
    _iw_debug "Warning: Cannot load spells from spell-levels imp, using minimal preload"
    # Fallback to minimal essential spells
    for _spell_name in banish menu; do
      for _spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_spell_dir" ] || continue
        case "$_spell_dir" in */.imps|*/.arcana) continue ;; esac
        _spell_file="$_spell_dir/$_spell_name"
        if [ -f "$_spell_file" ]; then
          _iw_debug "Loading spell: $_spell_name"
          if command -v word_of_binding >/dev/null 2>&1 \
            && word_of_binding "$_spell_name" 2>/dev/null; then
            _iw_status="✓ Loaded"
          else
            _iw_status="✗ Failed"
          fi
          _iw_debug "  $_iw_status: $_spell_name"
          break
        fi
      done
    done
  fi

  _iw_menu_ok=0
  if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    if whence -v menu 2>/dev/null | grep -q 'shell function'; then
      _iw_menu_ok=1
    fi
  elif command -v type >/dev/null 2>&1; then
    if type menu 2>/dev/null | grep -q 'function'; then
      _iw_menu_ok=1
    fi
  elif command -v menu >/dev/null 2>&1; then
    _iw_menu_ok=1
  fi

  if [ "${WIZARDRY_DEBUG-}" = "1" ]; then
    if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
      _iw_debug "menu whence: $(whence -v menu 2>/dev/null)"
    elif command -v type >/dev/null 2>&1; then
      _iw_debug "menu type: $(type menu 2>/dev/null)"
    else
      _iw_debug "menu path: $(command -v menu 2>/dev/null)"
    fi
  fi

  if [ "$_iw_menu_ok" -ne 1 ]; then
    printf '%s\n' "invoke-wizardry: ERROR - failed to load menu spell" >&2
    return 1
  fi

  # Wizardry initialization complete
  _iw_debug "Wizardry initialization complete"
  return 0
}

# Run the setup
invoke_wizardry
_iw_status=$?
return $_iw_status
