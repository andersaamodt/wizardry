#!/bin/sh
# word-of-binding NAME [ARGS...] - resolve and invoke a wizardry command by name
# Dispatcher for autoloading missing commands.
# Sources the module and calls its true-name function.
set -eu

_word_of_binding() {
  if [ $# -eq 0 ]; then
    printf '%s\n' "word-of-binding: command name required" >&2
    return 1
  fi

  _wob_name=$1
  shift

  if [ -z "${WIZARDRY_DIR-}" ]; then
    _wob_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    WIZARDRY_DIR=$(CDPATH= cd -- "$_wob_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi

  # Find module file
  _wob_module=""
  _wob_is_imp=0
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _wob_imps_dir="$WIZARDRY_DIR/spells/.imps"
    if [ -d "$_wob_imps_dir" ]; then
      if [ -f "$_wob_imps_dir/$_wob_name" ]; then
        _wob_module="$_wob_imps_dir/$_wob_name"
        _wob_is_imp=1
      else
        for _wob_family_dir in "$_wob_imps_dir"/*; do
          [ -d "$_wob_family_dir" ] || continue
          if [ -f "$_wob_family_dir/$_wob_name" ]; then
            _wob_module="$_wob_family_dir/$_wob_name"
            _wob_is_imp=1
            break
          fi
        done
      fi
    fi
    
    if [ -z "$_wob_module" ]; then
      for _wob_spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_wob_spell_dir" ] || continue
        case "$_wob_spell_dir" in */.imps) continue ;; esac
        if [ -f "$_wob_spell_dir/$_wob_name" ]; then
          _wob_module="$_wob_spell_dir/$_wob_name"
          break
        fi
      done
    fi
  fi
  
  if [ -z "$_wob_module" ]; then
    if [ -n "${SPELLBOOK_DIR-}" ] && [ -d "$SPELLBOOK_DIR" ]; then
      if [ -f "$SPELLBOOK_DIR/$_wob_name" ]; then
        _wob_module="$SPELLBOOK_DIR/$_wob_name"
      fi
    elif [ -n "${HOME-}" ] && [ -d "$HOME/.spellbook" ]; then
      if [ -f "$HOME/.spellbook/$_wob_name" ]; then
        _wob_module="$HOME/.spellbook/$_wob_name"
      fi
    fi
  fi

  if [ -z "$_wob_module" ]; then
    printf '%s\n' "word-of-binding: unknown command '$_wob_name'" >&2
    return 127
  fi

  # Determine true-name based on module type
  # Imps use _underscore true-names (e.g., clip-copy -> _clip_copy)
  # Spells use non-underscore true-names (e.g., menu -> menu)
  if [ "$_wob_is_imp" -eq 1 ]; then
    _wob_true_name=$(printf '_%s\n' "$_wob_name" | sed 's/-/_/g')
  else
    _wob_true_name=$(printf '%s\n' "$_wob_name" | sed 's/-/_/g')
  fi

  # Check if module has true-name function (for binding/sourcing)
  if grep -qE "^[[:space:]]*${_wob_true_name}[[:space:]]*\\(\\)" "$_wob_module" 2>/dev/null; then
    # Bind (source) the module to load its function without running self-exec blocks.
    if ! _wob_tmp=$(mktemp "${TMPDIR:-/tmp}/wizardry-wob.XXXXXX" 2>/dev/null || mktemp "/tmp/wizardry-wob.XXXXXX"); then
      printf '%s\n' "word-of-binding: failed to create temp file" >&2
      return 1
    fi
    if ! awk 'NR==1 && /^#!/ {next} /^[[:space:]]*case "\\$0" in/ {skip=1} skip {if ($0 ~ /^[[:space:]]*esac[[:space:]]*$/) {skip=0}; next} {print}' \
      "$_wob_module" > "$_wob_tmp"; then
      rm -f "$_wob_tmp"
      printf '%s\n' "word-of-binding: failed to prepare module '$_wob_name'" >&2
      return 1
    fi
    # shellcheck disable=SC1090
    if ! . "$_wob_tmp"; then
      rm -f "$_wob_tmp"
      printf '%s\n' "word-of-binding: failed to bind '$_wob_name'" >&2
      return 1
    fi
    rm -f "$_wob_tmp"
    
    # Create alias for future calls
    alias "$_wob_name=$_wob_true_name" 2>/dev/null || true
    
    if command -v "$_wob_true_name" >/dev/null 2>&1; then
      "$_wob_true_name" "$@"
    else
      printf '%s\n' "word-of-binding: failed to bind '$_wob_name' - function not defined" >&2
      return 1
    fi
  else
    # Evoke (execute) the script directly in a subshell
    "$_wob_module" "$@"
  fi
}

# Self-execute when run directly (not sourced)
case "$0" in
  */word-of-binding) _word_of_binding "$@" ;; esac
