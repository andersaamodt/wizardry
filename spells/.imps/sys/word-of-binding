#!/bin/sh
# word-of-binding NAME [ARGS...] - resolve and invoke a wizardry command by name
# Dispatcher for autoloading missing commands.
# Sources the module and calls its true-name function.
# NOTE: Avoid changing shell options when sourced into an interactive shell.
if [ "${WIZARDRY_SOURCE_WORD_OF_BINDING-}" != "1" ]; then
  set -eu
fi

word_of_binding() {
  _wob_run=0
  case "${1-}" in
    --run)
      _wob_run=1
      shift
      ;;
  esac

  if [ $# -eq 0 ]; then
    printf '%s\n' "word-of-binding: command name required" >&2
    return 1
  fi

  _wob_name=$1
  shift

  if [ -z "${WIZARDRY_DIR-}" ]; then
    _wob_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    WIZARDRY_DIR=$(CDPATH= cd -- "$_wob_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi

  # Find module file
  _wob_module=""
  _wob_is_imp=0
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _wob_imps_dir="$WIZARDRY_DIR/spells/.imps"
    if [ -d "$_wob_imps_dir" ]; then
      if [ -f "$_wob_imps_dir/$_wob_name" ]; then
        _wob_module="$_wob_imps_dir/$_wob_name"
        _wob_is_imp=1
      else
        for _wob_family_dir in "$_wob_imps_dir"/*; do
          [ -d "$_wob_family_dir" ] || continue
          if [ -f "$_wob_family_dir/$_wob_name" ]; then
            _wob_module="$_wob_family_dir/$_wob_name"
            _wob_is_imp=1
            break
          fi
        done
      fi
    fi
    
    if [ -z "$_wob_module" ]; then
      for _wob_spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_wob_spell_dir" ] || continue
        case "$_wob_spell_dir" in */.imps) continue ;; esac
        if [ -f "$_wob_spell_dir/$_wob_name" ]; then
          _wob_module="$_wob_spell_dir/$_wob_name"
          break
        fi
      done
    fi
  fi
  
  if [ -z "$_wob_module" ]; then
    if [ -n "${SPELLBOOK_DIR-}" ] && [ -d "$SPELLBOOK_DIR" ]; then
      if [ -f "$SPELLBOOK_DIR/$_wob_name" ]; then
        _wob_module="$SPELLBOOK_DIR/$_wob_name"
      fi
    elif [ -n "${HOME-}" ] && [ -d "$HOME/.spellbook" ]; then
      if [ -f "$HOME/.spellbook/$_wob_name" ]; then
        _wob_module="$HOME/.spellbook/$_wob_name"
      fi
    fi
  fi

  if [ -z "$_wob_module" ]; then
    printf '%s\n' "word-of-binding: unknown command '$_wob_name'" >&2
    return 127
  fi

  # Determine true-name based on module name.
  # Spells and imps now share the same naming scheme:
  #   clip-copy -> clip_copy
  _wob_true_name=$(printf '%s\n' "$_wob_name" | sed 's/-/_/g')

  # Check if module has true-name function (for binding/sourcing)
  _wob_true_pattern="^[[:space:]]*${_wob_true_name}[[:space:]]*\\(\\)"
  if grep -qE "$_wob_true_pattern" "$_wob_module" 2>/dev/null; then
    # Bind (source) the module to load its function without running self-exec blocks.
    if ! _wob_body=$(awk '
BEGIN {
  # Define regex patterns to keep line length under 100 chars
  func_kw = "^[[:space:]]*function[[:space:]]+[A-Za-z_][A-Za-z0-9_]*"
  func_paren = "[[:space:]]*\\(\\)?[[:space:]]*\\{"
  func_simple = "^[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\(\\)[[:space:]]*\\{"
  func_header = "^[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\(\\)[[:space:]]*$"
} # end BEGIN
function brace_delta(s, n, m) {
  n = gsub(/{/, "{", s)
  m = gsub(/}/, "}", s)
  return n - m
} # awk: brace delta
{
  if (!in_func) {
    if (match($0, func_kw func_paren)) {
      in_func = 1
      brace = brace_delta($0)
      print
      if (brace <= 0) {
        in_func = 0
      } # awk: end one-line function
      next
    } # awk: function keyword
    if (match($0, func_simple)) {
      in_func = 1
      brace = brace_delta($0)
      print
      if (brace <= 0) {
        in_func = 0
      } # awk: end one-line function
      next
    } # awk: function with brace
    if (match($0, func_header)) {
      in_func = 1
      brace = 0
      print
      next
    } # awk: function header
    next
  }
  brace += brace_delta($0)
  print
  if (brace <= 0) {
    in_func = 0
  } # awk: end function
} # awk: end program
' "$_wob_module"); then
      printf '%s\n' "word-of-binding: failed to prepare module '$_wob_name'" >&2
      return 1
    fi
    _wob_prev_loading_spells="${_WIZARDRY_LOADING_SPELLS-}"
    _WIZARDRY_LOADING_SPELLS=1
    export _WIZARDRY_LOADING_SPELLS
    if [ -n "$_wob_body" ] && ! eval "$_wob_body"; then
      if [ -n "$_wob_prev_loading_spells" ]; then
        _WIZARDRY_LOADING_SPELLS="$_wob_prev_loading_spells"
        export _WIZARDRY_LOADING_SPELLS
      else
        unset _WIZARDRY_LOADING_SPELLS
      fi
      printf '%s\n' "word-of-binding: failed to bind '$_wob_name'" >&2
      return 1
    fi
    if [ -n "$_wob_prev_loading_spells" ]; then
      _WIZARDRY_LOADING_SPELLS="$_wob_prev_loading_spells"
      export _WIZARDRY_LOADING_SPELLS
    else
      unset _WIZARDRY_LOADING_SPELLS
    fi
    case "$_wob_name" in
      *-*)
        alias "${_wob_name}=${_wob_true_name}" 2>/dev/null || :
        ;;
    esac
    if [ "$_wob_run" -ne 1 ]; then
      return 0
    fi
    if command -v "$_wob_true_name" >/dev/null 2>&1; then
      "$_wob_true_name" "$@"
    else
      printf '%s\n' \
        "word-of-binding: failed to bind '$_wob_name' - function not defined" >&2
      return 1
    fi
  else
    if [ "$_wob_run" -ne 1 ]; then
      return 0
    fi
    # Evoke (execute) the script directly in a subshell
    "$_wob_module" "$@"
  fi
}

# Self-execute when run directly (not sourced)
case "$0" in
  */word-of-binding) word_of_binding --run "$@" ;; esac
