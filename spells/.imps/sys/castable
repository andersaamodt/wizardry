#!/bin/sh
# castable [ARGS...]
# Allow a spell/imp to self-execute only when run directly.
# SPELL_NAME defaults to basename of $0.
# FUNCTION_NAME defaults to SPELL_NAME with hyphens replaced by underscores.
# Override detection with CASTABLE_NAME and/or CASTABLE_FUNC if needed.
# Example: castable "$@"
# Example: CASTABLE_FUNC=erase_spell castable "$@"
set -eu

castable() {
  # First check if we're being sourced (not executed)
  # When sourced, $0 won't match the spell name
  _cast_name=${CASTABLE_NAME-}
  if [ -z "$_cast_name" ]; then
    _cast_name=${0##*/}  # Equivalent to basename, avoids external command
  fi
  
  # Detect if being sourced by checking if $0 matches common shell names
  # or doesn't match the expected spell name pattern
  case "$0" in
    sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
      # Being sourced - don't execute, just return
      return 0
      ;;
    */"$_cast_name"|"$_cast_name")
      # Being executed directly - proceed with execution
      ;;
    *)
      # $0 doesn't match spell name - being sourced from another script
      return 0
      ;;
  esac
  
  # If we get here, we're being executed directly (not sourced)
  _cast_func=${CASTABLE_FUNC-}
  if [ -z "$_cast_func" ] && [ -n "$_cast_name" ]; then
    # Convert hyphens to underscores using pure shell (no external commands)
    _cast_func="$_cast_name"
    _cast_i=0
    while [ "$_cast_i" -lt 20 ]; do
      case "$_cast_func" in
        *-*)
          _cast_func="${_cast_func%%-*}_${_cast_func#*-}"
          _cast_i=$((_cast_i + 1))
          ;;
        *)
          break
          ;;
      esac
    done
  fi
  if [ -z "$_cast_func" ]; then
    printf '%s\n' "castable: unable to detect function name" >&2
    return 2
  fi

  # Call the spell function
  "$_cast_func" "$@"
}
