#!/bin/sh
# castable [ARGS...]
# Allow a spell/imp to self-execute only when run directly.
# SPELL_NAME defaults to basename of $0.
# FUNCTION_NAME defaults to SPELL_NAME with hyphens replaced by underscores.
# Override detection with CASTABLE_NAME and/or CASTABLE_FUNC if needed.
# Example: castable "$@"
# Example: CASTABLE_FUNC=erase_spell castable "$@"

castable() {
  set -eu
  
  # First check if we're being executed or sourced
  # When sourced, $0 won't match the spell name
  _cast_name=${CASTABLE_NAME-}
  if [ -z "$_cast_name" ]; then
    _cast_name=${0##*/}  # Equivalent to basename, avoids external command
  fi
  
  # Detect if being sourced by checking if $0 matches common shell names
  # or doesn't match the expected spell name pattern
  case "$0" in
    sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
      # Being sourced - don't execute, just return
      return 0
      ;;
    */"$_cast_name"|"$_cast_name")
      # Being executed directly - proceed with execution below
      ;;
    *)
      # $0 doesn't match spell name - being sourced from another script
      return 0
      ;;
  esac
  
  # If we're being executed (not sourced), check for special skip conditions
  # These only apply when sourced, not when executed
  # Skip execution if being sourced by word-of-binding during spell loading
  if [ "${_WIZARDRY_LOADING_SPELLS-}" = "1" ]; then
    return 0
  fi
  
  # Skip execution if being sourced by another spell (legacy check)
  if [ "${_WIZARDRY_SOURCING_SPELL-}" = "1" ]; then
    return 0
  fi
  
  # If we get here, we're being executed directly (not sourced)
  _cast_func=${CASTABLE_FUNC-}
  if [ -z "$_cast_func" ] && [ -n "$_cast_name" ]; then
    # Convert hyphens to underscores using pure shell (no external commands)
    _cast_func="$_cast_name"
    _cast_i=0
    while [ "$_cast_i" -lt 20 ]; do
      case "$_cast_func" in
        *-*)
          _cast_func="${_cast_func%%-*}_${_cast_func#*-}"
          _cast_i=$((_cast_i + 1))
          ;;
        *)
          break
          ;;
      esac
    done
  fi
  if [ -z "$_cast_func" ]; then
    printf '%s\n' "castable: unable to detect function name" >&2
    return 2
  fi

  # Source essential imps to make their functions available
  # Spells should still call require_wizardry and env_clear explicitly
  # This just makes the functions available when executed directly
  if ! command -v require_wizardry >/dev/null 2>&1; then
    _cast_wiz_dir="${WIZARDRY_DIR-}"
    if [ -z "$_cast_wiz_dir" ]; then
      # Try to detect from script location
      _cast_script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P)
      _cast_script_dir=${_cast_script_dir:-}
      if [ -n "$_cast_script_dir" ]; then
        # Navigate up to find wizardry root
        _cast_check_dir="$_cast_script_dir"
        while [ "$_cast_check_dir" != "/" ]; do
          if [ -d "$_cast_check_dir/spells/.imps" ]; then
            _cast_wiz_dir="$_cast_check_dir"
            break
          fi
          _cast_check_dir=$(dirname "$_cast_check_dir")
        done
      fi
    fi
    
    # Source essential imps if wizardry directory found
    if [ -n "$_cast_wiz_dir" ] && [ -d "$_cast_wiz_dir/spells/.imps/sys" ]; then
      for _cast_imp in require-wizardry env-clear; do
        _cast_imp_path="$_cast_wiz_dir/spells/.imps/sys/$_cast_imp"
        [ -f "$_cast_imp_path" ] && . "$_cast_imp_path"
      done
    fi
  fi

  # Call the spell function
  "$_cast_func" "$@"
}

# Self-execute when run directly (not sourced)
case "$0" in
  */castable) castable "$@" ;; esac
