#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Scans for linking words (imps in lex/) and delegates to them.
# Longer linking words take precedence (and-then before and or then).
#
# Current mode: PASSTHROUGH (parsing disabled for glossary-based interception paradigm)
# Linking word detection is logged when WIZARDRY_DEBUG=1 but not acted upon yet.
#
# RECURSION PREVENTION: Uses WIZARDRY_PARSE_DEPTH to prevent infinite loops


parse() {
    if [ $# -eq 0 ]; then
      return 0
    fi

    # RECURSION PREVENTION: Track parse depth to prevent infinite loops
    _parse_depth=${WIZARDRY_PARSE_DEPTH:-0}
    if [ "$_parse_depth" -ge 5 ]; then
      printf '[parse] ERROR: Maximum recursion depth (5) exceeded\n' >&2
      printf '[parse] This suggests a circular gloss or parsing loop\n' >&2
      return 1
    fi

    _parse_lex_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    _parse_debug="${WIZARDRY_DEBUG:-0}"

    # PASSTHROUGH MODE: For now, just detect linking words and log, then passthrough
    # This preserves existing behavior while preparing for future parsing functionality
  
    # Quick check for two-word linking phrases
    if [ $# -ge 2 ]; then
      _parse_two_word="$1-$2"
      if [ -x "$_parse_lex_dir/$_parse_two_word" ] && [ "$_parse_two_word" != "parse" ]; then
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found linking words: %s\n' "$_parse_two_word" >&2
        # FUTURE: Enable parsing by uncommenting the line below
        # shift 2; WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1)) "$_parse_lex_dir/$_parse_two_word" "" "" "$@"; return $?
      fi
    fi

    # Quick check for single-word linking words
    if [ $# -ge 1 ]; then
      _parse_first=$1
      if [ -x "$_parse_lex_dir/$_parse_first" ] && [ "$_parse_first" != "parse" ]; then
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found linking word: %s\n' "$_parse_first" >&2
        # FUTURE: Enable parsing by uncommenting the line below
        # shift; WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1)) "$_parse_lex_dir/$_parse_first" "" "" "$@"; return $?
      fi
    fi

    # PASSTHROUGH: Execute command as-is without parsing
    _parse_cmd=${1-}
    shift

    # CRITICAL SELF-REFERENCE HANDLING: If called via gloss for parse itself
    # This happens when: exec parse "parse" "$@"
    # In this case, just show help or return success (parse is already loaded)
    if [ "$_parse_cmd" = "parse" ]; then
      # If called with --help, show help
      case "${1-}" in
        --help|--usage|-h)
          cat <<'PARSE_HELP' >&2
  parse - Command execution engine for wizardry glosses

  The parse imp is automatically used by glosses and should not
  normally be called directly by users. It handles command resolution
  and recursion prevention for the glossary system.

  Usage (via glosses): Any wizardry command
  Usage (direct): parse <command> [args...]

  Note: parse is preloaded by invoke-wizardry and available as a function.
PARSE_HELP
          return 0
          ;;
      esac
      # Self-reference when called via gloss - just return success
      # The real parse function is already available
      return 0
    fi

    # Increment parse depth for next level
    export WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1))

    # STRATEGY: Find and execute the command in this priority order:
    # 1. Preloaded function - try multi-word combinations (up to 4 words)
    # 2. Command in PATH (with glossary removed to avoid recursion)
    # 3. Wizardry spell file in WIZARDRY_DIR - try multi-word combinations
    # 4. Not found - error
  
    # MULTI-WORD COMMAND RECONSTRUCTION
    # When first-word gloss calls: env() { parse "env" "$@"; }
    # And user types: env or VAR DEFAULT
    # Parse receives: "env" "or" "VAR" "DEFAULT"
    # Try to find: env_or_VAR_DEFAULT (4), env_or_VAR (3), env_or (2), env (1)
    # Execute first match with remaining args
  
    _remaining_args="$*"  # Save all args for later
    _matched_func=""
    _matched_words=0
  
    # Try 4-word combinations first (longest match wins)
    if [ $# -ge 3 ]; then
      _try_4word=$(printf '%s_%s_%s_%s' "$_parse_cmd" "$1" "$2" "$3" | tr '-' '_')
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 4-word function: %s\n' "$_try_4word" >&2
      if command -v "$_try_4word" >/dev/null 2>&1; then
        _type_out=$(type "$_try_4word" 2>/dev/null || printf '')
        case "$_type_out" in
          *function*)
            _matched_func="$_try_4word"
            _matched_words=4
            [ "$_parse_debug" = "1" ] && \
              printf '[parse] DEBUG: Found 4-word function: %s\n' "$_matched_func" >&2
            ;;
        esac
      fi
    fi
  
    # Try 3-word combinations
    if [ -z "$_matched_func" ] && [ $# -ge 2 ]; then
      _try_3word=$(printf '%s_%s_%s' "$_parse_cmd" "$1" "$2" | tr '-' '_')
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 3-word function: %s\n' "$_try_3word" >&2
      if command -v "$_try_3word" >/dev/null 2>&1; then
        _type_out=$(type "$_try_3word" 2>/dev/null || printf '')
        case "$_type_out" in
          *function*)
            _matched_func="$_try_3word"
            _matched_words=3
            [ "$_parse_debug" = "1" ] && \
              printf '[parse] DEBUG: Found 3-word function: %s\n' "$_matched_func" >&2
            ;;
        esac
      fi
    fi
  
    # Try 2-word combinations
    if [ -z "$_matched_func" ] && [ $# -ge 1 ]; then
      _try_2word=$(printf '%s_%s' "$_parse_cmd" "$1" | tr '-' '_')
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 2-word function: %s\n' "$_try_2word" >&2
      if command -v "$_try_2word" >/dev/null 2>&1; then
        _type_out=$(type "$_try_2word" 2>/dev/null || printf '')
        case "$_type_out" in
          *function*)
            _matched_func="$_try_2word"
            _matched_words=2
            [ "$_parse_debug" = "1" ] && \
              printf '[parse] DEBUG: Found 2-word function: %s\n' "$_matched_func" >&2
            ;;
        esac
      fi
    fi
  
    # If we found a multi-word match, call it with remaining args
    if [ -n "$_matched_func" ] && [ "$_matched_words" -gt 1 ]; then
      # Build the command name for display (convert underscores back to hyphens)
      _display_cmd=$(printf '%s' "$_matched_func" | tr '_' '-')
      printf 'Casting %s\n' "$_display_cmd" >&2
    
      # Shift off the matched words to get remaining args
      _shift_count=$((_matched_words - 1))  # -1 because first word was already shifted
      _i=0
      while [ "$_i" -lt "$_shift_count" ] && [ $# -gt 0 ]; do
        shift
        _i=$((_i + 1))
      done
    
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Calling %d-word function %s with %d args\n' \
               "$_matched_words" "$_matched_func" "$#" >&2
      if [ $# -eq 0 ]; then
        "$_matched_func"
      else
        "$_matched_func" "$@"
      fi
      _ret=$?
      export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
      return $_ret
    fi

    # Check for single-word preloaded function (convert hyphens to underscores)
    # Functions with hyphens don't work in POSIX sh, so we use underscores
    _func_name=$(printf '%s' "$_parse_cmd" | tr '-' '_')
  
    # Check if function exists using type command (portable POSIX method)
    # type outputs "X is a shell function" or similar for functions
    if command -v "$_func_name" >/dev/null 2>&1; then
      _type_output=$(type "$_func_name" 2>/dev/null || printf '')
      case "$_type_output" in
        *function*)
          # Function exists - call it directly (no PATH manipulation needed)
          printf 'Casting %s\n' "$_parse_cmd" >&2
          [ "$_parse_debug" = "1" ] && \
            printf '[parse] DEBUG: Calling preloaded function: %s\n' "$_func_name" >&2
          if [ $# -eq 0 ]; then
            "$_func_name"
          else
            "$_func_name" "$@"
          fi
          _ret=$?
          export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
          return $_ret
          ;;
      esac
    fi

    # No preloaded single-word function found
    # Before checking PATH, search for multi-word wizardry spells
    # This prevents system commands from shadowing multi-word wizardry commands
    # Example: "env or" should find env-or spell before falling through to /usr/bin/env
  
    [ "$_parse_debug" = "1" ] && \
      printf '[parse] DEBUG: Checking for multi-word wizardry spells...\n' >&2
    _wizardry_dir="${WIZARDRY_DIR:-${HOME}/.wizardry}"
    _spell_file=""
    _spell_matched_words=0
  
    # Try 4-word spell file combinations
    if [ $# -ge 3 ]; then
      _try_4word_spell=$(printf '%s-%s-%s-%s' "$_parse_cmd" "$1" "$2" "$3")
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 4-word spell file: %s\n' "$_try_4word_spell" >&2
      # Search for spell file (inline search logic)
      _found=""
      for _spell_dir in .wizardry cantrips menu arcane divination system spellcraft \
                        enchantment .imps .imps/*; do
        _spell_path="$_wizardry_dir/spells/$_spell_dir/$_try_4word_spell"
        if [ -f "$_spell_path" ] && [ -x "$_spell_path" ]; then
          _found="$_spell_path"
          break
        fi
      done
      # Slow path: search all directories
      if [ -z "$_found" ] && [ -d "$_wizardry_dir/spells" ]; then
        _found=$(find "$_wizardry_dir/spells" -type f -name "$_try_4word_spell" \
                      -print -quit 2>/dev/null)
      fi
      if [ -n "$_found" ]; then
        _spell_file="$_found"
        _spell_matched_words=4
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found 4-word spell: %s\n' "$_spell_file" >&2
      fi
    fi
  
    # Try 3-word spell file combinations
    if [ -z "$_spell_file" ] && [ $# -ge 2 ]; then
      _try_3word_spell=$(printf '%s-%s-%s' "$_parse_cmd" "$1" "$2")
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 3-word spell file: %s\n' "$_try_3word_spell" >&2
      # Search for spell file (inline search logic)
      _found=""
      for _spell_dir in .wizardry cantrips menu arcane divination system spellcraft \
                        enchantment .imps .imps/*; do
        _spell_path="$_wizardry_dir/spells/$_spell_dir/$_try_3word_spell"
        if [ -f "$_spell_path" ] && [ -x "$_spell_path" ]; then
          _found="$_spell_path"
          break
        fi
      done
      # Slow path: search all directories
      if [ -z "$_found" ] && [ -d "$_wizardry_dir/spells" ]; then
        _found=$(find "$_wizardry_dir/spells" -type f -name "$_try_3word_spell" \
                      -print -quit 2>/dev/null)
      fi
      if [ -n "$_found" ]; then
        _spell_file="$_found"
        _spell_matched_words=3
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found 3-word spell: %s\n' "$_spell_file" >&2
      fi
    fi
  
    # Try 2-word spell file combinations
    if [ -z "$_spell_file" ] && [ $# -ge 1 ]; then
      _try_2word_spell=$(printf '%s-%s' "$_parse_cmd" "$1")
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Trying 2-word spell file: %s\n' "$_try_2word_spell" >&2
      # Search for spell file (inline search logic)
      _found=""
      for _spell_dir in .wizardry cantrips menu arcane divination system spellcraft \
                        enchantment .imps .imps/*; do
        _spell_path="$_wizardry_dir/spells/$_spell_dir/$_try_2word_spell"
        if [ -f "$_spell_path" ] && [ -x "$_spell_path" ]; then
          _found="$_spell_path"
          break
        fi
      done
      # Slow path: search all directories
      if [ -z "$_found" ] && [ -d "$_wizardry_dir/spells" ]; then
        _found=$(find "$_wizardry_dir/spells" -type f -name "$_try_2word_spell" \
                      -print -quit 2>/dev/null)
      fi
      if [ -n "$_found" ]; then
        _spell_file="$_found"
        _spell_matched_words=2
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found 2-word spell: %s\n' "$_spell_file" >&2
      fi
    fi
  
    # If we found a multi-word spell, execute it
    if [ -n "$_spell_file" ] && [ "$_spell_matched_words" -gt 1 ]; then
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Found multi-word spell file: %s (matched %d words)\n' \
               "$_spell_file" "$_spell_matched_words" >&2
    
      # Get the base name of the spell file for display
      _spell_name=$(basename "$_spell_file")
      printf 'Casting %s\n' "$_spell_name" >&2
    
      # Shift off the matched words to get remaining args
      _shift_count=$((_spell_matched_words - 1))  # -1 because first word was already shifted
      _i=0
      while [ "$_i" -lt "$_shift_count" ] && [ $# -gt 0 ]; do
        shift
        _i=$((_i + 1))
      done
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Shifted %d words, %d args remaining\n' "$_shift_count" "$#" >&2
    
      # Execute spell file directly (flat-file paradigm, no word-of-binding)
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Executing spell directly: %s\n' "$_spell_file" >&2
      if [ $# -eq 0 ]; then
        "$_spell_file"
      else
        "$_spell_file" "$@"
      fi
      _ret=$?
      export WIZARDRY_PARSE_DEPTH=$((_parse_depth))
      return $_ret
    fi

    # Before falling through to PATH, check for single-word wizardry spell
    # This prevents system commands from shadowing single-word wizardry spells
    [ "$_parse_debug" = "1" ] && \
      printf '[parse] DEBUG: Checking for single-word wizardry spell: %s\n' "$_parse_cmd" >&2
  
    # Try to find single-word spell
    _spell_file=""
    for _spell_dir in .wizardry cantrips menu arcane divination system spellcraft \
                      enchantment .imps .imps/*; do
      _spell_path="$_wizardry_dir/spells/$_spell_dir/$_parse_cmd"
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Checking path: %s\n' "$_spell_path" >&2
      if [ -f "$_spell_path" ] && [ -x "$_spell_path" ]; then
        _spell_file="$_wizardry_dir/spells/$_spell_dir/$_parse_cmd"
        [ "$_parse_debug" = "1" ] && \
          printf '[parse] DEBUG: Found single-word spell: %s\n' "$_spell_file" >&2
        break
      fi
    done
  
    # Slow path: search all directories
    if [ -z "$_spell_file" ] && [ -d "$_wizardry_dir/spells" ]; then
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Searching all spell directories for %s...\n' \
               "$_parse_cmd" >&2
      _spell_file=$(find "$_wizardry_dir/spells" -type f -name "$_parse_cmd" \
                         -print -quit 2>/dev/null)
      [ "$_parse_debug" = "1" ] && [ -n "$_spell_file" ] && \
        printf '[parse] DEBUG: Found spell via find: %s\n' "$_spell_file" >&2
    fi
  
    # If single-word spell found, execute it
    if [ -n "$_spell_file" ] && [ -f "$_spell_file" ] && [ -x "$_spell_file" ]; then
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Found single-word spell file: %s\n' "$_spell_file" >&2
    
      # Get the base name of the spell file for display
      _spell_name=$(basename "$_spell_file")
      printf 'Casting %s\n' "$_spell_name" >&2
    
      # Execute spell file directly (flat-file paradigm, no word-of-binding)
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Executing spell directly: %s\n' "$_spell_file" >&2
      if [ $# -eq 0 ]; then
        "$_spell_file"
      else
        "$_spell_file" "$@"
      fi
      _ret=$?
      export WIZARDRY_PARSE_DEPTH=$((_parse_depth))
      return $_ret
    fi

    # No wizardry spell found - check for command in PATH (excluding glossary)
    _gloss_dir="${SPELLBOOK_DIR:-${HOME}/.spellbook}/.glossary"
    _old_path="$PATH"
    _old_path_clean=$(printf '%s' "$PATH" | sed "s|$_gloss_dir:||g" | \
                      sed "s|:$_gloss_dir||g" | sed "s|^$_gloss_dir\$||")
    PATH="$_old_path_clean"
  
    # Check if command exists in PATH (outside glossary)
    if command -v "$_parse_cmd" >/dev/null 2>&1; then
      # Command found in PATH - execute it
      # Build display name by reconstructing from all original args
      # Since we already shifted the first word, prepend it back
      if [ $# -eq 0 ]; then
        _display_full="$_parse_cmd"
      else
        _display_full="$_parse_cmd $1"
        # Show only first arg to keep message concise
      fi
      printf 'Casting %s\n' "$_display_full" >&2
      [ "$_parse_debug" = "1" ] && \
        printf '[parse] DEBUG: Executing command from PATH: %s\n' "$_parse_cmd" >&2
      if [ $# -eq 0 ]; then
        "$_parse_cmd"
      else
        "$_parse_cmd" "$@"
      fi
      _ret=$?
      PATH="$_old_path"  # Restore PATH
      export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
      return $_ret
    fi

    # Command not found anywhere
    PATH="$_old_path"
    export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
    [ "$_parse_debug" = "1" ] && printf '[parse] DEBUG: Command not found: %s\n' "$_parse_cmd" >&2
    printf '%s: command not found\n' "$_parse_cmd" >&2
    return 127
}

# Self-execute when run directly (not sourced)
case "$0" in
  */parse) parse "$@" ;; esac
