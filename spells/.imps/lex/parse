#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Reconstructs multi-word commands from space-separated arguments.
# For "env or VAR DEFAULT", tries env-or first, then falls back to env.
#
# The parse imp is automatically used by glosses to enable natural language
# command invocation like "read magic" instead of "read-magic".
#
# Usage (via glosses): Any wizardry command with spaces
# Usage (direct): . parse <word1> <word2> ... <args>
#
# Examples:
#   . parse env or VAR DEFAULT    # Tries env-or-VAR-DEFAULT, env-or-VAR, env-or, then env
#   . parse read magic file.txt   # Tries read-magic-file.txt, read-magic, then read
#   . parse temp file             # Tries temp-file, then temp
#
# RECURSION PREVENTION: Uses WIZARDRY_PARSE_DEPTH to prevent infinite loops
#
# NOTE: This imp must be SOURCED, not executed. It modifies the calling shell
# to preserve context for uncastable spells that change directories, etc.

# Uncastable pattern - ensures this imp is sourced, not executed
parse_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) parse_sourced=1 ;;
  esac
else
  parse_base=${0##*/}
  case "$parse_base" in
    sh|dash|bash|zsh|ksh|mksh) parse_sourced=1 ;;
    parse) parse_sourced=0 ;;
    *) parse_sourced=1 ;;
  esac
fi

if [ "$parse_sourced" -eq 0 ]; then
  printf '%s\n' "parse: This imp must be sourced, not executed. Use: . parse <args>" >&2
  exit 1
fi

# Increment recursion depth
parse_depth=${WIZARDRY_PARSE_DEPTH:-0}
parse_depth=$((parse_depth + 1))

# Prevent infinite recursion
if [ "$parse_depth" -gt 10 ]; then
  printf 'parse: Maximum recursion depth exceeded\n' >&2
  return 1
fi

export WIZARDRY_PARSE_DEPTH=$parse_depth

# If no arguments, just succeed
if [ $# -eq 0 ]; then
  return 0
fi

# Get WIZARDRY_DIR
wizardry_dir=${WIZARDRY_DIR:-${HOME:-.}/.wizardry}
if [ ! -d "$wizardry_dir/spells" ]; then
  # Fall back to detecting from script location if needed
  if command -v dirname >/dev/null 2>&1 && command -v pwd >/dev/null 2>&1; then
    script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || :
    if [ -n "$script_dir" ]; then
      wiz_root=$(CDPATH= cd -- "$script_dir/../../.." 2>/dev/null && pwd -P) || :
      if [ -n "$wiz_root" ] && [ -d "$wiz_root/spells" ]; then
        wizardry_dir=$wiz_root
      fi
    fi
  fi
fi

# Extract command words (non-flag args from the beginning)
cmd_word_count=0
first_word=""
all_args="$#"

# Count how many leading args are command words (not flags or pure numbers)
for loop_arg in "$@"; do
  case "$loop_arg" in
    -*) break ;;
    *[!0-9]*) 
      # Contains non-numeric characters - it's a command word
      if [ -z "$first_word" ]; then
        first_word=$loop_arg
      fi
      cmd_word_count=$((cmd_word_count + 1))
      ;;
    *)
      # Pure numeric argument - stop counting command words
      break
      ;;
  esac
done

# If no command words, nothing to do
if [ $cmd_word_count -eq 0 ]; then
  printf 'parse: no command specified\n' >&2
  return 1
fi

# Try progressively longer combinations (from max down to 1)
attempt_len=$cmd_word_count
while [ $attempt_len -gt 0 ]; do
  # Build command name from first N words joined with hyphens
  # IMPORTANT: Only use command words (skip flags and pure numbers)
  cmd_name=""
  i=0
  for loop_arg in "$@"; do
    # Skip flags and pure numeric arguments (same logic as counting loop)
    case "$loop_arg" in
      -*) break ;;
      *[!0-9]*) ;;  # Contains non-numeric - it's a command word, use it
      *) break ;;    # Pure numeric - stop
    esac
    
    if [ $i -ge $attempt_len ]; then
      break
    fi
    if [ -z "$cmd_name" ]; then
      cmd_name=$loop_arg
    else
      cmd_name="${cmd_name}-${loop_arg}"
    fi
    i=$((i + 1))
  done
  
  # Try all possible spell locations
  spell_path=""
  
  # Try imp directories
  for imp_dir in sys cond out fs str paths text input menu pkg test lang; do
    if [ -x "$wizardry_dir/spells/.imps/$imp_dir/$cmd_name" ]; then
      # Skip parse in lex to avoid recursion
      if [ "$imp_dir" = "lex" ] && [ "$cmd_name" = "parse" ]; then
        continue
      fi
      spell_path="$wizardry_dir/spells/.imps/$imp_dir/$cmd_name"
      break
    fi
  done
  
  # Try lex separately (but avoid parse recursion)
  if [ -z "$spell_path" ] && [ "$cmd_name" != "parse" ]; then
    if [ -x "$wizardry_dir/spells/.imps/lex/$cmd_name" ]; then
      spell_path="$wizardry_dir/spells/.imps/lex/$cmd_name"
    fi
  fi
  
  # Try .wizardry directory
  if [ -z "$spell_path" ] && [ -x "$wizardry_dir/spells/.wizardry/$cmd_name" ]; then
    spell_path="$wizardry_dir/spells/.wizardry/$cmd_name"
  fi
  
  # Try spell category directories
  if [ -z "$spell_path" ]; then
    for category_dir in "$wizardry_dir/spells"/*; do
      [ -d "$category_dir" ] || continue
      case "$category_dir" in
        */.|*/..|*/.imps|*/.wizardry|*/.arcana) continue ;;
      esac
      if [ -x "$category_dir/$cmd_name" ]; then
        spell_path="$category_dir/$cmd_name"
        break
      fi
    done
  fi
  
  # Check if this command name is a synonym
  if [ -z "$spell_path" ]; then
    spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
    synonym_target=""
    
    # Check user synonyms first
    if [ -f "$spell_home/.synonyms" ]; then
      synonym_target=$(grep "^$cmd_name=" "$spell_home/.synonyms" 2>/dev/null | \
        sed 's/^[^=]*=//' || true)
    fi
    
    # Check default synonyms if not found in user synonyms
    if [ -z "$synonym_target" ] && [ -f "$spell_home/.default-synonyms" ]; then
      synonym_target=$(grep "^$cmd_name=" "$spell_home/.default-synonyms" 2>/dev/null | \
        sed 's/^[^=]*=//' || true)
    fi
    
    # If synonym found, check if target is uncastable before recursing
    if [ -n "$synonym_target" ]; then
      # Check if synonym target is an uncastable spell that needs sourcing
      synonym_target_path=""
      
      # Search for the synonym target in spell directories
      for category_dir in "$wizardry_dir/spells"/*; do
        [ -d "$category_dir" ] || continue
        case "$category_dir" in
          */.|*/..|*/.imps|*/.wizardry|*/.arcana) continue ;;
        esac
        if [ -f "$category_dir/$synonym_target" ]; then
          if grep -q "^# Uncastable pattern" "$category_dir/$synonym_target" 2>/dev/null; then
            # Found uncastable synonym target - source it with remaining args
            synonym_target_path="$category_dir/$synonym_target"
            break
          fi
        fi
      done
      
      # If synonym target is uncastable, source it
      if [ -n "$synonym_target_path" ]; then
        # Skip first $attempt_len args (the synonym name parts)
        n=0
        while [ $n -lt $attempt_len ]; do
          shift
          n=$((_n + 1))
        done
        # Source the uncastable spell
        . "$synonym_target_path"
        return $?
      fi
      
      # Synonym target is castable - recursively source parse
      # Skip first $attempt_len args (the synonym name parts)
      n=0
      while [ $n -lt $attempt_len ]; do
        shift
        n=$(($n + 1))
      done
      # Source parse recursively to handle the synonym target
      # Find parse using the same method as glosses
      if command -v parse >/dev/null 2>&1; then
        set -- "$synonym_target" "$@"
        . parse
      elif [ -f "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse" ]; then
        set -- "$synonym_target" "$@"
        . "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse"
      else
        printf '%s\n' "parse: cannot find parse to handle synonym $cmd_name" >&2
        return 127
      fi
      return $?
    fi
  fi
  
  # If found, source or execute the spell
  if [ -n "$spell_path" ]; then
    # Skip first $attempt_len args to get remaining args for the spell
    n=0
    while [ $n -lt $attempt_len ]; do
      shift
      n=$((_n + 1))
    done
    
    # Check if spell is uncastable (must be sourced)
    if grep -q "^# Uncastable pattern" "$spell_path" 2>/dev/null; then
      # Source the uncastable spell
      . "$spell_path"
      return $?
    fi
    
    # Castable spell - execute it, unsetting any function with the same name first
    # This prevents recursive loops when glosses create functions with the same name
    unset -f "$cmd_name" 2>/dev/null || true
    "$spell_path" "$@"
    return $?
  fi
  
  # Try next shorter combination
  attempt_len=$((_attempt_len - 1))
done

# Last resort: try first word as system command (but not functions or aliases)
cmd_type=$(command -v "$first_word" 2>/dev/null || true)
if [ -n "$cmd_type" ]; then
  # Check if it's an actual executable file (not a function or alias)
  # command -v returns path for executables, name for builtins/functions/aliases
  case "$cmd_type" in
    */*)
      # Contains a slash - it's a path to an executable file
      if [ -f "$cmd_type" ] && [ -x "$cmd_type" ]; then
        # It's a real executable command, run it
        # Unset any gloss function first to prevent recursion
        unset -f "$first_word" 2>/dev/null || true
        "$first_word" "$@"
        return $?
      fi
      ;;
    *)
      # No slash - could be a builtin, function, or alias
      # Unset any gloss function first to prevent infinite recursion
      unset -f "$first_word" 2>/dev/null || true
      # Try to run it - if it was a function we just unset, this will fail
      # and we'll fall through to the error message
      if "$first_word" "$@" 2>/dev/null; then
        return $?
      fi
      # Command failed (was likely a function we just unset), continue to error
      ;;
  esac
fi

# Check synonyms as final fallback
spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
synonym_target=""

# Check user synonyms first
if [ -f "$spell_home/.synonyms" ]; then
  synonym_target=$(grep "^$first_word=" "$spell_home/.synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# Check default synonyms if not found in user synonyms
if [ -z "$synonym_target" ] && [ -f "$spell_home/.default-synonyms" ]; then
  synonym_target=$(grep "^$first_word=" "$spell_home/.default-synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# If synonym found, recursively source parse with the target
if [ -n "$synonym_target" ]; then
  shift  # Remove the synonym word itself
  # Source parse recursively to handle the synonym target
  # Find parse using the same method as glosses
  if command -v parse >/dev/null 2>&1; then
    set -- "$synonym_target" "$@"
    . parse
  elif [ -f "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse" ]; then
    set -- "$synonym_target" "$@"
    . "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse"
  else
    printf '%s\n' "parse: cannot find parse to handle synonym $first_word" >&2
    return 127
  fi
  return $?
fi

printf 'parse: %s: command not found\n' "$first_word" >&2
return 127



































