#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Scans for linking words (imps in lex/) and delegates to them.
# Longer linking words take precedence (and-then before and or then).
#
# Current mode: PASSTHROUGH (parsing disabled for glossary-based interception paradigm)
# Linking word detection is logged when WIZARDRY_DEBUG=1 but not acted upon yet.

parse() {
  if [ $# -eq 0 ]; then
    return 0
  fi

  _parse_lex_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _parse_debug="${WIZARDRY_DEBUG:-0}"

  # PASSTHROUGH MODE: For now, just detect linking words and log, then passthrough
  # This preserves existing behavior while preparing for future parsing functionality
  
  # Quick check for two-word linking phrases
  if [ $# -ge 2 ]; then
    _parse_two_word="$1-$2"
    if [ -x "$_parse_lex_dir/$_parse_two_word" ] && [ "$_parse_two_word" != "parse" ]; then
      [ "$_parse_debug" = "1" ] && printf '[parse] DEBUG: Found linking words: %s\n' "$_parse_two_word" >&2
      # FUTURE: Enable parsing by uncommenting the line below
      # shift 2; "$_parse_lex_dir/$_parse_two_word" "" "" "$@"; return $?
    fi
  fi

  # Quick check for single-word linking words
  if [ $# -ge 1 ]; then
    _parse_first=$1
    if [ -x "$_parse_lex_dir/$_parse_first" ] && [ "$_parse_first" != "parse" ]; then
      [ "$_parse_debug" = "1" ] && printf '[parse] DEBUG: Found linking word: %s\n' "$_parse_first" >&2
      # FUTURE: Enable parsing by uncommenting the line below
      # shift; "$_parse_lex_dir/$_parse_first" "" "" "$@"; return $?
    fi
  fi

  # PASSTHROUGH: Execute command as-is without parsing
  _parse_cmd=${1-}
  shift

  if [ $# -eq 0 ]; then
    # Check if command exists before executing to prevent infinite recursion
    if ! command -v "$_parse_cmd" >/dev/null 2>&1; then
      printf '%s: command not found\n' "$_parse_cmd" >&2
      return 127
    fi
    "$_parse_cmd"
    return $?
  fi

  # Execute with arguments
  if ! command -v "$_parse_cmd" >/dev/null 2>&1; then
    printf '%s: command not found\n' "$_parse_cmd" >&2
    return 127
  fi
  "$_parse_cmd" "$@"
  return $?
}

# Self-execute when run directly (not sourced)
case "$0" in
  */parse) parse "$@" ;; esac
