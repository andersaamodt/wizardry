#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Scans for linking words (imps in lex/) and delegates to them.
# Longer linking words take precedence (and-then before and or then).
#
# Current mode: PASSTHROUGH (parsing disabled for glossary-based interception paradigm)
# Linking word detection is logged when WIZARDRY_DEBUG=1 but not acted upon yet.
#
# RECURSION PREVENTION: Uses WIZARDRY_PARSE_DEPTH to prevent infinite loops

parse() {
  if [ $# -eq 0 ]; then
    return 0
  fi

  # RECURSION PREVENTION: Track parse depth to prevent infinite loops
  _parse_depth=${WIZARDRY_PARSE_DEPTH:-0}
  if [ "$_parse_depth" -ge 5 ]; then
    printf '[parse] ERROR: Maximum recursion depth (5) exceeded\n' >&2
    printf '[parse] This suggests a circular gloss or parsing loop\n' >&2
    return 1
  fi

  _parse_lex_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  _parse_debug="${WIZARDRY_DEBUG:-0}"

  # PASSTHROUGH MODE: For now, just detect linking words and log, then passthrough
  # This preserves existing behavior while preparing for future parsing functionality
  
  # Quick check for two-word linking phrases
  if [ $# -ge 2 ]; then
    _parse_two_word="$1-$2"
    if [ -x "$_parse_lex_dir/$_parse_two_word" ] && [ "$_parse_two_word" != "parse" ]; then
      [ "$_parse_debug" = "1" ] && printf '[parse] DEBUG: Found linking words: %s\n' "$_parse_two_word" >&2
      # FUTURE: Enable parsing by uncommenting the line below
      # shift 2; WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1)) "$_parse_lex_dir/$_parse_two_word" "" "" "$@"; return $?
    fi
  fi

  # Quick check for single-word linking words
  if [ $# -ge 1 ]; then
    _parse_first=$1
    if [ -x "$_parse_lex_dir/$_parse_first" ] && [ "$_parse_first" != "parse" ]; then
      [ "$_parse_debug" = "1" ] && printf '[parse] DEBUG: Found linking word: %s\n' "$_parse_first" >&2
      # FUTURE: Enable parsing by uncommenting the line below
      # shift; WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1)) "$_parse_lex_dir/$_parse_first" "" "" "$@"; return $?
    fi
  fi

  # PASSTHROUGH: Execute command as-is without parsing
  _parse_cmd=${1-}
  shift

  # CRITICAL SELF-REFERENCE HANDLING: If called via gloss for parse itself
  # This happens when: exec parse "parse" "$@"
  # In this case, just show help or return success (parse is already loaded)
  if [ "$_parse_cmd" = "parse" ]; then
    # If called with --help, show help
    case "${1-}" in
      --help|--usage|-h)
        cat <<'PARSE_HELP' >&2
parse - Command execution engine for wizardry glosses

The parse imp is automatically used by glosses and should not
normally be called directly by users. It handles command resolution
and recursion prevention for the glossary system.

Usage (via glosses): Any wizardry command
Usage (direct): parse <command> [args...]

Note: parse is preloaded by invoke-wizardry and available as a function.
PARSE_HELP
        return 0
        ;;
    esac
    # Self-reference when called via gloss - just return success
    # The real parse function is already available
    return 0
  fi

  # Increment parse depth for next level
  export WIZARDRY_PARSE_DEPTH=$((_parse_depth + 1))

  # Check if command exists before executing to prevent confusing errors
  # We need to look OUTSIDE the glossary to find the real command
  # Temporarily remove glossary from PATH
  _gloss_dir="${SPELLBOOK_DIR:-${HOME}/.spellbook}/.glossary"
  _old_path="$PATH"
  PATH=$(printf '%s' "$PATH" | sed "s|$_gloss_dir:||g" | sed "s|:$_gloss_dir||g" | sed "s|^$_gloss_dir\$||")
  
  if [ $# -eq 0 ]; then
    # Check if real command exists (not gloss)
    if ! command -v "$_parse_cmd" >/dev/null 2>&1; then
      PATH="$_old_path"
      export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
      printf '%s: command not found\n' "$_parse_cmd" >&2
      return 127
    fi
    # Execute with glossary still removed from PATH to prevent infinite loops
    "$_parse_cmd"
    _ret=$?
    PATH="$_old_path"  # Restore PATH after execution
    export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
    return $_ret
  fi

  # Execute with arguments
  if ! command -v "$_parse_cmd" >/dev/null 2>&1; then
    PATH="$_old_path"
    export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
    printf '%s: command not found\n' "$_parse_cmd" >&2
    return 127
  fi
  # Execute with glossary still removed from PATH to prevent infinite loops
  "$_parse_cmd" "$@"
  _ret=$?
  PATH="$_old_path"  # Restore PATH after execution
  export WIZARDRY_PARSE_DEPTH=$((_parse_depth))  # Reset depth
  return $_ret
}

# Self-execute when run directly (not sourced)
case "$0" in
  */parse) parse "$@" ;; esac
