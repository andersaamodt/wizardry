#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Reconstructs multi-word commands from space-separated arguments.
# For "env or VAR DEFAULT", tries env-or first, then falls back to env.
#
# The parse imp is automatically used by glosses to enable natural language
# command invocation like "read magic" instead of "read-magic".
#
# Usage (via glosses): Any wizardry command with spaces
# Usage (direct): . parse <word1> <word2> ... <args>
#
# Examples:
#   . parse env or VAR DEFAULT    # Tries env-or-VAR-DEFAULT, env-or-VAR, env-or, then env
#   . parse read magic file.txt   # Tries read-magic-file.txt, read-magic, then read
#   . parse temp file             # Tries temp-file, then temp
#
# RECURSION PREVENTION: Uses WIZARDRY_PARSE_DEPTH to prevent infinite loops
#
# NOTE: This imp must be SOURCED, not executed. It modifies the calling shell
# to preserve context for uncastable spells that change directories, etc.

# Uncastable pattern - ensures this imp is sourced, not executed
_parse_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _parse_sourced=1 ;;
  esac
else
  _parse_base=${0##*/}
  case "$_parse_base" in
    sh|dash|bash|zsh|ksh|mksh) _parse_sourced=1 ;;
    parse) _parse_sourced=0 ;;
    *) _parse_sourced=1 ;;
  esac
fi

if [ "$_parse_sourced" -eq 0 ]; then
  printf '%s\n' "parse: This imp must be sourced, not executed. Use: . parse <args>" >&2
  exit 1
fi

# Increment recursion depth
_parse_depth=${WIZARDRY_PARSE_DEPTH:-0}
_parse_depth=$((_parse_depth + 1))

# Prevent infinite recursion
if [ "$_parse_depth" -gt 10 ]; then
  printf 'parse: Maximum recursion depth exceeded\n' >&2
  return 1
fi

export WIZARDRY_PARSE_DEPTH=$_parse_depth

# If no arguments, just succeed
if [ $# -eq 0 ]; then
  return 0
fi

# Get WIZARDRY_DIR
_wizardry_dir=${WIZARDRY_DIR:-${HOME:-.}/.wizardry}
if [ ! -d "$_wizardry_dir/spells" ]; then
  # Fall back to detecting from script location if needed
  if command -v dirname >/dev/null 2>&1 && command -v pwd >/dev/null 2>&1; then
    _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || :
    if [ -n "$_script_dir" ]; then
      _wiz_root=$(CDPATH= cd -- "$_script_dir/../../.." 2>/dev/null && pwd -P) || :
      if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
        _wizardry_dir=$_wiz_root
      fi
    fi
  fi
fi

# Extract command words (non-flag args from the beginning)
_cmd_word_count=0
_first_word=""
_all_args="$#"

# Count how many leading args are command words (not flags or pure numbers)
for _arg in "$@"; do
  case "$_arg" in
    -*) break ;;
    *[!0-9]*) 
      # Contains non-numeric characters - it's a command word
      if [ -z "$_first_word" ]; then
        _first_word=$_arg
      fi
      _cmd_word_count=$((_cmd_word_count + 1))
      ;;
    *)
      # Pure numeric argument - stop counting command words
      break
      ;;
  esac
done

# If no command words, nothing to do
if [ $_cmd_word_count -eq 0 ]; then
  printf 'parse: no command specified\n' >&2
  return 1
fi

# Try progressively longer combinations (from max down to 1)
_attempt_len=$_cmd_word_count
while [ $_attempt_len -gt 0 ]; do
  # Build command name from first N words joined with hyphens
  # IMPORTANT: Only use command words (skip flags and pure numbers)
  _cmd_name=""
  _i=0
  for _arg in "$@"; do
    # Skip flags and pure numeric arguments (same logic as counting loop)
    case "$_arg" in
      -*) break ;;
      *[!0-9]*) ;;  # Contains non-numeric - it's a command word, use it
      *) break ;;    # Pure numeric - stop
    esac
    
    if [ $_i -ge $_attempt_len ]; then
      break
    fi
    if [ -z "$_cmd_name" ]; then
      _cmd_name=$_arg
    else
      _cmd_name="${_cmd_name}-${_arg}"
    fi
    _i=$((_i + 1))
  done
  
  # Try all possible spell locations
  _spell_path=""
  
  # Try imp directories
  for _imp_dir in sys cond out fs str paths text input menu pkg test lang; do
    if [ -x "$_wizardry_dir/spells/.imps/$_imp_dir/$_cmd_name" ]; then
      # Skip parse in lex to avoid recursion
      if [ "$_imp_dir" = "lex" ] && [ "$_cmd_name" = "parse" ]; then
        continue
      fi
      _spell_path="$_wizardry_dir/spells/.imps/$_imp_dir/$_cmd_name"
      break
    fi
  done
  
  # Try lex separately (but avoid parse recursion)
  if [ -z "$_spell_path" ] && [ "$_cmd_name" != "parse" ]; then
    if [ -x "$_wizardry_dir/spells/.imps/lex/$_cmd_name" ]; then
      _spell_path="$_wizardry_dir/spells/.imps/lex/$_cmd_name"
    fi
  fi
  
  # Try .wizardry directory
  if [ -z "$_spell_path" ] && [ -x "$_wizardry_dir/spells/.wizardry/$_cmd_name" ]; then
    _spell_path="$_wizardry_dir/spells/.wizardry/$_cmd_name"
  fi
  
  # Try spell category directories
  if [ -z "$_spell_path" ]; then
    for _category_dir in "$_wizardry_dir/spells"/*; do
      [ -d "$_category_dir" ] || continue
      case "$_category_dir" in
        */.|*/..|*/.imps|*/.wizardry|*/.arcana) continue ;;
      esac
      if [ -x "$_category_dir/$_cmd_name" ]; then
        _spell_path="$_category_dir/$_cmd_name"
        break
      fi
    done
  fi
  
  # Check if this command name is a synonym
  if [ -z "$_spell_path" ]; then
    _spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
    _synonym_target=""
    
    # Check user synonyms first
    if [ -f "$_spell_home/.synonyms" ]; then
      _synonym_target=$(grep "^$_cmd_name=" "$_spell_home/.synonyms" 2>/dev/null | \
        sed 's/^[^=]*=//' || true)
    fi
    
    # Check default synonyms if not found in user synonyms
    if [ -z "$_synonym_target" ] && [ -f "$_spell_home/.default-synonyms" ]; then
      _synonym_target=$(grep "^$_cmd_name=" "$_spell_home/.default-synonyms" 2>/dev/null | \
        sed 's/^[^=]*=//' || true)
    fi
    
    # If synonym found, check if target is uncastable before recursing
    if [ -n "$_synonym_target" ]; then
      # Check if synonym target is an uncastable spell that needs sourcing
      _synonym_target_path=""
      
      # Search for the synonym target in spell directories
      for _category_dir in "$_wizardry_dir/spells"/*; do
        [ -d "$_category_dir" ] || continue
        case "$_category_dir" in
          */.|*/..|*/.imps|*/.wizardry|*/.arcana) continue ;;
        esac
        if [ -f "$_category_dir/$_synonym_target" ]; then
          if grep -q "^# Uncastable pattern" "$_category_dir/$_synonym_target" 2>/dev/null; then
            # Found uncastable synonym target - source it with remaining args
            _synonym_target_path="$_category_dir/$_synonym_target"
            break
          fi
        fi
      done
      
      # If synonym target is uncastable, source it
      if [ -n "$_synonym_target_path" ]; then
        # Skip first $_attempt_len args (the synonym name parts)
        _n=0
        while [ $_n -lt $_attempt_len ]; do
          shift
          _n=$((_n + 1))
        done
        # Source the uncastable spell
        . "$_synonym_target_path"
        return $?
      fi
      
      # Synonym target is castable - recursively source parse
      # Skip first $_attempt_len args (the synonym name parts)
      _n=0
      while [ $_n -lt $_attempt_len ]; do
        shift
        _n=$(($_n + 1))
      done
      # Source parse recursively to handle the synonym target
      # Find parse using the same method as glosses
      if command -v parse >/dev/null 2>&1; then
        set -- "$_synonym_target" "$@"
        . parse
      elif [ -f "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse" ]; then
        set -- "$_synonym_target" "$@"
        . "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse"
      else
        printf '%s\n' "parse: cannot find parse to handle synonym $_cmd_name" >&2
        return 127
      fi
      return $?
    fi
  fi
  
  # If found, source or execute the spell
  if [ -n "$_spell_path" ]; then
    # Skip first $_attempt_len args to get remaining args for the spell
    _n=0
    while [ $_n -lt $_attempt_len ]; do
      shift
      _n=$((_n + 1))
    done
    
    # Check if spell is uncastable (must be sourced)
    if grep -q "^# Uncastable pattern" "$_spell_path" 2>/dev/null; then
      # Source the uncastable spell
      . "$_spell_path"
      return $?
    fi
    
    # Castable spell - execute it, unsetting any function with the same name first
    # This prevents recursive loops when glosses create functions with the same name
    unset -f "$_cmd_name" 2>/dev/null || true
    "$_spell_path" "$@"
    return $?
  fi
  
  # Try next shorter combination
  _attempt_len=$((_attempt_len - 1))
done

# Last resort: try first word as system command (but not functions or aliases)
_cmd_type=$(command -v "$_first_word" 2>/dev/null || true)
if [ -n "$_cmd_type" ]; then
  # Check if it's an actual executable file (not a function or alias)
  # command -v returns path for executables, name for builtins/functions/aliases
  case "$_cmd_type" in
    */*)
      # Contains a slash - it's a path to an executable file
      if [ -f "$_cmd_type" ] && [ -x "$_cmd_type" ]; then
        # It's a real executable command, run it
        # Unset any gloss function first to prevent recursion
        unset -f "$_first_word" 2>/dev/null || true
        "$_first_word" "$@"
        return $?
      fi
      ;;
    *)
      # No slash - could be a builtin, function, or alias
      # Unset any gloss function first to prevent infinite recursion
      unset -f "$_first_word" 2>/dev/null || true
      # Try to run it - if it was a function we just unset, this will fail
      # and we'll fall through to the error message
      if "$_first_word" "$@" 2>/dev/null; then
        return $?
      fi
      # Command failed (was likely a function we just unset), continue to error
      ;;
  esac
fi

# Check synonyms as final fallback
_spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
_synonym_target=""

# Check user synonyms first
if [ -f "$_spell_home/.synonyms" ]; then
  _synonym_target=$(grep "^$_first_word=" "$_spell_home/.synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# Check default synonyms if not found in user synonyms
if [ -z "$_synonym_target" ] && [ -f "$_spell_home/.default-synonyms" ]; then
  _synonym_target=$(grep "^$_first_word=" "$_spell_home/.default-synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# If synonym found, recursively source parse with the target
if [ -n "$_synonym_target" ]; then
  shift  # Remove the synonym word itself
  # Source parse recursively to handle the synonym target
  # Find parse using the same method as glosses
  if command -v parse >/dev/null 2>&1; then
    set -- "$_synonym_target" "$@"
    . parse
  elif [ -f "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse" ]; then
    set -- "$_synonym_target" "$@"
    . "${WIZARDRY_DIR:-./.wizardry}/spells/.imps/lex/parse"
  else
    printf '%s\n' "parse: cannot find parse to handle synonym $_first_word" >&2
    return 127
  fi
  return $?
fi

printf 'parse: %s: command not found\n' "$_first_word" >&2
return 127



































