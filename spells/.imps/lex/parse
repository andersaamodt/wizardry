#!/bin/sh
# parse CMD... - recursively parse and execute written imperatives
# Reconstructs multi-word commands from space-separated arguments.
# For "env or VAR DEFAULT", tries env-or first, then falls back to env.
#
# The parse imp is automatically used by glosses to enable natural language
# command invocation like "read magic" instead of "read-magic".
#
# Usage (via glosses): Any wizardry command with spaces
# Usage (direct): parse <word1> <word2> ... <args>
#
# Examples:
#   parse env or VAR DEFAULT    # Tries env-or-VAR-DEFAULT, env-or-VAR, env-or, then env
#   parse read magic file.txt   # Tries read-magic-file.txt, read-magic, then read
#   parse temp file             # Tries temp-file, then temp
#
# RECURSION PREVENTION: Uses WIZARDRY_PARSE_DEPTH to prevent infinite loops

set -eu

# Increment recursion depth
_parse_depth=${WIZARDRY_PARSE_DEPTH:-0}
_parse_depth=$((_parse_depth + 1))

# Prevent infinite recursion
if [ "$_parse_depth" -gt 10 ]; then
  printf 'parse: Maximum recursion depth exceeded\n' >&2
  exit 1
fi

export WIZARDRY_PARSE_DEPTH=$_parse_depth

# If no arguments, just succeed
if [ $# -eq 0 ]; then
  exit 0
fi

# Get WIZARDRY_DIR
_wizardry_dir=${WIZARDRY_DIR:-${HOME:-.}/.wizardry}
if [ ! -d "$_wizardry_dir/spells" ]; then
  # Fall back to detecting from script location if needed
  if command -v dirname >/dev/null 2>&1 && command -v pwd >/dev/null 2>&1; then
    _script_dir=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || :
    if [ -n "$_script_dir" ]; then
      _wiz_root=$(CDPATH= cd -- "$_script_dir/../../.." 2>/dev/null && pwd -P) || :
      if [ -n "$_wiz_root" ] && [ -d "$_wiz_root/spells" ]; then
        _wizardry_dir=$_wiz_root
      fi
    fi
  fi
fi

# Extract command words (non-flag args from the beginning)
_cmd_word_count=0
_first_word=""
_all_args="$#"

# Count how many leading args are command words (not flags or pure numbers)
for _arg in "$@"; do
  case "$_arg" in
    -*) break ;;
    *[!0-9]*) 
      # Contains non-numeric characters - it's a command word
      if [ -z "$_first_word" ]; then
        _first_word=$_arg
      fi
      _cmd_word_count=$((_cmd_word_count + 1))
      ;;
    *)
      # Pure numeric argument - stop counting command words
      break
      ;;
  esac
done

# If no command words, nothing to do
if [ $_cmd_word_count -eq 0 ]; then
  printf 'parse: no command specified\n' >&2
  exit 1
fi

# Try progressively longer combinations (from max down to 1)
_attempt_len=$_cmd_word_count
while [ $_attempt_len -gt 0 ]; do
  # Build command name from first N words joined with hyphens
  # IMPORTANT: Only use command words (skip flags and pure numbers)
  _cmd_name=""
  _i=0
  for _arg in "$@"; do
    # Skip flags and pure numeric arguments (same logic as counting loop)
    case "$_arg" in
      -*) break ;;
      *[!0-9]*) ;;  # Contains non-numeric - it's a command word, use it
      *) break ;;    # Pure numeric - stop
    esac
    
    if [ $_i -ge $_attempt_len ]; then
      break
    fi
    if [ -z "$_cmd_name" ]; then
      _cmd_name=$_arg
    else
      _cmd_name="${_cmd_name}-${_arg}"
    fi
    _i=$((_i + 1))
  done
  
  # Try all possible spell locations
  _spell_path=""
  
  # Try imp directories
  for _imp_dir in sys cond out fs str paths text input menu pkg test lang; do
    if [ -x "$_wizardry_dir/spells/.imps/$_imp_dir/$_cmd_name" ]; then
      # Skip parse in lex to avoid recursion
      if [ "$_imp_dir" = "lex" ] && [ "$_cmd_name" = "parse" ]; then
        continue
      fi
      _spell_path="$_wizardry_dir/spells/.imps/$_imp_dir/$_cmd_name"
      break
    fi
  done
  
  # Try lex separately (but avoid parse recursion)
  if [ -z "$_spell_path" ] && [ "$_cmd_name" != "parse" ]; then
    if [ -x "$_wizardry_dir/spells/.imps/lex/$_cmd_name" ]; then
      _spell_path="$_wizardry_dir/spells/.imps/lex/$_cmd_name"
    fi
  fi
  
  # Try .wizardry directory
  if [ -z "$_spell_path" ] && [ -x "$_wizardry_dir/spells/.wizardry/$_cmd_name" ]; then
    _spell_path="$_wizardry_dir/spells/.wizardry/$_cmd_name"
  fi
  
  # Try spell category directories
  if [ -z "$_spell_path" ]; then
    for _category_dir in "$_wizardry_dir/spells"/*; do
      [ -d "$_category_dir" ] || continue
      case "$_category_dir" in
        */.|*/..|*/.imps|*/.wizardry|*/.arcana) continue ;;
      esac
      if [ -x "$_category_dir/$_cmd_name" ]; then
        _spell_path="$_category_dir/$_cmd_name"
        break
      fi
    done
  fi
  
  # If found, check if it needs sourcing or can be exec'd
  if [ -n "$_spell_path" ]; then
    # Skip first $_attempt_len args to get remaining args for the spell
    _n=0
    while [ $_n -lt $_attempt_len ]; do
      shift
      _n=$((_n + 1))
    done
    
    # Execute the spell
    exec "$_spell_path" "$@"
  fi
  
  # Try next shorter combination
  _attempt_len=$((_attempt_len - 1))
done

# Last resort: try first word as system command (but not functions or aliases)
_cmd_type=$(command -v "$_first_word" 2>/dev/null || true)
if [ -n "$_cmd_type" ]; then
  # Check if it's an actual executable file (not a function or alias)
  # command -v returns path for executables, name for builtins/functions/aliases
  # We only want real executable files and builtins, not functions/aliases
  
  # Use type to check if it's a function - CRITICAL for avoiding exit 139!
  # exec-ing a function causes infinite recursion and segfault
  _type_output=$(type "$_first_word" 2>/dev/null || true)
  case "$_type_output" in
    *function*)
      # It's a function - DO NOT exec it! Skip to synonym fallback
      ;;
    *alias*)
      # It's an alias - DO NOT exec it! Skip to synonym fallback
      ;;
    *)
      # Not a function or alias - safe to try exec
      case "$_cmd_type" in
        */*)
          # Contains a slash - it's a path to an executable file
          if [ -f "$_cmd_type" ] && [ -x "$_cmd_type" ]; then
            # It's a real executable command, try to exec it
            exec "$_first_word" "$@"
          fi
          ;;
        *)
          # No slash - could be a builtin
          # Try to exec it - builtins will work
          exec "$_first_word" "$@" 2>/dev/null || true
          ;;
      esac
      ;;
  esac
fi

# Check synonyms as final fallback
_spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
_synonym_target=""

# Check user synonyms first
if [ -f "$_spell_home/.synonyms" ]; then
  _synonym_target=$(grep "^$_first_word=" "$_spell_home/.synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# Check default synonyms if not found in user synonyms
if [ -z "$_synonym_target" ] && [ -f "$_spell_home/.default-synonyms" ]; then
  _synonym_target=$(grep "^$_first_word=" "$_spell_home/.default-synonyms" 2>/dev/null | \
    sed 's/^[^=]*=//' || true)
fi

# If synonym found, recursively call parse with the target
if [ -n "$_synonym_target" ]; then
  shift  # Remove the synonym word itself
  # Call parse recursively to handle the synonym target  
  exec "$0" "$_synonym_target" "$@"
fi

printf 'parse: %s: command not found\n' "$_first_word" >&2
exit 127

































