#!/bin/sh
# disambiguate CMD [ARGS...] - resolve ambiguous command and execute
# When a command has multiple meanings, presents a menu to choose.
# Saves the choice in $SPELLBOOK_DIR/.disambiguations for future use.
# Example: disambiguate copy file.txt → menu: [1] copy (clipboard) [2] cp

set -eu

if [ $# -eq 0 ]; then
  exit 0
fi

cmd=$1
shift

# Find spellbook dir
spellbook_dir="${SPELLBOOK_DIR:-$HOME/.spellbook}"
disambig_dir="$spellbook_dir/.disambiguations"

# Check if we have a saved choice for this command
if [ -f "$disambig_dir/$cmd" ]; then
  saved_choice=$(cat "$disambig_dir/$cmd")
  if command -v "$saved_choice" >/dev/null 2>&1; then
    exec "$saved_choice" "$@"
  fi
  # Saved choice no longer valid, remove it
  rm -f "$disambig_dir/$cmd"
fi

# Find all candidates for this command
# 1. Check if it's a wizardry spell
# 2. Check if it's a system command
# 3. Check synonyms (future: synonyms system)

candidates=""
count=0

# Check wizardry spells directory
wizardry_dir="${WIZARDRY_DIR:-$HOME/.wizardry}"
if [ -d "$wizardry_dir/spells" ]; then
  spell_path=$(find "$wizardry_dir/spells" -name "$cmd" -type f -executable 2>/dev/null | head -1)
  if [ -n "$spell_path" ]; then
    count=$((count + 1))
    candidates="${candidates}${count}:$spell_path:wizardry spell
"
  fi
fi

# Check system PATH (excluding wizardry)
# Temporarily remove wizardry from PATH to find system commands
sys_cmd=$(PATH=$(printf '%s\n' "$PATH" | tr ':' '\n' | grep -v wizardry | tr '\n' ':' | sed 's/:$//') command -v "$cmd" 2>/dev/null || true)
if [ -n "$sys_cmd" ]; then
  count=$((count + 1))
  candidates="${candidates}${count}:$sys_cmd:system command
"
fi

# If only one candidate or none, just run it
if [ "$count" -eq 0 ]; then
  # No candidates found - just try to run it and let it fail naturally
  exec "$cmd" "$@"
fi

if [ "$count" -eq 1 ]; then
  # Only one candidate - run it directly
  choice_path=$(printf '%s' "$candidates" | head -1 | cut -d: -f2)
  exec "$choice_path" "$@"
fi

# Multiple candidates - present menu
printf '%s\n' "Multiple commands match '$cmd':" >&2
printf '%s' "$candidates" | while IFS=: read -r num path desc; do
  [ -z "$num" ] && continue
  printf '  [%s] %s (%s)\n' "$num" "$path" "$desc" >&2
done

printf '%s' "Choose [1-$count, or 'r' to remember]: " >&2
read -r choice

# Handle remember option
remember=0
case $choice in
  *r|*R)
    remember=1
    choice=$(printf '%s' "$choice" | tr -d 'rR ')
    ;;
esac

# Validate choice
if ! printf '%s' "$choice" | grep -qE '^[0-9]+$'; then
  printf '%s\n' "Invalid choice." >&2
  exit 1
fi

if [ "$choice" -lt 1 ] || [ "$choice" -gt "$count" ]; then
  printf '%s\n' "Choice out of range." >&2
  exit 1
fi

# Get the chosen path
chosen_path=$(printf '%s' "$candidates" | sed -n "${choice}p" | cut -d: -f2)

# Save choice if requested
if [ "$remember" -eq 1 ]; then
  mkdir -p "$disambig_dir"
  printf '%s\n' "$chosen_path" > "$disambig_dir/$cmd"
  printf '%s\n' "Remembered: '$cmd' → '$chosen_path'" >&2
fi

# Execute the chosen command
exec "$chosen_path" "$@"
