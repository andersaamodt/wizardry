#!/bin/sh
# parse-imperative CMD [ARGS...] - recursively parse and execute written imperatives
# Handles linking words (then, and, or, into, to, from) that chain or modify commands.
# Unknown commands fall through to the shell with an appropriate error message.
# Example: parse-imperative echo hello then echo world â†’ echo hello && echo world

set -eu

# If no arguments, nothing to do
if [ $# -eq 0 ]; then
  exit 0
fi

# Check if first word is a linking word that needs special handling
first=$1
shift

case $first in
  # Sequential/conjunction linking words - execute remainder
  then|and)
    if [ $# -eq 0 ]; then
      exit 0
    fi
    exec "$0" "$@"
    ;;
  
  # Alternation linking word - execute remainder (called after prior failure)
  or)
    if [ $# -eq 0 ]; then
      exit 0
    fi
    exec "$0" "$@"
    ;;
  
  # Target linking word - reorder arguments
  into|to)
    if [ $# -lt 2 ]; then
      printf '%s: %s requires a target and command\n' "parse-imperative" "$first" >&2
      exit 1
    fi
    target=$1
    shift
    cmd=$1
    shift
    # Execute: cmd [args...] target
    exec "$cmd" "$@" "$target"
    ;;
  
  # Source linking word - reorder arguments  
  from)
    if [ $# -lt 2 ]; then
      printf '%s: from requires a source and command\n' "parse-imperative" >&2
      exit 1
    fi
    source=$1
    shift
    cmd=$1
    shift
    # Execute: cmd source [args...]
    exec "$cmd" "$source" "$@"
    ;;
esac

# Not a linking word - first is the command
cmd=$first

# Simple case: no more arguments - just execute the command
if [ $# -eq 0 ]; then
  if command -v "$cmd" >/dev/null 2>&1; then
    exec "$cmd"
  else
    printf '%s: command not found\n' "$cmd" >&2
    exit 127
  fi
fi

# Look for linking words in the arguments
# We use a counter-based approach to track position
link_pos=0
pos=0
for arg in "$@"; do
  pos=$((pos + 1))
  case $arg in
    then|and|or|into|to|from)
      link_pos=$pos
      break
      ;;
  esac
done

# If no linking word found, execute the full command directly
if [ "$link_pos" -eq 0 ]; then
  if command -v "$cmd" >/dev/null 2>&1; then
    exec "$cmd" "$@"
  else
    printf '%s: command not found\n' "$cmd" >&2
    exit 127
  fi
fi

# We have a linking word at position link_pos
# Separate args before and at/after the linking word
cmd_arg_count=$((link_pos - 1))
total_args=$#

# Save all arguments to indexed variables for later retrieval
i=1
for arg in "$@"; do
  eval "saved_arg_$i=\"\$arg\""
  i=$((i + 1))
done

# Get the linking word
eval "link_word=\"\$saved_arg_$link_pos\""

# Handle the linking word
case $link_word in
  then|and)
    # Rebuild command arguments (before link word)
    set --
    i=1
    while [ "$i" -le "$cmd_arg_count" ]; do
      eval "set -- \"\$@\" \"\$saved_arg_$i\""
      i=$((i + 1))
    done
    
    # Execute command
    if "$cmd" "$@"; then
      # Rebuild remaining arguments (after link word)
      set --
      i=$((link_pos + 1))
      while [ "$i" -le "$total_args" ]; do
        eval "set -- \"\$@\" \"\$saved_arg_$i\""
        i=$((i + 1))
      done
      exec "$0" "$@"
    else
      exit $?
    fi
    ;;
    
  or)
    # Rebuild command arguments
    set --
    i=1
    while [ "$i" -le "$cmd_arg_count" ]; do
      eval "set -- \"\$@\" \"\$saved_arg_$i\""
      i=$((i + 1))
    done
    
    if "$cmd" "$@"; then
      exit 0
    else
      # Rebuild remaining arguments
      set --
      i=$((link_pos + 1))
      while [ "$i" -le "$total_args" ]; do
        eval "set -- \"\$@\" \"\$saved_arg_$i\""
        i=$((i + 1))
      done
      exec "$0" "$@"
    fi
    ;;
    
  into|to)
    # Target should be the next argument after link word
    target_pos=$((link_pos + 1))
    if [ "$target_pos" -gt "$total_args" ]; then
      printf '%s: %s requires a target\n' "parse-imperative" "$link_word" >&2
      exit 1
    fi
    eval "target=\"\$saved_arg_$target_pos\""
    
    # Rebuild: cmd [args before link word] target
    set --
    i=1
    while [ "$i" -le "$cmd_arg_count" ]; do
      eval "set -- \"\$@\" \"\$saved_arg_$i\""
      i=$((i + 1))
    done
    exec "$cmd" "$@" "$target"
    ;;
    
  from)
    # Source should be the next argument after link word
    source_pos=$((link_pos + 1))
    if [ "$source_pos" -gt "$total_args" ]; then
      printf '%s: from requires a source\n' "parse-imperative" >&2
      exit 1
    fi
    eval "source=\"\$saved_arg_$source_pos\""
    
    # Rebuild: cmd source [args before link word]
    set --
    i=1
    while [ "$i" -le "$cmd_arg_count" ]; do
      eval "set -- \"\$@\" \"\$saved_arg_$i\""
      i=$((i + 1))
    done
    exec "$cmd" "$source" "$@"
    ;;
esac
