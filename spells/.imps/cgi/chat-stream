#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (VERSION: 2026-01-31-v38-EVENT-DRIVEN)
# Streams chat messages as Server-Sent Events using event-driven tail -f
# Self-contained - no external imp dependencies
# Accepts query parameter: room=ROOM&since=TIMESTAMP
#
# CONCURRENCY: Each fcgiwrap worker handles one connection. Configure fcgiwrap with
# multiple workers (-c N) to support N concurrent SSE connections. Default: 10 workers.

set -eu

# Diagnostic logging
printf '[chat-stream] ========== v34-DEBUG: Enhanced diagnostics ==========\n' >&2
printf '[chat-stream] QUERY_STRING: %s\n' "${QUERY_STRING:-}" >&2

# Send SSE headers (inline, no http-status/http-header imps)
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf '\r\n'

# CRITICAL: Force headers to flush by sending 32KB padding immediately
# fcgiwrap + nginx may buffer ~8-16KB. This massive padding forces immediate flush.
printf ': padding '
i=0
while [ $i -lt 4000 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# SSE event sender - with MASSIVE padding to force fcgiwrap flush
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # Send the event
  printf 'event: %s\ndata: %s\n' "$event_type" "$event_data"
  
  # Add 32KB padding as SSE comment to FORCE buffer flush
  # Increased from 8KB to 32KB to handle multiple buffering layers
  printf ': '
  i=0
  while [ $i -lt 4000 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# Simple URL decoder (inline, no url-decode imp)
url_decode() {
  # Replace + with space, then decode %XX sequences
  printf '%s' "$1" | sed 's/+/ /g; s/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf '%b'
}

# Parse room name from query string
room_name="${QUERY_STRING:-}"
room_name=$(printf '%s' "$room_name" | sed 's/.*room=\([^&]*\).*/\1/')
room_name=$(url_decode "$room_name")
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# Validate room name
if ! printf '%s' "$room_name" | grep -q '^[a-zA-Z0-9_ -]\+$'; then
  printf '[chat-stream] ERROR: Invalid room name\n' >&2
  send_sse_event error "Invalid room name"
  exit 0
fi

# Parse optional 'since' timestamp
since_timestamp=""
if printf '%s' "${QUERY_STRING:-}" | grep -q 'since='; then
  since_timestamp=$(printf '%s' "${QUERY_STRING:-}" | sed 's/.*since=\([^&]*\).*/\1/')
  since_timestamp=$(url_decode "$since_timestamp")
  since_timestamp=$(printf '%s' "$since_timestamp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
fi

if [ -z "$room_name" ]; then
  send_sse_event error "No room specified"
  exit 0
fi

# Chat rooms directory
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
CHAT_DIR="$SITES_DIR/.sitedata/$site_id/chatrooms"
ROOM_DIR="$CHAT_DIR/$room_name"
LOG_FILE="$ROOM_DIR/.log"

printf '[chat-stream] Room: %s, Log: %s\n' "$room_name" "$LOG_FILE" >&2

if [ ! -d "$ROOM_DIR" ]; then
  send_sse_event error "Room not found"
  exit 0
fi

# Send initial batch of messages
# CRITICAL: Use temp file to avoid pipe subshell buffering
temp_init="/tmp/chat_stream_$$_init"
if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  if [ -n "$since_timestamp" ]; then
    # Filter messages after 'since' timestamp
    cat "$LOG_FILE" > "$temp_init"
    while IFS= read -r line || [ -n "$line" ]; do
      msg_timestamp=$(printf '%s' "$line" | sed 's/^\[\([^]]*\)\].*/\1/')
      latest=$(printf '%s\n%s' "$msg_timestamp" "$since_timestamp" | sort | tail -1)
      if [ "$latest" = "$msg_timestamp" ]; then
        send_sse_event message "$line"
      fi
    done < "$temp_init"
    rm -f "$temp_init"
  else
    # Send last 50 messages
    tail -50 "$LOG_FILE" > "$temp_init" 2>/dev/null || true
    while IFS= read -r line; do
      send_sse_event message "$line"
    done < "$temp_init"
    rm -f "$temp_init"
  fi
fi

# Send initial members list
if [ -f "$ROOM_DIR/.members" ]; then
  members_json=$(cat "$ROOM_DIR/.members" 2>/dev/null || printf '[]')
  send_sse_event members "$members_json"
fi

printf '[chat-stream] Initial messages sent, starting event-driven monitoring...\n' >&2

# Event-driven approach: Use tail -f with named pipe (FIFO)
# This avoids subshell buffering while being truly event-driven

# Create a named pipe for communication
fifo="/tmp/chat_stream_fifo_$$"
mkfifo "$fifo" 2>/dev/null || {
  printf '[chat-stream] ERROR: Could not create FIFO\n' >&2
  exit 1
}

# Cleanup function
cleanup_fifo() {
  rm -f "$fifo"
  # Kill tail -f if still running
  if [ -n "${tail_pid:-}" ]; then
    kill "$tail_pid" 2>/dev/null || true
  fi
}
trap cleanup_fifo EXIT INT TERM

# Start tail -f in background, outputting to FIFO
# -n 0 means start from end (don't repeat initial messages)
tail -f -n 0 "$LOG_FILE" > "$fifo" 2>/dev/null &
tail_pid=$!
printf '[chat-stream] Started tail -f with PID %d (event-driven mode)\n' "$tail_pid" >&2

# Track time for periodic tasks
last_keepalive=$(date +%s)
last_members=$(date +%s)

# Read from FIFO in an event-driven manner
# Each line from tail -f triggers immediate processing
while IFS= read -r line; do
  # Send the message immediately (event-driven!)
  send_sse_event message "$line"
  printf '[chat-stream] Sent message: %s\n' "$line" >&2
  
  # Periodic keepalive (every 15 seconds)
  now=$(date +%s)
  if [ $((now - last_keepalive)) -ge 15 ]; then
    send_sse_event ping "keepalive"
    last_keepalive=$now
  fi
  
  # Periodic members update (every 15 seconds)
  if [ $((now - last_members)) -ge 15 ] && [ -f "$ROOM_DIR/.members" ]; then
    members_json=$(cat "$ROOM_DIR/.members" 2>/dev/null || printf '[]')
    send_sse_event members "$members_json"
    last_members=$now
  fi
  
  # Check if room still exists
  if [ ! -d "$ROOM_DIR" ]; then
    printf '[chat-stream] Room deleted, exiting\n' >&2
    break
  fi
done < "$fifo"

cleanup_fifo
