#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (v1.1-TEST-16KB)
# Streams chat messages as Server-Sent Events using ultra-fast polling (50Hz)
# Testing 16KB padding (50% reduction from 32KB)

set -eu

# Send SSE headers
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf '\r\n'

# Initial 32KB padding to force fcgiwrap buffer flush
printf ': '
i=0
while [ $i -lt 4000 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# SSE event sender with 32KB padding for immediate delivery
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  printf 'event: %s\ndata: %s\n\n' "$event_type" "$event_data"
  
  # 16KB padding to force buffer flush (testing 50% reduction)
  printf ': '
  i=0
  while [ $i -lt 2000 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# URL decoder (inline, no external dependencies)
url_decode() {
  printf '%s' "$1" | sed 's/+/ /g; s/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf '%b'
}

# Parse query string
room=""
since_timestamp=""

if [ -n "${QUERY_STRING:-}" ]; then
  IFS='&'
  for param in $QUERY_STRING; do
    key="${param%%=*}"
    value="${param#*=}"
    case "$key" in
      room) room=$(url_decode "$value") ;;
      since) since_timestamp=$(url_decode "$value") ;;
    esac
  done
fi

# Default to General if no room specified
room="${room:-General}"

# Get site paths
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
SITE_NAME="${WIZARDRY_SITE_NAME:-default}"
SITEDATA_DIR="$SITES_DIR/.sitedata/$SITE_NAME"
ROOM_DIR="$SITEDATA_DIR/chatrooms/$room"
LOG_FILE="$ROOM_DIR/.log"

# Verify room exists
if [ ! -f "$LOG_FILE" ]; then
  send_sse_event error "Room not found"
  exit 1
fi

# Send initial messages (if since parameter provided, filter by timestamp)
if [ -n "$since_timestamp" ]; then
  # Send messages after the specified timestamp
  while IFS= read -r line; do
    # Extract timestamp from message: [YYYY-MM-DD HH:MM:SS] ...
    msg_timestamp=$(printf '%s' "$line" | sed -n 's/^\[\([^]]*\)\].*/\1/p')
    
    if [ -n "$msg_timestamp" ]; then
      # Compare timestamps (lexicographic comparison works for ISO format)
      latest=$(printf '%s\n%s' "$msg_timestamp" "$since_timestamp" | sort | tail -1)
      if [ "$latest" = "$msg_timestamp" ]; then
        send_sse_event message "$line"
      fi
    fi
  done < "$LOG_FILE"
else
  # Send last 50 messages if no timestamp filter
  tail -50 "$LOG_FILE" 2>/dev/null | while IFS= read -r line; do
    send_sse_event message "$line"
  done
fi

# Start polling loop (50Hz = 0.02s interval)
last_lines=$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)
last_keepalive=0
last_members=0

while true; do
  sleep 0.02
  
  # Check for new messages
  current_lines=$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)
  
  if [ "$current_lines" -gt "$last_lines" ]; then
    # New messages detected - send them
    temp="/tmp/chat_stream_$$_$(date +%s)"
    tail -n "+$((last_lines + 1))" "$LOG_FILE" > "$temp" 2>/dev/null || true
    
    while IFS= read -r line; do
      send_sse_event message "$line"
    done < "$temp"
    
    rm -f "$temp"
    last_lines=$current_lines
  fi
  
  # Send keepalive ping every 15 seconds
  now=$(date +%s)
  if [ $((now - last_keepalive)) -ge 15 ]; then
    send_sse_event ping "keepalive"
    last_keepalive=$now
  fi
  
  # Send members list every 15 seconds
  if [ $((now - last_members)) -ge 15 ]; then
    if [ -f "$ROOM_DIR/.members" ]; then
      members_json=$(cat "$ROOM_DIR/.members" 2>/dev/null || echo '[]')
      send_sse_event members "$members_json"
    fi
    last_members=$now
  fi
done
