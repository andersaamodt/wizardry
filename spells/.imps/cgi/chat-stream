#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages
# Streams chat messages as Server-Sent Events
# Accepts query parameter: room=ROOM&since=TIMESTAMP
set -eu

# Start SSE stream
sse-start

# Parse room name from query string
room_name="${QUERY_STRING:-}"
room_name=$(printf '%s' "$room_name" | sed 's/.*room=\([^&]*\).*/\1/')
room_name=$(url-decode "$room_name" || printf '%s' "$room_name")
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# Validate room name to prevent directory traversal
# Allow only alphanumeric, dash, underscore, and space
if ! printf '%s' "$room_name" | grep -q '^[a-zA-Z0-9_ -]\+$'; then
  sse-event error "Invalid room name"
  exit 0
fi

# Parse optional 'since' timestamp from query string
since_timestamp=""
if printf '%s' "${QUERY_STRING:-}" | grep -q 'since='; then
  since_timestamp=$(printf '%s' "${QUERY_STRING:-}" | sed 's/.*since=\([^&]*\).*/\1/')
  since_timestamp=$(url-decode "$since_timestamp" || printf '%s' "$since_timestamp")
  since_timestamp=$(printf '%s' "$since_timestamp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
fi

if [ -z "$room_name" ]; then
  sse-event error "No room specified"
  exit 0
fi

# Chat rooms directory - use site-specific location
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
CHAT_DIR="$SITES_DIR/.sitedata/$site_id/chatrooms"
ROOM_DIR="$CHAT_DIR/$room_name"

if [ ! -d "$ROOM_DIR" ]; then
  sse-event error "Room not found"
  exit 0
fi

LOG_FILE="$ROOM_DIR/.log"

# Send initial batch of messages
if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  # If since timestamp provided, filter messages after that timestamp
  if [ -n "$since_timestamp" ]; then
    # Filter messages that come after the 'since' timestamp
    # Format: [YYYY-MM-DD HH:MM:SS] username: message
    # Compare timestamps lexicographically (works for ISO format)
    tail -200 "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
      # Extract timestamp from line
      msg_timestamp=$(printf '%s' "$line" | sed 's/^\[\([^]]*\)\].*/\1/')
      
      # Use string comparison (timestamps are in sortable format)
      # Only send messages strictly after the 'since' timestamp
      if [ "$msg_timestamp" '>' "$since_timestamp" ]; then
        sse-event message "$line"
      fi
    done
  else
    # Send last 200 messages if no 'since' provided
    tail -200 "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
      sse-event message "$line"
    done
  fi
  
  # Record the last line count for tracking new messages
  last_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
else
  # No messages yet
  sse-event empty "No messages yet"
  last_line_count=0
fi

# Function to escape JSON strings
json_escape() {
  # Escape backslashes, quotes, and control characters for JSON
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' ' | sed 's/ *$//'
}

# Function to get current member list as JSON
get_member_list() {
  room_dir="$1"
  printf '['
  first=1
  for avatar_dir in "$room_dir"/.*; do
    [ -d "$avatar_dir" ] || continue
    avatar_name=$(basename "$avatar_dir")
    
    # Skip . and .. and .log
    case "$avatar_name" in
      .|..|.log) continue ;;
    esac
    
    # Check if it's a web avatar
    is_web="false"
    if get-attribute "user.web_avatar" "$avatar_dir" >/dev/null 2>&1; then
      is_web="true"
    fi
    
    # Remove leading dot from username and escape for JSON
    username=$(printf '%s' "$avatar_name" | sed 's/^\.//')
    username_escaped=$(json_escape "$username")
    
    if [ "$first" -eq 1 ]; then
      first=0
    else
      printf ', '
    fi
    
    printf '{"username": "%s", "is_web": %s}' "$username_escaped" "$is_web"
  done
  printf ']'
}

# Send initial member list
initial_members=$(get_member_list "$ROOM_DIR")
sse-event members "$initial_members"
last_members="$initial_members"

# Keep connection alive and stream new messages and member updates
# Poll the log file and room directory for changes every 1 second
# Exit if output fails (client disconnected)
heartbeat_counter=0
max_idle_time=300  # Exit after 5 minutes of no activity
idle_counter=0

while true; do
  sleep 1
  
  # Try to send output and exit if it fails (broken pipe = client disconnected)
  if ! printf '' 2>/dev/null; then
    exit 0
  fi
  
  # Check if log file has new lines
  if [ -f "$LOG_FILE" ]; then
    current_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
    
    if [ "$current_line_count" -gt "$last_line_count" ]; then
      # New messages available - send them
      new_message_count=$((current_line_count - last_line_count))
      tail -n "$new_message_count" "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
        sse-event message "$line" || exit 0  # Exit if output fails
      done
      last_line_count=$current_line_count
      heartbeat_counter=0  # Reset heartbeat counter
      idle_counter=0  # Reset idle counter
    else
      idle_counter=$((idle_counter + 1))
    fi
  else
    idle_counter=$((idle_counter + 1))
  fi
  
  # Check for member list changes
  current_members=$(get_member_list "$ROOM_DIR")
  if [ "$current_members" != "$last_members" ]; then
    sse-event members "$current_members" || exit 0
    last_members="$current_members"
    idle_counter=0  # Reset idle counter
  fi
  
  # Exit if idle for too long
  if [ "$idle_counter" -ge "$max_idle_time" ]; then
    exit 0
  fi
  
  # Send heartbeat comment every 15 seconds to keep connection alive
  heartbeat_counter=$((heartbeat_counter + 1))
  if [ "$heartbeat_counter" -ge 15 ]; then
    printf ': heartbeat\n\n' || exit 0  # Exit if output fails
    heartbeat_counter=0
  fi
done
