#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (v2.3-2KB-TEST)
# True event-driven SSE using tail -f + file descriptor (no polling, 0ms detection)
# Testing 2KB padding (middle ground between 4KB and 1KB)
# Uses avatar directories as single source of truth (no redundant .members file)

set -eu

# Send SSE headers
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf '\r\n'

# Initial 4KB padding to force fcgiwrap buffer flush (confirmed minimum)
printf ': '
i=0
while [ $i -lt 500 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# SSE event sender with 4KB padding for immediate delivery
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # FLUSH BEFORE: 4KB padding (confirmed minimum for reliable delivery)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
  
  # Event data
  printf 'event: %s\ndata: %s\n\n' "$event_type" "$event_data"
  
  # 4KB padding after event (complete the flush)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# URL decoder (inline, no external dependencies)
url_decode() {
  printf '%s' "$1" | sed 's/+/ /g; s/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf '%b'
}

# Parse query string
room=""
since_timestamp=""

if [ -n "${QUERY_STRING:-}" ]; then
  IFS='&'
  for param in $QUERY_STRING; do
    key="${param%%=*}"
    value="${param#*=}"
    case "$key" in
      room) room=$(url_decode "$value") ;;
      since) since_timestamp=$(url_decode "$value") ;;
    esac
  done
fi

# Default to General if no room specified
room="${room:-General}"

# Get site paths
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
SITE_NAME="${WIZARDRY_SITE_NAME:-default}"
SITEDATA_DIR="$SITES_DIR/.sitedata/$SITE_NAME"
ROOM_DIR="$SITEDATA_DIR/chatrooms/$room"
LOG_FILE="$ROOM_DIR/.log"

# Verify room exists
if [ ! -f "$LOG_FILE" ]; then
  send_sse_event error "Room not found"
  exit 1
fi

# Send initial messages (if since parameter provided, filter by timestamp)
if [ -n "$since_timestamp" ]; then
  # Send messages after the specified timestamp
  while IFS= read -r line; do
    # Extract timestamp from message: [YYYY-MM-DD HH:MM:SS] ...
    msg_timestamp=$(printf '%s' "$line" | sed -n 's/^\[\([^]]*\)\].*/\1/p')
    
    if [ -n "$msg_timestamp" ]; then
      # Compare timestamps (lexicographic comparison works for ISO format)
      latest=$(printf '%s\n%s' "$msg_timestamp" "$since_timestamp" | sort | tail -1)
      if [ "$latest" = "$msg_timestamp" ]; then
        send_sse_event message "$line"
      fi
    fi
  done < "$LOG_FILE"
else
  # Send last 50 messages if no timestamp filter
  tail -50 "$LOG_FILE" 2>/dev/null | while IFS= read -r line; do
    send_sse_event message "$line"
  done
fi

# Event-driven monitoring using tail -f + file descriptor approach
# EXPERIMENTAL: Testing if FD redirection avoids subshell buffering

last_message_time=$(date +%s)
last_room_mtime=0

# Create FIFO for tail output
fifo="/tmp/chat_stream_$$_fifo"
mkfifo "$fifo" || exit 1

# Cleanup function
cleanup() {
  exec 3<&- 2>/dev/null || true
  kill $tail_pid 2>/dev/null || true
  kill $keepalive_pid 2>/dev/null || true
  kill $membership_pid 2>/dev/null || true
  rm -f "$fifo"
  exit
}

trap cleanup INT TERM EXIT

# Start tail -f writing to FIFO (background, starts from end)
tail -f -n 0 "$LOG_FILE" > "$fifo" &
tail_pid=$!

# Start background keepalive monitor
(
  while true; do
    sleep 15
    now=$(date +%s)
    # Only send keepalive if idle > 30s
    if [ $((now - last_message_time)) -ge 30 ]; then
      send_sse_event ping "keepalive"
    fi
  done
) &
keepalive_pid=$!

# Background membership monitor (tracks changes in member count)
# More reliable than mtime since avatars can be added within same second
(
  last_member_count=-1  # Start with -1 to force initial update
  while true; do
    sleep 2
    if [ -d "$ROOM_DIR" ]; then
      # Count avatar directories (hidden directories starting with .)
      # Skip . and .. and .log
      current_member_count=0
      for avatar_dir in "$ROOM_DIR"/.*; do
        [ -d "$avatar_dir" ] || continue
        avatar_name=$(basename "$avatar_dir")
        case "$avatar_name" in
          .|..|.log) continue ;;
        esac
        current_member_count=$((current_member_count + 1))
      done
      
      # Log for debugging (to stderr so it doesn't interfere with SSE)
      printf '[membership-monitor] Room: %s, Count: %d, Last: %d\n' "$room" "$current_member_count" "$last_member_count" >&2
      
      # Send update if count changed
      if [ "$current_member_count" != "$last_member_count" ]; then
        printf '[membership-monitor] Count changed! Sending member update\n' >&2
        
        # Call chat-list-avatars to get member list
        # Requires wizardry commands in PATH (set up by serve-site)
        query="room=$room"
        members_output=$(QUERY_STRING="$query" chat-list-avatars 2>&1)
        
        # Strip carriage returns (HTTP uses CRLF, not just LF)
        # This ensures blank lines are actually blank for sed matching
        members_output=$(printf '%s' "$members_output" | tr -d '\r')
        
        # Extract JSON body (everything after first blank line)
        members_json=$(printf '%s' "$members_output" | sed -n '/^$/,$ p' | tail -n +2)
        
        # Validate JSON
        if [ -z "$members_json" ] || ! printf '%s' "$members_json" | grep -q '^{'; then
          printf '[membership-monitor] Warning: chat-list-avatars failed, using empty array\n' >&2
          printf '[membership-monitor] Output was: %s\n' "$members_output" >&2
          members_json='{"avatars":[]}'
        fi
        
        send_sse_event members "$members_json"
        last_member_count=$current_member_count
      fi
    fi
  done
) &
membership_pid=$!

# Open FIFO as file descriptor 3 in MAIN shell (critical!)
exec 3< "$fifo"

# Event loop: Read from FD 3 - testing if this stays in main shell
# If this works, no subshell = no buffering = instant delivery!
while IFS= read -r line <&3; do
  send_sse_event message "$line"
  last_message_time=$(date +%s)
done

cleanup
