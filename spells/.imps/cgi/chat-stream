#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (v1.4-NO-MEMBERS-FILE)
# Streams chat messages as Server-Sent Events using ultra-fast polling (50Hz)
# Uses avatar directories as single source of truth (no redundant .members file)

set -eu

# Send SSE headers
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf '\r\n'

# Initial 32KB padding to force fcgiwrap buffer flush
printf ': '
i=0
while [ $i -lt 4000 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# SSE event sender with 32KB flush-before padding for immediate delivery
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # FLUSH BEFORE: 32KB padding to force buffer overflow
  printf ': '
  i=0
  while [ $i -lt 4000 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
  
  # Event data
  printf 'event: %s\ndata: %s\n\n' "$event_type" "$event_data"
  
  # 16KB padding to force buffer flush (testing 50% reduction)
  printf ': '
  i=0
  while [ $i -lt 2000 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# URL decoder (inline, no external dependencies)
url_decode() {
  printf '%s' "$1" | sed 's/+/ /g; s/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf '%b'
}

# Parse query string
room=""
since_timestamp=""

if [ -n "${QUERY_STRING:-}" ]; then
  IFS='&'
  for param in $QUERY_STRING; do
    key="${param%%=*}"
    value="${param#*=}"
    case "$key" in
      room) room=$(url_decode "$value") ;;
      since) since_timestamp=$(url_decode "$value") ;;
    esac
  done
fi

# Default to General if no room specified
room="${room:-General}"

# Get site paths
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
SITE_NAME="${WIZARDRY_SITE_NAME:-default}"
SITEDATA_DIR="$SITES_DIR/.sitedata/$SITE_NAME"
ROOM_DIR="$SITEDATA_DIR/chatrooms/$room"
LOG_FILE="$ROOM_DIR/.log"

# Verify room exists
if [ ! -f "$LOG_FILE" ]; then
  send_sse_event error "Room not found"
  exit 1
fi

# Send initial messages (if since parameter provided, filter by timestamp)
if [ -n "$since_timestamp" ]; then
  # Send messages after the specified timestamp
  while IFS= read -r line; do
    # Extract timestamp from message: [YYYY-MM-DD HH:MM:SS] ...
    msg_timestamp=$(printf '%s' "$line" | sed -n 's/^\[\([^]]*\)\].*/\1/p')
    
    if [ -n "$msg_timestamp" ]; then
      # Compare timestamps (lexicographic comparison works for ISO format)
      latest=$(printf '%s\n%s' "$msg_timestamp" "$since_timestamp" | sort | tail -1)
      if [ "$latest" = "$msg_timestamp" ]; then
        send_sse_event message "$line"
      fi
    fi
  done < "$LOG_FILE"
else
  # Send last 50 messages if no timestamp filter
  tail -50 "$LOG_FILE" 2>/dev/null | while IFS= read -r line; do
    send_sse_event message "$line"
  done
fi

# Start polling loop (50Hz = 0.02s interval)
last_lines=$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)
last_message_time=$(date +%s)
last_keepalive=0
last_room_mtime=0

while true; do
  sleep 0.02
  
  # Check for new messages
  current_lines=$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)
  
  if [ "$current_lines" -gt "$last_lines" ]; then
    # New messages detected - send them
    temp="/tmp/chat_stream_$$_$(date +%s)"
    tail -n "+$((last_lines + 1))" "$LOG_FILE" > "$temp" 2>/dev/null || true
    
    while IFS= read -r line; do
      send_sse_event message "$line"
    done < "$temp"
    
    rm -f "$temp"
    last_lines=$current_lines
    last_message_time=$(date +%s)
  fi
  
  # Smart keepalive: Only send if idle for 30 seconds
  now=$(date +%s)
  if [ $((now - last_message_time)) -ge 30 ] && [ $((now - last_keepalive)) -ge 15 ]; then
    send_sse_event ping "keepalive"
    last_keepalive=$now
  fi
  
  # On-change membership: Watch room directory mtime (changes when avatars added/removed)
  if [ -d "$ROOM_DIR" ]; then
    # Get room directory modification time (cross-platform)
    if command -v stat >/dev/null 2>&1; then
      current_room_mtime=$(stat -f %m "$ROOM_DIR" 2>/dev/null || stat -c %Y "$ROOM_DIR" 2>/dev/null || echo 0)
    else
      current_room_mtime=0
    fi
    
    if [ "$current_room_mtime" != "$last_room_mtime" ] && [ "$current_room_mtime" != "0" ]; then
      # Generate member list from avatar directories (single source of truth)
      # Use chat-list-avatars imp to scan .username directories
      members_json=$(QUERY_STRING="room=$room_name" chat-list-avatars 2>/dev/null || echo '{"avatars":[]}')
      send_sse_event members "$members_json"
      last_room_mtime=$current_room_mtime
    fi
  fi
done
