#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (v2.8-gapless)
# True event-driven SSE using tail -f + file descriptor (no polling, 0ms detection)
# Enhanced with: retry field, connection timeout, health monitoring, CORS support
# Uses avatar directories as single source of truth (no redundant .members file)
# Gapless connection: continuous tail -f stream with timestamp filtering prevents message loss

# Debug logging to ~/testlog.txt
printf '[CHAT-STREAM DEBUG] ========== NEW CONNECTION ==========\n' >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] Timestamp: %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] QUERY_STRING: %s\n' "${QUERY_STRING:-UNSET}" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] WIZARDRY_SITE_NAME: %s\n' "${WIZARDRY_SITE_NAME:-UNSET}" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] WIZARDRY_SITES_DIR: %s\n' "${WIZARDRY_SITES_DIR:-UNSET}" >> ~/testlog.txt 2>&1 || true

# Send SSE headers with CORS support FIRST (before set -eu)
# This ensures headers are always output even if script fails early
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf 'Access-Control-Allow-Origin: *\r\n'
printf 'Access-Control-Allow-Methods: GET, OPTIONS\r\n'
printf 'Access-Control-Allow-Headers: Content-Type, Last-Event-ID\r\n'
printf '\r\n'

# Don't enable strict mode yet - wait until after initial setup
# set -eu moved to after padding/retry output

# Configuration
MAX_CONNECTION_TIME=3600  # 1 hour maximum connection duration
KEEPALIVE_INTERVAL=15     # Send keepalive every 15s when idle
IDLE_THRESHOLD=30         # Only send keepalive if idle > 30s

# Initial 4KB padding to force fcgiwrap buffer flush (confirmed minimum)
printf ': '
i=0
while [ $i -lt 500 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# Set reconnection retry interval (5 seconds)
printf 'retry: 5000\n\n'

# SSE event sender with 4KB padding for immediate delivery
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # FLUSH BEFORE: 4KB padding (confirmed minimum for reliable delivery)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
  
  # Event data
  printf 'event: %s\ndata: %s\n\n' "$event_type" "$event_data"
  
  # 4KB padding after event (complete the flush)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# Now enable strict mode after headers and padding are output
set -eu

printf '[CHAT-STREAM DEBUG] Headers and padding sent\n' >> ~/testlog.txt 2>&1 || true

# Parse query string using get-query-param
room=$(get-query-param "room" "${QUERY_STRING:-}")
since_timestamp=$(get-query-param "since" "${QUERY_STRING:-}")

printf '[CHAT-STREAM DEBUG] Parsed parameters:\n' >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] - room: %s\n' "${room:-EMPTY}" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] - since_timestamp: %s\n' "${since_timestamp:-EMPTY}" >> ~/testlog.txt 2>&1 || true

# Default to General if no room specified
room="${room:-General}"

# Validate room name to prevent path traversal
if ! validate-room-name "$room"; then
  printf '[CHAT-STREAM DEBUG] Invalid room name: %s\n' "$room" >> ~/testlog.txt 2>&1 || true
  sse-error 400 "Invalid room name"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

printf '[CHAT-STREAM DEBUG] Room name validated: %s\n' "$room" >> ~/testlog.txt 2>&1 || true

# Get site paths using get-site-data-dir
CHAT_DIR=$(get-site-data-dir "chatrooms")
ROOM_DIR="$CHAT_DIR/$room"
LOG_FILE="$ROOM_DIR/.log"

printf '[CHAT-STREAM DEBUG] Paths resolved:\n' >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] - CHAT_DIR: %s\n' "$CHAT_DIR" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] - ROOM_DIR: %s\n' "$ROOM_DIR" >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] - LOG_FILE: %s\n' "$LOG_FILE" >> ~/testlog.txt 2>&1 || true

# Verify room exists
if [ ! -d "$ROOM_DIR" ]; then
  printf '[CHAT-STREAM DEBUG] Room directory not found: %s\n' "$ROOM_DIR" >> ~/testlog.txt 2>&1 || true
  sse-error 404 "Room not found"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

printf '[CHAT-STREAM DEBUG] Room directory exists\n' >> ~/testlog.txt 2>&1 || true

# Historical messages are fetched separately via chat-get-messages endpoint
# However, we send recent messages to prevent gaps during connection:
# - Messages sent while SSE is "Connecting" could otherwise be lost
# - Same-second messages need full coverage (log has 1-second resolution)
# We use tail -f with initial lines to ensure continuous coverage with no gaps

# Send initial member list
query="room=$room"
members_output=$(QUERY_STRING="$query" chat-list-avatars 2>&1)
members_output=$(printf '%s' "$members_output" | tr -d '\r')
members_json=$(printf '%s' "$members_output" | sed -n '/^$/,$ p' | tail -n +2)
if [ -z "$members_json" ] || ! printf '%s' "$members_json" | grep -q '^{'; then
  members_json='{"avatars":[]}'
fi
send_sse_event members "$members_json"

# Event-driven monitoring using tail -f + file descriptor approach
# EXPERIMENTAL: Testing if FD redirection avoids subshell buffering

connection_start=$(date +%s)
last_message_time=$(date +%s)
last_room_mtime=0

# Create FIFO for tail output
fifo="/tmp/chat_stream_$$_fifo"
mkfifo "$fifo" || {
  sse-error 500 "Failed to create communication channel"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
}

# Cleanup function
cleanup() {
  printf '[CHAT-STREAM DEBUG] Cleanup called\n' >> ~/testlog.txt 2>&1 || true
  printf '[CHAT-STREAM DEBUG] - Reason: connection closed or error\n' >> ~/testlog.txt 2>&1 || true
  exec 3<&- 2>/dev/null || true
  kill ${tail_pid:-} 2>/dev/null || true
  kill ${keepalive_pid:-} 2>/dev/null || true
  kill ${membership_pid:-} 2>/dev/null || true
  kill ${timeout_pid:-} 2>/dev/null || true
  kill ${health_pid:-} 2>/dev/null || true
  rm -f "${fifo:-}"
  printf '[CHAT-STREAM DEBUG] ========== CONNECTION CLOSED ==========\n' >> ~/testlog.txt 2>&1 || true
  exit
}

trap cleanup INT TERM EXIT

# Ensure LOG_FILE exists for tail -f (creates if missing)
touch "$LOG_FILE"
chmod 664 "$LOG_FILE" 2>/dev/null || true

# Determine initial line count for tail -f based on whether we need gap prevention
# - If since_timestamp provided: start with last 100 lines to cover connection gap
# - Otherwise: start from end (0 lines) for pure real-time monitoring
if [ -n "$since_timestamp" ]; then
  initial_lines=100
else
  initial_lines=0
fi

# Start tail -f writing to FIFO (background)
# Using -n to send initial lines ensures NO GAP between initial and ongoing monitoring
printf '[CHAT-STREAM DEBUG] Starting tail -f with initial_lines=%s\n' "$initial_lines" >> ~/testlog.txt 2>&1 || true
tail -f -n "$initial_lines" "$LOG_FILE" > "$fifo" &
tail_pid=$!

printf '[CHAT-STREAM DEBUG] tail process started with PID: %s\n' "$tail_pid" >> ~/testlog.txt 2>&1 || true

# Verify tail started successfully
sleep 0.1
if ! kill -0 $tail_pid 2>/dev/null; then
  printf '[CHAT-STREAM DEBUG] tail process failed to start\n' >> ~/testlog.txt 2>&1 || true
  sse-error 500 "Failed to monitor chat log"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

printf '[CHAT-STREAM DEBUG] tail process verified running\n' >> ~/testlog.txt 2>&1 || true
printf '[CHAT-STREAM DEBUG] Entering event loop\n' >> ~/testlog.txt 2>&1 || true

# Background subprocess health monitor
# Detects if critical subprocesses die unexpectedly
(
  while true; do
    sleep 10
    # Check if tail process is still running
    if ! kill -0 $tail_pid 2>/dev/null; then
      send_sse_event error "Stream monitor failed - please reconnect"
      kill $$ 2>/dev/null || true
      exit 1
    fi
  done
) &
health_pid=$!

# Background keepalive monitor with health check
(
  while true; do
    sleep "$KEEPALIVE_INTERVAL"
    now=$(date +%s)
    # Only send keepalive if idle > threshold
    if [ $((now - last_message_time)) -ge "$IDLE_THRESHOLD" ]; then
      send_sse_event ping "keepalive"
    fi
  done
) &
keepalive_pid=$!

# Background connection timeout monitor
# Enforces maximum connection duration to prevent resource leaks
(
  sleep "$MAX_CONNECTION_TIME"
  send_sse_event timeout "Connection time limit reached. Please reconnect."
  kill $$ 2>/dev/null || true
) &
timeout_pid=$!

# Background membership monitor (tracks changes in member list)
# Uses sorted member names as signature to detect ANY membership change,
# including simultaneous join/leave (where count stays same but members change)
(
  last_member_signature=""  # Start empty to force initial update
  while true; do
    sleep 2
    if [ -d "$ROOM_DIR" ]; then
      # Build membership signature from sorted avatar directory names
      # This catches count changes AND member changes with same count
      member_list=""
      current_member_count=0
      for avatar_dir in "$ROOM_DIR"/.*; do
        [ -d "$avatar_dir" ] || continue
        avatar_name=$(basename "$avatar_dir")
        case "$avatar_name" in
          .|..|.log) continue ;;
        esac
        member_list="$member_list$avatar_name "
        current_member_count=$((current_member_count + 1))
      done
      
      # Sort names for consistent comparison (handles join/leave order)
      current_member_signature=$(printf '%s' "$member_list" | tr ' ' '\n' | sort | tr '\n' ' ')
      
      # Send update if membership changed (detects count OR member changes)
      if [ "$current_member_signature" != "$last_member_signature" ]; then
        
        # Call chat-list-avatars to get member list
        # Requires wizardry commands in PATH (set up by serve-site)
        query="room=$room"
        members_output=$(QUERY_STRING="$query" chat-list-avatars 2>&1)
        
        # Strip carriage returns (HTTP uses CRLF, not just LF)
        # This ensures blank lines are actually blank for sed matching
        members_output=$(printf '%s' "$members_output" | tr -d '\r')
        
        # Extract JSON body (everything after first blank line)
        members_json=$(printf '%s' "$members_output" | sed -n '/^$/,$ p' | tail -n +2)
        
        # Validate JSON
        if [ -z "$members_json" ] || ! printf '%s' "$members_json" | grep -q '^{'; then
          members_json='{"avatars":[]}'
        fi
        
        send_sse_event members "$members_json"
        last_member_signature=$current_member_signature
      fi
    fi
  done
) &
membership_pid=$!

# Open FIFO as file descriptor 3 in MAIN shell (critical!)
exec 3< "$fifo"

# Event loop: Read from FD 3 and filter by timestamp if needed
# This ensures NO GAP between initial messages and ongoing monitoring
while IFS= read -r line <&3; do
  # If since_timestamp provided, filter messages by timestamp
  if [ -n "$since_timestamp" ]; then
    # Extract timestamp from message: [YYYY-MM-DD HH:MM:SS] ...
    msg_timestamp=$(printf '%s' "$line" | sed -n 's/^\[\([^]]*\)\].*/\1/p')
    
    # Only send if timestamp >= since_timestamp (or no timestamp in line)
    # Lexicographic comparison works for ISO 8601 format (YYYY-MM-DD HH:MM:SS)
    # because the format sorts correctly as strings (year > month > day > hour > min > sec)
    if [ -z "$msg_timestamp" ] || [ "$msg_timestamp" \> "$since_timestamp" ] || [ "$msg_timestamp" = "$since_timestamp" ]; then
      send_sse_event message "$line"
      last_message_time=$(date +%s)
    fi
  else
    # No filtering needed - send all messages
    send_sse_event message "$line"
    last_message_time=$(date +%s)
  fi
done

cleanup
