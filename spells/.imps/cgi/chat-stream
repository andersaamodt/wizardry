#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (VERSION: 2026-01-31-v34-DEBUG)
# Streams chat messages as Server-Sent Events using optimized polling
# Self-contained - no external imp dependencies
# Accepts query parameter: room=ROOM&since=TIMESTAMP
#
# CONCURRENCY: Each fcgiwrap worker handles one connection. Configure fcgiwrap with
# multiple workers (-c N) to support N concurrent SSE connections. Default: 10 workers.

set -eu

# Diagnostic logging
printf '[chat-stream] ========== v34-DEBUG: Enhanced diagnostics ==========\n' >&2
printf '[chat-stream] QUERY_STRING: %s\n' "${QUERY_STRING:-}" >&2

# Send SSE headers (inline, no http-status/http-header imps)
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf '\r\n'

# CRITICAL: Force headers to flush by sending 8KB padding immediately
# fcgiwrap buffers ~4-8KB before sending to nginx. This forces immediate flush.
printf ': padding ' 
i=0
while [ $i -lt 1000 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# SSE event sender - with padding to force fcgiwrap flush
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # Send the event
  printf 'event: %s\ndata: %s\n' "$event_type" "$event_data"
  
  # Add 8KB padding as SSE comment to force buffer flush
  # This ensures the event is delivered immediately, not buffered
  printf ': '
  i=0
  while [ $i -lt 1000 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# Simple URL decoder (inline, no url-decode imp)
url_decode() {
  # Replace + with space, then decode %XX sequences
  printf '%s' "$1" | sed 's/+/ /g; s/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf '%b'
}

# Parse room name from query string
room_name="${QUERY_STRING:-}"
room_name=$(printf '%s' "$room_name" | sed 's/.*room=\([^&]*\).*/\1/')
room_name=$(url_decode "$room_name")
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# Validate room name
if ! printf '%s' "$room_name" | grep -q '^[a-zA-Z0-9_ -]\+$'; then
  printf '[chat-stream] ERROR: Invalid room name\n' >&2
  send_sse_event error "Invalid room name"
  exit 0
fi

# Parse optional 'since' timestamp
since_timestamp=""
if printf '%s' "${QUERY_STRING:-}" | grep -q 'since='; then
  since_timestamp=$(printf '%s' "${QUERY_STRING:-}" | sed 's/.*since=\([^&]*\).*/\1/')
  since_timestamp=$(url_decode "$since_timestamp")
  since_timestamp=$(printf '%s' "$since_timestamp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
fi

if [ -z "$room_name" ]; then
  send_sse_event error "No room specified"
  exit 0
fi

# Chat rooms directory
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
CHAT_DIR="$SITES_DIR/.sitedata/$site_id/chatrooms"
ROOM_DIR="$CHAT_DIR/$room_name"
LOG_FILE="$ROOM_DIR/.log"

printf '[chat-stream] Room: %s, Log: %s\n' "$room_name" "$LOG_FILE" >&2

if [ ! -d "$ROOM_DIR" ]; then
  send_sse_event error "Room not found"
  exit 0
fi

# Send initial batch of messages
# CRITICAL: Use temp file to avoid pipe subshell buffering
temp_init="/tmp/chat_stream_$$_init"
if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  if [ -n "$since_timestamp" ]; then
    # Filter messages after 'since' timestamp
    cat "$LOG_FILE" > "$temp_init"
    while IFS= read -r line || [ -n "$line" ]; do
      msg_timestamp=$(printf '%s' "$line" | sed 's/^\[\([^]]*\)\].*/\1/')
      latest=$(printf '%s\n%s' "$msg_timestamp" "$since_timestamp" | sort | tail -1)
      if [ "$latest" = "$msg_timestamp" ]; then
        send_sse_event message "$line"
      fi
    done < "$temp_init"
    rm -f "$temp_init"
  else
    # Send last 50 messages
    tail -50 "$LOG_FILE" > "$temp_init" 2>/dev/null || true
    while IFS= read -r line; do
      send_sse_event message "$line"
    done < "$temp_init"
    rm -f "$temp_init"
  fi
fi

# Send initial members list
if [ -f "$ROOM_DIR/.members" ]; then
  members_json=$(cat "$ROOM_DIR/.members" 2>/dev/null || printf '[]')
  send_sse_event members "$members_json"
fi

printf '[chat-stream] Initial messages sent, starting polling loop...\n' >&2

# Track last known line count for efficient change detection
last_line_count=0
if [ -f "$LOG_FILE" ]; then
  last_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || printf '0')
fi

# Polling loop - check for new messages every 0.5 seconds
# We can't use tail -f in a pipe because it creates a subshell that buffers output
while true; do
  sleep 0.5
  
  # Check if room still exists
  if [ ! -d "$ROOM_DIR" ]; then
    printf '[chat-stream] Room deleted, exiting\n' >&2
    exit 0
  fi
  
  # Check for new messages
  if [ -f "$LOG_FILE" ]; then
    current_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || printf '0')
    
    if [ "$current_line_count" -gt "$last_line_count" ]; then
      # New messages detected - send them
      new_msg_count=$((current_line_count - last_line_count))
      printf '[chat-stream] DETECTED %d new messages (was %d, now %d)\n' "$new_msg_count" "$last_line_count" "$current_line_count" >&2
      
      # Use temp file to avoid pipe subshell
      temp_new="/tmp/chat_stream_$$_new"
      tail -n "+$((last_line_count + 1))" "$LOG_FILE" > "$temp_new" 2>/dev/null || true
      
      # Debug: check temp file
      if [ -f "$temp_new" ]; then
        temp_lines=$(wc -l < "$temp_new" 2>/dev/null || printf '0')
        printf '[chat-stream] Temp file has %d lines\n' "$temp_lines" >&2
      fi
      
      line_num=0
      while IFS= read -r line; do
        line_num=$((line_num + 1))
        printf '[chat-stream] SENDING line %d: %s\n' "$line_num" "$line" >&2
        send_sse_event message "$line"
        printf '[chat-stream] SENT line %d\n' "$line_num" >&2
      done < "$temp_new"
      
      printf '[chat-stream] Finished sending %d lines\n' "$line_num" >&2
      rm -f "$temp_new"
      last_line_count="$current_line_count"
    fi
  fi
  
  # Send members update every 2 seconds (every 4th iteration)
  if [ $(($(date +%s) % 2)) -eq 0 ]; then
    if [ -f "$ROOM_DIR/.members" ]; then
      members_json=$(cat "$ROOM_DIR/.members" 2>/dev/null || printf '[]')
      send_sse_event members "$members_json"
    fi
  fi
  
  # Send keepalive comment to prevent timeout
  printf ': keepalive\n\n'
done
