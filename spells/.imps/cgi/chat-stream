#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (v2.7-gap-prevention)
# True event-driven SSE using tail -f + file descriptor (no polling, 0ms detection)
# Enhanced with: retry field, connection timeout, health monitoring, CORS support
# Uses avatar directories as single source of truth (no redundant .members file)
# O(1) connection time with gap prevention - sends last ~100 messages to cover connection window

# Send SSE headers with CORS support FIRST (before set -eu)
# This ensures headers are always output even if script fails early
printf 'Status: 200 OK\r\n'
printf 'Content-Type: text/event-stream\r\n'
printf 'Cache-Control: no-cache\r\n'
printf 'Connection: keep-alive\r\n'
printf 'Access-Control-Allow-Origin: *\r\n'
printf 'Access-Control-Allow-Methods: GET, OPTIONS\r\n'
printf 'Access-Control-Allow-Headers: Content-Type, Last-Event-ID\r\n'
printf '\r\n'

# Don't enable strict mode yet - wait until after initial setup
# set -eu moved to after padding/retry output

# Configuration
MAX_CONNECTION_TIME=3600  # 1 hour maximum connection duration
KEEPALIVE_INTERVAL=15     # Send keepalive every 15s when idle
IDLE_THRESHOLD=30         # Only send keepalive if idle > 30s

# Initial 4KB padding to force fcgiwrap buffer flush (confirmed minimum)
printf ': '
i=0
while [ $i -lt 500 ]; do
  printf '........'
  i=$((i + 1))
done
printf '\n\n'

# Set reconnection retry interval (5 seconds)
printf 'retry: 5000\n\n'

# SSE event sender with 4KB padding for immediate delivery
send_sse_event() {
  event_type="$1"
  event_data="$2"
  
  # FLUSH BEFORE: 4KB padding (confirmed minimum for reliable delivery)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
  
  # Event data
  printf 'event: %s\ndata: %s\n\n' "$event_type" "$event_data"
  
  # 4KB padding after event (complete the flush)
  printf ': '
  i=0
  while [ $i -lt 500 ]; do
    printf '........'
    i=$((i + 1))
  done
  printf '\n\n'
}

# Now enable strict mode after headers and padding are output
set -eu

# Parse query string using get-query-param
room=$(get-query-param "room" "${QUERY_STRING:-}")
since_timestamp=$(get-query-param "since" "${QUERY_STRING:-}")

# Default to General if no room specified
room="${room:-General}"

# Validate room name to prevent path traversal
if ! validate-room-name "$room"; then
  sse-error 400 "Invalid room name"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

# Get site paths using get-site-data-dir
CHAT_DIR=$(get-site-data-dir "chatrooms")
ROOM_DIR="$CHAT_DIR/$room"
LOG_FILE="$ROOM_DIR/.log"

# Verify room exists
if [ ! -d "$ROOM_DIR" ]; then
  sse-error 404 "Room not found"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

# Historical messages are fetched separately via chat-get-messages endpoint
# However, we send recent messages (last ~10 seconds) to prevent gaps during connection:
# - Messages sent while SSE is "Connecting" could otherwise be lost
# - Same-second messages need full coverage (log has 1-second resolution)
# Using tail -100 + timestamp filter keeps connection O(1) while preventing message loss

# Send recent messages if since_timestamp provided (covers connection gap)
if [ -n "$since_timestamp" ] && [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  # Get last ~100 messages (typically covers last 10-30 seconds)
  # This prevents message loss during connection without iterating full history
  tail -100 "$LOG_FILE" 2>/dev/null | while IFS= read -r line; do
    # Extract timestamp from message: [YYYY-MM-DD HH:MM:SS] ...
    msg_timestamp=$(printf '%s' "$line" | sed -n 's/^\[\([^]]*\)\].*/\1/p')
    
    if [ -n "$msg_timestamp" ]; then
      # Send message if it's >= since_timestamp (lexicographic comparison works for ISO format)
      # This covers: messages during connection window + same-second messages
      if [ "$msg_timestamp" \> "$since_timestamp" ] || [ "$msg_timestamp" = "$since_timestamp" ]; then
        send_sse_event message "$line"
      fi
    fi
  done
fi

# Send initial member list
query="room=$room"
members_output=$(QUERY_STRING="$query" chat-list-avatars 2>&1)
members_output=$(printf '%s' "$members_output" | tr -d '\r')
members_json=$(printf '%s' "$members_output" | sed -n '/^$/,$ p' | tail -n +2)
if [ -z "$members_json" ] || ! printf '%s' "$members_json" | grep -q '^{'; then
  members_json='{"avatars":[]}'
fi
send_sse_event members "$members_json"

# Event-driven monitoring using tail -f + file descriptor approach
# EXPERIMENTAL: Testing if FD redirection avoids subshell buffering

connection_start=$(date +%s)
last_message_time=$(date +%s)
last_room_mtime=0

# Create FIFO for tail output
fifo="/tmp/chat_stream_$$_fifo"
mkfifo "$fifo" || {
  sse-error 500 "Failed to create communication channel"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
}

# Cleanup function
cleanup() {
  exec 3<&- 2>/dev/null || true
  kill ${tail_pid:-} 2>/dev/null || true
  kill ${keepalive_pid:-} 2>/dev/null || true
  kill ${membership_pid:-} 2>/dev/null || true
  kill ${timeout_pid:-} 2>/dev/null || true
  kill ${health_pid:-} 2>/dev/null || true
  rm -f "${fifo:-}"
  exit
}

trap cleanup INT TERM EXIT

# Ensure LOG_FILE exists for tail -f (creates if missing)
touch "$LOG_FILE"

# Start tail -f writing to FIFO (background, starts from end)
tail -f -n 0 "$LOG_FILE" > "$fifo" &
tail_pid=$!

# Verify tail started successfully
sleep 0.1
if ! kill -0 $tail_pid 2>/dev/null; then
  sse-error 500 "Failed to monitor chat log"
  sleep 0.1  # Ensure output is flushed before exit
  exit 1
fi

# Background subprocess health monitor
# Detects if critical subprocesses die unexpectedly
(
  while true; do
    sleep 10
    # Check if tail process is still running
    if ! kill -0 $tail_pid 2>/dev/null; then
      send_sse_event error "Stream monitor failed - please reconnect"
      kill $$ 2>/dev/null || true
      exit 1
    fi
  done
) &
health_pid=$!

# Background keepalive monitor with health check
(
  while true; do
    sleep "$KEEPALIVE_INTERVAL"
    now=$(date +%s)
    # Only send keepalive if idle > threshold
    if [ $((now - last_message_time)) -ge "$IDLE_THRESHOLD" ]; then
      send_sse_event ping "keepalive"
    fi
  done
) &
keepalive_pid=$!

# Background connection timeout monitor
# Enforces maximum connection duration to prevent resource leaks
(
  sleep "$MAX_CONNECTION_TIME"
  send_sse_event timeout "Connection time limit reached. Please reconnect."
  kill $$ 2>/dev/null || true
) &
timeout_pid=$!

# Background membership monitor (tracks changes in member list)
# Uses sorted member names as signature to detect ANY membership change,
# including simultaneous join/leave (where count stays same but members change)
(
  last_member_signature=""  # Start empty to force initial update
  while true; do
    sleep 2
    if [ -d "$ROOM_DIR" ]; then
      # Build membership signature from sorted avatar directory names
      # This catches count changes AND member changes with same count
      member_list=""
      current_member_count=0
      for avatar_dir in "$ROOM_DIR"/.*; do
        [ -d "$avatar_dir" ] || continue
        avatar_name=$(basename "$avatar_dir")
        case "$avatar_name" in
          .|..|.log) continue ;;
        esac
        member_list="$member_list$avatar_name "
        current_member_count=$((current_member_count + 1))
      done
      
      # Sort names for consistent comparison (handles join/leave order)
      current_member_signature=$(printf '%s' "$member_list" | tr ' ' '\n' | sort | tr '\n' ' ')
      
      # Send update if membership changed (detects count OR member changes)
      if [ "$current_member_signature" != "$last_member_signature" ]; then
        
        # Call chat-list-avatars to get member list
        # Requires wizardry commands in PATH (set up by serve-site)
        query="room=$room"
        members_output=$(QUERY_STRING="$query" chat-list-avatars 2>&1)
        
        # Strip carriage returns (HTTP uses CRLF, not just LF)
        # This ensures blank lines are actually blank for sed matching
        members_output=$(printf '%s' "$members_output" | tr -d '\r')
        
        # Extract JSON body (everything after first blank line)
        members_json=$(printf '%s' "$members_output" | sed -n '/^$/,$ p' | tail -n +2)
        
        # Validate JSON
        if [ -z "$members_json" ] || ! printf '%s' "$members_json" | grep -q '^{'; then
          members_json='{"avatars":[]}'
        fi
        
        send_sse_event members "$members_json"
        last_member_signature=$current_member_signature
      fi
    fi
  done
) &
membership_pid=$!

# Open FIFO as file descriptor 3 in MAIN shell (critical!)
exec 3< "$fifo"

# Event loop: Read from FD 3 - testing if this stays in main shell
# If this works, no subshell = no buffering = instant delivery!
while IFS= read -r line <&3; do
  send_sse_event message "$line"
  last_message_time=$(date +%s)
done

cleanup
