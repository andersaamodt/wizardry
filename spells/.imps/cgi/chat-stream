#!/bin/sh
# chat-stream - SSE endpoint for real-time chat messages (VERSION: 2026-01-30-v3)
# Streams chat messages as Server-Sent Events
# Accepts query parameter: room=ROOM&since=TIMESTAMP
set -eu

# CRITICAL: Unbuffer output for real-time SSE
# Try multiple methods in order of preference
if [ "${UNBUFFERED:-}" != "1" ]; then
  export UNBUFFERED=1
  
  # Method 1: Python unbuffered mode (most reliable on macOS)
  if command -v python3 >/dev/null 2>&1; then
    printf '[chat-stream] Using Python unbuffered wrapper\n' >&2
    exec python3 -u -c 'import sys, os; os.execvp(sys.argv[1], sys.argv[1:])' "$0" "$@"
  # Method 2: Perl autoflush (fallback)
  elif command -v perl >/dev/null 2>&1; then
    printf '[chat-stream] Using Perl autoflush wrapper\n' >&2
    exec perl -e 'use IO::Handle; STDOUT->autoflush(1); STDERR->autoflush(1); exec @ARGV' "$0" "$@"
  else
    printf '[chat-stream] WARNING: No unbuffering available, output may be delayed\n' >&2
    # Continue without unbuffering
  fi
fi

# Diagnostic logging to stderr (appears in web server error log)
printf '[chat-stream] ========== SCRIPT STARTED (VERSION: 2026-01-30-v3) ==========\n' >&2
printf '[chat-stream] UNBUFFERED=%s (should be 1 if wrapper worked)\n' "${UNBUFFERED:-NOT SET}" >&2
printf '[chat-stream] Script location: %s\n' "$0" >&2
printf '[chat-stream] PWD: %s\n' "$(pwd)" >&2
printf '[chat-stream] QUERY_STRING: %s\n' "${QUERY_STRING:-}" >&2

# Start SSE stream
printf '[chat-stream] Calling sse-start...\n' >&2
sse-start
printf '[chat-stream] sse-start completed successfully\n' >&2

# Parse room name from query string
printf '[chat-stream] Parsing room name from query string...\n' >&2
room_name="${QUERY_STRING:-}"
room_name=$(printf '%s' "$room_name" | sed 's/.*room=\([^&]*\).*/\1/')
printf '[chat-stream] After extracting: "%s"\n' "$room_name" >&2
room_name=$(url-decode "$room_name" || printf '%s' "$room_name")
printf '[chat-stream] After decoding: "%s"\n' "$room_name" >&2
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
printf '[chat-stream] After trim: "%s"\n' "$room_name" >&2

# Validate room name to prevent directory traversal
# Allow only alphanumeric, dash, underscore, and space
printf '[chat-stream] Validating room name...\n' >&2
if ! printf '%s' "$room_name" | grep -q '^[a-zA-Z0-9_ -]\+$'; then
  printf '[chat-stream] ERROR: Invalid room name: "%s"\n' "$room_name" >&2
  sse-event error "Invalid room name"
  exit 0
fi
printf '[chat-stream] Room name validation passed\n' >&2

# Parse optional 'since' timestamp from query string
since_timestamp=""
if printf '%s' "${QUERY_STRING:-}" | grep -q 'since='; then
  since_timestamp=$(printf '%s' "${QUERY_STRING:-}" | sed 's/.*since=\([^&]*\).*/\1/')
  since_timestamp=$(url-decode "$since_timestamp" || printf '%s' "$since_timestamp")
  since_timestamp=$(printf '%s' "$since_timestamp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
fi

if [ -z "$room_name" ]; then
  printf '[chat-stream] ERROR: Room name is empty\n' >&2
  sse-event error "No room specified"
  exit 0
fi
printf '[chat-stream] Room name is non-empty: "%s"\n' "$room_name" >&2

# Chat rooms directory - use site-specific location
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
CHAT_DIR="$SITES_DIR/.sitedata/$site_id/chatrooms"
ROOM_DIR="$CHAT_DIR/$room_name"
LOG_FILE="$ROOM_DIR/.log"

printf '[chat-stream] Directory configuration:\n' >&2
printf '[chat-stream]   SITES_DIR: %s\n' "$SITES_DIR" >&2
printf '[chat-stream]   site_id: %s\n' "$site_id" >&2
printf '[chat-stream]   CHAT_DIR: %s\n' "$CHAT_DIR" >&2
printf '[chat-stream]   ROOM_DIR: %s\n' "$ROOM_DIR" >&2
printf '[chat-stream]   LOG_FILE: %s\n' "$LOG_FILE" >&2

if [ ! -d "$ROOM_DIR" ]; then
  printf '[chat-stream] ERROR: Room directory does not exist\n' >&2
  sse-event error "Room not found"
  exit 0
fi
printf '[chat-stream] Room directory exists\n' >&2

# Send initial batch of messages
printf '[chat-stream] Checking for initial messages...\n' >&2
if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
  printf '[chat-stream] Log file exists and is non-empty\n' >&2
  # If since timestamp provided, filter messages after that timestamp
  if [ -n "$since_timestamp" ]; then
    # Filter messages that come after the 'since' timestamp
    # Format: [YYYY-MM-DD HH:MM:SS] username: message
    # Compare timestamps lexicographically (works for ISO format)
    tail -200 "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
      # Extract timestamp from line
      msg_timestamp=$(printf '%s' "$line" | sed 's/^\[\([^]]*\)\].*/\1/')
      
      # Use string comparison (timestamps are in sortable format)
      # Only send messages strictly after the 'since' timestamp
      if [ "$msg_timestamp" '>' "$since_timestamp" ]; then
        sse-event message "$line"
      fi
    done
  else
    # Send last 200 messages if no 'since' provided
    tail -200 "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
      sse-event message "$line"
    done
  fi
  
  # Record the last line count for tracking new messages
  last_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
  printf '[chat-stream] Sent initial messages (last_line_count=%s)\n' "$last_line_count" >&2
else
  # No messages yet
  printf '[chat-stream] No log file or empty, sending empty event\n' >&2
  sse-event empty "No messages yet"
  last_line_count=0
fi

# Function to escape JSON strings
json_escape() {
  # Escape backslashes, quotes, and control characters for JSON
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' ' | sed 's/ *$//'
}

# Function to get current member list as JSON
get_member_list() {
  room_dir="$1"
  printf '['
  first=1
  for avatar_dir in "$room_dir"/.*; do
    [ -d "$avatar_dir" ] || continue
    avatar_name=$(basename "$avatar_dir")
    
    # Skip . and .. and .log
    case "$avatar_name" in
      .|..|.log) continue ;;
    esac
    
    # Check if it's a web avatar
    is_web="false"
    if get-attribute "user.web_avatar" "$avatar_dir" >/dev/null 2>&1; then
      is_web="true"
    fi
    
    # Remove leading dot from username and escape for JSON
    username=$(printf '%s' "$avatar_name" | sed 's/^\.//')
    username_escaped=$(json_escape "$username")
    
    if [ "$first" -eq 1 ]; then
      first=0
    else
      printf ', '
    fi
    
    printf '{"username": "%s", "is_web": %s}' "$username_escaped" "$is_web"
  done
  printf ']'
}

# Send initial member list
printf '[chat-stream] Getting initial member list...\n' >&2
initial_members=$(get_member_list "$ROOM_DIR")
printf '[chat-stream] Initial members: %s\n' "$initial_members" >&2
sse-event members "$initial_members"
last_members="$initial_members"
printf '[chat-stream] Sent initial member list\n' >&2

# Keep connection alive and stream new messages and member updates
# Poll the log file and room directory for changes every 1 second
# Exit if output fails (client disconnected)
heartbeat_counter=0
max_idle_time=60  # Exit after 1 minute of no activity (reduced from 5 minutes)
idle_counter=0
loop_count=0

printf '[chat-stream] ===== ENTERING MAIN LOOP =====\n' >&2

while true; do
  sleep 1
  loop_count=$((loop_count + 1))
  
  # Log every 10 iterations
  if [ $((loop_count % 10)) -eq 0 ]; then
    printf '[chat-stream] Loop iteration %d (idle=%d, heartbeat=%d)\n' "$loop_count" "$idle_counter" "$heartbeat_counter" >&2
  fi
  
  # Check if log file has new lines
  if [ -f "$LOG_FILE" ]; then
    current_line_count=$(wc -l < "$LOG_FILE" 2>/dev/null || echo "0")
    
    if [ "$current_line_count" -gt "$last_line_count" ]; then
      # New messages available - send them
      new_message_count=$((current_line_count - last_line_count))
      printf '[chat-stream] Found %d new messages\n' "$new_message_count" >&2
      tail -n "$new_message_count" "$LOG_FILE" | while IFS= read -r line || [ -n "$line" ]; do
        sse-event message "$line" || exit 0  # Exit if output fails
      done
      last_line_count=$current_line_count
      heartbeat_counter=0  # Reset heartbeat counter
      idle_counter=0  # Reset idle counter
    else
      idle_counter=$((idle_counter + 1))
    fi
  else
    idle_counter=$((idle_counter + 1))
  fi
  
  # Check for member list changes
  current_members=$(get_member_list "$ROOM_DIR")
  if [ "$current_members" != "$last_members" ]; then
    printf '[chat-stream] Member list changed\n' >&2
    sse-event members "$current_members" || exit 0
    last_members="$current_members"
    idle_counter=0  # Reset idle counter
  fi
  
  # Exit if idle for too long
  if [ "$idle_counter" -ge "$max_idle_time" ]; then
    printf '[chat-stream] Idle timeout reached (%d seconds), exiting\n' "$idle_counter" >&2
    exit 0
  fi
  
  # Send heartbeat comment every 10 seconds to keep connection alive
  # This also serves as broken pipe detection
  heartbeat_counter=$((heartbeat_counter + 1))
  if [ "$heartbeat_counter" -ge 10 ]; then
    printf '[chat-stream] Sending heartbeat\n' >&2
    if ! printf ': heartbeat\n\n'; then
      # Output failed - client disconnected
      printf '[chat-stream] Heartbeat failed (broken pipe), exiting\n' >&2
      exit 0
    fi
    heartbeat_counter=0
  fi
done
