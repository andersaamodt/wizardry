#!/bin/sh
# drag-drop-upload - Handle drag-and-drop file uploads with auto-display

# Don't use set -eu to avoid silent failures
set -u

# Only handle POST requests
if [ "${REQUEST_METHOD:-}" != "POST" ]; then
  http-status 405 "Method Not Allowed"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p>Only POST requests allowed</p>\n'
  exit 0
fi

# Determine site-specific data directory
# Use WIZARDRY_SITE_NAME if available (set by nginx), otherwise default
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  # Fallback for non-nginx environments
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
SITE_DATA_DIR="$SITES_DIR/.sitedata/$site_id"
UPLOAD_DIR="$SITE_DATA_DIR/uploads"

# Create uploads directory if needed
mkdir -p "$UPLOAD_DIR" || {
  http-status 500 "Internal Server Error"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p class="error">Failed to create upload directory</p>\n'
  exit 1
}

# Read multipart boundary from Content-Type header
boundary=$(printf '%s' "${CONTENT_TYPE:-}" | sed 's/.*boundary=//')

if [ -z "$boundary" ]; then
  http-status 400 "Bad Request"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p class="error">No boundary found in Content-Type</p>\n'
  exit 0
fi

# Save uploaded content to temp file
temp_file=$(mktemp "${TMPDIR:-/tmp}/drag-upload.XXXXXX")
cat > "$temp_file"

# Extract filename from Content-Disposition header
content_disp=$(grep -a "Content-Disposition" "$temp_file" | head -1)
filename=$(printf '%s' "$content_disp" | sed 's/.*filename="//' | sed 's/".*//')
filename=$(url-decode "$filename" 2>/dev/null || \
  printf '%s' "$filename" | sed 's/+/ /g;s/%20/ /g')
if [ -z "$filename" ]; then
  filename="upload"
fi

# Remove any Windows-style paths (strip everything up to last backslash or forward slash)
filename=$(printf '%s' "$filename" | sed 's/.*[\\\/]//')

# Sanitize filename - remove path components and keep only safe characters
filename=$(basename "$filename" | sed 's/[^a-zA-Z0-9._-]/_/g')

# Generate unique filename with timestamp
timestamp=$(date +%Y-%m-%d-%H%M%S)
save_name="${timestamp}-${filename}"
save_path="$UPLOAD_DIR/$save_name"

# Extract file data - use a more reliable binary-safe approach
# The multipart data has this structure:
# --boundary
# Content-Disposition: form-data; name="file"; filename="..."
# Content-Type: ...
# <blank line>
# <binary data>
# --boundary--

# Use perl for binary-safe extraction
if command -v perl >/dev/null 2>&1; then
  # Binary-safe perl script that reads entire file
  perl -e '
    use strict;
    binmode STDIN;
    binmode STDOUT;
    
    my $boundary = $ARGV[0];
    my $content = do { local $/; <STDIN> };
    
    # Find Content-Type header followed by blank line
    if ($content =~ /Content-Type:[^\r\n]*\r?\n\r?\n/s) {
      my $pos = $+[0];  # Position after the blank line
      
      # Find the closing boundary (could be \r\n-- or just \n--)
      my $end_marker1 = "\r\n--" . $boundary;
      my $end_marker2 = "\n--" . $boundary;
      
      my $data_end = index($content, $end_marker1, $pos);
      if ($data_end == -1) {
        $data_end = index($content, $end_marker2, $pos);
      }
      
      if ($data_end > $pos) {
        # Extract the binary data
        my $data = substr($content, $pos, $data_end - $pos);
        print $data;
      }
    }
  ' "$boundary" < "$temp_file" > "$save_path"
else
  # Fallback: Use dd with byte offsets if perl not available
  # Find byte position after Content-Type header and blank line
  header_end=$(grep -abo "Content-Type:" "$temp_file" | head -1 | cut -d: -f1)
  if [ -n "$header_end" ]; then
    # Find the first empty line after Content-Type
    skip_bytes=$((header_end + 1))
    data_start=$(tail -c +$skip_bytes "$temp_file" | \
      grep -abo $'^\r$' | head -1 | cut -d: -f1)
    if [ -z "$data_start" ]; then
      data_start=$(tail -c +$skip_bytes "$temp_file" | \
        grep -abo '^$' | head -1 | cut -d: -f1)
    fi
    
    if [ -n "$data_start" ]; then
      # Calculate absolute position
      abs_start=$((header_end + data_start + 2))
      
      # Find boundary end position
      boundary_pos=$(grep -abo -- "--$boundary" "$temp_file" | \
        tail -1 | cut -d: -f1)
      
      if [ -n "$boundary_pos" ] && [ "$boundary_pos" -gt "$abs_start" ]; then
        # Extract data
        data_length=$((boundary_pos - abs_start - 2))
        dd if="$temp_file" of="$save_path" bs=1 \
          skip="$abs_start" count="$data_length" 2>/dev/null
      else
        touch "$save_path"
      fi
    else
      touch "$save_path"
    fi
  else
    touch "$save_path"
  fi
fi

# Detect MIME type
mime_type="application/octet-stream"
if command -v file >/dev/null 2>&1; then
  mime_type=$(file --mime-type -b "$save_path" 2>/dev/null || echo "application/octet-stream")
fi

# Get file size
file_size=$(wc -c < "$save_path" | tr -d ' ')

# Generate download URL - use relative path to uploaded file
download_url="/uploads/$save_name"

# Also show the full server path for reference
server_path="$UPLOAD_DIR/$save_name"

# Generate appropriate display HTML based on MIME type
display_html=""
case "$mime_type" in
  image/*)
    img_style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;"
    display_html="<img src=\"$download_url\" alt=\"Uploaded image\" style=\"$img_style\">"
    ;;
  video/*)
    video_style="max-width: 100%; height: auto;"
    display_html="<video controls style=\"$video_style\">"
    display_html="$display_html<source src=\"$download_url\" type=\"$mime_type\">"
    display_html="${display_html}Your browser doesn't support video.</video>"
    ;;
  audio/*)
    audio_style="width: 100%;"
    display_html="<audio controls style=\"$audio_style\">"
    display_html="$display_html<source src=\"$download_url\" type=\"$mime_type\">"
    display_html="${display_html}Your browser doesn't support audio.</audio>"
    ;;
  application/pdf)
    pdf_style="border: 1px solid #ddd;"
    display_html="<embed src=\"$download_url\" type=\"application/pdf\" "
    display_html="${display_html}width=\"100%\" height=\"600px\" style=\"$pdf_style\">"
    ;;
  text/*)
    # For text files, read and display content
    content=$(cat "$save_path" | head -c 10000)
    escaped=$(printf '%s' "$content" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
    pre_style="background: #f5f5f5; padding: 1em; border-radius: 4px; overflow-x: auto;"
    display_html="<pre style=\"$pre_style\">$escaped</pre>"
    ;;
  *)
    display_html="<p><em>Preview not available for this file type ($mime_type)</em></p>"
    ;;
esac

# Clean up temp file
rm -f "$temp_file"

# Return success response
http-status 200 "OK"
http-header "Content-Type" "text/html"
http-end-headers
# Styles for HTML output
info_style="background: #f8f9fa; padding: 0.75em; border-radius: 4px; margin: 1em 0;"
display_style="margin: 1em 0; padding: 1em; border: 1px solid #ddd;"
display_style="$display_style border-radius: 4px; background: white;"
link_style="display: inline-block; padding: 0.5em 1em; background: #007bff;"
link_style="$link_style color: white; text-decoration: none; border-radius: 4px;"

cat <<HTML
<div class="upload-result">
  <h4 style="color: #28a745; margin-top: 0;">✓ Upload Successful!</h4>
  
  <div class="file-info" style="$info_style">
    <p style="margin: 0.25em 0;"><strong>Filename:</strong> $filename</p>
    <p style="margin: 0.25em 0;"><strong>Type:</strong> $mime_type</p>
    <p style="margin: 0.25em 0;"><strong>Size:</strong> $file_size bytes</p>
    <p style="margin: 0.25em 0;"><strong>Location:</strong> $server_path</p>
  </div>
  
  <div class="file-display" style="$display_style">
    $display_html
  </div>
  
  <p style="margin-top: 1em;">
    <a href="$download_url" download="$filename" style="$link_style">
      ⬇ Download File
    </a>
  </p>
</div>
HTML
