#!/bin/sh
# drag-drop-upload - Handle drag-and-drop file uploads with auto-display

# Don't use set -eu to avoid silent failures
set -u

# Only handle POST requests
if [ "${REQUEST_METHOD:-}" != "POST" ]; then
  http-status 405 "Method Not Allowed"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p>Only POST requests allowed</p>\n'
  exit 0
fi

# Determine site-specific data directory
# Use WIZARDRY_SITE_NAME if available (set by nginx), otherwise default
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  # Fallback for non-nginx environments
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
SITE_DATA_DIR="$SITES_DIR/.sitedata/$site_id"
UPLOAD_DIR="$SITE_DATA_DIR/uploads"

# Create uploads directory if needed
mkdir -p "$UPLOAD_DIR" || {
  http-status 500 "Internal Server Error"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p class="error">Failed to create upload directory</p>\n'
  exit 1
}

# Read multipart boundary from Content-Type header
boundary=$(printf '%s' "${CONTENT_TYPE:-}" | sed 's/.*boundary=//')

if [ -z "$boundary" ]; then
  http-status 400 "Bad Request"
  http-header "Content-Type" "text/html"
  http-end-headers
  printf '<p class="error">No boundary found in Content-Type</p>\n'
  exit 0
fi

# Save uploaded content to temp file
temp_file=$(mktemp "${TMPDIR:-/tmp}/drag-upload.XXXXXX")
cat > "$temp_file"

# Extract filename from Content-Disposition header
content_disp=$(grep -a "Content-Disposition" "$temp_file" | head -1)
filename=$(printf '%s' "$content_disp" | sed 's/.*filename="//' | sed 's/".*//')
filename=$(url-decode "$filename" 2>/dev/null || \
  printf '%s' "$filename" | sed 's/+/ /g;s/%20/ /g')
if [ -z "$filename" ]; then
  filename="upload"
fi

# Remove any Windows-style paths (strip everything up to last backslash or forward slash)
filename=$(printf '%s' "$filename" | sed 's/.*[\\\/]//')

# Sanitize filename - remove path components and keep only safe characters
filename=$(basename "$filename" | sed 's/[^a-zA-Z0-9._-]/_/g')

# Generate unique filename with timestamp
timestamp=$(date +%Y-%m-%d-%H%M%S)
save_name="${timestamp}-${filename}"
save_path="$UPLOAD_DIR/$save_name"

# Extract file data - use a more reliable binary-safe approach
# The multipart data has this structure:
# --boundary
# Content-Disposition: form-data; name="file"; filename="..."
# Content-Type: ...
# <blank line>
# <binary data>
# --boundary--

# Find where the actual file data starts (after the blank line following headers)
# Look for the pattern of two consecutive line breaks (empty line)
# We need to find the Content-Type line first, then the empty line after it

# Method: Find all occurrences of double newline and take the first one after headers
# Use perl for better binary handling
if command -v perl >/dev/null 2>&1; then
  # Use perl to extract binary data between headers and boundary
  perl -ne '
    BEGIN { binmode STDIN; binmode STDOUT; }
    if (!$in_data && /^Content-Type:/i) { $found_ct = 1; }
    if ($found_ct && /^[\r\n]*$/) { $in_data = 1; next; }
    if ($in_data) {
      if (/^--'"$boundary"'/) { exit; }
      print;
    }
  ' < "$temp_file" > "$save_path"
else
  # Fallback: simpler approach using awk
  # Find the first empty line after Content-Type, then extract until boundary
  awk -v RS= -v boundary="$boundary" '
    NR > 1 {
      data = $0
      # Remove the final boundary marker
      sub("--" boundary ".*", "", data)
      # Print without trailing newlines
      printf "%s", data
      exit
    }
  ' "$temp_file" > "$save_path"
fi

# Detect MIME type
mime_type="application/octet-stream"
if command -v file >/dev/null 2>&1; then
  mime_type=$(file --mime-type -b "$save_path" 2>/dev/null || echo "application/octet-stream")
fi

# Get file size
file_size=$(wc -c < "$save_path" | tr -d ' ')

# Generate download URL - use relative path to uploaded file
download_url="/uploads/$save_name"

# Also show the full server path for reference
server_path="$UPLOAD_DIR/$save_name"

# Generate appropriate display HTML based on MIME type
display_html=""
case "$mime_type" in
  image/*)
    img_style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;"
    display_html="<img src=\"$download_url\" alt=\"Uploaded image\" style=\"$img_style\">"
    ;;
  video/*)
    video_style="max-width: 100%; height: auto;"
    display_html="<video controls style=\"$video_style\">"
    display_html="$display_html<source src=\"$download_url\" type=\"$mime_type\">"
    display_html="${display_html}Your browser doesn't support video.</video>"
    ;;
  audio/*)
    audio_style="width: 100%;"
    display_html="<audio controls style=\"$audio_style\">"
    display_html="$display_html<source src=\"$download_url\" type=\"$mime_type\">"
    display_html="${display_html}Your browser doesn't support audio.</audio>"
    ;;
  application/pdf)
    pdf_style="border: 1px solid #ddd;"
    display_html="<embed src=\"$download_url\" type=\"application/pdf\" "
    display_html="${display_html}width=\"100%\" height=\"600px\" style=\"$pdf_style\">"
    ;;
  text/*)
    # For text files, read and display content
    content=$(cat "$save_path" | head -c 10000)
    escaped=$(printf '%s' "$content" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
    pre_style="background: #f5f5f5; padding: 1em; border-radius: 4px; overflow-x: auto;"
    display_html="<pre style=\"$pre_style\">$escaped</pre>"
    ;;
  *)
    display_html="<p><em>Preview not available for this file type ($mime_type)</em></p>"
    ;;
esac

# Clean up temp file
rm -f "$temp_file"

# Return success response
http-status 200 "OK"
http-header "Content-Type" "text/html"
http-end-headers
# Styles for HTML output
info_style="background: #f8f9fa; padding: 0.75em; border-radius: 4px; margin: 1em 0;"
display_style="margin: 1em 0; padding: 1em; border: 1px solid #ddd;"
display_style="$display_style border-radius: 4px; background: white;"
link_style="display: inline-block; padding: 0.5em 1em; background: #007bff;"
link_style="$link_style color: white; text-decoration: none; border-radius: 4px;"

cat <<HTML
<div class="upload-result">
  <h4 style="color: #28a745; margin-top: 0;">✓ Upload Successful!</h4>
  
  <div class="file-info" style="$info_style">
    <p style="margin: 0.25em 0;"><strong>Filename:</strong> $filename</p>
    <p style="margin: 0.25em 0;"><strong>Type:</strong> $mime_type</p>
    <p style="margin: 0.25em 0;"><strong>Size:</strong> $file_size bytes</p>
    <p style="margin: 0.25em 0;"><strong>Location:</strong> $server_path</p>
  </div>
  
  <div class="file-display" style="$display_style">
    $display_html
  </div>
  
  <p style="margin-top: 1em;">
    <a href="$download_url" download="$filename" style="$link_style">
      ⬇ Download File
    </a>
  </p>
</div>
HTML
