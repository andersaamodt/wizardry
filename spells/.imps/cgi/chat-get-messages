#!/bin/sh
# chat-get-messages - Get messages from a chat room
set -eu

http-ok-html

# Parse room name from query string
room_name=$(get-query-param "room")

# Trim whitespace
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

if [ -z "$room_name" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p style="color: #666; font-style: italic;">Select a room to start chatting</p>
</div>
HTML
  exit 0
fi

# Chat rooms directory - use site-specific location
CHAT_DIR=$(get-site-data-dir "chatrooms")
ROOM_DIR="$CHAT_DIR/$room_name"

if [ ! -d "$ROOM_DIR" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p class="demo-result error">Room not found</p>
</div>
HTML
  exit 0
fi

# Run cleanup when viewing room (removes inactive avatars >5 min old)
chat-cleanup-inactive-avatars "$ROOM_DIR" 2>/dev/null || true

# Read messages from .log file (same format as MUD 'say' command)
LOG_FILE="$ROOM_DIR/.log"

if [ ! -f "$LOG_FILE" ] || [ ! -s "$LOG_FILE" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p class="empty-state-message">No messages yet. Be the first to say something!</p>
</div>
HTML
else
  cat <<HTML
<div id="chat-messages" class="chat-display">
HTML
  
  # Build list of MUD avatars (those WITHOUT web_avatar xattr)
  # This is done once before AWK processing for efficiency
  # Default to Verdana for web users (majority); monospace only for active MUD users
  mud_users=""
  for avatar_dir in "$ROOM_DIR"/.*; do
    [ -d "$avatar_dir" ] || continue
    avatar_name=$(basename "$avatar_dir")
    
    # Skip . and .. and .log
    case "$avatar_name" in
      .|..|.log) continue ;;
    esac
    
    # Check if it's NOT a web avatar (i.e., a MUD avatar)
    if ! get-attribute "user.web_avatar" "$avatar_dir" >/dev/null 2>&1; then
      # Remove leading dot from username
      username=$(printf '%s' "$avatar_name" | sed 's/^\.//')
      mud_users="$mud_users:$username:"
    fi
  done
  
  # Display last 200 messages using AWK for performance
  # AWK processes all messages much faster than shell loops
  tail -200 "$LOG_FILE" | awk -v mud_users="$mud_users" '
    function html_escape(str) {
      gsub(/&/, "\\&amp;", str)
      gsub(/</, "\\&lt;", str)
      gsub(/>/, "\\&gt;", str)
      return str
    }
    
    function hash_username(username,    i, hash, char, ascii_val) {
      hash = 0
      for (i = 1; i <= length(username); i++) {
        char = substr(username, i, 1)
        # Simple hash: sum of character positions
        # Using a simpler approach that avoids quote escaping issues
        ascii_val = index("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", char)
        if (ascii_val == 0) ascii_val = length(char)  # Fallback for other chars
        hash += ascii_val * (i + 1)  # Weight by position
      }
      # Use spiral color selection for more distinct colors
      # Map to 12 distinct hues (30 degree steps) instead of 360
      # This gives very distinct colors that are clearly different
      return (hash % 12) * 30
    }
    
    {
      line = html_escape($0)
      
      # Parse format: [YYYY-MM-DD HH:MM:SS] username: message
      # Use standard AWK pattern matching (POSIX compatible)
      if (match(line, /^\[[^]]+\] [^:]+: /)) {
        # Extract full timestamp [YYYY-MM-DD HH:MM:SS]
        full_timestamp = substr(line, 2, index(line, "]") - 2)
        
        # Extract just HH:MM for display
        # Format is "YYYY-MM-DD HH:MM:SS", we want characters 12-16 (HH:MM)
        if (length(full_timestamp) >= 16) {
          timestamp = substr(full_timestamp, 12, 5)
        } else {
          # Fallback for old format or malformed timestamps
          timestamp = full_timestamp
        }
        
        # Extract rest after "] "
        rest = substr(line, index(line, "]") + 2)
        
        # Extract username (everything before first ":")
        colon_pos = index(rest, ":")
        username = substr(rest, 1, colon_pos - 1)
        
        # Extract message (everything after ": ")
        message = substr(rest, colon_pos + 2)
        
        # Check if this is a system message (from "log")
        if (username == "log") {
          # System message - style as grey, centered, small text, no bubble
          printf "  <div class=\"chat-msg-system\">%s</div>\n", message
        } else {
          # Regular message
          # Generate color from username hash
          hue = hash_username(username)
          color = sprintf("hsl(%d, 70%%, 35%%)", hue)
          
          # Determine font based on whether user is MUD user
          # Default to Verdana (web users are majority); monospace only for active MUD users
          # Check if username is in mud_users list (format ":username:")
          is_mud = index(mud_users, ":" username ":")
          font_family = is_mud ? "Courier New, Courier, monospace" : "Verdana, sans-serif"
          
          # Output with timestamp in bottom-right corner, include full timestamp as data attribute
          printf "  <div class=\"chat-msg\" style=\"font-family: %s;\"><span class=\"username\" style=\"color: %s; font-weight: bold;\">%s:</span> %s<span class=\"timestamp\" data-full-timestamp=\"%s\" title=\"%s\">%s</span></div>\n", \
            font_family, color, username, message, full_timestamp, full_timestamp, timestamp
        }
      } else {
        # No username found, display as-is
        printf "  <div class=\"chat-msg\">%s</div>\n", line
      }
    }
  '
  
  cat <<HTML
</div>
HTML
fi
