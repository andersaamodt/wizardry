#!/bin/sh
# chat-get-messages - Get messages from a chat room
set -eu

http-status 200 "OK"
http-header "Content-Type" "text/html"
http-end-headers

# Parse room name from query string
room_name="${QUERY_STRING:-}"
room_name=$(printf '%s' "$room_name" | sed 's/room=//' | sed 's/&.*//')
room_name=$(url-decode "$room_name" || printf '%s' "$room_name")

# Trim whitespace
room_name=$(printf '%s' "$room_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

if [ -z "$room_name" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p style="color: #666; font-style: italic;">Select a room to start chatting</p>
</div>
HTML
  exit 0
fi

# Chat rooms directory - use site-specific location
# Use WIZARDRY_SITE_NAME if available (set by nginx), otherwise default
if [ -n "${WIZARDRY_SITE_NAME:-}" ]; then
  site_id="$WIZARDRY_SITE_NAME"
else
  site_id="default"
fi
SITES_DIR="${WIZARDRY_SITES_DIR:-$HOME/sites}"
CHAT_DIR="$SITES_DIR/.sitedata/$site_id/chatrooms"
ROOM_DIR="$CHAT_DIR/$room_name"

if [ ! -d "$ROOM_DIR" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p class="demo-result error">Room not found</p>
</div>
HTML
  exit 0
fi

# Run cleanup when viewing room (removes inactive avatars >30 min old)
# Log that cleanup was called
printf '[%s] chat-get-messages: calling cleanup for %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" "$ROOM_DIR" >> /tmp/chat-cleanup-calls.log 2>/dev/null || true
chat-cleanup-inactive-avatars "$ROOM_DIR" 2>/dev/null || true

# Read messages from .log file (same format as MUD 'say' command)
LOG_FILE="$ROOM_DIR/.log"

if [ ! -f "$LOG_FILE" ] || [ ! -s "$LOG_FILE" ]; then
  cat <<HTML
<div id="chat-messages" class="chat-display">
  <p class="empty-state-message">No messages yet. Be the first to say something!</p>
</div>
HTML
else
  cat <<HTML
<div id="chat-messages" class="chat-display">
HTML
  
  # Build list of web avatars by checking xattr
  # This is done once before AWK processing for efficiency
  web_users=""
  for avatar_dir in "$ROOM_DIR"/.*; do
    [ -d "$avatar_dir" ] || continue
    avatar_name=$(basename "$avatar_dir")
    
    # Skip . and .. and .log
    case "$avatar_name" in
      .|..|.log) continue ;;
    esac
    
    # Check if it's a web avatar
    if get-attribute "user.web_avatar" "$avatar_dir" >/dev/null 2>&1; then
      # Remove leading dot from username
      username=$(printf '%s' "$avatar_name" | sed 's/^\.//')
      web_users="$web_users:$username:"
    fi
  done
  
  # Display last 200 messages using AWK for performance
  # AWK processes all messages much faster than shell loops
  tail -200 "$LOG_FILE" | awk -v web_users="$web_users" '
    function html_escape(str) {
      gsub(/&/, "\\&amp;", str)
      gsub(/</, "\\&lt;", str)
      gsub(/>/, "\\&gt;", str)
      return str
    }
    
    function hash_username(username,    i, hash, char, ascii_val) {
      hash = 0
      for (i = 1; i <= length(username); i++) {
        char = substr(username, i, 1)
        # Simple hash: sum of character positions
        # Using a simpler approach that avoids quote escaping issues
        ascii_val = index("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", char)
        if (ascii_val == 0) ascii_val = length(char)  # Fallback for other chars
        hash += ascii_val * (i + 1)  # Weight by position
      }
      # Use spiral color selection for more distinct colors
      # Map to 12 distinct hues (30 degree steps) instead of 360
      # This gives very distinct colors that are clearly different
      return (hash % 12) * 30
    }
    
    {
      line = html_escape($0)
      
      # Parse format: [YYYY-MM-DD HH:MM:SS] username: message
      # Use standard AWK pattern matching (POSIX compatible)
      if (match(line, /^\[[^]]+\] [^:]+: /)) {
        # Extract full timestamp [YYYY-MM-DD HH:MM:SS]
        full_timestamp = substr(line, 2, index(line, "]") - 2)
        
        # Extract just HH:MM for display
        # Format is "YYYY-MM-DD HH:MM:SS", we want characters 12-16 (HH:MM)
        if (length(full_timestamp) >= 16) {
          timestamp = substr(full_timestamp, 12, 5)
        } else {
          # Fallback for old format or malformed timestamps
          timestamp = full_timestamp
        }
        
        # Extract rest after "] "
        rest = substr(line, index(line, "]") + 2)
        
        # Extract username (everything before first ":")
        colon_pos = index(rest, ":")
        username = substr(rest, 1, colon_pos - 1)
        
        # Extract message (everything after ": ")
        message = substr(rest, colon_pos + 2)
        
        # Generate color from username hash
        hue = hash_username(username)
        color = sprintf("hsl(%d, 70%%, 35%%)", hue)
        
        # Determine font based on whether user is web user
        # Check if username is in web_users list (format ":username:")
        is_web = index(web_users, ":" username ":")
        font_family = is_web ? "Verdana, sans-serif" : "Courier New, Courier, monospace"
        
        # Output with timestamp in bottom-right corner, include full timestamp as data attribute
        printf "  <div class=\"chat-msg\" style=\"font-family: %s;\"><span class=\"username\" style=\"color: %s; font-weight: bold;\">%s:</span> %s<span class=\"timestamp\" data-full-timestamp=\"%s\" title=\"%s\">%s</span></div>\n", \
          font_family, color, username, message, full_timestamp, full_timestamp, timestamp
      } else {
        # No username found, display as-is
        printf "  <div class=\"chat-msg\">%s</div>\n", line
      }
    }
  '
  
  cat <<HTML
</div>
HTML
fi
