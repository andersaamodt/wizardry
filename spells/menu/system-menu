#!/bin/sh

# This spell displays system maintenance tasks.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . system-menu    OR    system menu    (via parse/gloss)

Displays the system maintenance menu.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  return 0 2>/dev/null || return 0
  ;;
esac

# Uncastable pattern - detect if sourced
system_menu_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) system_menu_sourced=1 ;;
  esac
else
  system_menu_base=${0##*/}
  case "$system_menu_base" in
    sh|dash|bash|zsh|ksh|mksh) system_menu_sourced=1 ;;
    system-menu) system_menu_sourced=0 ;;
    parse) system_menu_sourced=1 ;;  # Sourced via parse
    *) system_menu_sourced=1 ;;
  esac
fi

if [ "$system_menu_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . system-menu  OR  system menu" >&2
  return 1 2>/dev/null || return 1
fi
unset system_menu_sourced system_menu_base

set +e  # Permissive mode since we're in user's shell
set -u

. env-clear
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
spells_dir=$(dirname "$script_dir")
repo_dir=$(dirname "$spells_dir")

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The system menu needs the 'menu' command to present options."; then
  return 1
fi

# Detect whether we are running on NixOS to offer system-specific actions.
nixos_rebuild=""
if has detect-distro && [ "$(detect-distro 2>/dev/null)" = "nixos" ]; then
  nixos_rebuild="Rebuild NixOS%sudo nixos-rebuild switch"
fi

system_menu_display_menu() {
  restart_menu="Restart...%shutdown-menu"
  services="Manage services%services-menu"
  verify_posix="Verify POSIX spells%verify-posix"
  update_wizardry="Update wizardry%update-wizardry"
  test_suite="Test all wizardry spells%test-magic"
  profile_tests="Profile test performance%profile-tests"
  update_all="Update all software%update-all -v"
  uninstall_wizardry="Uninstall wizardry%$repo_dir/.uninstall; return 0"
  exit_label=$(exit-label)
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$restart_menu" "$update_all" "$update_wizardry" "$services"
  if [ -n "$nixos_rebuild" ]; then
    set -- "$@" "$nixos_rebuild"
  fi
  set -- "$@" "$verify_posix" "$test_suite" "$profile_tests" "$uninstall_wizardry" "$exit_item"

  menu "System Menu:" "$@" || system_menu_status=$?
  return "${system_menu_status:-0}"
}

# Catch Ctrl-C and TERM signal to return 1 cleanly
trap 'return 0' INT TERM

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    :
  else
    first_run=0
  fi

  system_menu_display_menu || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC kills this menu script via TERM signal (same as Exit button)
  # Direct kill: kill -TERM $$ → kills this script
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    kill -TERM $$ 2>/dev/null || true
    return 0
  fi
done
