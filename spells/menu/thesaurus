#!/bin/sh
# This spell displays a menu for managing synonyms (aliases).
# Use --list for view-only mode, otherwise includes add and toggle options.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: thesaurus [--list]

Display management menu for synonyms (aliases).

Options:
  --list    View-only mode (no add/edit options)
  --help    Show this help message
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

  
  # Catch Ctrl-C and TERM signal to return cleanly
  trap 'exit 0' INT TERM
  
  if ! require menu "The thesaurus menu needs the 'menu' command."; then
    exit 1
  fi
  
  # Check for --list flag
  list_mode=0
  case "${1-}" in
    --list)
      list_mode=1
      shift
      ;;
  esac
  
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  custom_file="$spell_home/.synonyms"
  default_file="$spell_home/.default-synonyms"
  synonyms_enabled_file="$spell_home/.synonyms-enabled"
  
  # Ensure spellbook directory exists
  if [ ! -d "$spell_home" ]; then
    mkdir -p "$spell_home" 2>/dev/null || true
  fi
  
  # Initialize defaults if needed (invoke-thesaurus handles this)
  if [ ! -f "$spell_home/.default-synonyms-initialized" ]; then
    # Source invoke-thesaurus to initialize defaults
    # This is safe in a non-interactive context
    _invoke_thes="$_i/invoke-thesaurus"
    if [ -f "$_invoke_thes" ]; then
      # shellcheck disable=SC1090,SC1091
      . "$_invoke_thes" 2>/dev/null || :
    fi
  fi
  
  # If --list mode, print flat list and exit
  if [ "$list_mode" -eq 1 ]; then
    # Print custom synonyms first
    if [ -f "$custom_file" ]; then
      while IFS= read -r line; do
        # Skip comments and empty lines
        case $line in
          \#*|'') continue ;;
        esac
        
        # Parse alias definition: alias word='spell'
        if printf '%s' "$line" | grep -q "^alias "; then
          synonym_word=$(printf '%s' "$line" | sed "s/^alias \\([^=]*\\)=.*$/\\1/")
          target_spell=$(printf '%s' "$line" | sed "s/^alias [^=]*='\\(.*\\)'$/\\1/")
          target_spell=$(printf '%s' "$target_spell" | sed "s/'\\\\''/'/g")
          
          if [ -n "$synonym_word" ] && [ -n "$target_spell" ]; then
            printf '%s → %s\n' "$synonym_word" "$target_spell"
          fi
        fi
      done < "$custom_file"
    fi
    
    # Print default synonyms
    if [ -f "$default_file" ]; then
      while IFS= read -r line; do
        # Skip comments and empty lines
        case $line in
          \#*|'') continue ;;
        esac
        
        # Parse alias definition: alias word='spell'
        if printf '%s' "$line" | grep -q "^alias "; then
          synonym_word=$(printf '%s' "$line" | sed "s/^alias \\([^=]*\\)=.*$/\\1/")
          target_spell=$(printf '%s' "$line" | sed "s/^alias [^=]*='\\(.*\\)'$/\\1/")
          target_spell=$(printf '%s' "$target_spell" | sed "s/'\\\\''/'/g")
          
          if [ -n "$synonym_word" ] && [ -n "$target_spell" ]; then
            # Check if this default is overridden by a custom synonym
            is_overridden=0
            if [ -f "$custom_file" ]; then
              custom_override=$(grep "^alias $synonym_word=" "$custom_file" 2>/dev/null || true)
              if [ -n "$custom_override" ]; then
                is_overridden=1
              fi
            fi
            
            # Only show if not overridden
            if [ "$is_overridden" -eq 0 ]; then
              printf '%s → %s\n' "$synonym_word" "$target_spell"
            fi
          fi
        fi
      done < "$default_file"
    fi
    
    exit 0
  fi
  
  # Check if synonyms are enabled (for full mode)
  synonyms_enabled=1
  if [ "$list_mode" -eq 0 ]; then
    if [ -f "$synonyms_enabled_file" ]; then
      enabled_value=$(cat "$synonyms_enabled_file" 2>/dev/null || printf '1')
      case $enabled_value in
        0) synonyms_enabled=0 ;;
        *) synonyms_enabled=1 ;;
      esac
    fi
  fi
  
  while :; do
    set --
    
    # Add "Add synonym" option in full mode only
    if [ "$list_mode" -eq 0 ]; then
      set -- "$@" "Add synonym%add-synonym"
      set -- "$@" "---"
    fi
    
    # List custom synonyms first
    has_custom=0
    if [ -f "$custom_file" ]; then
      while IFS= read -r line; do
        # Skip comments and empty lines
        case $line in
          \#*|'') continue ;;
        esac
        
        # Parse alias definition: alias word='spell'
        if printf '%s' "$line" | grep -q "^alias "; then
          synonym_word=$(printf '%s' "$line" | sed "s/^alias \\([^=]*\\)=.*$/\\1/")
          target_spell=$(printf '%s' "$line" | sed "s/^alias [^=]*='\\(.*\\)'$/\\1/")
          target_spell=$(printf '%s' "$target_spell" | sed "s/'\\\\''/'/g")
          
          if [ -n "$synonym_word" ] && [ -n "$target_spell" ]; then
            has_custom=1
            # Escape single quotes for safe passing
            escaped_word=$(printf '%s' "$synonym_word" | sed "s/'/'\\\\''/g")
            set -- "$@" "$synonym_word → $target_spell%synonym-menu '$escaped_word'"
          fi
        fi
      done < "$custom_file"
    fi
    
    # Add separator if we have both custom and default synonyms
    has_default=0
    if [ -f "$default_file" ]; then
      has_default=$(grep -c "^alias " "$default_file" 2>/dev/null || printf '0')
    fi
    
    if [ "$has_custom" -eq 1 ] && [ "$has_default" -gt 0 ]; then
      set -- "$@" "---"
    fi
    
    # List default synonyms
    if [ -f "$default_file" ]; then
      while IFS= read -r line; do
        # Skip comments and empty lines
        case $line in
          \#*|'') continue ;;
        esac
        
        # Parse alias definition: alias word='spell'
        if printf '%s' "$line" | grep -q "^alias "; then
          synonym_word=$(printf '%s' "$line" | sed "s/^alias \\([^=]*\\)=.*$/\\1/")
          target_spell=$(printf '%s' "$line" | sed "s/^alias [^=]*='\\(.*\\)'$/\\1/")
          target_spell=$(printf '%s' "$target_spell" | sed "s/'\\\\''/'/g")
          
          if [ -n "$synonym_word" ] && [ -n "$target_spell" ]; then
            # Check if this default is overridden by a custom synonym
            is_overridden=0
            custom_override=$(grep "^alias $synonym_word=" "$custom_file" 2>/dev/null || true)
            if [ -f "$custom_file" ] && [ -n "$custom_override" ]; then
              is_overridden=1
            fi
            
            # Only show if not overridden
            if [ "$is_overridden" -eq 0 ]; then
              # Escape single quotes for safe passing
              escaped_word=$(printf '%s' "$synonym_word" | sed "s/'/'\\\\''/g")
              set -- "$@" "$synonym_word → $target_spell%synonym-menu '$escaped_word'"
            fi
          fi
        fi
      done < "$default_file"
    fi
    
    # If no synonyms exist, show a message
    if [ "$has_custom" -eq 0 ] && [ "$has_default" -eq 0 ]; then
      set -- "$@" "No synonyms defined%:"
    fi
    
    # Add reset and toggle options in full mode only
    if [ "$list_mode" -eq 0 ]; then
      set -- "$@" "---"
      set -- "$@" "Reset default synonyms%reset-default-synonyms"
      
      # Check if custom synonyms are enabled
      custom_enabled_file="$spell_home/.custom-synonyms-enabled"
      custom_enabled=1
      if [ -f "$custom_enabled_file" ]; then
        custom_enabled=$(cat "$custom_enabled_file" 2>/dev/null || printf '1')
        case $custom_enabled in
          0) custom_enabled=0 ;;
          *) custom_enabled=1 ;;
        esac
      fi
      
      # Check if default synonyms are enabled
      default_enabled_file="$spell_home/.default-synonyms-enabled"
      default_enabled=1
      if [ -f "$default_enabled_file" ]; then
        default_enabled=$(cat "$default_enabled_file" 2>/dev/null || printf '1')
        case $default_enabled in
          0) default_enabled=0 ;;
          *) default_enabled=1 ;;
        esac
      fi
      
      # Toggle for custom synonyms
      if [ "$custom_enabled" -eq 1 ]; then
        custom_toggle_label="[X] Custom synonyms"
        custom_toggle_cmd="printf '0' > '$custom_enabled_file'"
      else
        custom_toggle_label="[ ] Custom synonyms"
        custom_toggle_cmd="printf '1' > '$custom_enabled_file'"
      fi
      set -- "$@" "$custom_toggle_label%$custom_toggle_cmd"
      
      # Toggle for default synonyms
      if [ "$default_enabled" -eq 1 ]; then
        default_toggle_label="[X] Default synonyms"
        default_toggle_cmd="printf '0' > '$default_enabled_file'"
      else
        default_toggle_label="[ ] Default synonyms"
        default_toggle_cmd="printf '1' > '$default_enabled_file'"
      fi
      set -- "$@" "$default_toggle_label%$default_toggle_cmd"
      
      # Toggle for enabling/disabling all synonyms
      if [ "$synonyms_enabled" -eq 1 ]; then
        toggle_label="[X] All synonyms enabled"
        toggle_cmd="printf '0' > '$synonyms_enabled_file'"
      else
        toggle_label="[ ] All synonyms enabled"
        toggle_cmd="printf '1' > '$synonyms_enabled_file'"
      fi
      set -- "$@" "$toggle_label%$toggle_cmd"
    fi
    
    exit_label=$(exit-label)
    set -- "$@" "${exit_label}%kill -TERM \$PPID"
    
    menu "Thesaurus:" "$@" || true
    
    # Re-check enabled state for next iteration (full mode only)
    if [ "$list_mode" -eq 0 ]; then
      if [ -f "$synonyms_enabled_file" ]; then
        enabled_value=$(cat "$synonyms_enabled_file" 2>/dev/null || printf '1')
        case $enabled_value in
          0) synonyms_enabled=0 ;;
          *) synonyms_enabled=1 ;;
        esac
      else
        synonyms_enabled=1
      fi
    fi
  done
