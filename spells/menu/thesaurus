#!/bin/sh
# This spell displays a menu for managing synonyms (aliases).
# Use --list for view-only mode, otherwise includes add and toggle options.

show_usage() {
  cat <<'USAGE'
Usage: thesaurus [--list]

Display a menu for managing synonyms. Without --list, includes
options to add synonyms and toggle synonym support. With --list,
shows a read-only list of existing synonyms.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

require-wizardry || exit 1

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to return cleanly
trap 'exit 0' INT TERM

if ! require menu "The thesaurus menu needs the 'menu' command."; then
  exit 1
fi

# Check for --list flag
list_mode=0
case "${1-}" in
  --list)
    list_mode=1
    shift
    ;;
esac

spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
synonyms_file="$spell_home/.synonyms"
synonyms_enabled_file="$spell_home/.synonyms-enabled"

# Ensure spellbook directory exists
if [ ! -d "$spell_home" ]; then
  mkdir -p "$spell_home" 2>/dev/null || true
fi

# Initialize defaults if needed (invoke-thesaurus handles this)
if [ ! -f "$spell_home/.synonyms-initialized" ]; then
  # Source invoke-thesaurus to initialize defaults
  # This is safe in a non-interactive context
  if [ -f "$ROOT_DIR/spells/.imps/sys/invoke-thesaurus" ]; then
    # shellcheck disable=SC1090,SC1091
    . "$ROOT_DIR/spells/.imps/sys/invoke-thesaurus" 2>/dev/null || :
  fi
fi

# Check if synonyms are enabled (for full mode)
synonyms_enabled=1
if [ "$list_mode" -eq 0 ]; then
  if [ -f "$synonyms_enabled_file" ]; then
    enabled_value=$(cat "$synonyms_enabled_file" 2>/dev/null || printf '1')
    case $enabled_value in
      0) synonyms_enabled=0 ;;
      *) synonyms_enabled=1 ;;
    esac
  fi
fi

while :; do
  set --
  
  # Add "Add synonym" option in full mode only
  if [ "$list_mode" -eq 0 ]; then
    set -- "$@" "Add synonym%add-synonym"
    set -- "$@" "---"
  fi
  
  # List all synonyms from the alias file
  has_synonyms=0
  if [ -f "$synonyms_file" ]; then
    while IFS= read -r line; do
      # Skip comments and empty lines
      case $line in
        \#*|'') continue ;;
      esac
      
      # Parse alias definition: alias word='spell'
      if printf '%s' "$line" | grep -q "^alias "; then
        synonym_word=$(printf '%s' "$line" | sed "s/^alias \\([^=]*\\)=.*$/\\1/")
        target_spell=$(printf '%s' "$line" | sed "s/^alias [^=]*='\\(.*\\)'$/\\1/" | sed "s/'\\\\''/'/g")
        
        if [ -n "$synonym_word" ] && [ -n "$target_spell" ]; then
          has_synonyms=1
          # Escape single quotes for safe passing
          escaped_word=$(printf '%s' "$synonym_word" | sed "s/'/'\\\\''/g")
          set -- "$@" "$synonym_word â†’ $target_spell%synonym-menu '$escaped_word'"
        fi
      fi
    done < "$synonyms_file"
  fi
  
  # If no synonyms exist, show a message
  if [ "$has_synonyms" -eq 0 ]; then
    set -- "$@" "No synonyms defined%:"
  fi
  
  # Add toggle and divider in full mode only
  if [ "$list_mode" -eq 0 ]; then
    set -- "$@" "---"
    
    # Toggle for enabling/disabling synonyms
    if [ "$synonyms_enabled" -eq 1 ]; then
      toggle_label="[X] Synonyms enabled"
      toggle_cmd="printf '0' > '$synonyms_enabled_file'"
    else
      toggle_label="[ ] Synonyms enabled"
      toggle_cmd="printf '1' > '$synonyms_enabled_file'"
    fi
    set -- "$@" "$toggle_label%$toggle_cmd"
  fi
  
  exit_label=$(exit-label)
  set -- "$@" "${exit_label}%kill -TERM \$PPID"
  
  menu "Thesaurus:" "$@" || true
  
  # Re-check enabled state for next iteration (full mode only)
  if [ "$list_mode" -eq 0 ]; then
    if [ -f "$synonyms_enabled_file" ]; then
      enabled_value=$(cat "$synonyms_enabled_file" 2>/dev/null || printf '1')
      case $enabled_value in
        0) synonyms_enabled=0 ;;
        *) synonyms_enabled=1 ;;
      esac
    else
      synonyms_enabled=1
    fi
  fi
done
