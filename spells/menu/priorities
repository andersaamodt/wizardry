#!/bin/sh

# This spell displays and manages prioritized items in the current directory.
# Use it to view and reorder files by priority.

priorities_usage() {
cat <<'USAGE'
Usage: priorities [-v]

Display prioritized items in the current directory as an interactive menu, with -v to show priority numbers.
USAGE
}



priorities() {

case "${1-}" in
--help|--usage|-h)
        priorities_usage
        return 0
        ;;
esac

require_wizardry || return 1

set -eu
env_clear

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Initialize verbose flag to 0
verbose=0

# Parse options
while getopts "v" opt; do
  case $opt in
    v) verbose=1 ;; # If -v is passed, set verbose to 1
    \?) usage-error "priorities" "Invalid option: -$OPTARG" ;; # Invalid option
  esac
done
shift $((OPTIND-1)) # Shift off the options and optional --.

# Function to display priorities
display_priorities() {
  # Get directory
  dir="${PWD}"

  # Get the current priorities of the directory
  dir_priorities=$(read_magic "${dir}" priorities)

  # If there are no priorities, print an error message and exit
  if [ -z "${dir_priorities}" ] || [ "$dir_priorities" = "read-magic: attribute does not exist." ]; then
    echo "No priorities set in the current folder. Try 'prioritize <filename>'."
    return 1
  fi

  # Initialize variables
  highest_priority=""
  line_added=false
  menu_command="menu Priorities:"

  # Loop through the priorities
  dir_priorities=$(echo "${dir_priorities}" | tr ',' '\n')

  for priority_hash in $dir_priorities; do
    # Get the priority file
    priority_file=$(get-card "${priority_hash}")

    # Check if the file exists
    if [ -n "${priority_file}" ]; then
      # Get priority of the file
      file_priority=$(read_magic "${priority_file}" priority 2>/dev/null)
      
      # If the file does not have a priority, set it to 0
      if [ -z "${file_priority}" ] || [ "$file_priority" = "read-magic: attribute does not exist." ]; then
        file_priority=0
      fi

      # If the priority of the file is a number
      if [ "${file_priority}" -eq "${file_priority}" ] 2>/dev/null; then
        # If the file's priority is not the highest priority, add a line
        if [ -n "${highest_priority}" ] && [ "${file_priority}" -ne "${highest_priority}" ] && [ "${line_added}" = false ]; then
          menu_command="${menu_command} \"─── %\""
          line_added=true
        fi

        # Add the file to the menu command
        menu_command="${menu_command} \""
        if [ $verbose -eq 1 ]; then
          menu_command="${menu_command}${file_priority} "
        fi
        item_name=$(basename "$priority_file")
        menu_command="${menu_command}$item_name%priority-menu \\\"${priority_file}\\\"\""

        # Update the highest priority
        highest_priority="${file_priority}"
      fi
    fi
  done

  # Add exit command
  exit_label=$(exit-label)
  menu_command="${menu_command} \"${exit_label}%kill -TERM \$PPID\""

  # Execute the constructed menu command
  eval "${menu_command}"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    display_priorities || true
  else
    first_run=0
    # On first run, exit if display_priorities fails (no priorities set)
    if ! display_priorities; then
      return 1
    fi
  fi
done
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
