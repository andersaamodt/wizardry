#!/bin/sh

# This spell displays and manages prioritized items in the current directory with echelon support.
# Use it to view and reorder files by priority tiers (echelons).

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: priorities [-v]

Display prioritized items in the current directory as an interactive menu, with -v to show priority numbers (echelons).
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Initialize verbose flag to 0
verbose=0

# Parse options
while getopts "v" opt; do
  case $opt in
    v) verbose=1 ;; # If -v is passed, set verbose to 1
    \?) printf '%s\n' "priorities: invalid option: -$OPTARG" >&2; exit 2 ;;
  esac
done
shift $((OPTIND-1)) # Shift off the options and optional --.

# Function to display priorities
display_priorities() {
  # Get directory
  dir="${PWD}"

  # Get the current priorities of the directory
  dir_priorities=$(read-magic "${dir}" priorities 2>/dev/null || true)

  # If there are no priorities, print an error message and exit
  case "$dir_priorities" in
    ''|*Error*|*"does not exist"*)
      printf '%s\n' "No priorities set in the current folder. Try 'prioritize <filename>'."
      return 1
      ;;
  esac

  # Initialize variables
  highest_priority=""
  menu_command="menu Priorities:"

  # Loop through the priorities
  dir_priorities=$(printf '%s' "${dir_priorities}" | tr ',' '\n')

  for priority_hash in $dir_priorities; do
    # Get the priority file using get-card
    priority_file=$(get-card "${priority_hash}" "${dir}" 2>/dev/null || true)

    # Check if the file exists and was found
    if [ -n "${priority_file}" ] && [ -f "${priority_file}" ]; then
      # Get priority of the file
      file_priority=$(read-magic "${priority_file}" priority 2>/dev/null || true)
      
      # Handle errors or empty priority
      case "$file_priority" in
        ''|*Error*) file_priority=0 ;;
        *[!0-9]*) file_priority=0 ;;
      esac

      # If the file's priority differs from the previous highest, add an echelon separator line
      if [ -n "${highest_priority}" ] && [ "${file_priority}" -ne "${highest_priority}" ]; then
        menu_command="${menu_command} \"---\""
      fi

      # Add the file to the menu command
      menu_command="${menu_command} \""
      if [ $verbose -eq 1 ]; then
        menu_command="${menu_command}${file_priority} "
      fi
      item_name=$(basename "$priority_file")
      menu_command="${menu_command}$item_name%priority-menu \\\"${priority_file}\\\"\""

      # Update the highest priority (for detecting echelon boundaries)
      highest_priority="${file_priority}"
    fi
  done

  # Add separator before Exit
  menu_command="${menu_command} \"---\""
  
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  menu_command="${menu_command} \"${exit_label}%exit 0\""

  # Execute the constructed menu command
  eval "${menu_command}" || _priorities_menu_status=$?
  return "${_priorities_menu_status:-0}"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    display_priorities || menu_status=$?
    menu_status=${menu_status:-0}
    # ESC kills this menu script via TERM signal (same as Exit button)
    # Direct kill: kill -TERM $$ → kills this script
    if [ "$menu_status" -eq 130 ]; then
      printf 'ESC\n' >&2
      kill -TERM $$ 2>/dev/null || true
      exit 0
    fi
  else
    first_run=0
    # On first run, exit if display_priorities fails (no priorities set)
    if ! display_priorities; then
      exit 1
    fi
    menu_status=$?
    # ESC kills this menu script via TERM signal (same as Exit button)
    # Direct kill: kill -TERM $$ → kills this script
    if [ "$menu_status" -eq 130 ]; then
      printf 'ESC\n' >&2
      kill -TERM $$ 2>/dev/null || true
      exit 0
    fi
  fi
done
