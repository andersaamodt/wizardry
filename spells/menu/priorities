#!/bin/sh

# This spell displays and manages prioritized items in the current directory with echelon support.
# Use it to view and reorder files by priority tiers (echelons).

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: priorities [-v]

Display prioritized items in the current directory as an interactive menu, with -v to show priority numbers (echelons).
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Initialize verbose flag to 0
verbose=0

# Parse options
while getopts "v" opt; do
  case $opt in
    v) verbose=1 ;; # If -v is passed, set verbose to 1
    \?) printf '%s\n' "priorities: invalid option: -$OPTARG" >&2; exit 2 ;;
  esac
done
shift $((OPTIND-1)) # Shift off the options and optional --.

# Function to display priorities
display_priorities() {
  # Get directory
  dir="${PWD}"

  # Get the current priorities of the directory
  dir_priorities=$(read-magic "${dir}" priorities 2>/dev/null || true)

  # If there are no priorities, print an error message and exit
  case "$dir_priorities" in
    ''|*Error*|*"does not exist"*)
      printf '%s\n' "No priorities set in the current folder. Try 'prioritize <filename>'."
      return 1
      ;;
  esac

  # Initialize variables
  highest_priority=""
  menu_command="menu --start-selection $start_selection Priorities:"
  
  # Count items for tracking (includes all menu items for position calculation)
  item_count=0
  total_menu_items=0

  # Loop through the priorities
  dir_priorities=$(printf '%s' "${dir_priorities}" | tr ',' '\n')

  for priority_hash in $dir_priorities; do
    # Get the priority file using get-card
    priority_file=$(get-card "${priority_hash}" "${dir}" 2>/dev/null || true)

    # Check if the file exists and was found (support both files and directories)
    if [ -n "${priority_file}" ] && [ -e "${priority_file}" ]; then
      # Get priority of the file
      file_priority=$(read-magic "${priority_file}" priority 2>/dev/null || true)
      
      # Handle errors or empty priority
      case "$file_priority" in
        ''|*Error*) file_priority=0 ;;
        *[!0-9]*) file_priority=0 ;;
      esac

      # If the file's priority differs from the previous highest, add an echelon separator line
      if [ -n "${highest_priority}" ] && [ "${file_priority}" -ne "${highest_priority}" ]; then
        menu_command="${menu_command} \"---\""
        total_menu_items=$((total_menu_items + 1))
      fi

      # Read checked attribute
      checked_value=$(read-magic "${priority_file}" checked 2>/dev/null || printf '0')
      
      # Handle errors or empty values
      case "$checked_value" in
        ''|*Error*) checked_value=0 ;;
        *[!0-9]*) checked_value=0 ;;
      esac
      
      # Set checkbox display
      if [ "$checked_value" = "1" ]; then
        checkbox="[X] "
      else
        checkbox="[ ] "
      fi

      # Add the file to the menu command
      menu_command="${menu_command} \""
      if [ $verbose -eq 1 ]; then
        menu_command="${menu_command}${file_priority} "
      fi
      item_name=$(basename "$priority_file")
      # Add * after folder names
      if [ -d "$priority_file" ]; then
        item_name="${item_name}*"
      fi
      menu_command="${menu_command}${checkbox}$item_name%priority-menu \\\"${priority_file}\\\"\""

      # Update the highest priority (for detecting echelon boundaries)
      highest_priority="${file_priority}"
      
      # Increment counts
      item_count=$((item_count + 1))
      total_menu_items=$((total_menu_items + 1))
    fi
  done
  
  # Store counts for next iteration comparison
  current_item_count=$item_count
  
  # Add separator before Add priority and Exit
  menu_command="${menu_command} \"---\""
  total_menu_items=$((total_menu_items + 1))
  
  # Add "Add priority" option
  menu_command="${menu_command} \"Add priority%prioritize --interactive\""
  add_priority_position=$((total_menu_items + 1))
  current_add_priority_position=$add_priority_position
  
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  menu_command="${menu_command} \"${exit_label}%kill -TERM \\\$PPID\""

  # Execute the constructed menu command
  eval "${menu_command}" || _priorities_menu_status=$?
  return "${_priorities_menu_status:-0}"
}

first_run=1
start_selection=1
previous_item_count=0
previous_add_priority_position=0

while true; do
  if [ "$first_run" -eq 0 ]; then
    # Always keep "Add priority" selected when item count increases (new priority was added)
    if [ "$current_item_count" -gt "$previous_item_count" ]; then
      # New item was added, keep "Add priority" selected
      # Use the calculated position from display_priorities
      start_selection=$current_add_priority_position
    else
      # If count didn't change, reset to default (first item)
      start_selection=1
    fi
    previous_item_count=$current_item_count
    previous_add_priority_position=$current_add_priority_position
    
    display_priorities || menu_status=$?
    menu_status=${menu_status:-0}
    # ESC kills this menu script via TERM signal (same as Exit button)
    # Direct kill: kill -TERM $$ → kills this script
    if [ "$menu_status" -eq 130 ]; then
      printf 'ESC\n' >&2
      kill -TERM $$ 2>/dev/null || true
      exit 0
    fi
  else
    first_run=0
    # On first run, exit if display_priorities fails (no priorities set)
    if ! display_priorities; then
      exit 1
    fi
    previous_item_count=$current_item_count
    previous_add_priority_position=$current_add_priority_position
    menu_status=$?
    # ESC kills this menu script via TERM signal (same as Exit button)
    # Direct kill: kill -TERM $$ → kills this script
    if [ "$menu_status" -eq 130 ]; then
      printf 'ESC\n' >&2
      kill -TERM $$ 2>/dev/null || true
      exit 0
    fi
  fi
done
