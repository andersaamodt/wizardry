#!/bin/sh

# This spell displays a menu of commands for a prioritized file or folder with echelon support.
# Use 'priorities' to easily select a priority with this menu.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: priority-menu <file>

Display an interactive menu of actions for a prioritized file, offering quick options to prioritize, check, edit, or browse within it.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

# Check for menu command
if ! command -v menu >/dev/null 2>&1; then
  printf '%s\n' "priority-menu: menu command required" >&2
  exit 1
fi

file="${1-}"

if [ -z "$file" ]; then
  printf '%s\n' "priority-menu: file path required" >&2
  exit 2
fi

priority_menu_display_menu() {
  checked_value=$(read-magic "${file}" checked 2>/dev/null || printf '0')
  
  # Handle errors or empty values
  case "$checked_value" in
    ''|*Error*) checked_value=0 ;;
    *[!0-9]*) checked_value=0 ;;
  esac
  
  if [ "$checked_value" = "1" ]; then
    # Checked - show Uncheck option
    check_item="Uncheck%uncheck \"$file\""
  else
    # Not checked - show Check option
    check_item="Check%check \"$file\""
  fi

  filename=$(basename "$file")
  
  # Add checkbox state to header
  if [ "$checked_value" = "1" ]; then
    header_checkbox="[X] "
  else
    header_checkbox="[ ] "
  fi
  
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  # Check if this file is the highest priority (highest echelon)
  # Get parent directory
  parent_dir=$(dirname "$file")
  if [ "$parent_dir" = "." ]; then
    parent_dir=$(pwd -P)
  fi
  
  # Get this file's echelon
  file_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
  case "$file_echelon" in
    *Error*|''|*[!0-9]*) file_echelon=0 ;;
  esac
  
  # Find the highest echelon in the parent directory
  highest_echelon=0
  for f in "$parent_dir"/*; do
    [ -e "$f" ] || continue
    
    item_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
    case "$item_echelon" in
      *Error*|''|*[!0-9]*) continue ;;
    esac
    
    if [ "$item_echelon" -gt "$highest_echelon" ]; then
      highest_echelon=$item_echelon
    fi
  done
  
  # Determine if this file is the highest priority
  is_highest_priority=0
  if [ "$file_echelon" -gt 0 ] && [ "$file_echelon" -eq "$highest_echelon" ]; then
    is_highest_priority=1
  fi

  # Check if file is a directory and has subpriorities
  browse_item=""
  if [ -d "$file" ]; then
    # Check if directory has items with echelon >= 1
    has_subpriorities=0
    for item in "$file"/*; do
      [ -e "$item" ] || continue
      item_echelon=$(read-magic "$item" echelon 2>/dev/null || printf '0')
      # Handle errors or empty values
      case "$item_echelon" in
        ''|*Error*) item_echelon=0 ;;
        *[!0-9]*) item_echelon=0 ;;
      esac
      if [ "$item_echelon" -ge 1 ]; then
        has_subpriorities=1
        break
      fi
    done
    
    if [ "$has_subpriorities" = "1" ]; then
      browse_item="Subpriorities...%(cd \"$file\" && priorities)"
    else
      # No subpriorities - offer to add one
      browse_item="Add subpriority%(cd \"$file\" && prioritize --interactive)"
    fi
  fi

  # Check if file is a regular file (not a directory) for "Make project" option
  make_project_item=""
  if [ -f "$file" ]; then
    make_project_item="Make project%file-to-folder \"$file\""
  fi

  # Build menu items - conditionally include Prioritize based on whether it's highest priority
  # Order: Subpriorities... (if available), Prioritize, Check, Edit priority, Make project (if file), Discard priority
  if [ "$is_highest_priority" = "1" ]; then
    # Don't show Prioritize for highest priority items
    if [ -n "$browse_item" ]; then
      if [ -n "$make_project_item" ]; then
        set -- "$browse_item" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "$make_project_item" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      else
        set -- "$browse_item" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      fi
    else
      if [ -n "$make_project_item" ]; then
        set -- "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "$make_project_item" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      else
        set -- "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      fi
    fi
  else
    # Show Prioritize for non-highest priority items
    if [ -n "$browse_item" ]; then
      if [ -n "$make_project_item" ]; then
        set -- "$browse_item" \
               "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "$make_project_item" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      else
        set -- "$browse_item" \
               "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      fi
    else
      if [ -n "$make_project_item" ]; then
        set -- "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "$make_project_item" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      else
        set -- "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
               "${check_item}" \
               "Edit priority%rename-interactive \"$file\"" \
               "Discard priority%deprioritize \"$file\"" \
               "---" \
               "$exit_item"
      fi
    fi
  fi
  menu --start-selection "$start_selection" "${THEME_HEADING}${header_checkbox}${filename}${RESET}:" "$@"
}

first_run=1
start_selection=1
was_checked=0

while true; do
  if [ "$first_run" -eq 0 ]; then
    # Check if checked state changed (Check/Uncheck was used)
    # Get current checked state
    now_checked=$(read-magic "${file}" checked 2>/dev/null || printf '0')
    case "$now_checked" in
      ''|*Error*) now_checked=0 ;;
      *[!0-9]*) now_checked=0 ;;
      *) : ;;
    esac
    
    # If checked state changed, keep Check/Uncheck item selected
    if [ "$was_checked" != "$now_checked" ]; then
      # Check/Uncheck position varies based on menu structure
      # It's typically position 2 (after browse_item) or position 1 (no browse_item)
      # For simplicity and since browse items don't toggle state, we check the check item position
      # When there's a browse_item and Prioritize, Check is at position 3
      # When there's a browse_item but no Prioritize (highest priority), Check is at position 2
      # When there's no browse_item but Prioritize exists, Check is at position 2
      # When there's no browse_item and no Prioritize, Check is at position 1
      
      # Since menu structure is dynamic, we need to determine position
      # The safest approach: Check is always after browse_item (if exists) and Prioritize (if exists)
      check_position=1
      if [ -d "$file" ]; then
        # Has browse item
        check_position=2
        # Check if this is highest priority (no Prioritize item)
        parent_dir=$(dirname "$file")
        if [ "$parent_dir" = "." ]; then
          parent_dir=$(pwd -P)
        fi
        
        # Get this file's echelon
        file_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
        case "$file_echelon" in
          *Error*|''|*[!0-9]*) file_echelon=0 ;;
        esac
        
        # Find highest echelon in parent directory
        highest_echelon=0
        for f in "$parent_dir"/*; do
          [ -e "$f" ] || continue
          item_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
          case "$item_echelon" in
            *Error*|''|*[!0-9]*) continue ;;
          esac
          if [ "$item_echelon" -gt "$highest_echelon" ]; then
            highest_echelon=$item_echelon
          fi
        done
        
        # If not highest echelon, Prioritize exists
        if [ "$file_echelon" -gt 0 ] && [ "$file_echelon" -lt "$highest_echelon" ]; then
          check_position=3
        fi
      else
        # No browse item, Check position depends on Prioritize
        parent_dir=$(dirname "$file")
        if [ "$parent_dir" = "." ]; then
          parent_dir=$(pwd -P)
        fi
        
        # Get this file's echelon
        file_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
        case "$file_echelon" in
          *Error*|''|*[!0-9]*) file_echelon=0 ;;
        esac
        
        # Find highest echelon in parent directory
        highest_echelon=0
        for f in "$parent_dir"/*; do
          [ -e "$f" ] || continue
          item_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
          case "$item_echelon" in
            *Error*|''|*[!0-9]*) continue ;;
          esac
          if [ "$item_echelon" -gt "$highest_echelon" ]; then
            highest_echelon=$item_echelon
          fi
        done
        
        # Determine if Prioritize item exists
        if [ "$file_echelon" -eq "$highest_echelon" ] && [ "$file_echelon" -gt 0 ]; then
          # Highest priority, no Prioritize
          check_position=1
        else
          # Not highest, Prioritize exists
          check_position=2
        fi
      fi
      
      start_selection=$check_position
    fi
    
    # Save current state for next iteration
    was_checked=$now_checked
  else
    first_run=0
    # Save initial state
    was_checked=$(read-magic "${file}" checked 2>/dev/null || printf '0')
    case "$was_checked" in
      ''|*Error*) was_checked=0 ;;
      *[!0-9]*) was_checked=0 ;;
      *) : ;;
    esac
  fi

  priority_menu_display_menu || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC kills this menu script via TERM signal (same as Exit button)
  # Direct kill: kill -TERM $$ → kills this script
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    kill -TERM $$ 2>/dev/null || true
    exit 0
  fi
done
