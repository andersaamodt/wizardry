#!/bin/sh

# This spell displays a menu of commands for a prioritized file or folder with echelon support.
# Use 'priorities' to easily select a priority with this menu.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: priority-menu <file>

Display an interactive menu of actions for a prioritized file, offering quick options to prioritize, check, edit, or browse within it.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

# Check for menu command
if ! command -v menu >/dev/null 2>&1; then
  printf '%s\n' "priority-menu: menu command required" >&2
  exit 1
fi

file="${1-}"

if [ -z "$file" ]; then
  printf '%s\n' "priority-menu: file path required" >&2
  exit 2
fi

priority_menu_display_menu() {
  checked_value=$(read-magic "${file}" checked 2>/dev/null || printf '0')
  
  # Handle errors or empty values
  case "$checked_value" in
    ''|*Error*) checked_value=0 ;;
    *[!0-9]*) checked_value=0 ;;
  esac
  
  if [ "$checked_value" = "1" ]; then
    # Checked - show Uncheck option
    check_item="Uncheck%uncheck \"$file\""
  else
    # Not checked - show Check option
    check_item="Check%check \"$file\""
  fi

  filename=$(basename "$file")
  
  # Add checkbox state to header
  if [ "$checked_value" = "1" ]; then
    header_checkbox="[X] "
  else
    header_checkbox="[ ] "
  fi
  
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  # Check if this file is the very first priority (lowest priority number in highest echelon)
  # Get parent directory
  parent_dir=$(dirname "$file")
  if [ "$parent_dir" = "." ]; then
    parent_dir=$(pwd -P)
  fi
  
  # Get this file's echelon and priority
  file_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
  case "$file_echelon" in
    *Error*|''|*[!0-9]*) file_echelon=0 ;;
  esac
  
  file_priority=$(read-magic "$file" priority 2>/dev/null || printf '0')
  case "$file_priority" in
    *Error*|''|*[!0-9]*) file_priority=0 ;;
  esac
  
  # Find the highest echelon and lowest priority in that echelon
  highest_echelon=0
  lowest_priority_in_highest=999999
  for f in "$parent_dir"/*; do
    [ -e "$f" ] || continue
    
    item_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
    case "$item_echelon" in
      *Error*|''|*[!0-9]*) continue ;;
    esac
    
    if [ "$item_echelon" -gt "$highest_echelon" ]; then
      highest_echelon=$item_echelon
      lowest_priority_in_highest=999999  # Reset when we find a new highest
    fi
    
    # Track lowest priority in the highest echelon
    if [ "$item_echelon" -eq "$highest_echelon" ]; then
      item_priority=$(read-magic "$f" priority 2>/dev/null || printf '0')
      case "$item_priority" in
        *Error*|''|*[!0-9]*) item_priority=999999 ;;
      esac
      if [ "$item_priority" -lt "$lowest_priority_in_highest" ]; then
        lowest_priority_in_highest=$item_priority
      fi
    fi
  done
  
  # Determine if this file is the very first priority (lowest priority # in highest echelon)
  is_very_first_priority=0
  if [ "$file_echelon" -gt 0 ] && [ "$file_echelon" -eq "$highest_echelon" ] && [ "$file_priority" -eq "$lowest_priority_in_highest" ]; then
    is_very_first_priority=1
  fi

  # Check if file is a directory and has subpriorities
  browse_item=""
  if [ -d "$file" ]; then
    # Check if directory has items with echelon >= 1
    has_subpriorities=0
    for item in "$file"/*; do
      [ -e "$item" ] || continue
      item_echelon=$(read-magic "$item" echelon 2>/dev/null || printf '0')
      # Handle errors or empty values
      case "$item_echelon" in
        ''|*Error*) item_echelon=0 ;;
        *[!0-9]*) item_echelon=0 ;;
      esac
      if [ "$item_echelon" -ge 1 ]; then
        has_subpriorities=1
        break
      fi
    done
    
    if [ "$has_subpriorities" = "1" ]; then
      browse_item="${THEME_SUCCESS}Subpriorities...${RESET}%(cd \"$file\" && priorities)"
    else
      # No subpriorities - offer to add one
      browse_item="Add subpriority%(cd \"$file\" && prioritize --interactive)"
    fi
  fi

  # Check if file is a regular file (not a directory) for "Make project" option
  make_project_item=""
  if [ -f "$file" ]; then
    make_project_item="Make project%file-to-folder \"$file\""
  fi

  # Build menu items - conditionally include Prioritize based on whether it's the very first priority
  # Order: Prioritize (if not first), Check, Edit priority, Make project/Subpriorities (mutually exclusive), Discard priority
  if [ "$is_very_first_priority" = "1" ]; then
    # Don't show Prioritize for the very first priority item only
    if [ -n "$browse_item" ]; then
      set -- "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "$browse_item" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    elif [ -n "$make_project_item" ]; then
      set -- "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "$make_project_item" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    else
      set -- "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    fi
  else
    # Show Prioritize for all other items
    if [ -n "$browse_item" ]; then
      set -- "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
             "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "$browse_item" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    elif [ -n "$make_project_item" ]; then
      set -- "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
             "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "$make_project_item" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    else
      set -- "Prioritize%prioritize \"$file\"; kill -TERM \$PPID" \
             "${check_item}" \
             "Edit priority%newname=\$(ask-text 'New name:' \"\$(basename \"$file\")\") && mv \"$file\" \"\$(dirname \"$file\")/\$newname\" && priority-menu \"\$(dirname \"$file\")/\$newname\"" \
             "Discard priority%deprioritize \"$file\"; kill -TERM \$PPID" \
             "---" \
             "$exit_item"
    fi
  fi
  menu --start-selection "$start_selection" "${THEME_HEADING}${header_checkbox}${filename}:${RESET}" "$@"
}

first_run=1
start_selection=1
was_checked=0

while true; do
  if [ "$first_run" -eq 0 ]; then
    # Check if checked state changed (Check/Uncheck was used)
    # Get current checked state
    now_checked=$(read-magic "${file}" checked 2>/dev/null || printf '0')
    case "$now_checked" in
      ''|*Error*) now_checked=0 ;;
      *[!0-9]*) now_checked=0 ;;
      *) : ;;
    esac
    
    # If checked state changed, keep Check/Uncheck item selected
    if [ "$was_checked" != "$now_checked" ]; then
      # Determine Check/Uncheck position based on current menu structure
      # Position depends on: browse_item (if dir), prioritize (if not very first), check_item
      check_position=1
      
      # Add 1 for browse_item if directory
      if [ -d "$file" ]; then
        check_position=$((check_position + 1))
      fi
      
      # Add 1 for Prioritize if not the very first priority
      # Need to recalculate is_very_first_priority
      file_echelon=$(read-magic "$file" echelon 2>/dev/null || printf '0')
      case "$file_echelon" in
        *Error*|''|*[!0-9]*) file_echelon=0 ;;
      esac
      
      file_priority=$(read-magic "$file" priority 2>/dev/null || printf '0')
      case "$file_priority" in
        *Error*|''|*[!0-9]*) file_priority=0 ;;
      esac
      
      parent_dir=$(dirname "$file")
      if [ "$parent_dir" = "." ]; then
        parent_dir=$(pwd -P)
      fi
      
      highest_echelon=0
      lowest_priority_in_highest=999999
      for f in "$parent_dir"/*; do
        [ -e "$f" ] || continue
        item_echelon=$(read-magic "$f" echelon 2>/dev/null || printf '0')
        case "$item_echelon" in
          *Error*|''|*[!0-9]*) continue ;;
        esac
        if [ "$item_echelon" -gt "$highest_echelon" ]; then
          highest_echelon=$item_echelon
          lowest_priority_in_highest=999999
        fi
        if [ "$item_echelon" -eq "$highest_echelon" ]; then
          item_priority=$(read-magic "$f" priority 2>/dev/null || printf '0')
          case "$item_priority" in
            *Error*|''|*[!0-9]*) item_priority=999999 ;;
          esac
          if [ "$item_priority" -lt "$lowest_priority_in_highest" ]; then
            lowest_priority_in_highest=$item_priority
          fi
        fi
      done
      
      is_very_first=0
      if [ "$file_echelon" -gt 0 ] && [ "$file_echelon" -eq "$highest_echelon" ] && [ "$file_priority" -eq "$lowest_priority_in_highest" ]; then
        is_very_first=1
      fi
      
      # Add 1 for Prioritize if NOT very first priority
      if [ "$is_very_first" -eq 0 ]; then
        check_position=$((check_position + 1))
      fi
      
      start_selection=$check_position
    fi
    
    # Save current state for next iteration
    was_checked=$now_checked
  else
    first_run=0
    # Save initial state
    was_checked=$(read-magic "${file}" checked 2>/dev/null || printf '0')
    case "$was_checked" in
      ''|*Error*) was_checked=0 ;;
      *[!0-9]*) was_checked=0 ;;
      *) : ;;
    esac
  fi

  priority_menu_display_menu || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC kills this menu script via TERM signal (same as Exit button)
  # Direct kill: kill -TERM $$ → kills this script
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    kill -TERM $$ 2>/dev/null || true
    exit 0
  fi
done
