#!/bin/sh

# This spell presents a menu of options for managing users on the system.
# Use it to manage passwords, groups, and user accounts.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . users-menu    OR    users menu    (via parse/gloss)

Display an interactive menu for user and group management, covering password changes, group memberships, and user account administration.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - detect if sourced
users_menu_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) users_menu_sourced=1 ;;
  esac
else
  users_menu_base=${0##*/}
  case "$users_menu_base" in
    sh|dash|bash|zsh|ksh|mksh) users_menu_sourced=1 ;;
    users-menu) users_menu_sourced=0 ;;
    parse) users_menu_sourced=1 ;;  # Sourced via parse
    *) users_menu_sourced=1 ;;
  esac
fi

if [ "$users_menu_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . users-menu  OR  users menu" >&2
  return 1 2>/dev/null || exit 1
fi
unset users_menu_sourced users_menu_base

set +e  # Permissive mode since we're in user's shell
set -u
. env-clear

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The Users menu needs the 'menu' command to present options."; then
  return 1
fi

# Catch Ctrl-C and TERM signal to return cleanly
trap 'return 0' INT TERM

users_menu_display_menu() {
  change_my_password="Change my password%passwd"
  list_users="List all users%cut -d: -f1 /etc/passwd"
  change_other_password="Change other user's password%read -p \"Enter username: \" username; sudo passwd \$username"
  view_my_groups="View my group memberships%groups"
  view_other_groups="View other user's group membership%read -p \"Enter username: \" username; groups \$username"
  list_groups="List all groups%cut -d: -f1 /etc/group"
  create_group="Create new group%read -p \"Enter new group name: \" groupname; sudo groupadd \$groupname"
  delete_group="Delete group%read -p \"Enter group to delete: \" groupname; sudo groupdel \$groupname"
  join_group="Join group%read -p \"Enter group name to join: \" groupname; sudo usermod -a -G \$groupname \$USER"
  leave_group="Leave group%read -p \"Enter group name to leave: \" group; sudo gpasswd -d \$USER \$group"
  list_users_in_group="List users in group%read -p \"Enter group name to list members: \" group; getent group \$group"
  add_user_to_group="Add other user to group%read -p \"Enter username: \" username; read -p \"Enter group name to add them to: \" group; sudo usermod -a -G \$group \$username"
  remove_user_from_group="Remove other user from group%read -p \"Enter username: \" username; read -p \"Enter group to remove them from: \" group; sudo gpasswd -d \$username \$group"
  create_user="Create new user%read -p \"Enter new username: \" username; sudo useradd \$username; printf \"The new user needs a password (use 'Change other user's password').\""
  delete_user="Delete user%read -p \"Enter username of user to delete: \" username; sudo userdel \$username"
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$change_my_password" "$list_users" "$change_other_password" "$view_my_groups" "$view_other_groups" "$list_groups" "$create_group" "$delete_group" "$join_group" "$leave_group" "$list_users_in_group" "$add_user_to_group" "$remove_user_from_group" "$create_user" "$delete_user" "$exit_item"
  menu "Users Menu:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    :
  else
    first_run=0
  fi

  users_menu_display_menu || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC kills this menu script via TERM signal (same as Exit button)
  # Direct kill: kill -TERM $$ → kills this script
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    kill -TERM $$ 2>/dev/null || true
    return 0
  fi
done
