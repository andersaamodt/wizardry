#!/bin/sh
# spell-menu - Display action menu for a spell or custom command
# Shows options: Cast now, Memorize/Forget, Help, Test spell, Delete (for custom)

set -eu

menu_escape_status=113

# Load colors for display
if command -v colors >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$(command -v colors)"
else
        RESET=''
        CYAN=''
fi

if [ -n "${REQUIRE_COMMAND-}" ]; then
        require_cmd=$REQUIRE_COMMAND
else
        require_cmd=require-command
fi

require_tool() {
        "$require_cmd" "$@"
}

cast_store=${CAST_STORE-memorize-command}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spell-menu: memorize-command helper is missing." >&2
        exit 1
fi

resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)

cast_list() {
        "$cast_store" list
}

is_memorized() {
        check_name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$check_name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

do_memorize() {
        mem_name=$1
        shift
        "$cast_store" add "$mem_name" "$@"
}

do_forget() {
        mem_name=$1
        "$cast_store" remove "$mem_name"
}

# Check if a script is a scribed command (exists as executable in spell_home)
is_scribed_command() {
        check_name=$1
        script_path="$spell_home/$check_name"
        [ -f "$script_path" ] && [ -x "$script_path" ]
}

remove_scribed_command() {
        cmd_name=$1
        script_path="$spell_home/$cmd_name"
        if [ -f "$script_path" ]; then
                rm -f "$script_path"
                return 0
        fi
        return 1
}

# Check if a spell has an install() function (making it installable)
# Uses the is-installable imp if available, otherwise falls back to inline check
is_installable() {
        spell_cmd=$1
        if command -v is-installable >/dev/null 2>&1; then
                is-installable "$spell_cmd"
                return $?
        fi
        # Fallback: inline check
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        if grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

usage() {
        cat <<'USAGE'
Usage: spell-menu SPELLNAME
       spell-menu --cast COMMAND
       spell-menu --help-spell COMMAND
       spell-menu --test NAME
       spell-menu --delete NAME
       spell-menu --install COMMAND

Display an action menu for a spell with options to cast, memorize, get help, test, or delete.

Arguments:
  SPELLNAME        The name of the spell or command to show the menu for
USAGE
}

# Handle action flags (called by menu via subprocess)
case ${1-} in
        --cast)
                shift
                eval "$*"
                exit 0
                ;;
        --help-spell)
                shift
                eval "$* --help" || true
                exit 0
                ;;
        --test)
                shift
                name=$1
                if command -v test-magic >/dev/null 2>&1; then
                        test-magic --only "$name" || true
                else
                        printf '%s\n' "test-magic is unavailable; cannot test $name." >&2
                fi
                exit 0
                ;;
        --delete)
                shift
                name=$1
                if remove_scribed_command "$name"; then
                        printf "Deleted scribed command '%s'.\n" "$name"
                else
                        printf "Failed to delete scribed command '%s'.\n" "$name" >&2
                fi
                exit 0
                ;;
        --install)
                shift
                # The command is already escaped when passed to this handler
                # Run the spell with --install flag to trigger its install() function
                cmd=$1
                # Use eval since command might contain arguments/quotes
                # The caller has already escaped the command properly
                eval "$cmd" --install || true
                exit 0
                ;;
        -h|--help)
                usage
                exit 0
                ;;
esac

if [ "$#" -lt 1 ]; then
        usage >&2
        exit 1
fi

name=$1
# The command is the spell name (which is executable either as scribed command or from PATH)
command=$name

if ! require_tool menu "The spell menu needs the 'menu' command."; then
        exit 1
fi

# Escape single quotes in command for safe passing
escaped_command=$(printf '%s' "$command" | sed "s/'/'\\\\''/g")

first_run=1

while :; do
        if [ "$first_run" -eq 0 ]; then
                printf '\n'
        else
                first_run=0
        fi

        # Show checkbox for Cast menu visibility (toggleable)
        # Use standalone memorize-command instead of spell-menu flags
        if is_memorized "$name"; then
                cast_toggle="[X] Show in Cast menu%memorize-command remove '$name'"
        else
                cast_toggle="[ ] Show in Cast menu%memorize-command add '$name' '$escaped_command'"
        fi
        # Build menu items - Cast runs the command directly (using escaped version for safety)
        exit_label=$(exit-label)
        exit_item="${exit_label}%exit $menu_escape_status"
        if is_scribed_command "$name"; then
                # Scribed (custom) commands show Delete option
                set -- "Cast%$escaped_command" "$cast_toggle" "Help%$escaped_command --help" "Test spell%spell-menu --test '$name'" "Delete command%spell-menu --delete '$name'" "$exit_item"
        elif is_installable "$command"; then
                # Show Install option for spells with install() function
                set -- "Cast%$escaped_command" "$cast_toggle" "Install to shell%spell-menu --install '$escaped_command'" "Help%$escaped_command --help" "Test spell%spell-menu --test '$name'" "$exit_item"
        else
                # Built-in spells: no Delete option
                set -- "Cast%$escaped_command" "$cast_toggle" "Help%$escaped_command --help" "Test spell%spell-menu --test '$name'" "$exit_item"
        fi
        
        MENU_ESCAPE_STATUS=$menu_escape_status menu "Spell Menu:" "$@"
        status=$?
        if [ "$status" -eq "$menu_escape_status" ]; then
                break
        fi
        if [ "$status" -ne 0 ]; then
                exit "$status"
        fi
done
