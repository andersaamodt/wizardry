#!/bin/sh
# spell-menu - Display action menu for a spell or custom command
# Shows options: Cast now, Memorize/Forget, Help, Test spell, Delete (for custom)

set -eu

menu_escape_status=113

# Load colors for display
if command -v colors >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$(command -v colors)"
else
        RESET=''
        CYAN=''
fi

if [ -n "${REQUIRE_COMMAND-}" ]; then
        require_cmd=$REQUIRE_COMMAND
else
        require_cmd=require-command
fi

require_tool() {
        "$require_cmd" "$@"
}

cast_store=${CAST_STORE-memorize-spell}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spell-menu: memorize-spell helper is missing." >&2
        exit 1
fi

resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)

cast_list() {
        "$cast_store" list
}

is_memorized() {
        check_name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$check_name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

do_memorize() {
        mem_name=$1
        shift
        "$cast_store" add "$mem_name" "$@"
}

do_forget() {
        mem_name=$1
        "$cast_store" remove "$mem_name"
}

# Check if a script is a custom spell (exists as executable in spell_home or its subfolders)
is_custom_spell() {
        check_name=$1
        # Check in spell_home root
        script_path="$spell_home/$check_name"
        if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$check_name"
                if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                        return 0
                fi
        done
        # Also check if the command path itself is under spell_home
        cmd_path=$(command -v "$check_name" 2>/dev/null) || return 1
        case "$cmd_path" in
                "$spell_home"*) return 0 ;;
        esac
        return 1
}

remove_custom_spell() {
        cmd_name=$1
        # Check in spell_home root
        script_path="$spell_home/$cmd_name"
        if [ -f "$script_path" ]; then
                rm -f "$script_path"
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$cmd_name"
                if [ -f "$script_path" ]; then
                        rm -f "$script_path"
                        return 0
                fi
        done
        return 1
}

# Check if a spell has an install() function (making it installable)
# Uses the is-installable imp if available, otherwise falls back to inline check
is_installable() {
        spell_cmd=$1
        if command -v is-installable >/dev/null 2>&1; then
                is-installable "$spell_cmd"
                return $?
        fi
        # Fallback: inline check
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        if grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

# Check if a spell has a --help option
has_help_option() {
        spell_cmd=$1
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        # Check if the script contains --help or -h handling
        if grep -Eq '(--help|-h\))' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

usage() {
        cat <<'USAGE'
Usage: spell-menu SPELLNAME
       spell-menu --cast COMMAND
       spell-menu --help-spell COMMAND
       spell-menu --delete NAME
       spell-menu --install COMMAND

Display an action menu for a spell with options to cast, memorize, get help, or delete.

Arguments:
  SPELLNAME        The name of the spell or command to show the menu for
USAGE
}

# Handle action flags (called by menu via subprocess)
case ${1-} in
        --cast)
                shift
                eval "$*"
                exit 0
                ;;
        --help-spell)
                shift
                eval "$* --help" || true
                exit 0
                ;;
        --delete)
                shift
                name=$1
                if remove_custom_spell "$name"; then
                        printf "Erased spell '%s'.\n" "$name"
                else
                        printf "Failed to erase spell '%s'.\n" "$name" >&2
                fi
                exit 0
                ;;
        --install)
                shift
                # The command is already escaped when passed to this handler
                # Run the spell with --install flag to trigger its install() function
                cmd=$1
                # Use eval since command might contain arguments/quotes
                # The caller has already escaped the command properly
                eval "$cmd" --install || true
                exit 0
                ;;
        -h|--help)
                usage
                exit 0
                ;;
esac

if [ "$#" -lt 1 ]; then
        usage >&2
        exit 1
fi

name=$1
# The command is the spell name (which is executable either as scribed command or from PATH)
command=$name

if ! require_tool menu "The spell menu needs the 'menu' command."; then
        exit 1
fi

# Escape single quotes in command for safe passing
escaped_command=$(printf '%s' "$command" | sed "s/'/'\\\\''/g")

first_run=1

while :; do
        if [ "$first_run" -eq 0 ]; then
                printf '\n'
        else
                first_run=0
        fi

        # Show checkbox for Cast menu visibility (toggleable)
        # Use standalone memorize-spell instead of spell-menu flags
        if is_memorized "$name"; then
                cast_toggle="[X] Forget%memorize-spell remove '$name'"
        else
                cast_toggle="[ ] Memorize%memorize-spell add '$name'"
        fi
        # Build menu items - Cast now runs the command directly (using escaped version for safety)
        exit_label=$(exit-label)
        exit_item="${exit_label}%exit $menu_escape_status"
        
        # Check if spell has --help option
        help_item=""
        if has_help_option "$command"; then
                help_item="Help%$escaped_command --help"
        fi
        
        if is_custom_spell "$name"; then
                # Custom spells (in ~/.spellbook or subfolders) show Erase spell option
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "Erase spell%spell-menu --delete '$name'" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Erase spell%spell-menu --delete '$name'" "$exit_item"
                fi
        elif is_installable "$command"; then
                # Show Learn option for spells with install() function
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$exit_item"
                fi
        else
                # Built-in spells: no Erase option
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$exit_item"
                fi
        fi
        
        MENU_ESCAPE_STATUS=$menu_escape_status menu "Spell: $name" "$@"
        status=$?
        if [ "$status" -eq "$menu_escape_status" ]; then
                break
        fi
        if [ "$status" -ne 0 ]; then
                exit "$status"
        fi
done
