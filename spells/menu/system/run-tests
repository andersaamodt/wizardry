#!/usr/bin/env bash
# shellcheck disable=SC2016

# Run the wizardry shell test suite in a bubblewrap sandbox.
# The suite discovers test_*.sh and test_*.bats scripts under tests/
# and executes each one. Bubblewrap keeps the host safe from accidental
# writes while tests exercise spells.

set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: run-tests [options]

Execute the behavior-driven shell tests located in tests/.
Each test_*.sh script runs inside bubblewrap to prevent host
modifications.

Options:
  --only PATTERN   Run test scripts matching the glob PATTERN relative
                   to tests/. May be repeated. When omitted, every
                   test_*.sh file runs.
  --list           Print the resolved test files and exit without running.
  -h, --help       Show this help and exit.
USAGE
}

# Resolve repository paths relative to this spell's location.
SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
ROOT_DIR=$(CDPATH= cd -- "$SCRIPT_DIR/../../.." && pwd -P)
TEST_DIR="$ROOT_DIR/tests"
BATS_BIN=""

# Ensure bubblewrap is available before running anything.
if ! command -v bwrap >/dev/null 2>&1; then
  echo "bubblewrap missing; attempting installation via install-bwrap"
  if ! "$ROOT_DIR/spells/menu/install/core/install-bwrap"; then
    echo "run-tests: failed to install bubblewrap" >&2
    exit 1
  fi
fi

declare -a only_patterns=()
list_only=0

shopt -s nullglob globstar

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "run-tests: --only requires a pattern" >&2
        usage
        exit 1
      fi
      only_patterns+=("$2")
      shift 2
      ;;
    --list)
      list_only=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "run-tests: unknown option '$1'" >&2
      usage
      exit 1
      ;;
  esac
done

spell_path_for_test() {
  local test_file=$1
  local rel=${test_file#"$TEST_DIR/"}
  local dir base
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$ROOT_DIR" "spells/$dir" "$base"
}

is_spell_bats_test() {
  local test_file=$1
  local sibling_sh=${test_file%.bats}.sh
  if [ -f "$sibling_sh" ]; then
    return 1
  fi
  local spell_path
  spell_path=$(spell_path_for_test "$test_file")
  [ -f "$spell_path" ]
}

select_tests() {
  if [ ${#only_patterns[@]} -eq 0 ]; then
    for file in "$TEST_DIR"/**/test_*.sh "$TEST_DIR"/**/test_*.bats; do
      [[ $file == */lib/* ]] && continue
      case "$file" in
        *.bats)
          is_spell_bats_test "$file" || continue
          ;;
      esac
      [ -f "$file" ] && printf '%s\n' "$file"
    done
    return 0
  fi

  for pattern in "${only_patterns[@]}"; do
    if [[ $pattern == /* ]]; then
      matches=($pattern)
    else
      matches=("$TEST_DIR"/**/$pattern)
    fi
    if [ ${#matches[@]} -eq 0 ]; then
      echo "run-tests: pattern '$pattern' matched no tests" >&2
      exit 1
    fi
    for match in "${matches[@]}"; do
      [[ $match == */lib/* ]] && continue
      case "$match" in
        *.bats)
          is_spell_bats_test "$match" || continue
          ;;
      esac
      if [ ! -f "$match" ]; then
        echo "run-tests: resolved '$match' is not a file" >&2
        exit 1
      fi
      printf '%s\n' "$match"
    done
  done
}

mapfile -t test_files < <(select_tests | sort -u)

if [ ${#test_files[@]} -eq 0 ]; then
  echo "run-tests: no tests discovered." >&2
  exit 1
fi

if [ "$list_only" -eq 1 ]; then
  for test in "${test_files[@]}"; do
    rel=${test#"$ROOT_DIR/"}
    printf '%s\n' "$rel"
  done
  exit 0
fi

status=0
pass_scripts=0
fail_scripts=0
for test in "${test_files[@]}"; do
  echo "Running ${test#"$ROOT_DIR/"}"
  case "$test" in
    *.bats)
      if [ -z "$BATS_BIN" ]; then
        if ! BATS_BIN=$("$TEST_DIR/lib/ensure_bats.sh"); then
          echo "run-tests: failed to ensure bats" >&2
          exit 1
        fi
      fi
      bats_lib_path="$TEST_DIR:$TEST_DIR/test_helper:$TEST_DIR/vendor"
      if ! BATS_LIB_PATH="$bats_lib_path" "$BATS_BIN" "$test"; then
        status=1
        fail_scripts=$((fail_scripts + 1))
      else
        pass_scripts=$((pass_scripts + 1))
      fi
      ;;
    *)
      if ! sh "$test"; then
        status=1
        fail_scripts=$((fail_scripts + 1))
      else
        pass_scripts=$((pass_scripts + 1))
      fi
      ;;
  esac
  echo
done

total_scripts=$((pass_scripts + fail_scripts))
if [ "$total_scripts" -gt 0 ]; then
  if [ "$fail_scripts" -gt 0 ]; then
    echo "Test summary: $fail_scripts failed, $pass_scripts passed ($total_scripts total)"
  else
    echo "Test summary: all $pass_scripts test scripts passed"
  fi
fi

exit $status
