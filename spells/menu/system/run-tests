#!/usr/bin/env bash
# shellcheck disable=SC2016

# Run the wizardry shell test suite in a bubblewrap sandbox.
#
# Philosophy
# ----------
# * Keep the host safe: tests run inside bubblewrap when available.
# * Be predictable: discover tests from the repository layout rather
#   than a hard-coded list.
# * Report clearly: colorize output when possible, indent sub-test
#   output, and summarize both pass/fail counts and coverage stats.
#
# What this spell does
# --------------------
# 1. Gather every test_*.sh file under tests/ (unless narrowed with
#    --only), skipping helper directories.
# 2. Ensure bubblewrap is available.
# 3. Run each script, indenting its output and printing a per-script
#    PASS/FAIL summary.
# 4. Scan spells/ for scripts without matching tests and print coverage
#    totals.
#
# The goal is clarity over cleverness, so novice bash developers can
# follow the control flow without surprises.

set -euo pipefail

# Optional ANSI styling for human-friendly output.
# NO_COLOR and dumb terminals disable decoration.

if [ -n "${NO_COLOR:-}" ] || [ "${TERM:-dumb}" = "dumb" ]; then
  BOLD=""; RED=""; GREEN=""; YELLOW=""; RESET=""
else
  BOLD="\033[1m"
  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  RESET="\033[0m"
fi

# usage: print inline help text.
usage() {
  cat <<'USAGE'
Usage: run-tests [options]

Execute the behavior-driven shell tests located in tests/.
Each test_*.sh script runs inside bubblewrap to prevent host
modifications.

Options:
  --only PATTERN   Run test scripts matching the glob PATTERN relative
                   to tests/. May be repeated. When omitted, every
                   test_*.sh file runs.
  --list           Print the resolved test files and exit without running.
  -h, --help       Show this help and exit.
USAGE
}

# Resolve repository paths relative to this spell's location so callers
# can execute the script from anywhere.
SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
ROOT_DIR=$(CDPATH= cd -- "$SCRIPT_DIR/../../.." && pwd -P)
TEST_DIR="$ROOT_DIR/tests"
uncovered_spells=()
coverage_total=0
coverage_covered=0

# Ensure bubblewrap is available before running anything; tests assume
# filesystem isolation unless overridden externally.
if ! command -v bwrap >/dev/null 2>&1; then
  echo "bubblewrap missing; attempting installation via install-bwrap"
  if ! "$ROOT_DIR/spells/menu/install/core/install-bwrap"; then
    echo "run-tests: failed to install bubblewrap" >&2
    exit 1
  fi
fi

# Detect whether bubblewrap will actually be used during tests. Mirror the
# logic in tests/lib/test_common.sh so the summary here matches the behavior
# inside each test script.
BWRAP_AVAILABLE=1
BWRAP_VIA_SUDO=0
BWRAP_USE_UNSHARE=1

if ! command -v bwrap >/dev/null 2>&1; then
  BWRAP_AVAILABLE=0
  BWRAP_REASON="bubblewrap not installed"
elif bwrap --unshare-user-try --ro-bind / / /bin/true 2>/dev/null; then
  :
elif command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
  if sudo -n bwrap --unshare-user-try --ro-bind / / /bin/true 2>/dev/null; then
    BWRAP_VIA_SUDO=1
  elif sudo -n bwrap --ro-bind / / /bin/true 2>/dev/null; then
    BWRAP_VIA_SUDO=1
    BWRAP_USE_UNSHARE=0
  else
    BWRAP_AVAILABLE=0
    BWRAP_REASON="bubblewrap unusable even via sudo"
  fi
else
  BWRAP_AVAILABLE=0
  BWRAP_REASON="bubblewrap unusable (user namespaces likely disabled)"
fi

if [ "$BWRAP_AVAILABLE" -eq 1 ]; then
  if [ "$BWRAP_VIA_SUDO" -eq 1 ]; then
    sudo_label="yes"
  else
    sudo_label="no"
  fi

  if [ "$BWRAP_USE_UNSHARE" -eq 1 ]; then
    unshare_label="yes"
  else
    unshare_label="no"
  fi

  printf '%sUsing bubblewrap sandbox (sudo=%s, unshare=%s)%s\n' \
    "$YELLOW" "$sudo_label" "$unshare_label" "$RESET"
else
  printf '%sWARNING: running tests without bubblewrap: %s%s\n' \
    "$YELLOW" "$BWRAP_REASON" "$RESET" >&2
fi

declare -a only_patterns=()
list_only=0

shopt -s nullglob globstar

# Parse command-line options. Keep the interface tiny: --only filters,
# --list shows resolution, and --help prints usage.
while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "run-tests: --only requires a pattern" >&2
        usage
        exit 1
      fi
      only_patterns+=("$2")
      shift 2
      ;;
    --list)
      list_only=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "run-tests: unknown option '$1'" >&2
      usage
      exit 1
      ;;
  esac
done

# spell_path_for_test: map tests/foo/test_bar.sh -> spells/foo/bar
spell_path_for_test() {
  local test_file=$1
  local rel=${test_file#"$TEST_DIR/"}
  local dir base
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$ROOT_DIR" "spells/$dir" "$base"
}

# find_matching_test_for_spell: locate a test script for a spell path,
# preferring shell tests and falling back to Bats when no shell sibling
# exists.
find_matching_test_for_spell() {
  local spell=$1
  local rel=${spell#"$ROOT_DIR/"}
  rel=${rel#spells/}
  local dir base
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  local candidate_sh="$TEST_DIR/$dir/test_${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi

  return 1
}

# scan_coverage: walk spells/ and record which spells lack matching
# tests. Coverage in this context measures test presence, not lines.
scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=()

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$ROOT_DIR/"}
    case "$rel" in
      spells/menu/system/run-tests)
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null; then
      coverage_covered=$((coverage_covered + 1))
    else
      uncovered_spells+=("$rel")
    fi
  done < <(cd "$ROOT_DIR" && find spells -type f | sort)
}

# select_tests: choose test files according to --only filters (if any),
# skipping helper folders. Returns a sorted list of paths.
select_tests() {
  if [ ${#only_patterns[@]} -eq 0 ]; then
    for file in "$TEST_DIR"/**/test_*.sh; do
      [[ $file == */lib/* ]] && continue
      [ -f "$file" ] && printf '%s\n' "$file"
    done
    return 0
  fi

  for pattern in "${only_patterns[@]}"; do
    if [[ $pattern == /* ]]; then
      matches=($pattern)
    else
      matches=("$TEST_DIR"/**/$pattern)
    fi
    if [ ${#matches[@]} -eq 0 ]; then
      echo "run-tests: pattern '$pattern' matched no tests" >&2
      exit 1
    fi
    for match in "${matches[@]}"; do
      [[ $match == */lib/* ]] && continue
      if [ ! -f "$match" ]; then
        echo "run-tests: resolved '$match' is not a file" >&2
        exit 1
      fi
      printf '%s\n' "$match"
    done
  done
}

# Finalize the list of test files.
mapfile -t test_files < <(select_tests | sort -u)

if [ ${#test_files[@]} -eq 0 ]; then
  echo "run-tests: no tests discovered." >&2
  exit 1
fi

# Listing mode prints resolved test paths and exits early.
if [ "$list_only" -eq 1 ]; then
  for test in "${test_files[@]}"; do
    rel=${test#"$ROOT_DIR/"}
    printf '%s\n' "$rel"
  done
  exit 0
fi

status=0
pass_scripts=0
fail_scripts=0
# Execute each test script, indenting its output for readability and
# tallying pass/fail counts per script (not per individual assertion).
for test in "${test_files[@]}"; do
  rel_path=${test#"$ROOT_DIR/"}
  printf '%sRunning %s%s\n' "$BOLD" "$rel_path" "$RESET"
  if output=$(sh "$test" 2>&1); then
    pass_scripts=$((pass_scripts + 1))
    printf '%s\n' "$output" | sed 's/^/  /'
  else
    status=1
    fail_scripts=$((fail_scripts + 1))
    printf '%s\n' "$output" | sed 's/^/  /'
  fi
done

# After execution, compute coverage stats to identify spells lacking
# tests. This intentionally runs even if earlier scripts failed so the
# summary stays informative.
scan_coverage

total_scripts=$((pass_scripts + fail_scripts))
coverage_uncovered=$((coverage_total - coverage_covered))
printf 'Test summary: %s%d passed%s, %s%d failed%s, %s%d uncovered%s\n' \
  "$GREEN" "$pass_scripts" "$RESET" \
  "$RED" "$fail_scripts" "$RESET" \
  "$YELLOW" "$coverage_uncovered" "$RESET"
if [ "$coverage_uncovered" -gt 0 ]; then
  for spell in "${uncovered_spells[@]}"; do
    printf '  - %s%s%s\n' "$YELLOW" "$spell" "$RESET"
  done
fi

exit $status
