#!/usr/bin/env bash
# shellcheck disable=SC2016

# Run the wizardry shell test suite in a bubblewrap sandbox.
#
# Philosophy
# ----------
# * Keep the host safe: tests run inside bubblewrap when available.
# * Be predictable: discover tests from the repository layout rather
#   than a hard-coded list.
# * Report clearly: colorize output when possible, indent sub-test
#   output, and summarize both pass/fail counts and coverage stats.
#
# What this spell does
# --------------------
# 1. Gather every test_*.sh and test_*.bats file under tests/ (unless
#    narrowed with --only), skipping helper directories.
# 2. Ensure bubblewrap (and Bats for .bats files) is available.
# 3. Run each script, indenting its output and printing a per-script
#    PASS/FAIL summary.
# 4. Scan spells/ for scripts without matching tests and print coverage
#    totals.
#
# The goal is clarity over cleverness, so novice bash developers can
# follow the control flow without surprises.

set -euo pipefail

# Optional ANSI styling for human-friendly output.
# NO_COLOR and dumb terminals disable decoration.

if [ -n "${NO_COLOR:-}" ] || [ "${TERM:-dumb}" = "dumb" ]; then
  BOLD=""; RED=""; GREEN=""; YELLOW=""; RESET=""
else
  BOLD="\033[1m"
  RED="\033[31m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  RESET="\033[0m"
fi

# usage: print inline help text.
usage() {
  cat <<'USAGE'
Usage: run-tests [options]

Execute the behavior-driven shell tests located in tests/.
Each test_*.sh script runs inside bubblewrap to prevent host
modifications.

Options:
  --only PATTERN   Run test scripts matching the glob PATTERN relative
                   to tests/. May be repeated. When omitted, every
                   test_*.sh file runs.
  --list           Print the resolved test files and exit without running.
  -h, --help       Show this help and exit.
USAGE
}

# Resolve repository paths relative to this spell's location so callers
# can execute the script from anywhere.
SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
ROOT_DIR=$(CDPATH= cd -- "$SCRIPT_DIR/../../.." && pwd -P)
TEST_DIR="$ROOT_DIR/tests"
BATS_BIN=""
uncovered_spells=()
coverage_total=0
coverage_covered=0

# Ensure bubblewrap is available before running anything; tests assume
# filesystem isolation unless overridden externally.
if ! command -v bwrap >/dev/null 2>&1; then
  echo "bubblewrap missing; attempting installation via install-bwrap"
  if ! "$ROOT_DIR/spells/menu/install/core/install-bwrap"; then
    echo "run-tests: failed to install bubblewrap" >&2
    exit 1
  fi
fi

declare -a only_patterns=()
list_only=0

shopt -s nullglob globstar

# Parse command-line options. Keep the interface tiny: --only filters,
# --list shows resolution, and --help prints usage.
while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "run-tests: --only requires a pattern" >&2
        usage
        exit 1
      fi
      only_patterns+=("$2")
      shift 2
      ;;
    --list)
      list_only=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "run-tests: unknown option '$1'" >&2
      usage
      exit 1
      ;;
  esac
done

# spell_path_for_test: map tests/foo/test_bar.sh -> spells/foo/bar
spell_path_for_test() {
  local test_file=$1
  local rel=${test_file#"$TEST_DIR/"}
  local dir base
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$ROOT_DIR" "spells/$dir" "$base"
}

# find_matching_test_for_spell: locate a test script for a spell path,
# preferring shell tests and falling back to Bats when no shell sibling
# exists.
find_matching_test_for_spell() {
  local spell=$1
  local rel=${spell#"$ROOT_DIR/"}
  rel=${rel#spells/}
  local dir base
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  local candidate_sh="$TEST_DIR/$dir/test_${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi

  local candidate_bats="$TEST_DIR/$dir/test_${base}.bats"
  if [ -f "$candidate_bats" ] && is_spell_bats_test "$candidate_bats"; then
    printf '%s\n' "$candidate_bats"
    return 0
  fi

  return 1
}

# is_spell_bats_test: true when the .bats file is the sole test for a
# spell (no same-name .sh present) and the spell file exists.
is_spell_bats_test() {
  local test_file=$1
  local sibling_sh=${test_file%.bats}.sh
  if [ -f "$sibling_sh" ]; then
    return 1
  fi
  local spell_path
  spell_path=$(spell_path_for_test "$test_file")
  [ -f "$spell_path" ]
}

# scan_coverage: walk spells/ and record which spells lack matching
# tests. Coverage in this context measures test presence, not lines.
scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=()

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$ROOT_DIR/"}
    case "$rel" in
      spells/menu/system/run-tests)
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null; then
      coverage_covered=$((coverage_covered + 1))
    else
      uncovered_spells+=("$rel")
    fi
  done < <(cd "$ROOT_DIR" && find spells -type f | sort)
}

# select_tests: choose test files according to --only filters (if any),
# skipping helper folders. Returns a sorted list of paths.
select_tests() {
  if [ ${#only_patterns[@]} -eq 0 ]; then
    for file in "$TEST_DIR"/**/test_*.sh "$TEST_DIR"/**/test_*.bats; do
      [[ $file == */lib/* ]] && continue
      case "$file" in
        *.bats)
          is_spell_bats_test "$file" || continue
          ;;
      esac
      [ -f "$file" ] && printf '%s\n' "$file"
    done
    return 0
  fi

  for pattern in "${only_patterns[@]}"; do
    if [[ $pattern == /* ]]; then
      matches=($pattern)
    else
      matches=("$TEST_DIR"/**/$pattern)
    fi
    if [ ${#matches[@]} -eq 0 ]; then
      echo "run-tests: pattern '$pattern' matched no tests" >&2
      exit 1
    fi
    for match in "${matches[@]}"; do
      [[ $match == */lib/* ]] && continue
      case "$match" in
        *.bats)
          is_spell_bats_test "$match" || continue
          ;;
      esac
      if [ ! -f "$match" ]; then
        echo "run-tests: resolved '$match' is not a file" >&2
        exit 1
      fi
      printf '%s\n' "$match"
    done
  done
}

# Finalize the list of test files.
mapfile -t test_files < <(select_tests | sort -u)

if [ ${#test_files[@]} -eq 0 ]; then
  echo "run-tests: no tests discovered." >&2
  exit 1
fi

# Listing mode prints resolved test paths and exits early.
if [ "$list_only" -eq 1 ]; then
  for test in "${test_files[@]}"; do
    rel=${test#"$ROOT_DIR/"}
    printf '%s\n' "$rel"
  done
  exit 0
fi

status=0
pass_scripts=0
fail_scripts=0
# Execute each test script, indenting its output for readability and
# tallying pass/fail counts per script (not per individual assertion).
for test in "${test_files[@]}"; do
  rel_path=${test#"$ROOT_DIR/"}
  printf '%sRunning %s%s\n' "$BOLD" "$rel_path" "$RESET"
  case "$test" in
    *.bats)
      if [ -z "$BATS_BIN" ]; then
        if ! BATS_BIN=$("$TEST_DIR/lib/ensure_bats.sh"); then
          echo "run-tests: failed to ensure bats" >&2
          exit 1
        fi
      fi
      bats_lib_path="$TEST_DIR:$TEST_DIR/test_helper:$TEST_DIR/vendor"
      if output=$(BATS_LIB_PATH="$bats_lib_path" "$BATS_BIN" "$test" 2>&1); then
        pass_scripts=$((pass_scripts + 1))
        printf '%s\n' "$output" | sed 's/^/  /'
      else
        status=1
        fail_scripts=$((fail_scripts + 1))
        printf '%s\n' "$output" | sed 's/^/  /'
      fi
      ;;
    *)
      if output=$(sh "$test" 2>&1); then
        pass_scripts=$((pass_scripts + 1))
        printf '%s\n' "$output" | sed 's/^/  /'
      else
        status=1
        fail_scripts=$((fail_scripts + 1))
        printf '%s\n' "$output" | sed 's/^/  /'
      fi
      ;;
  esac
done

# After execution, compute coverage stats to identify spells lacking
# tests. This intentionally runs even if earlier scripts failed so the
# summary stays informative.
scan_coverage

total_scripts=$((pass_scripts + fail_scripts))
coverage_uncovered=$((coverage_total - coverage_covered))
printf 'Test summary: %s%d passed%s, %s%d failed%s, %s%d uncovered%s\n' \
  "$GREEN" "$pass_scripts" "$RESET" \
  "$RED" "$fail_scripts" "$RESET" \
  "$YELLOW" "$coverage_uncovered" "$RESET"
if [ "$coverage_uncovered" -gt 0 ]; then
  for spell in "${uncovered_spells[@]}"; do
    printf '  - %s%s%s\n' "$YELLOW" "$spell" "$RESET"
  done
fi

exit $status
