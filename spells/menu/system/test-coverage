#!/bin/sh

# Summarize test coverage by matching spells to test scripts.
# Lists every spell alongside a matching test file and reports
# how many subtests each file contains. Optionally runs the
# full test suite first for up-to-date results.

set -eu

usage() {
        cat <<'USAGE'
Usage: test-coverage [--run-tests] [--root DIR]

Report which spells have accompanying test scripts. Optionally run the
shell test suite before reporting coverage.

Options:
  --run-tests     Execute run-tests before calculating coverage.
  --root DIR      Use DIR as the wizardry repository root. Defaults to
                  the repo root relative to this spell.
  -h, --help      Show this help message and exit.
USAGE
}

run_tests=0
ROOT_DIR=$(cd "$(dirname "$0")/../../.." && pwd -P)

while [ "$#" -gt 0 ]; do
        case "$1" in
        --run-tests)
                run_tests=1
                shift
                ;;
        --root)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "test-coverage: --root requires a directory" >&2
                        exit 1
                fi
                ROOT_DIR=$2
                shift 2
                ;;
        -h|--help)
                usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "test-coverage: unknown option '$1'" >&2
                usage
                exit 1
                ;;
        *)
                break
                ;;
        esac
done

SPELLS_DIR="$ROOT_DIR/spells"
TESTS_DIR="$ROOT_DIR/tests"

if [ ! -d "$SPELLS_DIR" ] || [ ! -d "$TESTS_DIR" ]; then
        printf '%s\n' "test-coverage: could not find spells/ or tests/ under $ROOT_DIR" >&2
        exit 1
fi

if [ "$run_tests" -eq 1 ]; then
        if ! (cd "$ROOT_DIR" && "$ROOT_DIR/spells/menu/system/run-tests"); then
                printf '%s\n' "test-coverage: test suite failed" >&2
                exit 1
        fi
fi

# Disable colours on dumb terminals or when NO_COLOR is set so automated
# consumers get plain text.
if [ "${NO_COLOR-}" = "1" ] || [ "${NO_COLOR-}" = "true" ] || [ "${TERM:-}" = "dumb" ]; then
        green=""
        red=""
        reset=""
        ok_marker="[OK]"
        miss_marker="[MISSING]"
else
        green='\033[32m'
        red='\033[31m'
        reset='\033[0m'
        ok_marker="${green}[OK]${reset}"
        miss_marker="${red}[MISSING]${reset}"
fi

test_files() {
        find "$TESTS_DIR" -type f \( -name 'test_*.sh' -o -name 'test_*.bats' \) -print | sort
}

count_subtests() {
        file=$1
        case "$file" in
        *.sh)
                awk '/run_test_case[[:space:]]/ {c++} END{print c+0}' "$file"
                ;;
        *.bats)
                awk '/^[[:space:]]*@test[[:space:]]/ {c++} END{print c+0}' "$file"
                ;;
        *)
                printf '0\n'
                ;;
        esac
}

find_matching_test() {
        rel_name=$1
        case "$rel_name" in
        spells/*)
                rel_name=${rel_name#spells/}
                ;;
        esac
        rel_dir=$(dirname "$rel_name")
        base_name=$(basename "$rel_name")
        for ext in sh bats; do
                candidate="$TESTS_DIR/$rel_dir/test_${base_name}.$ext"
                if [ -f "$candidate" ]; then
                        printf '%s\n' "$candidate"
                        return 0
                fi
        done
        # Fallback: tolerate legacy flat layouts by picking the first
        # reasonable match when an exact mirror path is unavailable.
        best_match=""
        best_score=999999
        spell_token=$(printf '%s' "$base_name" | tr '/-' '_' | sed 's/[^A-Za-z0-9_]/_/g')
        for test in $(test_files); do
                base=$(basename "$test")
                base=${base#test_}
                base=${base%.*}
                if [ "$base" = "$base_name" ] || [ "$base" = "$spell_token" ]; then
                        printf '%s\n' "$test"
                        return 0
                fi
                case "$base" in
                *"$base_name"*|*"$spell_token"*)
                        score=$(( ${#base} - ${#spell_token} ))
                        [ "$score" -lt 0 ] && score=$(( -score ))
                        if [ "$score" -lt "$best_score" ]; then
                                best_match=$test
                                best_score=$score
                        fi
                        ;;
                esac
        done
        if [ -n "$best_match" ]; then
                printf '%s\n' "$best_match"
                return 0
        fi
        return 1
}

spell_count=0
covered=0

spell_list=$(find "$SPELLS_DIR" -type f -print | sort)

while IFS= read -r spell; do
        [ -n "$spell" ] || continue
        rel=${spell#"$ROOT_DIR/"}
        case "$rel" in
        spells/menu/system/run-tests)
                continue
                ;;
        esac
        spell_count=$((spell_count + 1))
        if test_path=$(find_matching_test "$rel"); then
                subtests=$(count_subtests "$test_path")
                covered=$((covered + 1))
                printf '%s %-40s -> %s (%s subtests)\n' "$ok_marker" "$rel" "${test_path#"$ROOT_DIR/"}" "$subtests"
        else
                printf '%s %-40s -> none (0 subtests)\n' "$miss_marker" "$rel"
        fi
done <<SPELLS
$spell_list
SPELLS

if [ "$spell_count" -eq 0 ]; then
        printf '%s\n' "test-coverage: no spells found" >&2
        exit 1
fi

percent=$(awk -v c="$covered" -v t="$spell_count" 'BEGIN { if (t==0) {print "0"} else {printf "%.2f", (c/t)*100} }')
printf '\nCoverage: %s/%s spells with tests (%.2f%%)\n' "$covered" "$spell_count" "$percent"

exit 0
