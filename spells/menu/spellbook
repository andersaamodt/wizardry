#!/bin/sh
# This spell provides a menu interface for managing the spellbook.

require-wizardry || exit 1

show_usage() {
        cat <<'USAGE'
Usage: spellbook [PATH|--memorize NAME CMD|--forget NAME|--scribe NAME CMD|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

ROOT_DIR=$(CDPATH= cd -- "$(dirname "$0")/../.." && pwd -P)

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

cast_store=${CAST_STORE-memorize}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spellbook: memorize helper is missing." >&2
        exit 1
fi

cast_dir=$($cast_store dir)

spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")

if [ -d "$spell_home" ]; then
        PATH="$spell_home:$PATH"
fi

write_scribed_script() {
        script_name=$1
        cmd_text=$2
        script_path="$spell_home/$script_name"
        ensure-parent-dir "$script_path"
        mkdir -p "$spell_home"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$script_path" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$script_path"
}

# Extract the command from a scribed script file
# Returns empty string if not a valid scribed script format
# For non-scribed scripts, returns the command if there's exactly one line of sh code
# (excluding shebang, comments, and whitespace)
extract_command_from_script() {
        script_path=$1
        if [ ! -f "$script_path" ]; then
                return 1
        fi
        # First try to extract from scribed format
        # Scripts are in format: exec sh -c 'COMMAND' "$0" "$@"
        scribed_pattern="s/^exec sh -c '\\(.*\\)' \"\\\$0\" \"\\\$@\"$/\\1/p"
        extracted=$(sed -n "$scribed_pattern" "$script_path")
        result=$(printf '%s\n' "$extracted" | sed "s/'\\\\''/'/g")
        if [ -n "$result" ]; then
                printf '%s' "$result"
                return 0
        fi
        
        # For non-scribed scripts, check if there's exactly one line of code
        # Count meaningful lines (excluding shebang, comments, and whitespace)
        no_blank=$(grep -v '^[[:space:]]*$' "$script_path")
        no_comments=$(printf '%s\n' "$no_blank" | grep -v '^[[:space:]]*#')
        code_lines=$(printf '%s\n' "$no_comments" | wc -l | tr -d ' ')
        if [ "$code_lines" -eq 1 ]; then
                # Return the single code line
                no_blank_lines=$(grep -v '^[[:space:]]*$' "$script_path")
                no_comment_lines=$(printf '%s\n' "$no_blank_lines" | grep -v '^[[:space:]]*#')
                result=$(printf '%s\n' "$no_comment_lines" | head -n 1)
                if [ -n "$result" ]; then
                        printf '%s' "$result"
                        return 0
                fi
        fi
        return 1
}

list_spell_directories() {
        set --
        for dir in "$ROOT_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                [ "$(basename "$dir")" = "menu" ] && continue
                set -- "$@" "$(basename "$dir")"
        done
        printf '%s\n' "$@"
}

# Resolve a category path by searching in multiple locations.
# If the path starts with ./ or /, use it directly.
# Otherwise, search in: spells/, ~/.spellbook, current directory
resolve_category_path() {
        category=$1
        case $category in
                /*|./*)
                        # Absolute or explicit relative path - use directly
                        if [ -d "$category" ]; then
                                printf '%s' "$category"
                                return 0
                        fi
                        return 1
                        ;;
        esac
        # Search in spells/ directory first
        if [ -d "$ROOT_DIR/spells/$category" ]; then
                printf '%s' "$ROOT_DIR/spells/$category"
                return 0
        fi
        # Search in ~/.spellbook (user spell home)
        if [ -d "$spell_home/$category" ]; then
                printf '%s' "$spell_home/$category"
                return 0
        fi
        # Search in current directory
        if [ -d "$category" ]; then
                printf '%s' "$category"
                return 0
        fi
        return 1
}

# List all scribed commands (custom commands in spell_home, excluding built-in spells)
# Only shows truly custom user-created commands, not built-in spells that might have
# been memorized (those should only appear in the Cast menu)
list_scribed_commands() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        # Handle empty directory by checking if glob matches anything
        set +f  # Enable globbing
        for script in "$spell_home"/*; do
                # Skip if glob didn't match (no files exist)
                [ -e "$script" ] || continue
                [ -f "$script" ] || continue
                [ -x "$script" ] || continue
                script_name=$(basename "$script")
                # Skip hidden files and the .memorized file
                case $script_name in
                        .*) continue ;;
                esac
                # Skip if this command exists elsewhere in PATH (it's a built-in spell, not custom)
                if cmd_path=$(command -v "$script_name" 2>/dev/null); then
                        case "$cmd_path" in
                                "$spell_home"/*) 
                                        # Only found in spell_home - this is a custom command
                                        ;;
                                *)
                                        # Found in system PATH - skip this built-in spell
                                        continue
                                        ;;
                        esac
                fi
                cmd_text=$(extract_command_from_script "$script")
                if [ -n "$cmd_text" ]; then
                        printf '%s\t%s\n' "$script_name" "$cmd_text"
                fi
        done
}

# List user folders in ~/.spellbook
# (excluding hidden folders and folders matching built-in categories)
list_user_folders() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        builtin_cats=$(list_spell_directories | sort)
        for folder in "$spell_home"/*; do
                [ -d "$folder" ] || continue
                folder_name=$(basename "$folder")
                # Skip hidden folders
                case $folder_name in
                        .*) continue ;;
                esac
                # Skip folders that match a built-in category
                is_builtin=0
                for cat in $builtin_cats; do
                        if [ "$folder_name" = "$cat" ]; then
                                is_builtin=1
                                break
                        fi
                done
                [ "$is_builtin" -eq 1 ] && continue
                printf '%s\n' "$folder_name"
        done
}

# Check if a custom category folder is empty (no executable files)
is_custom_category_empty() {
        check_path=$1
        # Must be in spell_home to be a custom category
        case "$check_path" in
                "$spell_home"*) ;;
                *) return 1 ;;
        esac
        # Check if directory has any executable files
        if find "$check_path" -maxdepth 1 -type f -perm -111 2>/dev/null | grep -q .; then
                return 1
        fi
        return 0
}

# Delete an empty custom category folder
delete_custom_category() {
        cat_path=$1
        case "$cat_path" in
                "$spell_home"*) ;;
                *) return 1 ;;
        esac
        if [ -d "$cat_path" ]; then
                # Only delete if empty of executable files
                if is_custom_category_empty "$cat_path"; then
                        rm -rf "$cat_path"
                        printf '%s\n' "Deleted category: $(basename "$cat_path")"
                        return 0
                fi
        fi
        return 1
}

record_scribed_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate-name "$cmd_name" "spellbook" || exit 1
        validate-command "$cmd" "spellbook: command" || exit 1
        mkdir -p "$spell_home"
        write_scribed_script "$cmd_name" "$cmd"
}

spellbook_menu() {
        current_path=${1-}
        first_run=1
        while :; do
                if [ "$first_run" -eq 0 ]; then
                        :
                else
                        first_run=0
                fi

                set --
                # Determine the resolved path for non-root views
                resolved_path=""
                in_custom_folder=0
                category_name=""
                if [ -n "$current_path" ]; then
                        # Get the category name (last component of path)
                        category_name=$(basename "$current_path")
                        if resolved_path=$(resolve_category_path "$current_path"); then
                                case "$resolved_path" in
                                        "$spell_home"*) in_custom_folder=1 ;;
                                esac
                        else
                                printf '%s\n' "spellbook: category '$current_path' not found" >&2
                                return 1
                        fi
                fi
                
                # Only show three sections at root level (no path argument)
                if [ -z "$current_path" ]; then
                        # SECTION 1: Individual scribed commands (showing command content)
                        while IFS=$(printf '\t') read -r cmd_name cmd_text; do
                                [ -z "$cmd_name" ] && continue
                                # Show the command text as the label
                                label=$(printf '%s' "$cmd_text")
                                set -- "$@" "$label%spell-menu $cmd_name"
                        done <<SCRIBED_COMMANDS
$(list_scribed_commands)
SCRIBED_COMMANDS
                        
                        # SECTION 2: User folders in ~/.spellbook
                        # (if any exist, excluding those matching built-in)
                        user_folders=$(list_user_folders)
                        if [ -n "$user_folders" ]; then
                                # Add divider between commands and user folders (only if there are items before)
                                if [ "$#" -gt 0 ]; then
                                        set -- "$@" "---"
                                fi
                                while IFS= read -r folder_name; do
                                        [ -z "$folder_name" ] && continue
                                        # Don't capitalize - just use the folder name
                                        set -- "$@" "${folder_name}%spellbook $spell_home/$folder_name"
                                done <<USER_FOLDERS
$user_folders
USER_FOLDERS
                        fi
                        
                        # SECTION 3: Built-in spell categories
                        # Add divider between user folders and built-in categories (only if there are items before)
                        if [ "$#" -gt 0 ]; then
                                set -- "$@" "---"
                        fi
                        for category in $(list_spell_directories | sort); do
                                # Don't capitalize - just use the folder name
                                set -- "$@" "${category}%spellbook $category"
                        done
                else
                        # Non-root view: show spells from both built-in and custom folders combined
                        # First, list built-in spells
                        builtin_dir="$ROOT_DIR/spells/$category_name"
                        custom_dir="$spell_home/$category_name"
                        
                        # List built-in spells
                        if [ -d "$builtin_dir" ]; then
                                builtin_spells=$(find "$builtin_dir" -maxdepth 1 \
                                  -type f -perm -111 2>/dev/null | sort)
                                for spell in $builtin_spells; do
                                        spell_name=$(basename "$spell")
                                        set -- "$@" "${spell_name}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List custom spells from ~/.spellbook/<category> with custom theme color
                        if [ -d "$custom_dir" ]; then
                                custom_spells=$(find "$custom_dir" -maxdepth 1 \
                                  -type f -perm -111 2>/dev/null | sort)
                                for spell in $custom_spells; do
                                        spell_name=$(basename "$spell")
                                        # Use THEME_CUSTOM for custom spell names (distinct from highlight)
                                        set -- "$@" "${THEME_CUSTOM}${spell_name}${RESET}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List subdirectories (only for navigation, shown after spells)
                        if [ -d "$resolved_path" ]; then
                                for subdir in "$resolved_path"/*; do
                                        [ -d "$subdir" ] || continue
                                        subname=$(basename "$subdir")
                                        set -- "$@" "${subname}%spellbook $resolved_path/$subname"
                                done
                        fi
                fi
                
                # Add "Delete category" option for empty custom category folders
                is_current=$([ -n "$current_path" ] && echo "yes" || echo "no")
                is_resolved=$([ -n "$resolved_path" ] && echo "yes" || echo "no")
                is_empty="no"
                if [ "$is_current" = "yes" ] && [ "$is_resolved" = "yes" ]; then
                        is_custom_category_empty "$resolved_path" && is_empty="yes"
                fi
                
                if [ "$is_empty" = "yes" ]; then
                        # Use escaped path in the command
                        escaped_path=$(printf '%s' "$resolved_path" | sed "s/'/'\\\\''/g")
                        set -- "$@" "Delete category%rm -rf '$escaped_path' && kill -TERM \$PPID"
                fi
                
                # Add "New category" at root level (third-to-last item)
                if [ -z "$current_path" ]; then
                        set -- "$@" "New category%scribe-spell --new-category"
                fi
                
                # Add "Scribe new spell" as penultimate menu item
                if [ -z "$current_path" ]; then
                        # Root level - create in ~/.spellbook
                        set -- "$@" "Scribe new spell%scribe-spell"
                else
                        # Category level - create in ~/.spellbook/<category>
                        set -- "$@" "Scribe new spell%scribe-spell --dir $spell_home/$category_name"
                fi
                
                # Use "Back" when in a submenu, "Exit" at root
                if [ -z "$current_path" ]; then
                        exit_label=$(exit-label)
                else
                        exit_label="Back"
                fi
                set -- "$@" "${exit_label}%kill -TERM \$PPID"
                
                # Build menu title - use original folder name for category
                if [ -z "$current_path" ]; then
                        menu_title="Spellbook:"
                else
                        menu_title="${category_name}:"
                fi
                menu "$menu_title" "$@" || true
        done
}

spellbook_path=""

case ${1-} in
        --memorize)
                shift
                if [ "$#" -lt 2 ]; then
                        show_usage >&2
                        exit 1
                fi
                name=$1
                shift
                "$cast_store" add "$name" "$@"
                exit 0
                ;;
        --forget)
                shift
                if [ "$#" -ne 1 ]; then
                        show_usage >&2
                        exit 1
                fi
                "$cast_store" remove "$1"
                exit 0
                ;;
        --list)
                "$cast_store" list
                exit 0
                ;;
        --scribe)
                shift
                if [ "$#" -lt 2 ]; then
                        show_usage >&2
                        exit 1
                fi
                name=$1
                shift
                record_scribed_command "$name" "$@"
                display_path=$(tilde-path "$spell_home")
                printf "Scribed '%s' to %s.\n" "$name" "$display_path"
                exit 0
                ;;
        --interactive-scribe)
                cmd_name=$(read-line "Name: ")
                cmd_text=$(read-line "Command: ")
                if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
                        printf '%s\n' "A name and command are required." >&2
                        exit 1
                fi
                record_scribed_command "$cmd_name" "$cmd_text"
                display_path=$(tilde-path "$spell_home")
                printf "Scribed '%s' to %s.\n" "$cmd_name" "$display_path"
                exit 0
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                spellbook_path=${1-}
                ;;
        "")
                :
                ;;
        -*)
                show_usage >&2
                exit 1
                ;;
        *)
                # Treat as a path to a category
                spellbook_path=$1
                ;;
        esac

if ! require menu "The spellbook menu needs the 'menu' command."; then
        exit 1
fi

spellbook_menu "$spellbook_path"
