#!/bin/sh
# This spell provides a menu interface for managing the spellbook.

set -eu

menu_escape_status=113
ROOT_DIR=$(CDPATH= cd -- "$(dirname "$0")/../.." && pwd -P)

# Load colors for display
if command -v colors >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$(command -v colors)"
else
        RESET=''
        CYAN=''
        PURPLE=''
        YELLOW=''
fi

cast_store=${CAST_STORE-memorize-command}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spellbook: memorize-command helper is missing." >&2
        exit 1
fi

if [ -n "${REQUIRE_COMMAND-}" ]; then
        require_cmd=$REQUIRE_COMMAND
else
        require_cmd=require-command
fi

require_tool() {
        "$require_cmd" "$@"
}

cast_dir=$($cast_store dir)

resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)
commands_file=${SPELLBOOK_COMMANDS_FILE-$spell_home/custom-commands}
custom_spells_dir=${SPELLBOOK_CUSTOM_DIR-$spell_home/custom}

if [ -d "$custom_spells_dir" ]; then
        PATH="$custom_spells_dir:$PATH"
fi

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "spellbook: names may contain only letters, digits, dots, underscores, and dashes." >&2
                exit 1
                ;;
        -*)
                printf '%s\n' "spellbook: names may not begin with a dash." >&2
                exit 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook: command must not be empty." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command may not contain tabs." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command must be a single line." >&2
                exit 1
        fi
}

custom_spell_path() {
        printf '%s/%s' "$custom_spells_dir" "$1"
}

write_custom_script() {
        script_name=$1
        cmd_text=$2
        ensure_parent_dir "$(custom_spell_path "$script_name")"
        mkdir -p "$custom_spells_dir"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$(custom_spell_path "$script_name")" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$(custom_spell_path "$script_name")"
}

list_spell_directories() {
        set --
        for dir in "$ROOT_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                [ "$(basename "$dir")" = "menu" ] && continue
                set -- "$@" "$(basename "$dir")"
        done
        printf '%s\n' "$@"
}

categories() {
        list_spell_directories
        if [ -f "$commands_file" ]; then
                while IFS=$(printf '\t') read -r category _ _ || [ -n "$category" ]; do
                        [ -z "$category" ] && continue
                        printf '%s\n' "$category"
                done <"$commands_file"
        fi | sort -u
}

spell_categories() {
        list_spell_directories | sort
}

# Convert folder name to display name using the category-title imp
category_display_name() {
        folder=$1
        if command -v category-title >/dev/null 2>&1; then
                category-title "$folder"
        else
                # Fallback if imp not available
                case $folder in
                        enchant)
                                printf '%s' "Enchantment"
                                ;;
                        mud)
                                printf '%s' "MUD"
                                ;;
                        mud-admin)
                                printf '%s' "MUD Admin"
                                ;;
                        *)
                                # Capitalize first letter
                                first=$(printf '%s' "$folder" | cut -c1 | tr '[:lower:]' '[:upper:]')
                                rest=$(printf '%s' "$folder" | cut -c2-)
                                printf '%s%s' "$first" "$rest"
                                ;;
                esac
        fi
}

# Convert filename to display name: hyphens to spaces, titlecase
filename_to_display() {
        name=$1
        # Convert hyphens to spaces and titlecase each word
        printf '%s' "$name" | awk '{gsub(/-/," "); for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1))tolower(substr($i,2))}}1'
}

safe_command_label() {
        filename=$1
        printf '%s' "$(filename_to_display "$filename")"
}

command_for_spell() {
        spell_path=$1
        name=$(basename "$spell_path")
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s' "$name"
        else
                printf '%s' "$spell_path"
        fi
}

# Resolve a category path by searching in multiple locations.
# If the path starts with ./ or /, use it directly.
# Otherwise, search in: spells/, ~/.spellbook, current directory
resolve_category_path() {
        category=$1
        case $category in
                /*|./*)
                        # Absolute or explicit relative path - use directly
                        if [ -d "$category" ]; then
                                printf '%s' "$category"
                                return 0
                        fi
                        return 1
                        ;;
        esac
        # Search in spells/ directory first
        if [ -d "$ROOT_DIR/spells/$category" ]; then
                printf '%s' "$ROOT_DIR/spells/$category"
                return 0
        fi
        # Search in ~/.spellbook (user spell home)
        if [ -d "$spell_home/$category" ]; then
                printf '%s' "$spell_home/$category"
                return 0
        fi
        # Search in current directory
        if [ -d "$category" ]; then
                printf '%s' "$category"
                return 0
        fi
        return 1
}

list_category_spells() {
        cat_name=$1
        # Use resolve_category_path to find the actual directory
        resolved_path=$(resolve_category_path "$cat_name") || resolved_path="$ROOT_DIR/spells/$cat_name"
        find "$resolved_path" -maxdepth 2 -type f -perm -111 2>/dev/null | sort
}

list_custom_commands() {
        cat_name=$1
        if [ ! -f "$commands_file" ]; then
                return 0
        fi
        while IFS=$(printf '\t') read -r category name command || [ -n "$category" ]; do
                [ -z "$category" ] && continue
                if [ "$category" = "$cat_name" ]; then
                        printf '%s\t%s\t%s\n' "$category" "$name" "$command"
                fi
        done <"$commands_file"
}

list_all_custom_commands() {
        if [ ! -f "$commands_file" ]; then
                return 0
        fi
        while IFS=$(printf '\t') read -r category name command || [ -n "$category" ]; do
                [ -z "$category" ] && continue
                [ -z "$name" ] && continue
                printf '%s\t%s\t%s\n' "$category" "$name" "$command"
        done <"$commands_file"
}

is_custom_command() {
        check_category=$1
        check_name=$2
        if [ ! -f "$commands_file" ]; then
                return 1
        fi
        while IFS=$(printf '\t') read -r category name command || [ -n "$category" ]; do
                [ -z "$category" ] && continue
                if [ "$category" = "$check_category" ] && [ "$name" = "$check_name" ]; then
                        return 0
                fi
        done <"$commands_file"
        return 1
}

record_custom_command() {
        cat_name=$1
        cmd_name=$2
        shift 2
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name"
        validate_command "$cmd"
        ensure_parent_dir "$commands_file"
        mkdir -p "$custom_spells_dir"
        write_custom_script "$cmd_name" "$cmd"
        tmp=$(mktemp "${TMPDIR:-/tmp}/spellbook-commands.XXXXXX") || exit 1
        if [ -f "$commands_file" ]; then
                while IFS= read -r line || nonempty "$line"; do
                        entry_category=${line%%$(printf '\t')*}
                        case $line in
                        *$(printf '\t')*)
                                entry_rest=${line#*$(printf '\t')}
                                entry_name=${entry_rest%%$(printf '\t')*}
                                ;;
                        *)
                                entry_name=''
                                ;;
                        esac
                        if [ "$entry_category" = "$cat_name" ] && [ "$entry_name" = "$cmd_name" ]; then
                                continue
                        fi
                        printf '%s\n' "$line" >>"$tmp"
                done <"$commands_file"
        fi
        printf '%s\t%s\t%s\n' "$cat_name" "$cmd_name" "$cmd" >>"$tmp"
        mv "$tmp" "$commands_file"
}

remove_custom_command() {
        cat_name=$1
        cmd_name=$2
        [ -f "$commands_file" ] || return 1
        tmp=$(mktemp "${TMPDIR:-/tmp}/spellbook-commands.XXXXXX") || exit 1
        kept=0
        removed=0
        while IFS= read -r line || nonempty "$line"; do
                        entry_category=${line%%$(printf '\t')*}
                        case $line in
                        *$(printf '\t')*)
                                entry_rest=${line#*$(printf '\t')}
                                entry_name=${entry_rest%%$(printf '\t')*}
                                ;;
                        *)
                                entry_name=''
                                ;;
                        esac
                        if [ "$entry_category" = "$cat_name" ] && [ "$entry_name" = "$cmd_name" ]; then
                                removed=1
                                continue
                        fi
                        kept=1
                        printf '%s\n' "$line" >>"$tmp"
        done <"$commands_file"
        mv "$tmp" "$commands_file"
        rm -f "$(custom_spell_path "$cmd_name")"
        if [ "$kept" -eq 0 ] && [ ! -s "$commands_file" ]; then
                rm -f "$commands_file"
        fi
        [ "$removed" -eq 1 ]
}

cast_list() {
        "$cast_store" list
}

is_memorized() {
        name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

memorize_spell() {
        name=$1
        shift
        "$cast_store" add "$name" "$@"
}

forget_spell() {
        name=$1
        "$cast_store" remove "$name"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt"
        IFS= read -r value
        printf '%s' "$value"
}

scribe_command() {
        cat_name=$(prompt_for_input "Category: ")
        cmd_name=$(prompt_for_input "Name: ")
        cmd_text=$(prompt_for_input "Command: ")
        if [ -z "$cat_name" ] || [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
                printf '%s\n' "A category, name, and command are required." >&2
                return 1
        fi
        record_custom_command "$cat_name" "$cmd_name" "$cmd_text"
        printf "Scribed '%s' into %s.\n" "$cmd_name" "$cat_name"
        printf "Custom spells live in %s (add it to PATH to run by name).\n" "$custom_spells_dir"
}

spell_action_menu() {
        category=$1
        name=$2
        command=$3
        display_command=${4-$command}
        action=''
        while :; do
                if is_memorized "$name"; then
                        memory_toggle="Forget%action=forget"
                else
                        memory_toggle="Memorize%action=memorize"
                fi
                if is_custom_command "$category" "$name"; then
                        set -- "Cast now%action=cast" "$memory_toggle" "Help%action=help" "Test spell%action=test" "Delete command%action=delete" "Back%exit $menu_escape_status"
                else
                        set -- "Cast now%action=cast" "$memory_toggle" "Help%action=help" "Test spell%action=test" "Back%exit $menu_escape_status"
                fi
                MENU_ESCAPE_STATUS=$menu_escape_status menu "Spell: $name" "$@"
                status=$?
                if [ "$status" -eq "$menu_escape_status" ]; then
                        break
                fi
                case ${action-} in
                cast)
                        eval "$command"
                        ;;
                memorize)
                        memorize_spell "$name" "$command"
                        ;;
                forget)
                        if is_memorized "$name"; then
                                forget_spell "$name"
                        fi
                        ;;
                help)
                        eval "$command --help" || true
                        ;;
                test)
                        if command -v test-magic >/dev/null 2>&1; then
                                test-magic --only "$name" || true
                        else
                                printf '%s\n' "test-magic is unavailable; cannot test $name." >&2
                        fi
                        ;;
                delete)
                        if is_custom_command "$category" "$name"; then
                                if remove_custom_command "$category" "$name"; then
                                        printf "Deleted custom command '%s' from category '%s'.\n" "$name" "$category"
                                        break
                                else
                                        printf "Failed to delete custom command '%s'.\n" "$name" >&2
                                fi
                        fi
                        ;;
                esac
                action=''
        done
}

category_menu() {
        category=$1
        display_name=$(category_display_name "$category")
        while :; do
                set --
                for spell in $(list_category_spells "$category"); do
                        spell_name=$(basename "$spell")
                        cmd=$(command_for_spell "$spell")
                        set -- "$@" "$(safe_command_label "$spell_name")%selected_name='$spell_name';selected_cmd='$cmd';selected_display='$cmd'"
                done
                while IFS=$(printf '\t') read -r _ custom_name custom_cmd; do
                        [ -z "$custom_name" ] && continue
                        spell_path=$(custom_spell_path "$custom_name")
                        command_value=$spell_path
                        set -- "$@" "$(safe_command_label "$custom_name")%selected_name='$custom_name';selected_cmd='$command_value';selected_display='$custom_cmd'"
                done <<CUSTOM
$(list_custom_commands "$category")
CUSTOM
                exit_label=$(exit-label)
                set -- "$@" "${exit_label}%exit $menu_escape_status"
                selected_name=''
                selected_cmd=''
                selected_display=''
                MENU_ESCAPE_STATUS=$menu_escape_status menu "$display_name:" "$@"
                status=$?
                if [ "$status" -eq "$menu_escape_status" ]; then
                        break
                fi
                if [ -n "$selected_name" ] && [ -n "$selected_cmd" ]; then
                        spell_action_menu "$category" "$selected_name" "$selected_cmd" "$selected_display"
                fi
                printf '\n'
        done
}

spellbook_menu() {
        current_path=${1-}
        while :; do
                set --
                # Only show custom commands, scribe option, and divider at root level
                if [ -z "$current_path" ]; then
                        # First, add individual saved custom commands
                        while IFS=$(printf '\t') read -r cmd_category cmd_name cmd_text; do
                                [ -z "$cmd_category" ] && continue
                                [ -z "$cmd_name" ] && continue
                                spell_path=$(custom_spell_path "$cmd_name")
                                label=$(printf '%s (%s)' "$cmd_name" "$cmd_category")
                                set -- "$@" "$(safe_command_label "$label")%spell-menu $cmd_category $cmd_name $spell_path"
                        done <<CUSTOM_COMMANDS
$(list_all_custom_commands)
CUSTOM_COMMANDS
                        # Add "Scribe new spell" option
                        set -- "$@" "Scribe Spell%spellbook --interactive-scribe"
                        # Add divider between custom commands and categories
                        set -- "$@" "%--divider--"
                fi
                # Then, add spell categories or subfolders
                if [ -z "$current_path" ]; then
                        # Root: show spell categories
                        for category in $(spell_categories); do
                                display_name=$(category_display_name "$category")
                                set -- "$@" "${display_name}%spellbook $category"
                        done
                else
                        # Category view: show spells and subfolders in this category
                        if ! resolved_path=$(resolve_category_path "$current_path"); then
                                printf '%s\n' "spellbook: category '$current_path' not found" >&2
                                return 1
                        fi
                        # List executable spells in this directory
                        for spell in $(find "$resolved_path" -maxdepth 1 -type f -perm -111 2>/dev/null | sort); do
                                spell_name=$(basename "$spell")
                                cmd=$(command_for_spell "$spell")
                                set -- "$@" "$(safe_command_label "$spell_name")%spell-menu $current_path $spell_name $cmd"
                        done
                        # List subdirectories
                        for subdir in "$resolved_path"/*; do
                                [ -d "$subdir" ] || continue
                                subname=$(basename "$subdir")
                                display_name=$(category_display_name "$subname")
                                set -- "$@" "${display_name}%spellbook $current_path/$subname"
                        done
                fi
                # Use "Back" when in a submenu, "Exit" at root
                if [ -z "$current_path" ]; then
                        exit_label=$(exit-label)
                else
                        exit_label="Back"
                fi
                set -- "$@" "${exit_label}%exit $menu_escape_status"
                if [ -z "$current_path" ]; then
                        menu_title="${CYAN}Spellbook:${RESET}"
                else
                        current_display=$(category_display_name "$(basename "$current_path")")
                        menu_title="${CYAN}Spellbook${RESET} > ${YELLOW}${current_display}${RESET}:"
                fi
                MENU_ESCAPE_STATUS=$menu_escape_status menu "$menu_title" "$@"
                status=$?
                if [ "$status" -eq "$menu_escape_status" ]; then
                        break
                fi
                printf '\n'
        done
}

usage() {
        cat <<'USAGE'
Usage: spellbook [PATH|--memorize NAME COMMAND...|--forget NAME|--list|--scribe CATEGORY NAME COMMAND...|--interactive-scribe]

Without arguments, opens the interactive spellbook to browse categories,
scribe commands, and manage the cast menu.

With a PATH argument (e.g., 'arcane' or 'install/core'), opens the spellbook
directly to that category. PATH is resolved by searching in:
  1. $WIZARDRY_ROOT/spells/ (wizardry installation)
  2. ~/.spellbook/ (user spell home)
  3. Current directory

Use './category' to search only in the current directory.

Options:
  --interactive-scribe  Prompt for category, name, and command to scribe a new spell.
  --scribe CATEGORY NAME COMMAND...  Scribe a new custom command directly.
  --memorize NAME COMMAND...  Add a spell to the cast menu.
  --forget NAME  Remove a spell from the cast menu.
  --list  Show the stored spells.

Custom commands are stored as executable spells under the user spell home
(default: ~/.spellbook/custom or $XDG_DATA_HOME/wizardry/spellbook/custom).
USAGE
}

spellbook_path=""

case ${1-} in
        --memorize)
                shift
                if [ "$#" -lt 2 ]; then
                        usage >&2
                        exit 1
                fi
                name=$1
                shift
                memorize_spell "$name" "$@"
                exit 0
                ;;
        --forget)
                shift
                if [ "$#" -ne 1 ]; then
                        usage >&2
                        exit 1
                fi
                forget_spell "$1"
                exit 0
                ;;
        --list)
                cast_list
                exit 0
                ;;
        --scribe)
                shift
                if [ "$#" -lt 3 ]; then
                        usage >&2
                        exit 1
                fi
                category=$1
                shift
                name=$1
                shift
                record_custom_command "$category" "$name" "$@"
                printf "Scribed '%s' into %s.\n" "$name" "$category"
                printf "Custom spells live in %s (add it to PATH to run by name).\n" "$custom_spells_dir"
                exit 0
                ;;
        --interactive-scribe)
                scribe_command
                exit $?
                ;;
        --help|-h)
                usage
                exit 0
                ;;
        --)
                shift
                spellbook_path=${1-}
                ;;
        "")
                :
                ;;
        -*)
                usage >&2
                exit 1
                ;;
        *)
                # Treat as a path to a category
                spellbook_path=$1
                ;;
        esac

if ! require_tool menu "The spellbook menu needs the 'menu' command."; then
        exit 1
fi

spellbook_menu "$spellbook_path"
