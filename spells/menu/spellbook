#!/bin/sh
# This spell provides a menu interface for managing the spellbook.

set -eu

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

ROOT_DIR=$(CDPATH= cd -- "$(dirname "$0")/../.." && pwd -P)

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

cast_store=${CAST_STORE-memorize}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spellbook: memorize helper is missing." >&2
        exit 1
fi

cast_dir=$($cast_store dir)

resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)

if [ -d "$spell_home" ]; then
        PATH="$spell_home:$PATH"
fi

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "spellbook: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                exit 1
                ;;
        -*)
                printf '%s\n' "spellbook: names may not begin with a dash." >&2
                exit 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook: command must not be empty." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command may not contain tabs." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command must be a single line." >&2
                exit 1
        fi
}

scribed_spell_path() {
        printf '%s/%s' "$spell_home" "$1"
}

write_scribed_script() {
        script_name=$1
        cmd_text=$2
        ensure_parent_dir "$(scribed_spell_path "$script_name")"
        mkdir -p "$spell_home"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$(scribed_spell_path "$script_name")" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$(scribed_spell_path "$script_name")"
}

# Extract the command from a scribed script file
# Returns empty string if not a valid scribed script format
# For non-scribed scripts, returns the command if there's exactly one line of sh code
# (excluding shebang, comments, and whitespace)
extract_command_from_script() {
        script_path=$1
        if [ ! -f "$script_path" ]; then
                return 1
        fi
        # First try to extract from scribed format
        # Scripts are in format: exec sh -c 'COMMAND' "$0" "$@"
        result=$(sed -n "s/^exec sh -c '\\(.*\\)' \"\\\$0\" \"\\\$@\"$/\\1/p" "$script_path" | sed "s/'\\\\''/'/g")
        if [ -n "$result" ]; then
                printf '%s' "$result"
                return 0
        fi
        
        # For non-scribed scripts, check if there's exactly one line of code
        # Count meaningful lines (excluding shebang, comments, and whitespace)
        code_lines=$(grep -v '^[[:space:]]*$' "$script_path" | grep -v '^[[:space:]]*#' | wc -l | tr -d ' ')
        if [ "$code_lines" -eq 1 ]; then
                # Return the single code line
                result=$(grep -v '^[[:space:]]*$' "$script_path" | grep -v '^[[:space:]]*#' | head -n 1)
                if [ -n "$result" ]; then
                        printf '%s' "$result"
                        return 0
                fi
        fi
        return 1
}

list_spell_directories() {
        set --
        for dir in "$ROOT_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                [ "$(basename "$dir")" = "menu" ] && continue
                set -- "$@" "$(basename "$dir")"
        done
        printf '%s\n' "$@"
}

spell_categories() {
        list_spell_directories | sort
}

# Convert folder name to display name using the category-title imp
category_display_name() {
        folder=$1
        if command -v category-title >/dev/null 2>&1; then
                category-title "$folder"
        else
                # Fallback if imp not available
                case $folder in
                        enchant)
                                printf '%s' "Enchantment"
                                ;;
                        mud)
                                printf '%s' "MUD"
                                ;;
                        *)
                                # Capitalize first letter
                                first=$(printf '%s' "$folder" | cut -c1 | tr '[:lower:]' '[:upper:]')
                                rest=$(printf '%s' "$folder" | cut -c2-)
                                printf '%s%s' "$first" "$rest"
                                ;;
                esac
        fi
}

# Convert filename to display name: hyphens to spaces, titlecase
filename_to_display() {
        name=$1
        # Convert hyphens to spaces and titlecase each word
        printf '%s' "$name" | awk '{gsub(/-/," "); for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1))tolower(substr($i,2))}}1'
}

safe_command_label() {
        filename=$1
        printf '%s' "$(filename_to_display "$filename")"
}

command_for_spell() {
        spell_path=$1
        name=$(basename "$spell_path")
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s' "$name"
        else
                printf '%s' "$spell_path"
        fi
}

# Resolve a category path by searching in multiple locations.
# If the path starts with ./ or /, use it directly.
# Otherwise, search in: spells/, ~/.spellbook, current directory
resolve_category_path() {
        category=$1
        case $category in
                /*|./*)
                        # Absolute or explicit relative path - use directly
                        if [ -d "$category" ]; then
                                printf '%s' "$category"
                                return 0
                        fi
                        return 1
                        ;;
        esac
        # Search in spells/ directory first
        if [ -d "$ROOT_DIR/spells/$category" ]; then
                printf '%s' "$ROOT_DIR/spells/$category"
                return 0
        fi
        # Search in ~/.spellbook (user spell home)
        if [ -d "$spell_home/$category" ]; then
                printf '%s' "$spell_home/$category"
                return 0
        fi
        # Search in current directory
        if [ -d "$category" ]; then
                printf '%s' "$category"
                return 0
        fi
        return 1
}

list_category_spells() {
        cat_name=$1
        # Use resolve_category_path to find the actual directory
        resolved_path=$(resolve_category_path "$cat_name") || resolved_path="$ROOT_DIR/spells/$cat_name"
        find "$resolved_path" -maxdepth 2 -type f -perm -111 2>/dev/null | sort
}

# List all scribed commands (custom commands in spell_home, excluding built-in spells)
# Only shows truly custom user-created commands, not built-in spells that might have
# been memorized (those should only appear in the Cast menu)
list_scribed_commands() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        # Handle empty directory by checking if glob matches anything
        set +f  # Enable globbing
        for script in "$spell_home"/*; do
                # Skip if glob didn't match (no files exist)
                [ -e "$script" ] || continue
                [ -f "$script" ] || continue
                [ -x "$script" ] || continue
                script_name=$(basename "$script")
                # Skip hidden files and the .memorized file
                case $script_name in
                        .*) continue ;;
                esac
                # Skip if this command exists elsewhere in PATH (it's a built-in spell, not custom)
                if cmd_path=$(command -v "$script_name" 2>/dev/null); then
                        case "$cmd_path" in
                                "$spell_home"/*) 
                                        # Only found in spell_home - this is a custom command
                                        ;;
                                *)
                                        # Found in system PATH - skip this built-in spell
                                        continue
                                        ;;
                        esac
                fi
                cmd_text=$(extract_command_from_script "$script")
                if [ -n "$cmd_text" ]; then
                        printf '%s\t%s\n' "$script_name" "$cmd_text"
                fi
        done
}

# List user folders in ~/.spellbook (excluding hidden folders and folders matching built-in categories)
list_user_folders() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        builtin_cats=$(spell_categories)
        for folder in "$spell_home"/*; do
                [ -d "$folder" ] || continue
                folder_name=$(basename "$folder")
                # Skip hidden folders
                case $folder_name in
                        .*) continue ;;
                esac
                # Skip folders that match a built-in category
                is_builtin=0
                for cat in $builtin_cats; do
                        if [ "$folder_name" = "$cat" ]; then
                                is_builtin=1
                                break
                        fi
                done
                [ "$is_builtin" -eq 1 ] && continue
                printf '%s\n' "$folder_name"
        done
}

# Check if a category name is a built-in category
is_builtin_category() {
        check_name=$1
        for cat in $(spell_categories); do
                if [ "$check_name" = "$cat" ]; then
                        return 0
                fi
        done
        return 1
}

# Check if a path is inside the spell_home directory (custom spellbook)
is_in_spell_home() {
        check_path=$1
        case "$check_path" in
                "$spell_home"*)
                        return 0
                        ;;
        esac
        return 1
}

# Check if a custom category folder is empty (no executable files)
is_custom_category_empty() {
        check_path=$1
        # Must be in spell_home to be a custom category
        if ! is_in_spell_home "$check_path"; then
                return 1
        fi
        # Check if directory has any executable files
        if find "$check_path" -maxdepth 1 -type f -perm -111 2>/dev/null | grep -q .; then
                return 1
        fi
        return 0
}

# Delete an empty custom category folder
delete_custom_category() {
        cat_path=$1
        if [ -d "$cat_path" ] && is_in_spell_home "$cat_path"; then
                # Only delete if empty of executable files
                if is_custom_category_empty "$cat_path"; then
                        rm -rf "$cat_path"
                        printf '%s\n' "Deleted category: $(basename "$cat_path")"
                        return 0
                fi
        fi
        return 1
}

# Check if a script is a scribed command (exists as executable in spell_home)
is_scribed_command() {
        check_name=$1
        script_path=$(scribed_spell_path "$check_name")
        [ -f "$script_path" ] && [ -x "$script_path" ]
}

record_scribed_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name"
        validate_command "$cmd"
        mkdir -p "$spell_home"
        write_scribed_script "$cmd_name" "$cmd"
}

remove_scribed_command() {
        cmd_name=$1
        script_path=$(scribed_spell_path "$cmd_name")
        if [ -f "$script_path" ]; then
                rm -f "$script_path"
                return 0
        fi
        return 1
}

cast_list() {
        "$cast_store" list
}

is_memorized() {
        name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

memorize_spell() {
        name=$1
        shift
        "$cast_store" add "$name" "$@"
}

forget_spell() {
        name=$1
        "$cast_store" remove "$name"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt"
        IFS= read -r value
        printf '%s' "$value"
}

scribe_command_interactive() {
        cmd_name=$(prompt_for_input "Name: ")
        cmd_text=$(prompt_for_input "Command: ")
        if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
                printf '%s\n' "A name and command are required." >&2
                return 1
        fi
        record_scribed_command "$cmd_name" "$cmd_text"
        printf "Scribed '%s' to %s.\n" "$cmd_name" "$spell_home"
}

spellbook_menu() {
        current_path=${1-}
        first_run=1
        while :; do
                if [ "$first_run" -eq 0 ]; then
                        printf '\n'
                else
                        first_run=0
                fi

                set --
                # Determine the resolved path for non-root views
                resolved_path=""
                in_custom_folder=0
                category_name=""
                if [ -n "$current_path" ]; then
                        # Get the category name (last component of path)
                        category_name=$(basename "$current_path")
                        if resolved_path=$(resolve_category_path "$current_path"); then
                                if is_in_spell_home "$resolved_path"; then
                                        in_custom_folder=1
                                fi
                        else
                                printf '%s\n' "spellbook: category '$current_path' not found" >&2
                                return 1
                        fi
                fi
                
                # Only show three sections at root level (no path argument)
                if [ -z "$current_path" ]; then
                        # SECTION 1: Individual scribed commands (showing command content)
                        while IFS=$(printf '\t') read -r cmd_name cmd_text; do
                                [ -z "$cmd_name" ] && continue
                                # Show the command text as the label
                                label=$(printf '%s' "$cmd_text")
                                set -- "$@" "$label%spell-menu $cmd_name"
                        done <<SCRIBED_COMMANDS
$(list_scribed_commands)
SCRIBED_COMMANDS
                        
                        # SECTION 2: User folders in ~/.spellbook (if any exist, excluding those matching built-in)
                        user_folders=$(list_user_folders)
                        if [ -n "$user_folders" ]; then
                                # Add divider between commands and user folders
                                set -- "$@" "%--divider--"
                                while IFS= read -r folder_name; do
                                        [ -z "$folder_name" ] && continue
                                        # Don't capitalize - just use the folder name
                                        set -- "$@" "${folder_name}%spellbook $spell_home/$folder_name"
                                done <<USER_FOLDERS
$user_folders
USER_FOLDERS
                        fi
                        
                        # SECTION 3: Built-in spell categories
                        # Add divider between user folders and built-in categories
                        set -- "$@" "%--divider--"
                        for category in $(spell_categories); do
                                # Don't capitalize - just use the folder name
                                set -- "$@" "${category}%spellbook $category"
                        done
                else
                        # Non-root view: show spells from both built-in and custom folders combined
                        # First, list built-in spells
                        builtin_dir="$ROOT_DIR/spells/$category_name"
                        custom_dir="$spell_home/$category_name"
                        
                        # List built-in spells
                        if [ -d "$builtin_dir" ]; then
                                for spell in $(find "$builtin_dir" -maxdepth 1 -type f -perm -111 2>/dev/null | sort); do
                                        spell_name=$(basename "$spell")
                                        set -- "$@" "${spell_name}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List custom spells from ~/.spellbook/<category> with custom theme color
                        if [ -d "$custom_dir" ]; then
                                for spell in $(find "$custom_dir" -maxdepth 1 -type f -perm -111 2>/dev/null | sort); do
                                        spell_name=$(basename "$spell")
                                        # Use THEME_CUSTOM for custom spell names (distinct from highlight)
                                        set -- "$@" "${THEME_CUSTOM}${spell_name}${RESET}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List subdirectories (only for navigation, shown after spells)
                        if [ -d "$resolved_path" ]; then
                                for subdir in "$resolved_path"/*; do
                                        [ -d "$subdir" ] || continue
                                        subname=$(basename "$subdir")
                                        set -- "$@" "${subname}%spellbook $resolved_path/$subname"
                                done
                        fi
                fi
                
                # Add "Delete category" option for empty custom category folders
                if [ -n "$current_path" ] && [ -n "$resolved_path" ] && is_custom_category_empty "$resolved_path"; then
                        # Use escaped path in the command
                        escaped_path=$(printf '%s' "$resolved_path" | sed "s/'/'\\\\''/g")
                        set -- "$@" "Delete category%rm -rf '$escaped_path' && kill -TERM \$PPID"
                fi
                
                # Add "New category" at root level (third-to-last item)
                if [ -z "$current_path" ]; then
                        set -- "$@" "New category%scribe-spell --new-category"
                fi
                
                # Add "Scribe new spell" as penultimate menu item
                if [ -z "$current_path" ]; then
                        # Root level - create in ~/.spellbook
                        set -- "$@" "Scribe new spell%scribe-spell"
                else
                        # Category level - create in ~/.spellbook/<category>
                        set -- "$@" "Scribe new spell%scribe-spell --dir $spell_home/$category_name"
                fi
                
                # Use "Back" when in a submenu, "Exit" at root
                if [ -z "$current_path" ]; then
                        exit_label=$(exit-label)
                else
                        exit_label="Back"
                fi
                set -- "$@" "${exit_label}%kill -TERM \$PPID"
                
                # Build menu title - use original folder name for category
                if [ -z "$current_path" ]; then
                        menu_title="Spellbook:"
                else
                        menu_title="${category_name}:"
                fi
                menu "$menu_title" "$@" || true
        done
}

usage() {
        cat <<'USAGE'
Usage: spellbook [PATH|--memorize NAME CMD|--forget NAME|--scribe NAME CMD|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
USAGE
}

spellbook_path=""

case ${1-} in
        --memorize)
                shift
                if [ "$#" -lt 2 ]; then
                        usage >&2
                        exit 1
                fi
                name=$1
                shift
                memorize_spell "$name" "$@"
                exit 0
                ;;
        --forget)
                shift
                if [ "$#" -ne 1 ]; then
                        usage >&2
                        exit 1
                fi
                forget_spell "$1"
                exit 0
                ;;
        --list)
                cast_list
                exit 0
                ;;
        --scribe)
                shift
                if [ "$#" -lt 2 ]; then
                        usage >&2
                        exit 1
                fi
                name=$1
                shift
                record_scribed_command "$name" "$@"
                printf "Scribed '%s' to %s.\n" "$name" "$spell_home"
                exit 0
                ;;
        --interactive-scribe)
                scribe_command_interactive
                exit $?
                ;;
        --help|-h)
                usage
                exit 0
                ;;
        --)
                shift
                spellbook_path=${1-}
                ;;
        "")
                :
                ;;
        -*)
                usage >&2
                exit 1
                ;;
        *)
                # Treat as a path to a category
                spellbook_path=$1
                ;;
        esac

if ! require menu "The spellbook menu needs the 'menu' command."; then
        exit 1
fi

spellbook_menu "$spellbook_path"
