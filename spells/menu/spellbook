#!/bin/sh
# This spell provides a menu interface for managing the spellbook.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: spellbook [PATH|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
Use --list to display all memorized commands.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Catch Ctrl-C and TERM signal to exit 1 cleanly
trap 'exit 0' INT TERM

ROOT_DIR=$(CDPATH= cd -- "$(dirname "$0")/../.." && pwd -P)

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

cast_store=${CAST_STORE-memorize}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        die "spellbook: memorize helper is missing."
        exit 1
fi

cast_dir=$($cast_store dir)

spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")

if [ -d "$spell_home" ]; then
        PATH="$spell_home:$PATH"
fi

spellbook_menu() {
        current_path=${1-}
        first_run=1
        while :; do
                if [ "$first_run" -eq 0 ]; then
                        :
                else
                        first_run=0
                fi

                set --
                # Determine the resolved path for non-root views
                # Inline resolve_category_path
                resolved_path=""
                in_custom_folder=0
                category_name=""
                if [ -n "$current_path" ]; then
                        # Get the category name (last component of path)
                        category_name=$(basename "$current_path")
                        # Resolve category path by searching in multiple locations
                        case $current_path in
                                /*|./*)
                                        # Absolute or explicit relative path - use directly
                                        if [ -d "$current_path" ]; then
                                                resolved_path=$current_path
                                        fi
                                        ;;
                                *)
                                        # Search in spells/ directory first
                                        if [ -d "$ROOT_DIR/spells/$current_path" ]; then
                                                resolved_path="$ROOT_DIR/spells/$current_path"
                                        # Search in ~/.spellbook (user spell home)
                                        elif [ -d "$spell_home/$current_path" ]; then
                                                resolved_path="$spell_home/$current_path"
                                        # Search in current directory
                                        elif [ -d "$current_path" ]; then
                                                resolved_path=$current_path
                                        fi
                                        ;;
                        esac
                        if [ -n "$resolved_path" ]; then
                                case "$resolved_path" in
                                        "$spell_home"*) in_custom_folder=1 ;;
                                esac
                        else
                                die "spellbook: category '$current_path' not found"
        exit 1
                        fi
                fi
                
                # Only show three sections at root level (no path argument)
                if [ -z "$current_path" ]; then
                        # SECTION 1: Individual scribed commands (showing command content)
                        # Inline list_scribed_commands
                        if [ -d "$spell_home" ]; then
                                # Handle empty directory by checking if glob matches anything
                                set +f  # Enable globbing
                                for script in "$spell_home"/*; do
                                        # Skip if glob didn't match (no files exist)
                                        [ -e "$script" ] || continue
                                        [ -f "$script" ] || continue
                                        [ -x "$script" ] || continue
                                        script_name=$(basename "$script")
                                        # Skip hidden files and the .memorized file
                                        case $script_name in
                                                .*) continue ;;
                                        esac
                                        # Skip if this command exists elsewhere in PATH (it's a built-in spell, not custom)
                                        if cmd_path=$(command -v "$script_name" 2>/dev/null); then
                                                case "$cmd_path" in
                                                        "$spell_home"/*)
                                                        # Only found in spell_home - this is a custom command
                                                        ;;
                                                        *)
                                                        # Found in system PATH - skip this built-in spell
                                                        continue
                                                        ;;
                                                esac
                                        fi
                                        # Extract command from scribed script
                                        cmd_text=""
                                        # First try to extract from scribed format
                                        # Scripts are in format: exec sh -c 'COMMAND' "$0" "$@"
                                        scribed_pattern="s/^exec sh -c '\\(.*\\)' \"\\\$0\" \"\\\$@\"$/\\1/p"
                                        extracted=$(sed -n "$scribed_pattern" "$script")
                                        cmd_text=$(printf '%s\n' "$extracted" | sed "s/'\\\\''/'/g")
                                        if [ -z "$cmd_text" ]; then
                                                # For non-scribed scripts, check if there's exactly one line of code
                                                # Count meaningful lines (excluding shebang, comments, and whitespace)
                                                blank_pattern='^[[:space:]]*$'
                                                comment_pattern='^[[:space:]]*#'
                                                no_blank=$(grep -v "$blank_pattern" "$script")
                                                no_comments_text=$(printf '%s\n' "$no_blank" | \
                                                        grep -v "$comment_pattern")
                                                code_lines=$(printf '%s\n' "$no_comments_text" | \
                                                        wc -l | tr -d ' ')
                                                if [ "$code_lines" -eq 1 ]; then
                                                        # Return the single code line
                                                        cmd_text=$(printf '%s\n' \
                                                        "$no_comments_text" | head -n 1)
                                                fi
                                        fi
                                        if [ -n "$cmd_text" ]; then
                                                # Show the command text as the label
                                                label=$(printf '%s' "$cmd_text")
                                                set -- "$@" "$label%spell-menu $script_name"
                                        fi
                                done
                        fi
                        
                        # SECTION 2: User folders in ~/.spellbook
                        # (if any exist, excluding those matching built-in)
                        # Inline list_user_folders
                        user_folder_count=0
                        if [ -d "$spell_home" ]; then
                                # Inline list_spell_directories to get builtin categories
                                builtin_cats=""
                                for dir in "$ROOT_DIR"/spells/*; do
                                        [ -d "$dir" ] || continue
                                        [ "$(basename "$dir")" = "menu" ] && continue
                                        cat_name=$(basename "$dir")
                                        builtin_cats="${builtin_cats}${cat_name}
"
                                done
                                builtin_cats=$(printf '%s' "$builtin_cats" | sort)
                                for folder in "$spell_home"/*; do
                                        [ -d "$folder" ] || continue
                                        folder_name=$(basename "$folder")
                                        # Skip hidden folders
                                        case $folder_name in
                                                .*) continue ;;
                                        esac
                                        # Skip folders that match a built-in category
                                        is_builtin=0
                                        for cat in $builtin_cats; do
                                                if [ "$folder_name" = "$cat" ]; then
                                                        is_builtin=1
                                                        break
                                                fi
                                        done
                                        if [ "$is_builtin" -eq 0 ]; then
                                                # Add divider before first user folder
                                                # (only if there are items before)
                                                if [ "$user_folder_count" -eq 0 ] && \
                                                        [ "$#" -gt 0 ]; then
                                                        set -- "$@" "---"
                                                fi
                                                user_folder_count=$((user_folder_count + 1))
                                                # Don't capitalize - just use the folder name
                                                folder_path="$spell_home/$folder_name"
                                                set -- "$@" "${folder_name}%spellbook $folder_path"
                                        fi
                                done
                        fi
                        
                        # SECTION 3: Built-in spell categories
                        # Add divider between user folders and built-in categories (only if there are items before)
                        if [ "$#" -gt 0 ]; then
                                set -- "$@" "---"
                        fi
                        # Inline list_spell_directories
                        for dir in "$ROOT_DIR"/spells/*; do
                                [ -d "$dir" ] || continue
                                [ "$(basename "$dir")" = "menu" ] && continue
                                category=$(basename "$dir")
                                # Don't capitalize - just use the folder name
                                set -- "$@" "${category}%spellbook $category"
                        done
                else
                        # Non-root view: show spells from both built-in and custom folders combined
                        # First, list built-in spells
                        builtin_dir="$ROOT_DIR/spells/$category_name"
                        custom_dir="$spell_home/$category_name"
                        
                        # List built-in spells
                        if [ -d "$builtin_dir" ]; then
                                builtin_spells=$(find "$builtin_dir" -maxdepth 1 \
                                  -type f -perm -111 2>/dev/null | sort)
                                for spell in $builtin_spells; do
                                        spell_name=$(basename "$spell")
                                        set -- "$@" "${spell_name}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List custom spells from ~/.spellbook/<category> with custom theme color
                        if [ -d "$custom_dir" ]; then
                                custom_spells=$(find "$custom_dir" -maxdepth 1 \
                                  -type f -perm -111 2>/dev/null | sort)
                                for spell in $custom_spells; do
                                        spell_name=$(basename "$spell")
                                        # Use THEME_CUSTOM for custom spell names (distinct from highlight)
                                        set -- "$@" "${THEME_CUSTOM}${spell_name}${RESET}%spell-menu $spell_name"
                                done
                        fi
                        
                        # List subdirectories (only for navigation, shown after spells)
                        if [ -d "$resolved_path" ]; then
                                for subdir in "$resolved_path"/*; do
                                        [ -d "$subdir" ] || continue
                                        subname=$(basename "$subdir")
                                        set -- "$@" "${subname}%spellbook $resolved_path/$subname"
                                done
                        fi
                fi
                
                # Add "Delete category" option for empty custom category folders
                is_empty="no"
                if [ -n "$current_path" ] && [ -n "$resolved_path" ]; then
                        # Check if custom category is empty (inline is_custom_category_empty)
                        case "$resolved_path" in
                                "$spell_home"*)
                                        # Check if directory has any executable files
                                        if ! find "$resolved_path" -maxdepth 1 -type f -perm -111 \
                                                2>/dev/null | grep -q .; then
                                                is_empty="yes"
                                        fi
                                        ;;
                        esac
                fi
                
                if [ "$is_empty" = "yes" ]; then
                        # Use escaped path in the command
                        escaped_path=$(printf '%s' "$resolved_path" | sed "s/'/'\\\\''/g")
                        set -- "$@" "Delete category%rm -rf '$escaped_path' && kill -TERM \$PPID"
                fi
                
                # Add horizontal divider and synonym-related menu items (only at root level)
                if [ -z "$current_path" ]; then
                        set -- "$@" "---"
                        set -- "$@" "Thesaurus%thesaurus"
                fi
                
                # Add "New category" at root level
                if [ -z "$current_path" ]; then
                        set -- "$@" "New category%scribe-spell --new-category"
                fi
                
                # Add "Scribe new spell" as penultimate menu item
                if [ -z "$current_path" ]; then
                        # Root level - create in ~/.spellbook
                        set -- "$@" "Scribe new spell%scribe-spell"
                else
                        # Category level - create in ~/.spellbook/<category>
                        set -- "$@" "Scribe new spell%scribe-spell --dir $spell_home/$category_name"
                fi
                
                # Use "Back" when in a submenu, "Exit" at root
                if [ -z "$current_path" ]; then
                        exit_label=$(exit-label)
                else
                        exit_label="Back"
                fi
                set -- "$@" "${exit_label}%kill -TERM \$PPID"
                
                # Build menu title - use original folder name for category
                if [ -z "$current_path" ]; then
                        menu_title="Spellbook:"
                else
                        menu_title="${category_name}:"
                fi
                menu "$menu_title" "$@" || menu_status=$?
                menu_status=${menu_status:-0}
                
                # Exit code 130 means ESC was pressed - go up one level (same as Exit button)
                if [ "$menu_status" -eq 130 ]; then
                        kill -TERM "$PPID" 2>/dev/null || true
                        exit 0
                fi
        done
}

spellbook_path=""

case ${1-} in
        --list)
                "$cast_store" list
                exit 0
                ;;
        --help|--usage|-h)
                cat <<'USAGE'
Usage: spellbook [PATH|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
Use --list to display all memorized commands.
USAGE
                exit 0
                ;;
        --)
                shift
                spellbook_path=${1-}
                ;;
        "")
                :
                ;;
        -*)
                cat <<'USAGE' >&2
Usage: spellbook [PATH|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
Use --list to display all memorized commands.
USAGE
                exit 1
                ;;
        *)
                # Treat as a path to a category
                spellbook_path=$1
                ;;
        esac

if ! require menu "The spellbook menu needs the 'menu' command."; then
        exit 1
fi

spellbook_menu "$spellbook_path"
