#!/usr/bin/env sh

# Present a menu of spells that can install supporting software.


set -eu
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
spells_dir=$(CDPATH= cd -- "$script_dir/.." && pwd)
install_dir=${INSTALL_MENU_ROOT:-$spells_dir/install}

if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
else
    require_cmd=require-command
fi

# Shared helper that ensures dependencies exist before we keep going.
require() {
    "$require_cmd" "$@"
}

load_colors() {
    if color_path=$(command -v colors 2>/dev/null); then
        # shellcheck source=/dev/null
        . "$color_path"
    else
        # Continue gracefully without colour if the palette is unavailable.
        RESET=''
        CYAN=''
        GREY=''
    fi
}

load_colors

if ! require menu "The install-menu spell needs the 'menu' command to present choices."; then
    exit 1
fi

# Let the user bail out with Ctrl+C while still printing a friendly message.
trap 'printf "\nExiting install menu.\n" >&2; exit 0' INT

list_entries() {
    # INSTALL_MENU_DIRS can override discovery for tests or custom menus.
    if [ -n "${INSTALL_MENU_DIRS-}" ]; then
        for name in $INSTALL_MENU_DIRS; do
            printf '%s\n' "$name"
        done
        return
    fi

    if [ ! -d "$install_dir" ]; then
        return
    fi

    # Preferred order: mud first, then others alphabetically
    # First output 'mud' if it exists
    if [ -e "$install_dir/mud" ]; then
        printf '%s\n' "mud"
    fi
    
    # Then output all other entries alphabetically
    for entry in "$install_dir"/*; do
        [ -e "$entry" ] || continue
        entry_name=$(basename "$entry")
        # Skip 'mud' since we already listed it first
        [ "$entry_name" = "mud" ] && continue
        printf '%s\n' "$entry_name"
    done
}

menu_escape_status=113
first_run=1

while :; do
    entries=$(list_entries)

    if [ -z "$entries" ]; then
        printf '%s\n' 'install-menu: no installable spells found' >&2
        exit 1
    fi

    if [ "$first_run" -eq 0 ]; then
        printf '\n'
    else
        first_run=0
    fi

    set --
    for name in $entries; do
        status_cmd=""
        if command -v "${name}-status" >/dev/null 2>&1; then
            status_cmd="${name}-status"
        elif [ -x "$install_dir/$name-status" ] && [ ! -d "$install_dir/$name-status" ]; then
            status_cmd="$install_dir/$name-status"
        elif [ -x "$install_dir/$name/$name-status" ] && [ ! -d "$install_dir/$name/$name-status" ]; then
            status_cmd="$install_dir/$name/$name-status"
        fi

        if [ -n "$status_cmd" ]; then
            status=$($status_cmd)
        else
            status='coming soon'
        fi

        if command -v "${name}-menu" >/dev/null 2>&1; then
            cmd="${name}-menu"
        elif [ -x "$install_dir/$name-menu" ] && [ ! -d "$install_dir/$name-menu" ]; then
            cmd="$install_dir/$name-menu"
        elif [ -x "$install_dir/$name/$name-menu" ] && [ ! -d "$install_dir/$name/$name-menu" ]; then
            cmd="$install_dir/$name/$name-menu"
        elif [ -x "$install_dir/$name" ] && [ -f "$install_dir/$name" ]; then
            cmd="$install_dir/$name"
        elif [ -x "$install_dir/$name/$name" ] && [ -f "$install_dir/$name/$name" ]; then
            cmd="$install_dir/$name/$name"
        elif [ -x "$install_dir/$name/install-$name" ] && [ -f "$install_dir/$name/install-$name" ]; then
            cmd="$install_dir/$name/install-$name"
        else
            cmd='printf "This entry is not ready yet.\n"'
        fi

        label="$name"
        if [ -n "$status" ]; then
            label="$label - $status"
        fi

        # Build the menu entry using the name%command convention expected by
        # the menu cantrip.
        set -- "$@" "${label}%$cmd"
    done

    exit_label=$(exit-label)
    set -- "$@" "${exit_label}%exit $menu_escape_status"

    if MENU_ESCAPE_STATUS=$menu_escape_status menu "Install Menu:" "$@"; then
        status=0
    else
        status=$?
    fi

    if [ "$status" -eq "$menu_escape_status" ]; then
        break
    fi

    if [ "$status" -ne 0 ]; then
        exit "$status"
    fi
done
