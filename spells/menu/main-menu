#!/bin/sh

# This spell displays the ao-mud main menu.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE' >&2
Usage: . main-menu    OR    main menu    (via parse/gloss)

Opens the Wizardry main menu so you can cast spells, browse your spellbook, install arcana, or jump into system tools.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - detect if sourced
main_menu_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) main_menu_sourced=1 ;;
  esac
else
  main_menu_base=${0##*/}
  case "$main_menu_base" in
    sh|dash|bash|zsh|ksh|mksh) main_menu_sourced=1 ;;
    main-menu) main_menu_sourced=0 ;;
    parse) main_menu_sourced=1 ;;  # Sourced via parse
    *) main_menu_sourced=1 ;;
  esac
fi

if [ "$main_menu_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . main-menu  OR  main menu" >&2
  return 1 2>/dev/null || exit 1
fi
unset main_menu_sourced main_menu_base

set +e  # Permissive mode since we're in user's shell
set -u

. env-clear

# Load color palette (colors handles terminal capability detection internally).
# When colors is preloaded as a function, call it directly; otherwise source the file.
if has colors; then
  colors_path=$(command -v colors 2>/dev/null || printf '')
  if [ -n "$colors_path" ] && [ -f "$colors_path" ]; then
    # shellcheck disable=SC1090
    . "$colors_path"
  else
    colors
  fi
fi

if ! require menu "The main menu needs the 'menu' command to present options."; then
  return 1
fi

# Catch Ctrl-C and TERM signal to return cleanly  
# INT (Ctrl-C) should return 130, TERM should return 0
trap 'return 130' INT
trap 'return 0' TERM

first_run=1

while true; do
  # Clear menu_status from previous iteration (important for uncastable/sourced menus)
  unset menu_status
  
  if [ "$first_run" -eq 0 ]; then
    :
  else
    first_run=0
  fi

  # Build menu items
  cast="Cast%cast"
  spellbook="Spellbook%spellbook"
  install="Arcana%install-menu"
  system="Computer%system-menu"
  
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID â†’ kills its parent (this script)
  exit_label_text=$(exit-label)
  exit_item="${exit_label_text}%kill -TERM \$PPID"

  # Check if MUD is enabled in config
  # Default to enabled (1) if config value doesn't exist or is unset
  spell_home="${SPELLBOOK_DIR:-$HOME/.spellbook}"
  mud_config_file="$spell_home/.mud"
  mud_enabled=1
  if [ -f "$mud_config_file" ]; then
    value=$(config-get "$mud_config_file" "mud-enabled" 2>/dev/null) || value=""
    if [ -n "$value" ]; then
      [ "$value" = "1" ] && mud_enabled=1 || mud_enabled=0
    fi
  fi
  
  # Build menu based on whether MUD is enabled
  if [ "$mud_enabled" -eq 1 ]; then
    mud="MUD%mud"
    install_mud="Install MUD features%mud-menu"
    set -- "$cast" "$mud" "$spellbook" "$install" "$system" "$install_mud" "$exit_item"
  else
    install_mud="Install MUD features%mud-menu"
    set -- "$cast" "$spellbook" "$install" "$system" "$install_mud" "$exit_item"
  fi
  
  menu "Main Menu:" "$@" || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC causes menu to exit with 130 - handle gracefully by returning
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    return 0
  fi
  
  # Any other exit code (0 for successful command execution) continues the loop
done
