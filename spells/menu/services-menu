#!/bin/sh

# services-menu collects all service-management spells in one place so users
# never need to remember flags. Each menu item launches a single-purpose spell.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: . services-menu    OR    services menu    (via parse/gloss)

Displays the system services management menu.

This spell must be sourced (not executed) to affect your current shell.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - detect if sourced
services_menu_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) services_menu_sourced=1 ;;
  esac
else
  services_menu_base=${0##*/}
  case "$services_menu_base" in
    sh|dash|bash|zsh|ksh|mksh) services_menu_sourced=1 ;;
    services-menu) services_menu_sourced=0 ;;
    parse) services_menu_sourced=1 ;;  # Sourced via parse
    *) services_menu_sourced=1 ;;
  esac
fi

if [ "$services_menu_sourced" -eq 0 ]; then
  printf '%s\n' "This spell must be sourced. Use:  . services-menu  OR  services menu" >&2
  return 1 2>/dev/null || exit 1
fi
unset services_menu_sourced services_menu_base

set +e  # Permissive mode since we're in user's shell
set -u
. env-clear

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The services menu needs the 'menu' command to present options."; then
  return 1
fi

for spell in start-service stop-service restart-service enable-service disable-service \
  service-status is-service-installed remove-service install-service-template; do
  if ! require "$spell" "The services menu expects the '$spell' spell."; then
    return 1
  fi
done

# Catch Ctrl-C and TERM signal to return cleanly
trap 'return 0' INT TERM

services_menu_display_menu() {
  start_item="Start a service%start-service"
  stop_item="Stop a service%stop-service"
  restart_item="Restart a service%restart-service"
  enable_item="Enable a service at boot%enable-service"
  disable_item="Disable a service at boot%disable-service"
  status_item="Check service status%service-status"
  installed_item="Check if a service is installed%is-service-installed"
  remove_item="Remove a service%remove-service"
  install_item="Install service from template%install-service-template"
  # Exit button kills this menu script via TERM signal
  # Menu (child process) evals: kill -TERM $PPID → kills its parent (this script)
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$start_item" "$stop_item" "$restart_item" \
    "$enable_item" "$disable_item" "$status_item" \
    "$installed_item" "$remove_item" "$install_item" "$exit_item"

  menu "Services Menu:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    :
  else
    first_run=0
  fi

  services_menu_display_menu || menu_status=$?
  menu_status=${menu_status:-0}
  
  # ESC kills this menu script via TERM signal (same as Exit button)
  # Direct kill: kill -TERM $$ → kills this script
  if [ "$menu_status" -eq 130 ]; then
    printf 'ESC\n' >&2
    kill -TERM $$ 2>/dev/null || true
    return 0
  fi
done
