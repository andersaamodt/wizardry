#!/bin/sh

# This spell displays the MUD install menu.

show_usage() {
  cat <<'USAGE'
Usage: mud-install-menu

Display the MUD installation menu with options to:
  - Toggle the CD hook (runs 'look' on every directory change)
  - Set up tor hidden service

The CD hook toggle shows [X] when enabled and [ ] when disabled.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

if [ -n "${REQUIRE_COMMAND-}" ]; then
  require_cmd=$REQUIRE_COMMAND
else
  require_cmd=require-command
fi

require() {
  "$require_cmd" "$@"
}

load_colors() {
  if color_path=$(command -v colors 2>/dev/null); then
    # shellcheck source=/dev/null
    . "$color_path"
  else
    RESET=''
    CYAN=''
    GREY=''
  fi
}

load_colors

if ! require menu "The MUD Install menu needs the 'menu' command to present options."; then
  exit 1
fi

SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
CD_SPELL="$SCRIPT_DIR/../install/mud/cd"

# Check if cd hook is currently installed by looking for the marker in rc file
is_cd_hook_installed() {
  # Try to resolve rc file using same logic as cd spell
  rc_file=''
  if [ -n "${WIZARDRY_RC_FILE-}" ]; then
    rc_file=$WIZARDRY_RC_FILE
  elif command -v detect-rc-file >/dev/null 2>&1; then
    if detected=$(detect-rc-file 2>/dev/null); then
      while IFS= read -r line; do
        case $line in
        rc_file=*)
          rc_file=${line#rc_file=}
          break
          ;;
        esac
      done <<EOF
$detected
EOF
    fi
  fi
  
  # Fallback to shell-specific defaults
  if [ -z "$rc_file" ] && [ -n "${HOME-}" ]; then
    shell_name=${SHELL-}
    case ${shell_name##*/} in
    zsh)
      rc_file="$HOME/.zshrc"
      ;;
    *)
      rc_file="$HOME/.bashrc"
      ;;
    esac
  fi
  
  if [ -z "$rc_file" ] || [ ! -f "$rc_file" ]; then
    return 1
  fi
  
  # Check for cd hook markers
  if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file" 2>/dev/null; then
    return 0
  fi
  if grep -Fq 'WIZARDRY_CD_CANTRIP' "$rc_file" 2>/dev/null; then
    return 0
  fi
  return 1
}

display_menu() {
  # Build cd hook toggle label based on current state
  if is_cd_hook_installed; then
    cd_hook="[X] CD hook (look on directory change)%$SCRIPT_DIR/../install/mud/toggle-cd"
  else
    cd_hook="[ ] CD hook (look on directory change)%$SCRIPT_DIR/../install/mud/toggle-cd"
  fi
  tor="Set up tor hidden service%$SCRIPT_DIR/../install/tor/setup-tor"
  exit_label=$(exit-label)
  exit_item="${exit_label}%exit $menu_escape_status"

  set -- "$cd_hook" "$tor" "$exit_item"
  MENU_ESCAPE_STATUS=$menu_escape_status menu --start-selection "$start_selection" "MUD Install:" "$@"
}

# Catch Ctrl-C and exit cleanly
trap 'exit' INT

menu_escape_status=113
loop_limit=${MENU_LOOP_LIMIT:-}
first_run=1
start_selection=1
was_cd_installed=0

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
    # Check if cd hook state changed (toggle was used)
    if is_cd_hook_installed; then
      now_cd_installed=1
    else
      now_cd_installed=0
    fi
    if [ "$was_cd_installed" != "$now_cd_installed" ]; then
      # Toggle was selected - keep cursor on toggle item (item 1)
      start_selection=1
    else
      # Other action - reset to first item
      start_selection=1
    fi
  else
    first_run=0
  fi

  # Track current cd hook state for detecting toggle
  if is_cd_hook_installed; then
    was_cd_installed=1
  else
    was_cd_installed=0
  fi

  if display_menu; then
    status=0
  else
    status=$?
  fi

  if [ "$status" -eq "$menu_escape_status" ]; then
    break
  fi

  if [ "$status" -ne 0 ]; then
    exit "$status"
  fi

  # Support MENU_LOOP_LIMIT for testing
  if [ -n "$loop_limit" ]; then
    loop_limit=$((loop_limit - 1))
    if [ "$loop_limit" -le 0 ]; then
      break
    fi
  fi
done
