#!/bin/sh

# This spell manages shell rc file snippets by adding, removing, or checking
# snippets wrapped with wizardry comment sentinels for reliable detection.

show_usage() {
  cat <<'USAGE'
Usage: learn-rc --spell NAME {add|remove|status}

Add, remove, or check shell rc file snippets wrapped in wizardry sentinels.
Reads content from stdin for add. RC file and format are auto-detected.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Helper to test for non-empty strings (used in read loop)
nonempty() {
  [ -n "$1" ]
}

# Find detect-rc-file helper
find_detect_rc_file() {
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    printf '%s' "$DETECT_RC_FILE"
    return 0
  fi
  helper="$SPELLS_DIR/divination/detect-rc-file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v detect-rc-file >/dev/null 2>&1; then
    command -v detect-rc-file
    return 0
  fi
  return 1
}

# Auto-detect rc file
auto_detect_rc() {
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "learn-rc: detect-rc-file helper not found." >&2
    return 1
  fi
  output=$("$detect_helper")
  rc_file_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn-rc: detect-rc-file did not provide an rc file." >&2
    return 1
  fi
  printf '%s\n' "rc_file=$rc_file_detected"
  printf '%s\n' "format=${format_detected:-shell}"
}

# Parse command line arguments
action=""
rc_file=""
spell=""
rc_format=""

while [ "$#" -gt 0 ]; do
  case $1 in
  --rc-file)
    # Internal option for learn-spellbook integration
    if [ "$#" -lt 2 ]; then
      printf '%s\n' "learn-rc: --rc-file expects a file path." >&2
      exit 1
    fi
    rc_file=$2
    shift 2
    ;;
  --rc-file=*)
    rc_file=${1#*=}
    shift
    ;;
  --spell)
    if [ "$#" -lt 2 ]; then
      printf '%s\n' "learn-rc: --spell expects a name." >&2
      show_usage >&2
      exit 1
    fi
    spell=$2
    shift 2
    ;;
  --spell=*)
    spell=${1#*=}
    shift
    ;;
  --format)
    # Internal option for backward compatibility
    if [ "$#" -lt 2 ]; then
      printf '%s\n' "learn-rc: --format expects a value." >&2
      exit 1
    fi
    rc_format=$2
    shift 2
    ;;
  --format=*)
    rc_format=${1#*=}
    shift
    ;;
  add|remove|status)
    if [ -n "$action" ]; then
      printf '%s\n' "learn-rc: only one action may be specified." >&2
      show_usage >&2
      exit 1
    fi
    action=$1
    shift
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn-rc: unknown option '$1'." >&2
    show_usage >&2
    exit 1
    ;;
  *)
    printf '%s\n' "learn-rc: unexpected argument '$1'." >&2
    show_usage >&2
    exit 1
    ;;
  esac
done

# Validate required arguments
if [ -z "$action" ] || [ -z "$spell" ]; then
  show_usage >&2
  exit 1
fi

# Auto-detect rc file if not provided
if [ -z "$rc_file" ]; then
  if ! detect_output=$(auto_detect_rc); then
    exit 1
  fi
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) [ -z "$rc_format" ] && rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT
fi

# Default format
: "${rc_format:=shell}"

# Auto-detect format from file extension
case $rc_file in
*.nix) rc_format=nix ;;
esac

# Validate spell name
case $spell in
*[!A-Za-z0-9._:-]*)
  printf '%s\n' "learn-rc: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
  exit 1
  ;;
esac

# Define sentinels
spell_tag="# wizardry: $spell"
legacy_spell_tag="# wizardry-spell: $spell"
inline_marker=" $spell_tag"
legacy_inline_marker=" $legacy_spell_tag"
block_start="$spell_tag begin"
legacy_block_start="$legacy_spell_tag begin"
block_end="$spell_tag end"
legacy_block_end="$legacy_spell_tag end"
block_prefix="$spell_tag lines="
legacy_prefix="$legacy_spell_tag lines="

ensure_rc_directory() {
  dir=${rc_file%/*}
  if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
    mkdir -p "$dir"
  fi
}

spell_status() {
  if [ ! -f "$rc_file" ]; then
    return 1
  fi
  if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
    return 0
  fi
  if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
    return 0
  fi
  return 1
}

ensure_trailing_newline() {
  if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
    return 0
  fi
  last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
  if [ "$last_char" != "012" ]; then
    printf '\n' >>"$rc_file"
  fi
}

add_spell() {
  ensure_rc_directory
  tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn-rc.XXXXXX") || exit 1
  line_count=0
  while IFS= read -r line || nonempty "$line"; do
    printf '%s\n' "$line" >>"$tmp_file"
    line_count=$((line_count + 1))
  done
  if [ "$line_count" -eq 0 ]; then
    rm -f "$tmp_file"
    printf '%s\n' "learn-rc: no spell content provided on stdin." >&2
    exit 1
  fi
  if spell_status; then
    rm -f "$tmp_file"
    return 0
  fi
  if [ ! -f "$rc_file" ]; then
    : >"$rc_file"
  fi
  ensure_trailing_newline
  if [ "$line_count" -eq 1 ]; then
    first_line=$(sed -n '1p' "$tmp_file")
    printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
    rm -f "$tmp_file"
    return 0
  fi
  block_header="$block_start lines=$line_count"
  printf '%s\n' "$block_header" >>"$rc_file"
  cat "$tmp_file" >>"$rc_file"
  printf '%s\n' "$block_end" >>"$rc_file"
  rm -f "$tmp_file"
}

remove_spell() {
  if [ ! -f "$rc_file" ]; then
    printf '%s\n' "learn-rc: cannot remove from missing file '$rc_file'." >&2
    exit 1
  fi
  tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn-rc.XXXXXX") || exit 1
  removing_block=0
  to_skip=0
  removed=0
  while IFS= read -r line || nonempty "$line"; do
    if [ "$removing_block" -eq 1 ]; then
      case $line in
      "$block_end"|"$legacy_block_end")
        removing_block=0
        ;;
      esac
      continue
    fi
    if [ "$to_skip" -gt 0 ]; then
      to_skip=$((to_skip - 1))
      continue
    fi
    case $line in
    "$block_start"*|"$legacy_block_start"*)
      removing_block=1
      removed=1
      continue
      ;;
    "$block_prefix"*)
      count=${line#"$block_prefix"}
      case $count in
      *[!0-9]*) to_skip=0 ;;
      *) to_skip=$count ;;
      esac
      removed=1
      continue
      ;;
    "$legacy_prefix"*)
      count=${line#"$legacy_prefix"}
      case $count in
      *[!0-9]*) to_skip=0 ;;
      *) to_skip=$count ;;
      esac
      removed=1
      continue
      ;;
    *"$inline_marker"|*"$legacy_inline_marker")
      removed=1
      continue
      ;;
    esac
    printf '%s\n' "$line" >>"$tmp_file"
  done <"$rc_file"
  if [ "$removed" -eq 0 ]; then
    rm -f "$tmp_file"
    printf '%s\n' "learn-rc: spell '$spell' not found in '$rc_file'." >&2
    exit 1
  fi
  mv "$tmp_file" "$rc_file"
}

# Find nix-shell-init helper
find_nix_shell_init() {
  if [ -n "${NIX_SHELL_INIT-}" ] && [ -x "$NIX_SHELL_INIT" ]; then
    printf '%s' "$NIX_SHELL_INIT"
    return 0
  fi
  helper="$SCRIPT_DIR/../.imps/sys/nix-shell-init"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v nix-shell-init >/dev/null 2>&1; then
    command -v nix-shell-init
    return 0
  fi
  return 1
}

# Nix format handlers
nix_spell_status() {
  if ! nix_helper=$(find_nix_shell_init); then
    printf '%s\n' "learn-rc: nix-shell-init imp not found." >&2
    exit 1
  fi
  "$nix_helper" status --shell bash --name "$spell" --file "$rc_file"
}

nix_add_spell() {
  if ! nix_helper=$(find_nix_shell_init); then
    printf '%s\n' "learn-rc: nix-shell-init imp not found." >&2
    exit 1
  fi
  "$nix_helper" add --shell bash --name "$spell" --file "$rc_file"
}

nix_remove_spell() {
  if ! nix_helper=$(find_nix_shell_init); then
    printf '%s\n' "learn-rc: nix-shell-init imp not found." >&2
    exit 1
  fi
  "$nix_helper" remove --shell bash --name "$spell" --file "$rc_file"
}

# Execute action based on format
if [ "$rc_format" = "nix" ]; then
  case $action in
  add) nix_add_spell ;;
  remove) nix_remove_spell ;;
  status)
    if nix_spell_status; then exit 0; fi
    exit 1
    ;;
  esac
else
  case $action in
  add) add_spell ;;
  remove) remove_spell ;;
  status)
    if spell_status; then exit 0; fi
    exit 1
    ;;
  esac
fi
