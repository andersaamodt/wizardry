#!/bin/sh

# This spell manages shell rc file snippets by adding, removing, or checking
# snippets wrapped with wizardry comment sentinels for reliable detection.

show_usage() {
  cat <<'USAGE'
Usage: learn-rc --rc-file FILE --spell NAME {add|remove|status}

Manage shell rc file snippets wrapped in wizardry comment sentinels.
Reads spell content from stdin for add; single-line gets inline suffix,
multi-line gets begin/end block markers. Names: letters, digits, -_.:
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

# Helper to test for non-empty strings (used in read loop)
nonempty() {
  [ -n "$1" ]
}

# Parse command line arguments
action=""
rc_file=""
spell=""

while [ "$#" -gt 0 ]; do
  case $1 in
  --rc-file)
    if [ "$#" -lt 2 ]; then
      printf '%s\n' "learn-rc: --rc-file expects a file path." >&2
      show_usage >&2
      exit 1
    fi
    rc_file=$2
    shift 2
    ;;
  --rc-file=*)
    rc_file=${1#*=}
    shift
    ;;
  --spell)
    if [ "$#" -lt 2 ]; then
      printf '%s\n' "learn-rc: --spell expects a name." >&2
      show_usage >&2
      exit 1
    fi
    spell=$2
    shift 2
    ;;
  --spell=*)
    spell=${1#*=}
    shift
    ;;
  add|remove|status)
    if [ -n "$action" ]; then
      printf '%s\n' "learn-rc: only one action may be specified." >&2
      show_usage >&2
      exit 1
    fi
    action=$1
    shift
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn-rc: unknown option '$1'." >&2
    show_usage >&2
    exit 1
    ;;
  *)
    printf '%s\n' "learn-rc: unexpected argument '$1'." >&2
    show_usage >&2
    exit 1
    ;;
  esac
done

# Validate required arguments
if [ -z "$action" ] || [ -z "$rc_file" ] || [ -z "$spell" ]; then
  show_usage >&2
  exit 1
fi

# Validate spell name: only letters, digits, dots, underscores, dashes, colons
case $spell in
*[!A-Za-z0-9._:-]*)
  printf '%s\n' "learn-rc: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
  exit 1
  ;;
esac

# Define sentinels for identifying wizardry-managed content
spell_tag="# wizardry: $spell"
legacy_spell_tag="# wizardry-spell: $spell"
inline_marker=" $spell_tag"
legacy_inline_marker=" $legacy_spell_tag"
block_start="$spell_tag begin"
legacy_block_start="$legacy_spell_tag begin"
block_end="$spell_tag end"
legacy_block_end="$legacy_spell_tag end"
block_prefix="$spell_tag lines="
legacy_prefix="$legacy_spell_tag lines="

# Create the rc file's parent directory if needed
ensure_rc_directory() {
  dir=${rc_file%/*}
  if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
    mkdir -p "$dir"
  fi
}

# Check if spell is already present in rc file (returns 0 if found)
spell_status() {
  if [ ! -f "$rc_file" ]; then
    return 1
  fi
  if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
    return 0
  fi
  if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
    return 0
  fi
  return 1
}

# Ensure rc file ends with a newline before appending
ensure_trailing_newline() {
  if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
    return 0
  fi
  last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
  if [ "$last_char" != "012" ]; then
    printf '\n' >>"$rc_file"
  fi
}

# Add spell content from stdin to rc file with wizardry sentinels
add_spell() {
  ensure_rc_directory

  # Read stdin into a temp file, counting lines
  tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn-rc.XXXXXX") || exit 1
  line_count=0
  while IFS= read -r line || nonempty "$line"; do
    printf '%s\n' "$line" >>"$tmp_file"
    line_count=$((line_count + 1))
  done

  # Bail if nothing provided
  if [ "$line_count" -eq 0 ]; then
    rm -f "$tmp_file"
    printf '%s\n' "learn-rc: no spell content provided on stdin." >&2
    exit 1
  fi

  # Skip if already present (idempotent)
  if spell_status; then
    rm -f "$tmp_file"
    return 0
  fi

  # Create rc file if missing
  if [ ! -f "$rc_file" ]; then
    : >"$rc_file"
  fi

  ensure_trailing_newline

  # Single-line: use inline marker suffix
  if [ "$line_count" -eq 1 ]; then
    first_line=$(sed -n '1p' "$tmp_file")
    printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
    rm -f "$tmp_file"
    return 0
  fi

  # Multi-line: wrap with begin/end block markers
  block_header="$block_start lines=$line_count"
  printf '%s\n' "$block_header" >>"$rc_file"
  cat "$tmp_file" >>"$rc_file"
  printf '%s\n' "$block_end" >>"$rc_file"
  rm -f "$tmp_file"
}

# Remove spell content from rc file (handles inline and block formats)
remove_spell() {
  if [ ! -f "$rc_file" ]; then
    printf '%s\n' "learn-rc: cannot remove from missing file '$rc_file'." >&2
    exit 1
  fi

  tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn-rc.XXXXXX") || exit 1
  removing_block=0
  to_skip=0
  removed=0

  while IFS= read -r line || nonempty "$line"; do
    # Inside a begin/end block: skip until we hit the end marker
    if [ "$removing_block" -eq 1 ]; then
      case $line in
      "$block_end"|"$legacy_block_end")
        removing_block=0
        ;;
      esac
      continue
    fi

    # Skipping lines from legacy "lines=N" format
    if [ "$to_skip" -gt 0 ]; then
      to_skip=$((to_skip - 1))
      continue
    fi

    case $line in
    # Begin block marker: start skipping
    "$block_start"*|"$legacy_block_start"*)
      removing_block=1
      removed=1
      continue
      ;;
    # Legacy lines=N format
    "$block_prefix"*)
      count=${line#"$block_prefix"}
      case $count in
      *[!0-9]*) to_skip=0 ;;
      *) to_skip=$count ;;
      esac
      removed=1
      continue
      ;;
    "$legacy_prefix"*)
      count=${line#"$legacy_prefix"}
      case $count in
      *[!0-9]*) to_skip=0 ;;
      *) to_skip=$count ;;
      esac
      removed=1
      continue
      ;;
    # Inline marker: skip this line
    *"$inline_marker"|*"$legacy_inline_marker")
      removed=1
      continue
      ;;
    esac

    printf '%s\n' "$line" >>"$tmp_file"
  done <"$rc_file"

  if [ "$removed" -eq 0 ]; then
    rm -f "$tmp_file"
    printf '%s\n' "learn-rc: spell '$spell' not found in '$rc_file'." >&2
    exit 1
  fi

  mv "$tmp_file" "$rc_file"
}

# Execute the requested action
case $action in
add)
  add_spell
  ;;
remove)
  remove_spell
  ;;
status)
  if spell_status; then
    exit 0
  fi
  exit 1
  ;;
*)
  show_usage >&2
  exit 1
  ;;
esac
