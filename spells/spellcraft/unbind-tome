#!/bin/sh

# This spell splits a bound tome back into individual page files.
# It derives filenames from page headers so the restored pages are easy to revisit.

require-wizardry || exit 1

show_usage() {
    cat <<'USAGE'
Usage: unbind-tome <tome-path>

Split a bound tome back into individual files, naming each page from its contents and placing them in a directory derived from the tome name.
USAGE
}

case "${1-}" in
--help|--usage|-h)
    show_usage
    exit 0
    ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
    warn "unbind-tome: file path required."
    show_usage >&2
    exit 1
fi

tome=$1
is file "$tome" || { warn "Error: '$tome' is not a file."; exit 1; }

stem=$(basename -- "$tome")
stem=${stem%.*}

pages_dir=$stem
suffix=1
while there "$pages_dir"; do
    pages_dir="${stem}${suffix}"
    suffix=$((suffix + 1))
done
make dir "$pages_dir"

# Parse tome with state machine
# Enhanced logic: In "collecting" state, buffer separators and check for full page header pattern
state="seeking"
page_name=""
current_page=""
page_num=1
sep_buffer=""  # Buffer to hold separator when we need to check if it starts new page

while IFS= read -r line || nonempty "$line"; do
    case "$state" in
        seeking)
            if [ "$line" = "# ----------------------------------------------------------------------------" ]; then
                state="found_sep1"
                sep_buffer=""
            fi
            ;;
        found_sep1)
            case "$line" in
                "# ----------------------------------------------------------------------------")
                    # Two separators in a row - not a page header, back to seeking
                    state="seeking"
                    ;;
                "# "*)
                    page_name=${line#"# "}
                    state="have_name"
                    ;;
                *)
                    state="seeking"
                    ;;
            esac
            ;;
        have_name)
            if [ "$line" = "# ----------------------------------------------------------------------------" ]; then
                # Complete page header! Create file and start collecting
                clean_name=$(printf '%s' "$page_name" | tr -dc '[:alnum:] .,;_-' | tr ' ' '_')
                if empty "$clean_name"; then
                    clean_name="page_${page_num}"
                fi
                current_page="$pages_dir/$clean_name"
                : >"$current_page"
                page_num=$((page_num + 1))
                state="collecting"
            else
                # Not a proper header
                state="seeking"
            fi
            ;;
        collecting)
            # In collecting state, we need to be careful about separators
            # Only treat a separator as a new page start if it's followed by "# name" + separator
            if [ "$line" = "# ----------------------------------------------------------------------------" ]; then
                # Buffer this separator and move to checking state
                state="maybe_new_page"
                sep_buffer="$line"
            else
                # Regular content line - write it
                if nonempty "$current_page"; then
                    say "$line" >>"$current_page"
                fi
            fi
            ;;
        maybe_new_page)
            # We saw a separator while collecting - check if this is a filename
            case "$line" in
                "# "*)
                    # Could be a filename - save it and check for closing separator
                    page_name=${line#"# "}
                    state="checking_page_header"
                    ;;
                *)
                    # Not a filename, so the separator was content
                    if nonempty "$current_page"; then
                        say "$sep_buffer" >>"$current_page"
                        say "$line" >>"$current_page"
                    fi
                    state="collecting"
                    ;;
            esac
            ;;
        checking_page_header)
            # We saw: separator + "# text" - check if next line is also separator
            if [ "$line" = "# ----------------------------------------------------------------------------" ]; then
                # Yes! This is a new page header - create new file
                clean_name=$(printf '%s' "$page_name" | tr -dc '[:alnum:] .,;_-' | tr ' ' '_')
                if empty "$clean_name"; then
                    clean_name="page_${page_num}"
                fi
                current_page="$pages_dir/$clean_name"
                : >"$current_page"
                page_num=$((page_num + 1))
                state="collecting"
            else
                # Not a new page - write the buffered content
                if nonempty "$current_page"; then
                    say "$sep_buffer" >>"$current_page"
                    say "# $page_name" >>"$current_page"
                    say "$line" >>"$current_page"
                fi
                state="collecting"
            fi
            ;;
    esac
done <"$tome"

exit 0

