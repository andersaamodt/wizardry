#!/bin/sh

# This spell splits a bound tome back into individual page files.
# It derives filenames from page headers so the restored pages are easy to revisit.

require-wizardry || exit 1

show_usage() {
    cat <<'USAGE'
Usage: unbind-tome <tome-path>

Split a bound tome back into individual files, naming each page from its contents and placing them in a directory derived from the tome name.
USAGE
}

case "${1-}" in
--help|--usage|-h)
    show_usage
    exit 0
    ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
    warn "unbind-tome: file path required."
    show_usage >&2
    exit 1
fi

tome=$1
is file "$tome" || { warn "Error: '$tome' is not a file."; exit 1; }

stem=$(basename -- "$tome")
stem=${stem%.*}

pages_dir=$stem
suffix=1
while there "$pages_dir"; do
    pages_dir="${stem}${suffix}"
    suffix=$((suffix + 1))
done
make dir "$pages_dir"

# Detect format by checking if the first non-empty line is a separator
first_line=""
while IFS= read -r line && empty "$first_line"; do
    nonempty "$line" && first_line="$line"
done <"$tome"

# Check if this is the new format (starts with separator)
if [ "$first_line" = "# ----------------------------------------------------------------------------" ]; then
    # New format with commented separators
    current_file=""
    in_header=0
    page_number=1
    while IFS= read -r line || nonempty "$line"; do
        # Check if this is a separator line
        case "$line" in
            "# ----------------------------------------------------------------------------")
                # Toggle header state - first separator starts header, second ends it
                if [ "$in_header" -eq 0 ]; then
                    in_header=1
                else
                    in_header=0
                fi
                continue
                ;;
        esac
        
        # If in header and line starts with "# ", extract the page name
        if [ "$in_header" -eq 1 ]; then
            case "$line" in
                "# "*)
                    page_name=${line#"# "}
                    clean_name=$(printf '%s' "$page_name" | tr -dc '[:alnum:] .,;_-' | tr ' ' '_')
                    empty "$clean_name" && clean_name="page_${page_number}"
                    current_file="$pages_dir/$clean_name"
                    : >"$current_file"
                    page_number=$((page_number + 1))
                    ;;
            esac
        # If not in header and we have a current file, append content
        elif nonempty "$current_file"; then
            say "$line" >>"$current_file"
        fi
    done <"$tome"
else
    # Old format - each line is a page
    page_number=1
    while IFS= read -r line || nonempty "$line"; do
        clean_name=$(printf '%s' "$line" | tr -dc '[:alnum:] .,;_-' | tr ' ' '_')
        empty "$clean_name" && clean_name="page_${page_number}"
        say "$line" >"$pages_dir/$clean_name"
        page_number=$((page_number + 1))
    done <"$tome"
fi
