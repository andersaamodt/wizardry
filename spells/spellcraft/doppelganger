#!/bin/sh

# Create a fully compiled clone of wizardry that works standalone.
# The doppelganger contains individual compiled spells in the same directory
# structure, minus GitHub-specific files, ready for distribution.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: doppelganger [OUTPUT_DIR]

Create a fully compiled clone of wizardry with standalone versions of all spells.

Arguments:
  OUTPUT_DIR    Directory to create doppelganger in (default: ./wizardry-compiled)

The doppelganger includes:
  - All spells compiled to standalone versions
  - Same directory structure as wizardry
  - Test files for validation
  - No .github or .git directories

Example:
  doppelganger /tmp/wizardry-standalone
  cd /tmp/wizardry-standalone
  hash --help
USAGE
  exit 0
  ;;
esac

# Handle require-wizardry availability (for script execution without invoke-wizardry in current shell)
# Check if require-wizardry function exists (may have been sourced already)
if command -v require-wizardry >/dev/null 2>&1; then
  require-wizardry || exit 1
elif command -v require-wizardry >/dev/null 2>&1; then
  require-wizardry || exit 1
else
  # Neither available - source it now
  # Try WIZARDRY_DIR first (set by invoke-wizardry)
  if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry" ]; then
    . "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry"
    require-wizardry || exit 1
  else
    # Fall back to relative path from script location
    _rw_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    _rw_imp_path="$_rw_script_dir/../../.imps/sys/require-wizardry"
    if [ -f "$_rw_imp_path" ]; then
      . "$_rw_imp_path"
      require-wizardry || exit 1
    else
      printf 'Error: require-wizardry not found\n' >&2
      exit 1
    fi
  fi
fi

set -eu

# Source env_clear if not already available
if ! command -v env_clear >/dev/null 2>&1; then
  if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/env-clear" ]; then
    . "${WIZARDRY_DIR}/spells/.imps/sys/env-clear"
  else
    _dg_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    . "$_dg_script_dir/../../.imps/sys/env-clear"
  fi
fi

# Source output imps (say, warn, etc.)
if [ -n "${WIZARDRY_DIR-}" ] && [ -d "${WIZARDRY_DIR}/spells/.imps/out" ]; then
  for _dg_out_imp in "${WIZARDRY_DIR}"/spells/.imps/out/*; do
    [ -f "$_dg_out_imp" ] && . "$_dg_out_imp"
  done
else
  _dg_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  for _dg_out_imp in "$_dg_script_dir"/../../.imps/out/*; do
    [ -f "$_dg_out_imp" ] && . "$_dg_out_imp"
  done
fi

# Get output directory
output_dir=${1:-./wizardry-compiled}

# Find wizardry root
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

# Convert output_dir to absolute path (needed for subshell operations)
case "$output_dir" in
  /*) ;;
  *) output_dir="$repo_dir/$output_dir" ;;
esac

say "Creating wizardry doppelganger in: $output_dir"

# Create output directory structure
mkdir -p "$output_dir/spells"
mkdir -p "$output_dir/.tests"

# Compile all spells
say "Compiling all spells..."
compiled_count=0
failed_count=0

# Find all executable files in spells/ directory (including hidden directories)
# Only skip .git and .github directories
# Store list in variable to avoid subshell and preserve counter variables
_spell_list=$(find "$repo_dir/spells" -type f -executable \
  ! -path "*/.git/*" \
  ! -path "*/.github/*")

# Use here-document to avoid creating temp file
while IFS= read -r spell_path; do
  [ -n "$spell_path" ] || continue
  
  # Get relative path from spells/
  rel_path=${spell_path#"$repo_dir/spells/"}
  
  # Get spell name
  spell_name=$(basename "$spell_path")
  
  # Create directory structure
  target_dir="$output_dir/spells/$(dirname "$rel_path")"
  mkdir -p "$target_dir"
  
  # Skip test infrastructure files - copy them as-is instead of compiling
  # test-bootstrap and boot imps need to remain uncompiled to work correctly
  case "$spell_path" in
    */test/test-bootstrap|*/test/boot/*)
      # Copy test infrastructure files directly
      cp "$spell_path" "$target_dir/$spell_name"
      chmod +x "$target_dir/$spell_name"
      compiled_count=$((compiled_count + 1))
      continue
      ;;
  esac
  
  # Compile spell: get relative path from repo root and compile
  spell_rel_path=${spell_path#$repo_dir/}
  target_file="$target_dir/$spell_name"
  
  # Compile spell: save current directory, cd to repo, compile, return
  # Don't use subshell () because functions don't pass to child processes
  # compile-spell needs require-wizardry which was sourced earlier in this script
  _dg_pwd=$(pwd -P)
  cd "$repo_dir" || {
    warn "doppelganger: failed to cd to $repo_dir"
    failed_count=$((failed_count + 1))
    continue
  }
  
  if "$repo_dir/spells/spellcraft/compile-spell" "$spell_rel_path" < /dev/null > "$target_file" 2>&1; then
    cd "$_dg_pwd" || true
    # Check if the target file is valid (has shebang)
    if head -n 1 "$target_file" 2>/dev/null | grep -q '^#!'; then
      chmod +x "$target_file"
      compiled_count=$((compiled_count + 1))
    else
      warn "doppelganger: compilation produced invalid output for $spell_name"
      failed_count=$((failed_count + 1))
      rm -f "$target_file"
    fi
  else
    cd "$_dg_pwd" || true
    warn "doppelganger: failed to compile $spell_name"
    failed_count=$((failed_count + 1))
    rm -f "$target_file"
  fi
done <<EOF
$_spell_list
EOF

# Copy test files (including hidden directories like .arcana and .imps)
say "Copying test files..."
if [ -d "$repo_dir/.tests" ]; then
  # Copy all files including hidden ones
  (cd "$repo_dir/.tests" && \
    find . -mindepth 1 -maxdepth 1 -exec cp -r {} "$output_dir/.tests/" \; \
    2>/dev/null) || true
fi

# Copy spell-levels imp (required by test-magic)
say "Copying spell-levels imp..."
if [ -f "$repo_dir/spells/.imps/sys/spell-levels" ]; then
  mkdir -p "$output_dir/spells/.imps/sys"
  cp "$repo_dir/spells/.imps/sys/spell-levels" "$output_dir/spells/.imps/sys/" 2>/dev/null || true
fi

# Copy essential files (README, LICENSE, etc.) but skip .git and .github
say "Copying essential files..."
for file in "$repo_dir"/*; do
  basename_file=$(basename "$file")
  case "$basename_file" in
    .git|.github) continue ;;
    README*|LICENSE*|*.md)
      if [ -f "$file" ]; then
        cp "$file" "$output_dir/" 2>/dev/null || true
      fi
      ;;
  esac
done

success "Doppelganger created successfully!"
say "Location: $output_dir"
say "Compiled: $compiled_count spells"
if [ "$failed_count" -gt 0 ]; then
  warn "doppelganger: $failed_count spells failed to compile"
fi
