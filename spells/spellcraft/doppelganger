#!/bin/sh

# Create a fully compiled clone of wizardry that works standalone.
# The doppelganger contains individual compiled spells in the same directory
# structure, minus GitHub-specific files, ready for distribution.

show_usage() {
  cat <<'USAGE'
Usage: doppelganger [OUTPUT_DIR]

Create a fully compiled clone of wizardry with standalone versions of all spells.

Arguments:
  OUTPUT_DIR    Directory to create doppelganger in (default: ./wizardry-compiled)

The doppelganger includes:
  - All spells compiled to standalone versions
  - Same directory structure as wizardry
  - Test files for validation
  - No .github or .git directories

Example:
  doppelganger /tmp/wizardry-standalone
  cd /tmp/wizardry-standalone
  ./spells/cantrips/hash --help
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

# Fallbacks for standalone execution
if ! command -v say >/dev/null 2>&1; then
  say() { printf '%s\n' "$*"; }
fi
if ! command -v warn >/dev/null 2>&1; then
  warn() { printf '%s\n' "$*" >&2; }
fi
if ! command -v success >/dev/null 2>&1; then
  success() { printf '%s\n' "$*"; }
fi

# Get output directory
output_dir=${1:-./wizardry-compiled}

# Find wizardry root
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

say "Creating wizardry doppelganger in: $output_dir"

# Create output directory structure
mkdir -p "$output_dir/spells"
mkdir -p "$output_dir/.tests"

# Compile all spells
say "Compiling all spells..."
temp_count_file=$(mktemp)
temp_failed_file=$(mktemp)
echo "0" > "$temp_count_file"
echo "0" > "$temp_failed_file"

# Ensure compile-spell can find the wizardry repo
export WIZARDRY_DIR="$repo_dir"

find "$repo_dir/spells" -type f -executable | while IFS= read -r spell_path; do
  # Skip hidden files and directories
  case "$spell_path" in
    */.git/*|*/.github/*) continue ;;
  esac
  
  # Get relative path from spells/
  rel_path=${spell_path#"$repo_dir/spells/"}
  
  # Get spell name
  spell_name=$(basename "$spell_path")
  
  # Create directory structure
  target_dir="$output_dir/spells/$(dirname "$rel_path")"
  mkdir -p "$target_dir"
  
  # Compile spell (compile-spell needs to be run from repo directory to find dependencies)
  if (cd "$repo_dir" && "$repo_dir/spells/spellcraft/compile-spell" "$spell_name" > "$target_dir/$spell_name" 2>&1); then
    chmod +x "$target_dir/$spell_name"
    count=$(cat "$temp_count_file")
    echo "$((count + 1))" > "$temp_count_file"
  else
    warn "doppelganger: failed to compile $spell_name"
    failed=$(cat "$temp_failed_file")
    echo "$((failed + 1))" > "$temp_failed_file"
  fi
done

compiled_count=$(cat "$temp_count_file")
failed_count=$(cat "$temp_failed_file")
rm -f "$temp_count_file" "$temp_failed_file"

# Copy test files (including hidden directories like .arcana and .imps)
say "Copying test files..."
if [ -d "$repo_dir/.tests" ]; then
  # Copy all files including hidden ones
  (cd "$repo_dir/.tests" && find . -mindepth 1 -maxdepth 1 -exec cp -r {} "$output_dir/.tests/" \; 2>/dev/null) || true
fi

# Copy essential files (README, LICENSE, etc.) but skip .git and .github
say "Copying essential files..."
for file in "$repo_dir"/*; do
  basename_file=$(basename "$file")
  case "$basename_file" in
    .git|.github) continue ;;
    README*|LICENSE*|*.md)
      if [ -f "$file" ]; then
        cp "$file" "$output_dir/" 2>/dev/null || true
      fi
      ;;
  esac
done

success "Doppelganger created successfully!"
say "Location: $output_dir"
say "Compiled: $compiled_count spells"
if [ "$failed_count" -gt 0 ]; then
  warn "doppelganger: $failed_count spells failed to compile"
fi
