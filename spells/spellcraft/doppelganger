#!/bin/sh

# Create a fully compiled clone of wizardry that works standalone.
# The doppelganger contains individual compiled spells in the same directory
# structure, minus GitHub-specific files, ready for distribution.

doppelganger_usage() {
  cat <<'USAGE'
Usage: doppelganger [OUTPUT_DIR]

Create a fully compiled clone of wizardry with standalone versions of all spells.

Arguments:
  OUTPUT_DIR    Directory to create doppelganger in (default: ./wizardry-compiled)

The doppelganger includes:
  - All spells compiled to standalone versions
  - Same directory structure as wizardry
  - Test files for validation
  - No .github or .git directories

Example:
  doppelganger /tmp/wizardry-standalone
  cd /tmp/wizardry-standalone
  hash --help
USAGE
}



doppelganger() {
case "${1-}" in
--help|--usage|-h)
  doppelganger_usage
  return 0
  ;;
esac

# Handle require-wizardry availability (for script execution without invoke-wizardry in current shell)
# Check if _require_wizardry function exists (may have been sourced already)
if command -v _require_wizardry >/dev/null 2>&1; then
  _require_wizardry || exit 1
elif command -v require-wizardry >/dev/null 2>&1; then
  require-wizardry || exit 1
else
  # Neither available - source it now
  # Try WIZARDRY_DIR first (set by invoke-wizardry)
  if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry" ]; then
    . "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry"
    _require_wizardry || exit 1
  else
    # Fall back to relative path from script location
    _rw_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    _rw_imp_path="$_rw_script_dir/../../.imps/sys/require-wizardry"
    if [ -f "$_rw_imp_path" ]; then
      . "$_rw_imp_path"
      _require_wizardry || exit 1
    else
      printf 'Error: require-wizardry not found\n' >&2
      exit 1
    fi
  fi
fi

set -eu

# Source env-clear (use WIZARDRY_DIR if available, otherwise compute relative path)
if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/env-clear" ]; then
  . "${WIZARDRY_DIR}/spells/.imps/sys/env-clear"
else
  _dg_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  . "$_dg_script_dir/../../.imps/sys/env-clear"
fi

# Source output imps (say, warn, etc.)
if [ -n "${WIZARDRY_DIR-}" ] && [ -d "${WIZARDRY_DIR}/spells/.imps/out" ]; then
  for _dg_out_imp in "${WIZARDRY_DIR}"/spells/.imps/out/*; do
    [ -f "$_dg_out_imp" ] && . "$_dg_out_imp"
  done
else
  _dg_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  for _dg_out_imp in "$_dg_script_dir"/../../.imps/out/*; do
    [ -f "$_dg_out_imp" ] && . "$_dg_out_imp"
  done
fi

# Get output directory
output_dir=${1:-./wizardry-compiled}

# Find wizardry root
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

# Convert output_dir to absolute path (needed for subshell operations)
case "$output_dir" in
  /*) ;;
  *) output_dir="$repo_dir/$output_dir" ;;
esac

_say "Creating wizardry doppelganger in: $output_dir"

# Create output directory structure
mkdir -p "$output_dir/spells"
mkdir -p "$output_dir/.tests"

# Compile all spells
_say "Compiling all spells..."
compiled_count=0
failed_count=0

# Process spells from known locations
for spell_path in \
  "$repo_dir/spells"/*/* \
  "$repo_dir/spells"/*/*/* \
  "$repo_dir/spells"/*/*/*/* \
  "$repo_dir/spells"/.imps/*/* \
  "$repo_dir/spells"/.imps/*/*/* \
  "$repo_dir/spells"/.arcana/*/*
do
  # Skip if not a file or not executable
  [ -f "$spell_path" ] || continue
  [ -x "$spell_path" ] || continue
  
  # Skip hidden files (except .imps and .arcana which are already in path)
  case "$spell_path" in
    */.git/*|*/.github/*|*/.*)
      # Allow .imps and .arcana
      case "$spell_path" in
        */.imps/*|*/.arcana/*) ;;
        *) continue ;;
      esac
      ;;
  esac
  
  # Get relative path from spells/
  rel_path=${spell_path#"$repo_dir/spells/"}
  
  # Get spell name
  spell_name=$(basename "$spell_path")
  
  # Create directory structure
  target_dir="$output_dir/spells/$(dirname "$rel_path")"
  mkdir -p "$target_dir"
  
  # Skip test infrastructure files - copy them as-is instead of compiling
  # test-bootstrap and boot imps need to remain uncompiled to work correctly
  case "$spell_path" in
    */test/test-bootstrap|*/test/boot/*)
      # Copy test infrastructure files directly
      cp "$spell_path" "$target_dir/$spell_name"
      chmod +x "$target_dir/$spell_name"
      compiled_count=$((compiled_count + 1))
      continue
      ;;
  esac
  
  # Compile spell: get relative path from repo root and compile
  spell_rel_path=${spell_path#$repo_dir/}
  target_file="$target_dir/$spell_name"
  
  # Call compile-spell from repo directory with full relative path and redirect output to target
  # Source invoke-wizardry in subshell to make all imps available for compilation
  # Call the function compile_spell directly (not the alias compile-spell)
  # because aliases don't work in non-interactive subshells without expand_aliases
  if (
    cd "$repo_dir" && \
    WIZARDRY_DIR="$repo_dir" && \
    export WIZARDRY_DIR && \
    . "$repo_dir/spells/.imps/sys/invoke-wizardry" && \
    compile_spell "$spell_rel_path"
  ) > "$target_file" 2>&1; then
    # Check if the target file is valid (has shebang)
    if head -n 1 "$target_file" 2>/dev/null | grep -q '^#!'; then
      chmod +x "$target_file"
      compiled_count=$((compiled_count + 1))
    else
      _warn "doppelganger: compilation produced invalid output for $spell_name"
      failed_count=$((failed_count + 1))
      rm -f "$target_file"
    fi
  else
    _warn "doppelganger: failed to compile $spell_name"
    failed_count=$((failed_count + 1))
    rm -f "$target_file"
  fi
done

compiled_count=$((compiled_count))
failed_count=$((failed_count))

# Copy test files (including hidden directories like .arcana and .imps)
_say "Copying test files..."
if [ -d "$repo_dir/.tests" ]; then
  # Copy all files including hidden ones
  (cd "$repo_dir/.tests" && \
    find . -mindepth 1 -maxdepth 1 -exec cp -r {} "$output_dir/.tests/" \; \
    2>/dev/null) || true
fi

# Copy essential files (README, LICENSE, etc.) but skip .git and .github
_say "Copying essential files..."
for file in "$repo_dir"/*; do
  basename_file=$(basename "$file")
  case "$basename_file" in
    .git|.github) continue ;;
    README*|LICENSE*|*.md)
      if [ -f "$file" ]; then
        cp "$file" "$output_dir/" 2>/dev/null || true
      fi
      ;;
  esac
done

_success "Doppelganger created successfully!"
_say "Location: $output_dir"
_say "Compiled: $compiled_count spells"
if [ "$failed_count" -gt 0 ]; then
  _warn "doppelganger: $failed_count spells failed to compile"
fi
}

# Self-execute when run directly (not sourced)
case "$0" in
  */doppelganger) doppelganger "$@" ;; esac
