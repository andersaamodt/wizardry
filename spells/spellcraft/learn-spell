#!/bin/sh

# This spell installs spells that define an install() function.
# It scans files for install() and runs them to set up shell integration.
# Bootstrappable - does not rely on wizardry scripts being installed.

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

show_usage() {
  cat <<'USAGE' >&2
Usage: learn-spell [-r] PATH...

Install spells that define an install() function. Scans paths for installable
spells and runs their install(). Use -r for recursive directory scanning.

Options:
  -r, --recursive  Recursively scan subdirectories
  --dry-run        Show what would be installed without executing
  -h, --help       Show this help message
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

# Find ask_yn helper
if [ -n "${MEMORIZE_ASK_YN-}" ]; then
  ASK_YN_HELPER=$MEMORIZE_ASK_YN
elif [ -x "$SPELLS_DIR/cantrips/ask_yn" ]; then
  ASK_YN_HELPER="$SPELLS_DIR/cantrips/ask_yn"
elif command -v ask_yn >/dev/null 2>&1; then
  ASK_YN_HELPER=$(command -v ask_yn)
else
  # Fallback to yes for non-interactive use
  ASK_YN_HELPER=""
fi

RECURSIVE=0
DRY_RUN=0
MEMORIZED_COUNT=0
SKIPPED_COUNT=0
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=
MEMORIZE_RC_FILE=
MEMORIZE_FORMAT=
DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE-}

warn() {
  printf '%s: %s\n' "$SCRIPT_NAME" "$1" >&2
}

detect_environment() {
  if [ "$MEMORIZE_DETECTED" -eq 1 ]; then
    return 0
  fi
  
  # Find detect-rc-file helper
  detect_rc_override=0
  if [ -n "${DETECT_RC_FILE-}" ]; then
    detect_rc_override=1
  elif [ -n "${MEMORIZE_DETECT_RC_FILE-}" ]; then
    DETECT_RC_FILE=$MEMORIZE_DETECT_RC_FILE
  else
    DETECT_RC_FILE=$SPELLS_DIR/divination/detect-rc-file
  fi
  
  if [ ! -x "$DETECT_RC_FILE" ]; then
    if [ "$detect_rc_override" -eq 0 ] && command -v detect-rc-file >/dev/null 2>&1; then
      DETECT_RC_FILE=$(command -v detect-rc-file)
    else
      printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing." >&2
      exit 1
    fi
  fi
  
  # Call detect-rc-file to get environment info
  output=$("$DETECT_RC_FILE")
  while IFS='=' read -r key value; do
    case $key in
    platform) MEMORIZE_PLATFORM=$value ;;
    rc_file) MEMORIZE_RC_FILE=$value ;;
    format) MEMORIZE_FORMAT=$value ;;
    esac
  done <<EOF_DETECT
$output
EOF_DETECT
  
  if [ -z "$MEMORIZE_RC_FILE" ]; then
    printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
    exit 1
  fi
  
  : "${MEMORIZE_PLATFORM:=unknown}"
  : "${MEMORIZE_FORMAT:=shell}"
  
  MEMORIZE_DETECTED=1
}

have_install_function() {
  file=$1
  [ -r "$file" ] || return 1
  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null
}

cleanup_wrapper() {
  [ -n "${MEMORIZE_WRAPPER-}" ] && [ -f "$MEMORIZE_WRAPPER" ] && rm -f "$MEMORIZE_WRAPPER"
}

create_wrapper() {
  MEMORIZE_WRAPPER=$(mktemp "${TMPDIR:-/tmp}/learn-spell.XXXXXX") || exit 1
  # The wrapper receives: TARGET RC_FILE RC_FORMAT PLATFORM
  # These are passed as positional arguments, not globals
  cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
set -eu
TARGET=$1
LEARN_SPELL_RC_FILE=$2
LEARN_SPELL_RC_FORMAT=$3
LEARN_SPELL_PLATFORM=$4
shift 4
[ -f "$TARGET" ] || { printf '%s\n' "learn-spell: missing target '$TARGET'" >&2; exit 1; }
# Export for install() function access
export LEARN_SPELL_RC_FILE LEARN_SPELL_RC_FORMAT LEARN_SPELL_PLATFORM
export LEARN_SPELL_TARGET="$TARGET"
. "$TARGET"
command -v install >/dev/null 2>&1 || { printf '%s\n' "learn-spell: $TARGET does not define install()" >&2; exit 1; }
install "$@"
WRAPPER
  trap cleanup_wrapper EXIT HUP INT TERM
}

get_interpreter() {
  target=$1
  first_line=''
  IFS= read -r first_line <"$target" || true
  case $first_line in
  '#!'*) first_line=${first_line#\#!} ;;
  *) first_line=/bin/sh ;;
  esac
  printf '%s' "$first_line" | tr -d '\r'
}

run_install() {
  target=$1
  [ -z "${MEMORIZE_WRAPPER-}" ] || [ ! -f "$MEMORIZE_WRAPPER" ] && create_wrapper
  detect_environment || return 1
  interpreter=$(get_interpreter "$target")
  : "${interpreter:=/bin/sh}"
  (
    set -- $interpreter
    [ "$#" -eq 0 ] && set -- /bin/sh
    "$@" "$MEMORIZE_WRAPPER" "$target" "$MEMORIZE_RC_FILE" "$MEMORIZE_FORMAT" "$MEMORIZE_PLATFORM"
  )
}

scribe_file() {
  path=$1
  if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  if [ "$DRY_RUN" -eq 1 ]; then
    printf '%s\n' "$path"
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
    return
  fi
  printf 'Memorizing %s...\n' "$path"
  if run_install "$path"; then
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
  else
    warn "Installation failed for '$path'."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
}

scan_directory() {
  dir=$1
  if [ ! -d "$dir" ]; then
    warn "'$dir' is not a directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  for entry in "$dir"/*; do
    [ -e "$entry" ] || continue
    if [ -d "$entry" ] && [ "$RECURSIVE" -eq 1 ]; then
      scan_directory "$entry"
    elif [ -f "$entry" ]; then
      scribe_file "$entry"
    fi
  done
}

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --dry-run)
    DRY_RUN=1
    shift
    ;;
  -h|--help)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    warn "Unknown option: $1"
    show_usage
    exit 1
    ;;
  *)
    break
    ;;
  esac
done

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

# Process paths
for path in "$@"; do
  if [ -d "$path" ]; then
    scan_directory "$path"
  elif [ -f "$path" ]; then
    scribe_file "$path"
  else
    warn "'$path' is not a file or directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
done

if [ "$DRY_RUN" -eq 1 ]; then
  printf 'Would memorize %d spell(s).\n' "$MEMORIZED_COUNT"
else
  printf 'Memorized %d spell(s).\n' "$MEMORIZED_COUNT"
fi

# Exit with failure if no spells were memorized and paths were skipped
if [ "$MEMORIZED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -gt 0 ]; then
  exit 1
fi

exit 0
