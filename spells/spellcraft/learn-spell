#!/bin/sh

# This spell installs spells that define an install() function.
# It scans files for install() and runs them to set up shell integration.
# Bootstrappable - does not rely on wizardry scripts being installed.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac

show_usage() {
  cat <<'USAGE' >&2
Usage: learn-spell [-r] PATH...

Install spells that define an install() function by scanning the given paths
and running each install hook. Use -r to recurse through directories and
--dry-run to see what would be installed without changing anything.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Initialize variables
RECURSIVE=0
DRY_RUN=0
MEMORIZED_COUNT=0
SKIPPED_COUNT=0
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=${WIZARDRY_PLATFORM-${MEMORIZE_PLATFORM-}}
MEMORIZE_RC_FILE=${WIZARDRY_RC_FILE-${MEMORIZE_RC_FILE-}}
MEMORIZE_FORMAT=${WIZARDRY_RC_FORMAT-${MEMORIZE_RC_FORMAT-}}
DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE-}
MEMORIZE_WRAPPER=""

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --dry-run)
    DRY_RUN=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    warn "learn-spell: Unknown option: $1"
    show_usage
    exit 1
    ;;
  *)
    break
    ;;
  esac
done

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

# Create wrapper function once if needed (for running install hooks)
if [ "$DRY_RUN" -eq 0 ]; then
  MEMORIZE_WRAPPER=$(temp-file learn-spell) || exit 1
  trap 'cleanup-file "$MEMORIZE_WRAPPER"' EXIT HUP INT TERM
  cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
set -eu
TARGET=$1
shift
[ -f "$TARGET" ] || {
  warn "learn-spell: missing target '$TARGET'"
  exit 1
}
WIZARDRY_MEMORIZE_TARGET="$TARGET"
export WIZARDRY_MEMORIZE_TARGET
. "$TARGET"
command -v install >/dev/null 2>&1 || {
  warn "learn-spell: $TARGET does not define install()"
  exit 1
}
install "$@"
WRAPPER
fi

# Process each path (file or directory)
process_path() {
  path=$1
  
  if [ -d "$path" ]; then
    # Scan directory
    for entry in "$path"/*; do
      [ -e "$entry" ] || continue
      if [ -d "$entry" ] && [ "$RECURSIVE" -eq 1 ]; then
        process_path "$entry"
      elif [ -f "$entry" ]; then
        process_path "$entry"
      fi
    done
  elif [ -f "$path" ]; then
    # Check if file has install() function
    if [ ! -x "$path" ] \
        || ! grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$path" 2>/dev/null; then
      SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
      return
    fi
    
    if [ "$DRY_RUN" -eq 1 ]; then
      printf '%s\n' "$path"
      MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
      return
    fi
    
    # Run install hook
    printf 'Memorizing %s...\n' "$path"
    
    # Detect environment once (inlined from detect_env_once)
    if [ "$MEMORIZE_DETECTED" -eq 0 ]; then
      detect_rc_override=0
      if [ -n "${DETECT_RC_FILE-}" ]; then
        detect_rc_override=1
      elif [ -n "${MEMORIZE_DETECT_RC_FILE-}" ]; then
        DETECT_RC_FILE=$MEMORIZE_DETECT_RC_FILE
      else
        DETECT_RC_FILE=$SPELLS_DIR/divination/detect-rc-file
      fi
      
      if [ ! -x "$DETECT_RC_FILE" ]; then
        if [ "$detect_rc_override" -eq 0 ] && command -v detect-rc-file >/dev/null 2>&1; then
          DETECT_RC_FILE=$(command -v detect-rc-file)
        else
          printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing." >&2
          return 1
        fi
      fi
      
      platform=$MEMORIZE_PLATFORM
      rc_file=$MEMORIZE_RC_FILE
      format=$MEMORIZE_FORMAT
      
      if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
        output=$("$DETECT_RC_FILE")
        while IFS='=' read -r key value; do
          case $key in
          platform) [ -z "$platform" ] && platform=$value ;;
          rc_file) [ -z "$rc_file" ] && rc_file=$value ;;
          format) [ -z "$format" ] && format=$value ;;
          esac
        done <<EOF_DETECT
$output
EOF_DETECT
      fi
      
      if [ -z "$rc_file" ]; then
        printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
        return 1
      fi
      
      : "${platform:=unknown}"
      : "${format:=shell}"
      
      MEMORIZE_PLATFORM=$platform
      MEMORIZE_RC_FILE=$rc_file
      MEMORIZE_FORMAT=$format
      export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
      export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
      export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
      MEMORIZE_DETECTED=1
    fi
    
    # Get interpreter from shebang
    first_line=''
    IFS= read -r first_line <"$path" || true
    case $first_line in
    '#!'*) interpreter=${first_line#\#!} ;;
    *) interpreter=/bin/sh ;;
    esac
    interpreter=$(printf '%s' "$interpreter" | tr -d '\r')
    : "${interpreter:=/bin/sh}"
    
    # Run installer in subshell with environment
    if (
      export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
      export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
      export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
      set -- $interpreter
      [ "$#" -eq 0 ] && set -- /bin/sh
      "$@" "$MEMORIZE_WRAPPER" "$path"
    ); then
      MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
    else
      warn "learn-spell: Installation failed for '$path'."
      SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    fi
  else
    warn "learn-spell: '$path' is not a file or directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
}

# Process all paths
for path in "$@"; do
  process_path "$path"
done

# Report results
if [ "$DRY_RUN" -eq 1 ]; then
  printf 'Would memorize %d spell(s).\n' "$MEMORIZED_COUNT"
else
  printf 'Memorized %d spell(s).\n' "$MEMORIZED_COUNT"
fi

# Exit with failure if no spells were memorized and paths were skipped
if [ "$MEMORIZED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -gt 0 ]; then
  exit 1
fi

exit 0
