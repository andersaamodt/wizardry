#!/bin/sh

# This spell installs spells that define an install() function.
# It scans files for install() and runs them to set up shell integration.
# Bootstrappable - does not rely on wizardry scripts being installed.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac

show_usage() {
  cat <<'USAGE' >&2
Usage: learn-spell [-r] PATH...

Install spells that define an install() function by scanning the given paths and running each install hook. Use -r to recurse through directories and --dry-run to see what would be installed without changing anything.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Find ask-yn helper
if [ -n "${MEMORIZE_ASK_YN-}" ]; then
  ASK_YN_HELPER=$MEMORIZE_ASK_YN
elif [ -x "$SPELLS_DIR/cantrips/ask-yn" ]; then
  ASK_YN_HELPER="$SPELLS_DIR/cantrips/ask-yn"
elif command -v ask-yn >/dev/null 2>&1; then
  ASK_YN_HELPER=$(command -v ask-yn)
else
  # Fallback to yes for non-interactive use
  ASK_YN_HELPER=""
fi

RECURSIVE=0
DRY_RUN=0
MEMORIZED_COUNT=0
SKIPPED_COUNT=0
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=${WIZARDRY_PLATFORM-${MEMORIZE_PLATFORM-}}
MEMORIZE_RC_FILE=${WIZARDRY_RC_FILE-${MEMORIZE_RC_FILE-}}
MEMORIZE_FORMAT=${WIZARDRY_RC_FORMAT-${MEMORIZE_RC_FORMAT-}}
DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE-}

warn() {
  printf '%s: %s\n' "$SCRIPT_NAME" "$1" >&2
}

detect_environment() {
  if [ "$MEMORIZE_DETECTED" -eq 1 ]; then
    return 0
  fi
  
  # Track whether DETECT_RC_FILE was explicitly set
  detect_rc_override=0
  if [ -n "${DETECT_RC_FILE-}" ]; then
    detect_rc_override=1
  elif [ -n "${MEMORIZE_DETECT_RC_FILE-}" ]; then
    DETECT_RC_FILE=$MEMORIZE_DETECT_RC_FILE
  else
    DETECT_RC_FILE=$SPELLS_DIR/divination/detect-rc-file
  fi
  
  if [ ! -x "$DETECT_RC_FILE" ]; then
    if [ "$detect_rc_override" -eq 0 ] && command -v detect-rc-file >/dev/null 2>&1; then
      DETECT_RC_FILE=$(command -v detect-rc-file)
    else
      printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing." >&2
      exit 1
    fi
  fi
  
  platform=$MEMORIZE_PLATFORM
  rc_file=$MEMORIZE_RC_FILE
  format=$MEMORIZE_FORMAT
  
  if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
    output=$("$DETECT_RC_FILE")
    while IFS='=' read -r key value; do
      case $key in
      platform) [ -z "$platform" ] && platform=$value ;;
      rc_file) [ -z "$rc_file" ] && rc_file=$value ;;
      format) [ -z "$format" ] && format=$value ;;
      esac
    done <<EOF_DETECT
$output
EOF_DETECT
  fi
  
  if [ -z "$rc_file" ]; then
    printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
    exit 1
  fi
  
  : "${platform:=unknown}"
  : "${format:=shell}"
  
  MEMORIZE_PLATFORM=$platform
  MEMORIZE_RC_FILE=$rc_file
  MEMORIZE_FORMAT=$format
  export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
  export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
  export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
  MEMORIZE_DETECTED=1
}

have_install_function() {
  file=$1
  [ -r "$file" ] || return 1
  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null
}

create_wrapper() {
  MEMORIZE_WRAPPER=$(temp-file learn-spell) || exit 1
  trap 'cleanup-file "$MEMORIZE_WRAPPER"' EXIT HUP INT TERM
  cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
set -eu
TARGET=$1
shift
[ -f "$TARGET" ] || { printf '%s\n' "learn-spell: missing target '$TARGET'" >&2; exit 1; }
WIZARDRY_MEMORIZE_TARGET="$TARGET"
export WIZARDRY_MEMORIZE_TARGET
. "$TARGET"
command -v install >/dev/null 2>&1 || { printf '%s\n' "learn-spell: $TARGET does not define install()" >&2; exit 1; }
install "$@"
WRAPPER
}

get_interpreter() {
  target=$1
  first_line=''
  IFS= read -r first_line <"$target" || true
  case $first_line in
  '#!'*) first_line=${first_line#\#!} ;;
  *) first_line=/bin/sh ;;
  esac
  printf '%s' "$first_line" | tr -d '\r'
}

run_install() {
  target=$1
  [ -z "${MEMORIZE_WRAPPER-}" ] || [ ! -f "$MEMORIZE_WRAPPER" ] && create_wrapper
  detect_environment || return 1
  interpreter=$(get_interpreter "$target")
  : "${interpreter:=/bin/sh}"
  (
    export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
    export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
    export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
    set -- $interpreter
    [ "$#" -eq 0 ] && set -- /bin/sh
    "$@" "$MEMORIZE_WRAPPER" "$target"
  )
}

scribe_file() {
  path=$1
  if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  if [ "$DRY_RUN" -eq 1 ]; then
    printf '%s\n' "$path"
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
    return
  fi
  printf 'Memorizing %s...\n' "$path"
  if run_install "$path"; then
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
  else
    warn "Installation failed for '$path'."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
}

scan_directory() {
  dir=$1
  if [ ! -d "$dir" ]; then
    warn "'$dir' is not a directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  for entry in "$dir"/*; do
    [ -e "$entry" ] || continue
    if [ -d "$entry" ] && [ "$RECURSIVE" -eq 1 ]; then
      scan_directory "$entry"
    elif [ -f "$entry" ]; then
      scribe_file "$entry"
    fi
  done
}

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --dry-run)
    DRY_RUN=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    warn "Unknown option: $1"
    show_usage
    exit 1
    ;;
  *)
    break
    ;;
  esac
done

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

# Process paths
for path in "$@"; do
  if [ -d "$path" ]; then
    scan_directory "$path"
  elif [ -f "$path" ]; then
    scribe_file "$path"
  else
    warn "'$path' is not a file or directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
done

if [ "$DRY_RUN" -eq 1 ]; then
  printf 'Would memorize %d spell(s).\n' "$MEMORIZED_COUNT"
else
  printf 'Memorized %d spell(s).\n' "$MEMORIZED_COUNT"
fi

# Exit with failure if no spells were memorized and paths were skipped
if [ "$MEMORIZED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -gt 0 ]; then
  exit 1
fi

exit 0
