#!/bin/sh

# This spell installs spells that define an install() function.
# It scans files for install() and runs them to set up shell integration.
# Bootstrappable - does not rely on wizardry scripts being installed.


script_name=$(basename "$0")
script_source=$0
case $script_source in
*/*) script_dir=${script_source%/*} ;;
*) script_dir=. ;;
esac

show_usage() {
  cat <<'USAGE' >&2
Usage: learn-spell [-r] PATH...

Install spells that define an install() function by scanning the given paths and running each install hook. Use -r to recurse through directories and --dry-run to see what would be installed without changing anything.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

script_dir=$(cd "$script_dir" && pwd -P)
spells_dir=${script_dir%/*}

# Find ask-yn helper
if [ -n "${memorize_ask_yn-}" ]; then
  ask_yn_helper=$memorize_ask_yn
elif [ -x "$spells_dir/cantrips/ask-yn" ]; then
  ask_yn_helper="$spells_dir/cantrips/ask-yn"
elif command -v ask-yn >/dev/null 2>&1; then
  ask_yn_helper=$(command -v ask-yn)
else
  # Fallback to yes for non-interactive use
  ask_yn_helper=""
fi

recursive=0
dry_run=0
memorized_count=0
skipped_count=0
memorize_detected=0
memorize_platform=${WIZARDRY_PLATFORM-${memorize_platform-}}
memorize_rc_file=${WIZARDRY_RC_FILE-${memorize_rc_file-}}
memorize_format=${WIZARDRY_RC_FORMAT-${MEMORIZE_RC_FORMAT-}}
detect_rc_file=${memorize_detect_rc_file-}

warn() {
  printf '%s: %s\n' "$script_name" "$1" >&2
}

detect_environment() {
  if [ "$memorize_detected" -eq 1 ]; then
    return 0
  fi
  
  # Track whether detect_rc_file was explicitly set
  detect_rc_override=0
  if [ -n "${detect_rc_file-}" ]; then
    detect_rc_override=1
  elif [ -n "${memorize_detect_rc_file-}" ]; then
    detect_rc_file=$memorize_detect_rc_file
  else
    detect_rc_file=$spells_dir/divination/detect-rc-file
  fi
  
  if [ ! -x "$detect_rc_file" ]; then
    if [ "$detect_rc_override" -eq 0 ] && command -v detect-rc-file >/dev/null 2>&1; then
      detect_rc_file=$(command -v detect-rc-file)
    else
      printf '%s\n' "$script_name: detect-rc-file spell is missing." >&2
      exit 1
    fi
  fi
  
  platform=$memorize_platform
  rc_file=$memorize_rc_file
  format=$memorize_format
  
  if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
    output=$("$detect_rc_file")
    while IFS='=' read -r key value; do
      case $key in
      platform) [ -z "$platform" ] && platform=$value ;;
      rc_file) [ -z "$rc_file" ] && rc_file=$value ;;
      format) [ -z "$format" ] && format=$value ;;
      esac
    done <<EOF_DETECT
$output
EOF_DETECT
  fi
  
  if [ -z "$rc_file" ]; then
    printf '%s\n' "$script_name: detect-rc-file did not yield an rc file." >&2
    exit 1
  fi
  
  : "${platform:=unknown}"
  : "${format:=shell}"
  
  memorize_platform=$platform
  memorize_rc_file=$rc_file
  memorize_format=$format
  export WIZARDRY_PLATFORM=$memorize_platform
  export WIZARDRY_RC_FILE=$memorize_rc_file
  export WIZARDRY_RC_FORMAT=$memorize_format
  memorize_detected=1
}

have_install_function() {
  file=$1
  [ -r "$file" ] || return 1
  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null
}

create_wrapper() {
  memorize_wrapper=$(temp-file learn-spell) || exit 1
  trap 'cleanup-file "$memorize_wrapper"' EXIT HUP INT TERM
  cat <<'WRAPPER' >"$memorize_wrapper"
set -eu
target=$1
shift
[ -f "$target" ] || { printf '%s\n' "learn-spell: missing target '$target'" >&2; exit 1; }
WIZARDRY_MEMORIZE_TARGET="$target"
export WIZARDRY_MEMORIZE_TARGET
. "$target"
command -v install >/dev/null 2>&1 || { printf '%s\n' "learn-spell: $target does not define install()" >&2; exit 1; }
install "$@"
WRAPPER
}

get_interpreter() {
  target=$1
  first_line=''
  IFS= read -r first_line <"$target" || true
  case $first_line in
  '#!'*) first_line=${first_line#\#!} ;;
  *) first_line=/bin/sh ;;
  esac
  printf '%s' "$first_line" | tr -d '\r'
}

run_install() {
  target=$1
  [ -z "${memorize_wrapper-}" ] || [ ! -f "$memorize_wrapper" ] && create_wrapper
  detect_environment || return 1
  interpreter=$(get_interpreter "$target")
  : "${interpreter:=/bin/sh}"
  (
    export WIZARDRY_PLATFORM=$memorize_platform
    export WIZARDRY_RC_FILE=$memorize_rc_file
    export WIZARDRY_RC_FORMAT=$memorize_format
    set -- $interpreter
    [ "$#" -eq 0 ] && set -- /bin/sh
    "$@" "$memorize_wrapper" "$target"
  )
}

scribe_file() {
  path=$1
  if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
    skipped_count=$((skipped_count + 1))
    return
  fi
  if [ "$dry_run" -eq 1 ]; then
    printf '%s\n' "$path"
    memorized_count=$((memorized_count + 1))
    return
  fi
  printf 'Memorizing %s...\n' "$path"
  if run_install "$path"; then
    memorized_count=$((memorized_count + 1))
  else
    warn "Installation failed for '$path'."
    skipped_count=$((skipped_count + 1))
  fi
}

scan_directory() {
  dir=$1
  if [ ! -d "$dir" ]; then
    warn "'$dir' is not a directory."
    skipped_count=$((skipped_count + 1))
    return
  fi
  for entry in "$dir"/*; do
    [ -e "$entry" ] || continue
    if [ -d "$entry" ] && [ "$recursive" -eq 1 ]; then
      scan_directory "$entry"
    elif [ -f "$entry" ]; then
      scribe_file "$entry"
    fi
  done
}

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    recursive=1
    shift
    ;;
  --dry-run)
    dry_run=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    warn "Unknown option: $1"
    show_usage
    exit 1
    ;;
  *)
    break
    ;;
  esac
done

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

# Process paths
for path in "$@"; do
  if [ -d "$path" ]; then
    scan_directory "$path"
  elif [ -f "$path" ]; then
    scribe_file "$path"
  else
    warn "'$path' is not a file or directory."
    skipped_count=$((skipped_count + 1))
  fi
done

if [ "$dry_run" -eq 1 ]; then
  printf 'Would memorize %d spell(s).\n' "$memorized_count"
else
  printf 'Memorized %d spell(s).\n' "$memorized_count"
fi

# Exit with failure if no spells were memorized and paths were skipped
if [ "$memorized_count" -eq 0 ] && [ "$skipped_count" -gt 0 ]; then
  exit 1
fi

exit 0
