#!/bin/sh

# This spell adds or removes a folder to your PATH permanently.
# Use learn-spellbook to manage which directories are available in your shell.

require-wizardry || exit 1

show_usage() {
        cat <<'USAGE' >&2
Usage: learn-spellbook {add|remove|remove-all|status} [DIRECTORY]

Add or remove directories to/from your shell PATH via rc file.
Use -r for recursive scanning, --dry-run to preview changes.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

script_source=$0
case $script_source in
*/*)
        script_dir=${script_source%/*}
        ;;
*)
        resolved=$(command -v "$script_source" 2>/dev/null || printf '%s' "$script_source")
        script_dir=${resolved%/*}
        script_source=$resolved
        ;;
esac
set -eu

if [ -z "$script_dir" ] || [ "$script_dir" = "$script_source" ]; then
        script_dir=.
fi
script_dir=$(cd "$script_dir" && pwd -P)
detect_rc_file_default="$script_dir/../divination/detect-rc-file"
learn_default="$script_dir/../spellcraft/learn"
# Path to text imps for indentation detection
imps_text_dir="$script_dir/../.imps/text"

detect_override=0
if [ -n "${detect_rc_file-}" ]; then
        detect_override=1
else
        detect_rc_file=$detect_rc_file_default
fi

learn_override=0
if [ -n "${learn_spell-}" ]; then
        learn_override=1
        learn=$learn_spell
elif [ -n "${scribe_spell-}" ]; then
        # Legacy environment variable for backwards compatibility
        learn_override=1
        learn=$scribe_spell
else
        learn=$learn_default
fi

if [ ! -x "$detect_rc_file" ]; then
        if [ "$detect_override" -eq 1 ]; then
                printf '%s\n' "learn-spellbook: required helper '$detect_rc_file' is missing or not executable." >&2
                exit 1
        fi

        if command -v detect-rc-file >/dev/null 2>&1; then
                detect_rc_file=$(command -v detect-rc-file)
        else
                printf '%s\n' "learn-spellbook: required helper '$detect_rc_file' is missing or not executable." >&2
                exit 1
        fi
fi

if [ ! -x "$learn" ]; then
        if [ "$learn_override" -eq 1 ]; then
                printf '%s\n' "learn-spellbook: required helper '$learn' is missing or not executable." >&2
                exit 1
        fi

        if command -v learn >/dev/null 2>&1; then
                learn=$(command -v learn)
        else
                printf '%s\n' "learn-spellbook: required helper '$learn' is missing or not executable." >&2
                exit 1
        fi
fi

# shellcheck disable=SC2039 # POSIX compliant but we rely on some utilities like awk.

recursive=0
batch_add_file=""
dry_run=0

while [ "$#" -gt 0 ]; do
        case $1 in
        -r|--recursive)
                recursive=1
                shift
                ;;
        --dry-run)
                dry_run=1
                shift
                ;;
        --recursive=*)
                recursive=1
                shift
                ;;
        --batch-add-from-file)
                # Internal flag: add all directories listed in file in single operation
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "learn-spellbook: --batch-add-from-file expects a file path" >&2
                        exit 1
                fi
                batch_add_file=$2
                shift 2
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "learn-spellbook: unknown option '$1'" >&2
                show_usage
                exit 1
                ;;
        *)
                break
                ;;
        esac
done

# Handle batch add mode specially - it doesn't need action/directory arguments
if [ -n "$batch_add_file" ]; then
        action="add"
        directory=""
        batch_mode=1
else
        batch_mode=0
        
        # We require at least one argument to decide whether we are adding, removing,
        # or checking the PATH entry. Showing usage keeps the interface self-documenting
        # for new Wizards-in-training.
        if [ "$#" -eq 0 ]; then
                show_usage
                exit 1
        fi
        
        action=$1
        shift
        
        case $action in
        add|remove|remove-all|status) : ;;
        *)
                printf '%s\n' "Error: The first argument must be 'add', 'remove', 'remove-all', or 'status'." >&2
                exit 1
                ;;
        esac
        
        if [ "$action" = "status" ] && [ "$#" -eq 0 ]; then
                printf '%s\n' "Error: The 'status' action expects a directory argument." >&2
                exit 1
        fi
fi

# Resolve the provided directory so that PATH entries are always absolute.
# Normalising here means the rc files never contain brittle relative paths.
normalize_directory() {
        directory=$1
        case $directory in
        "~")
                directory=$HOME
                ;;
        "~"/*)
                directory=$HOME/${directory#\~/}
                ;;
        esac

        if [ "$directory" = "" ]; then
                printf '%s\n' "Error: The directory does not exist." >&2
                exit 1
        fi

        if [ ! -d "$directory" ]; then
                printf '%s\n' "Error: The directory does not exist." >&2
                exit 1
        fi

        case $directory in
        /*) : ;;
        .)
                directory=$(pwd -P)
                ;;
        ..|../*|./*)
                directory=$(cd "$directory" && pwd -P)
                ;;
        *)
                directory=$(cd "$directory" && pwd -P)
                ;;
        esac

        printf '%s' "$directory"
}

# Skip directory normalization for batch mode and remove-all action
if [ "$batch_mode" -eq 0 ] && [ "$action" != "remove-all" ]; then
        if [ "$action" = "add" ]; then
                if [ "$#" -eq 0 ]; then
                        directory=$(normalize_directory "$(pwd -P)")
                else
                        directory=$(normalize_directory "$1")
                fi
        elif [ "$action" = "remove" ] || [ "$action" = "status" ]; then
                if [ "$#" -eq 0 ]; then
                        printf '%s\n' "Error: The '$action' action expects a directory argument." >&2
                        exit 1
                fi
                directory=$(normalize_directory "$1")
        fi
        
        if [ "$action" != "status" ] && [ "$#" -gt 1 ]; then
                shift
        else
                if [ "$#" -gt 0 ]; then
                        shift
                fi
        fi
fi

# Generate a timestamp for backup file naming. Tries date formats first,
# falls back to epoch seconds, then process ID prefixed with 'pid' for clarity.
generate_backup_timestamp() {
        date +%Y%m%d%H%M%S 2>/dev/null || date +%s 2>/dev/null || printf 'pid%s' "$$"
}

# Validate batch add file if specified
if [ "$batch_mode" -eq 1 ] && [ ! -f "$batch_add_file" ]; then
        printf '%s\n' "Error: Batch file '$batch_add_file' not found." >&2
        exit 1
fi

# When requested, operate recursively by invoking learn-spellbook on each
# discovered directory.  This leverages the existing single-directory
# implementation so we keep behaviour consistent across formats.
if [ "$recursive" -eq 1 ]; then
        tmp_file=$(temp-file learn-spellbook) || {
                printf '%s\n' "Error: Unable to enumerate directories under '$directory'." >&2
                exit 1
        }
        trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
        if ! find "$directory" -type d -print | sort >"$tmp_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to enumerate directories under '$directory'." >&2
                exit 1
        fi

        # In dry-run mode, just print paths that would be added
        if [ "$dry_run" -eq 1 ] && [ "$action" = "add" ]; then
                cat "$tmp_file"
                trap - EXIT HUP INT TERM
                cleanup-file "$tmp_file"
                exit 0
        fi

        # Detect format early for optimized recursive handling
        recursive_detect=$("$detect_rc_file" 2>/dev/null) || true
        recursive_format=$(printf '%s\n' "$recursive_detect" | while IFS='=' read -r k v; do
                [ "$k" = "format" ] && printf '%s' "$v"
        done)
        [ -z "$recursive_format" ] && recursive_format=shell

        # For nix format, collect all directories and add them in a single operation.
        # This is more efficient than invoking nix_add per directory since nix_add
        # already rewrites the entire block each time.
        if [ "$recursive_format" = "nix" ] && [ "$action" = "add" ]; then
                # Collect all directories into a list
                all_dirs=""
                while IFS= read -r subdir; do
                        if [ -z "$all_dirs" ]; then
                                all_dirs="$subdir"
                        else
                                all_dirs="$all_dirs
$subdir"
                        fi
                done <"$tmp_file"
                
                # Run single invocation with all directories passed as arguments
                # (We pass them through a temp file since command line length limits)
                run_nix_batch_add() {
                        set -- "$0"
                        set -- "$@" --batch-add-from-file "$tmp_file"
                        "$@"
                }
                
                if run_nix_batch_add; then
                        trap - EXIT HUP INT TERM
                        cleanup-file "$tmp_file"
                        exit 0
                else
                        status=$?
                        trap - EXIT HUP INT TERM
                        cleanup-file "$tmp_file"
                        exit $status
                fi
        fi

        run_recursive_action() {
                subdir=$1
                set -- "$0"
                set -- "$@" "$action" "$subdir"
                "$@"
        }

        result=0
        while IFS= read -r subdir; do
                if run_recursive_action "$subdir"; then
                        :
                else
                        status=$?
                        if [ "$result" -eq 0 ]; then
                                result=$status
                        fi
                        if [ "$action" = "status" ]; then
                                break
                        fi
                fi
        done <"$tmp_file"

        trap - EXIT HUP INT TERM
        cleanup-file "$tmp_file"
        exit $result
fi

# Use detect-rc-file to derive sane defaults. This keeps the CLI consistent 
# with the installer and any other spell that edits shell start-up files.
detect_output=$("$detect_rc_file")
rc_file=""
format=""
# detect-rc-file now outputs only the RC file path (single line)
if [ -n "$detect_output" ]; then
        rc_file="$detect_output"
fi

if [ -z "$rc_file" ]; then
        printf '%s\n' "learn-spellbook: unable to determine a startup file." >&2
        exit 1
fi

if [ -z "$format" ]; then
        case $rc_file in
        *.nix)
                format=nix
                ;;
        *)
                format=shell
                ;;
        esac
fi

case $format in
shell|nix) : ;;
*)
        printf '%s\n' "Error: Unsupported format '$format'." >&2
        exit 1
        ;;
esac

# Determine if the rc file requires elevated privileges to modify.
# System-level files like /etc/nixos/configuration.nix need sudo.
needs_sudo=0
case $rc_file in
/etc/*)
        if [ ! -w "$rc_file" ] 2>/dev/null && [ ! -w "$(dirname "$rc_file")" ] 2>/dev/null; then
                needs_sudo=1
        fi
        ;;
esac

# Helper to run a command, optionally with sudo for system-level files.
# Usage: run_maybe_sudo command [args...]
run_maybe_sudo() {
        if [ "$needs_sudo" -eq 1 ]; then
                if command -v sudo >/dev/null 2>&1; then
                        sudo "$@"
                elif command -v doas >/dev/null 2>&1; then
                        doas "$@"
                else
                        printf '%s\n' "learn-spellbook: sudo or doas required to modify '$rc_file'." >&2
                        exit 1
                fi
        else
                "$@"
        fi
}

# These literal export lines represent how we manage PATH entries inside shell
# rc files. The quoted variant is the format we now write, while the legacy
# string tracks the buggy form that escaped "$PATH" and therefore replaced the
# variable with a literal. Retaining both lets us tidy older installs while
# keeping removals idempotent. Variables are only populated when a directory
# argument is provided (add/remove/status actions require a directory).
managed_export_line=""
legacy_export_line=""
legacy_quoted_export_line=""
if [ -n "${directory-}" ]; then
        managed_export_line=$(printf 'export PATH="%s:$PATH"' "$directory")
        legacy_export_line=$(printf 'export PATH=%s:\\$PATH' "$directory")
        legacy_quoted_export_line=$(printf 'export PATH="%s:\\$PATH"' "$directory")
fi

# Track whether we refreshed a legacy export line so the caller can surface an
# appropriate message to the user.
legacy_export_refreshed=0

spell_identifier_for_directory() {
        dir=$1
        checksum=$(printf '%s' "$dir" | cksum | awk '{print $1}')
        safe=$(printf '%s' "$dir" | tr -c 'A-Za-z0-9._-' '_')
        printf 'path-%s-%s' "$safe" "$checksum"
}

# Create the parent directory for the rc file when it does not already exist.
# This lets us initialise fresh environments without manual scaffolding.
ensure_rc_directory() {
        rc_dir=${rc_file%/*}
        if [ "$rc_dir" != "$rc_file" ] && [ ! -d "$rc_dir" ]; then
                run_maybe_sudo mkdir -p "$rc_dir"
        fi
}

# configuration.nix deserves extra care: before we rewrite anything, stash a
# timestamped backup so users can inspect or restore the previous version.
# Callers are responsible for calling this only once per operation.
# Uses the backup-nix-config imp to standardize backup behavior across the project.
backup_nix_config_file() {
        if [ "$format" != "nix" ]; then
                return 0
        fi
        if [ ! -f "$rc_file" ]; then
                return 0
        fi

        if ! backup-nix-config "$rc_file"; then
                printf '%s\n' "learn-spellbook: unable to back up '$rc_file'." >&2
                exit 1
        fi
}

# Replace the historical buggy export line with the corrected form.  When no
# legacy entry exists we leave the rc file untouched. The caller can consult
# the legacy_export_refreshed flag to decide which message to print.
refresh_legacy_shell_export() {
        legacy_export_refreshed=0
        if [ ! -f "$rc_file" ]; then
                return 0
        fi

        # Create temp file adjacent to rc_file for atomic mv (same filesystem)
        tmp_file="$rc_file.wizardry.$$"
        : >"$tmp_file"
        trap 'rm -f "$tmp_file"' EXIT HUP INT TERM
        changed=0

        while IFS= read -r line; do
                case $line in
                "$legacy_export_line"|"$legacy_quoted_export_line")
                        changed=1
                        printf '%s\n' "$managed_export_line" >>"$tmp_file"
                        ;;
                *)
                        printf '%s\n' "$line" >>"$tmp_file"
                        ;;
                esac
        done <"$rc_file"

        if [ "$changed" -eq 0 ]; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                return 0
        fi

        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to refresh '$rc_file'." >&2
                exit 1
        fi

        trap - EXIT HUP INT TERM
        legacy_export_refreshed=1
        return 0
}

# Append the export line to POSIX shell rc files when it is not already
# present. Each branch prints guidance so users know what changed.
shell_add() {
        ensure_rc_directory
        if [ ! -f "$rc_file" ]; then
                : >"$rc_file"
        fi
        refresh_legacy_shell_export
        if [ "$legacy_export_refreshed" -eq 1 ]; then
                printf '%s\n' "Refreshed the existing wizardry PATH entry in '$rc_file' so '$directory' stays reachable. The change takes effect in new shell sessions."
                return 0
        fi
        if shell_status; then
                printf '%s\n' "'$directory' is already exported in '$rc_file'; nothing changed."
                return 0
        fi
        spell_name=$(spell_identifier_for_directory "$directory")
        if ! printf '%s\n' "$managed_export_line" | "$learn" --spell "$spell_name" add; then
                printf '%s\n' "learn-spellbook: unable to record the PATH entry." >&2
                exit 1
        fi
        printf '%s\n' "Added '$directory' to PATH via '$rc_file'. The change takes effect in new shell sessions."
}

# Remove a previously added export line from shell rc files.
shell_remove() {
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "Error: The startup file '$rc_file' does not exist." >&2
                exit 1
        fi
        spell_name=$(spell_identifier_for_directory "$directory")
        if "$learn" --spell "$spell_name" status >/dev/null 2>&1; then
                "$learn" --spell "$spell_name" remove
                printf '%s\n' "Removed '$directory' from PATH entries recorded in '$rc_file'. The change takes effect in new shell sessions."
                return 0
        fi
        has_managed=0
        if grep -Fqx "$managed_export_line" "$rc_file" 2>/dev/null; then
                has_managed=1
        fi
        has_legacy=0
        if grep -Fqx "$legacy_export_line" "$rc_file" 2>/dev/null; then
                has_legacy=1
        fi
        if grep -Fqx "$legacy_quoted_export_line" "$rc_file" 2>/dev/null; then
                has_legacy=1
        fi
        if [ "$has_managed" -eq 0 ] && [ "$has_legacy" -eq 0 ]; then
                printf '%s\n' "Error: The directory is not in your PATH." >&2
                exit 1
        fi
        # Create temp file adjacent to rc_file for atomic mv (same filesystem)
        tmp_file="$rc_file.wizardry.$$"
        : >"$tmp_file"
        trap 'rm -f "$tmp_file"' EXIT HUP INT TERM
        while IFS= read -r line; do
                case $line in
                "$managed_export_line"|"$legacy_export_line"|"$legacy_quoted_export_line")
                        ;;
                *)
                        printf '%s\n' "$line" >>"$tmp_file"
                        ;;
                esac
        done <"$rc_file"
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                printf '%s\n' "Error: Unable to replace '$rc_file'." >&2
                exit 1
        fi
        trap - EXIT HUP INT TERM
        printf '%s\n' "Removed '$directory' from PATH entries recorded in '$rc_file'. The change takes effect in new shell sessions."
}

# Identify whether the requested directory already appears in an export line
# within the provided rc file.  This mirrors how the installer reasons about
# idempotence so that every caller (installer, manual invocation, tests) shares
# exactly the same definition of “already present”.
shell_path_contains_directory() {
        file=$1
        target_dir=$2

        if [ ! -f "$file" ]; then
                return 1
        fi

        home_hint=""
        tilde_hint=""

        if [ -n "${HOME-}" ]; then
                case $target_dir in
                "$HOME"/*)
                        rel_path=${target_dir#"$HOME"/}
                        home_hint=$(printf '%s' "\$HOME/$rel_path")
                        tilde_hint=$(printf '%s' "~/$rel_path")
                        ;;
                esac
        fi

        awk -v dir="$target_dir" -v home_hint="$home_hint" -v tilde_hint="$tilde_hint" '
        /^[[:space:]]*#/ { next }
        {
                if ($0 ~ /(^|[[:space:]])PATH=/) {
                        if (index($0, dir)) {
                                found = 1
                                exit
                        }
                        if (home_hint != "" && index($0, home_hint)) {
                                found = 1
                                exit
                        }
                        if (tilde_hint != "" && index($0, tilde_hint)) {
                                found = 1
                                exit
                        }
                }
        }
        END {
                if (found) {
                        exit 0
                }
                exit 1
        }
        ' "$file"
}

# status returns success when the directory is already exported, allowing
# callers to avoid duplicate additions. It simply defers to the shared helper
# above so that every shell PATH check behaves the same way.
shell_status() {
        shell_path_contains_directory "$rc_file" "$directory"
}

# Remove all wizardry-managed PATH entries from shell rc files.
# Uses learn to remove all wizardry spell blocks.
shell_remove_all() {
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "Error: The configuration file '$rc_file' does not exist." >&2
                exit 1
        fi
        
        # Find all wizardry path spell identifiers and remove them
        # learn blocks are marked with spell names like "path-<path>-<checksum>"
        removed_count=0
        tmp_spells=$(temp-file learn-spellbook-spells) || exit 1
        
        # Extract spell names from the rc file that look like learn-spellbook entries
        # Format: # >>> <spell_name> >>>
        grep -o '# >>> path-[^>]*>>>' "$rc_file" 2>/dev/null | sed 's/# >>> //;s/ >>>//' | sort -u >"$tmp_spells" || true
        
        while IFS= read -r spell_name; do
                [ -z "$spell_name" ] && continue
                if "$learn" --spell "$spell_name" status >/dev/null 2>&1; then
                        "$learn" --spell "$spell_name" remove 2>/dev/null || true
                        removed_count=$((removed_count + 1))
                fi
        done <"$tmp_spells"
        cleanup-file "$tmp_spells"
        
        if [ "$removed_count" -gt 0 ]; then
                printf '%s\n' "Removed $removed_count wizardry PATH entries from '$rc_file'. The change takes effect in new shell sessions."
        else
                printf '%s\n' "No wizardry PATH entries found in '$rc_file'."
        fi
}

# Check if a path is already in the wizardry-managed PATH entries.
# Returns 0 if found, 1 otherwise.
has_wizardry_nix_path() {
        path_to_check=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Look for the path in wizardry-marked lines within environment.sessionVariables.PATH
        # Each path appears as "path" # wizardry
        grep -F "# wizardry" "$rc_file" 2>/dev/null | grep -Fq "\"$path_to_check\"" 2>/dev/null
}

# Parse the wizardry PATH block in configuration.nix and echo each tracked path.
extract_nix_paths() {
        if [ ! -f "$rc_file" ]; then
                return 0
        fi
        # Extract paths from wizardry-marked lines within environment.sessionVariables.PATH
        # Format: "path" # wizardry
        # Use || true to avoid exit on grep finding no matches
        grep -F "# wizardry" "$rc_file" 2>/dev/null | sed -n 's/.*"\([^"]*\)".*# wizardry.*/\1/p' || true
}

# Remove all wizardry PATH lines from configuration.nix
remove_wizardry_nix_lines() {
        tmp_file=$(temp-file learn-spellbook-nix) || exit 1
        # Remove wizardry-marked path lines and clean up empty sessionVariables.PATH blocks
        run_maybe_sudo cat "$rc_file" | awk '
        BEGIN { in_block = 0; block_start = 0; pending = "" }
        /environment\.sessionVariables\.PATH[[:space:]]*=/ {
                in_block = 1
                block_start = NR
                pending = $0
                next
        }
        in_block && /\];/ {
                in_block = 0
                # Check if block only had wizardry entries (now removed)
                # If so, skip the entire block
                if (pending ~ /environment\.sessionVariables\.PATH[[:space:]]*=[[:space:]]*\[/ && $0 ~ /^[[:space:]]*\];/) {
                        pending = ""
                        next
                }
                if (pending != "") print pending
                print
                pending = ""
                next
        }
        in_block && /# wizardry/ {
                # Skip wizardry-marked lines
                next
        }
        in_block {
                pending = pending "\n" $0
                next
        }
        { print }
        ' >"$tmp_file"
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
                cleanup-file "$tmp_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
}

# Remove a specific path from wizardry PATH block and rebuild
remove_wizardry_nix_path() {
        path_to_remove=$1
        
        # Get current paths
        tmp_paths=$(temp-file learn-spellbook-paths) || exit 1
        extract_nix_paths >"$tmp_paths"
        
        # Remove all wizardry lines and sessionVariables.PATH block
        tmp_file=$(temp-file learn-spellbook-nix) || exit 1
        run_maybe_sudo cat "$rc_file" | awk '
        BEGIN { in_block = 0; skip_block = 0 }
        /environment\.sessionVariables\.PATH[[:space:]]*=/ {
                in_block = 1
                # Check if this looks like a wizardry-only block
                skip_block = 1
                next
        }
        in_block && /\];/ {
                in_block = 0
                skip_block = 0
                next
        }
        in_block && /# wizardry/ {
                next
        }
        in_block && !/^[[:space:]]*$/ && !/^[[:space:]]*\[/ {
                # Non-wizardry content in block, do not skip
                skip_block = 0
        }
        in_block {
                next
        }
        { print }
        ' >"$tmp_file"
        
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
        cleanup-file "$tmp_file"
        
        # Build new path list excluding the removed path
        remaining_paths=""
        while IFS= read -r p; do
                [ -z "$p" ] && continue
                [ "$p" = "$path_to_remove" ] && continue
                if [ -z "$remaining_paths" ]; then
                        remaining_paths="$p"
                else
                        remaining_paths="$remaining_paths
$p"
                fi
        done <"$tmp_paths"
        cleanup-file "$tmp_paths"
        
        # If there are remaining paths, add them back
        if [ -n "$remaining_paths" ]; then
                write_wizardry_nix_path_block "$remaining_paths"
        fi
}

# Write the wizardry PATH block with the given newline-separated path list
# Uses environment.sessionVariables.PATH as a multi-line array of strings
# Each path added by wizardry has a # wizardry comment
write_wizardry_nix_path_block() {
        paths_input=$1
        
        # Detect indentation style from the existing config file
        indent_l1=""
        indent_l2=""
        if [ -x "$imps_text_dir/make-indent" ] && [ -f "$rc_file" ]; then
                indent_l1=$("$imps_text_dir/make-indent" 1 "$rc_file")
                indent_l2=$("$imps_text_dir/make-indent" 2 "$rc_file")
        else
                # Fallback to 2-space indentation
                indent_l1="  "
                indent_l2="    "
        fi
        
        # Build the multi-line array content directly (avoid subshell/temp file overhead)
        path_lines=""
        # Use a here-string approach with a while loop in the current shell
        while IFS= read -r p; do
                [ -z "$p" ] && continue
                if [ -z "$path_lines" ]; then
                        path_lines="${indent_l2}\"$p\" # wizardry"
                else
                        path_lines="$path_lines
${indent_l2}\"$p\" # wizardry"
                fi
        done <<EOF
$paths_input
EOF
        
        # If no paths, don't write anything
        [ -z "$path_lines" ] && return 0
        
        # Write the block to a temp file (avoids BSD awk newline-in-variable issues)
        block_file=$(temp-file learn-spellbook-block) || exit 1
        {
                printf '%senvironment.sessionVariables.PATH = [\n' "$indent_l1"
                printf '%s\n' "$path_lines"
                printf '%s];\n' "$indent_l1"
        } >"$block_file"
        
        # Insert before the closing brace
        tmp_file=$(temp-file learn-spellbook-nix) || exit 1
        final_file=$(temp-file learn-spellbook-final) || exit 1
        run_maybe_sudo cat "$rc_file" >"$tmp_file"
        
        # Use awk with file reading instead of -v variable (BSD awk compatible)
        awk -v blockfile="$block_file" '
        BEGIN {
                while ((getline line < blockfile) > 0) {
                        block[++blen] = line
                }
                close(blockfile)
        }
        {
                lines[NR] = $0
        }
        END {
                if (NR == 0) {
                        for (i = 1; i <= blen; i++) print block[i]
                        exit
                }
                # Find the last closing brace
                last = NR
                while (last > 0 && lines[last] ~ /^[[:space:]]*$/) {
                        last--
                }
                if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
                        for (i = 1; i < last; i++) print lines[i]
                        if (last > 1 && lines[last-1] !~ /^[[:space:]]*$/) {
                                print ""
                        }
                        for (i = 1; i <= blen; i++) print block[i]
                        print lines[last]
                        for (i = last + 1; i <= NR; i++) print lines[i]
                } else {
                        for (i = 1; i <= NR; i++) print lines[i]
                        if (NR > 0 && lines[NR] !~ /^[[:space:]]*$/) {
                                print ""
                        }
                        for (i = 1; i <= blen; i++) print block[i]
                }
        }
        ' "$tmp_file" >"$final_file"
        
        cleanup-file "$block_file"
        
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$final_file" "$rc_file"
                cleanup-file "$tmp_file"
                cleanup-file "$final_file"
        else
                mv "$final_file" "$rc_file"
                cleanup-file "$tmp_file"
        fi
}

# Add a path entry to configuration.nix with wizardry marker.
# Uses environment.sessionVariables.PATH as a multi-line array of strings.
# Each line added by wizardry has a # wizardry comment.
add_wizardry_nix_path() {
        path_to_add=$1
        
        # Check if this exact path is already added
        if has_wizardry_nix_path "$path_to_add"; then
                return 0
        fi
        
        # Get existing paths and build new list (newline-separated)
        tmp_paths=$(temp-file learn-spellbook-paths) || exit 1
        extract_nix_paths >"$tmp_paths"
        
        # Build path list: new path first, then existing paths
        new_path_list="$path_to_add"
        while IFS= read -r p; do
                [ -z "$p" ] && continue
                new_path_list="$new_path_list
$p"
        done <"$tmp_paths"
        cleanup-file "$tmp_paths"
        
        # Remove existing wizardry PATH block if present
        tmp_file=$(temp-file learn-spellbook-nix) || exit 1
        run_maybe_sudo cat "$rc_file" | awk '
        BEGIN { in_block = 0 }
        /environment\.sessionVariables\.PATH[[:space:]]*=/ {
                in_block = 1
                next
        }
        in_block && /\];/ {
                in_block = 0
                next
        }
        in_block && /# wizardry/ {
                next
        }
        in_block {
                next
        }
        { print }
        ' >"$tmp_file"
        if [ "$needs_sudo" -eq 1 ]; then
                run_maybe_sudo cp "$tmp_file" "$rc_file"
        else
                mv "$tmp_file" "$rc_file"
        fi
        cleanup-file "$tmp_file"
        
        # Write the new block with all paths
        write_wizardry_nix_path_block "$new_path_list"
}

# Add a directory to the managed list inside configuration.nix. Duplicates are
# ignored so repeated runs stay harmless. Uses inline # wizardry markers.
nix_add() {
        ensure_rc_directory
        
        # Create a minimal config file if none exists
        if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
                new_content_tmp=$(temp-file learn-spellbook-new) || exit 1
                {
                        printf '{ config, pkgs, ... }:\n'
                        printf '\n'
                        printf '{\n'
                        printf '}\n'
                } >"$new_content_tmp"
                if [ "$needs_sudo" -eq 1 ]; then
                        run_maybe_sudo cp "$new_content_tmp" "$rc_file"
                        cleanup-file "$new_content_tmp"
                else
                        mv "$new_content_tmp" "$rc_file"
                fi
        fi
        
        # Check if this path is already added
        if has_wizardry_nix_path "$directory"; then
                printf '%s\n' "'$directory' is already listed in '$rc_file'; nothing changed."
                return 0
        fi
        
        backup_nix_config_file
        add_wizardry_nix_path "$directory"
        printf '%s\n' "Recorded '$directory' in '$rc_file'. Rebuild your Nix environment to activate the change."
}

# Remove a directory from configuration.nix. Only removes wizardry-marked lines.
nix_remove() {
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "Error: The startup file '$rc_file' does not exist." >&2
                exit 1
        fi
        
        # Check if this path exists in wizardry-marked lines
        if ! has_wizardry_nix_path "$directory"; then
                printf '%s\n' "Error: The directory is not in your PATH." >&2
                exit 1
        fi
        
        backup_nix_config_file
        remove_wizardry_nix_path "$directory"
        printf '%s\n' "Removed '$directory' from '$rc_file'. Rebuild your Nix environment to activate the change."
}

# status for configuration.nix - returns success only when the directory
# is present in wizardry-marked lines.
nix_status() {
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        has_wizardry_nix_path "$directory"
}

# Remove all wizardry-managed PATH entries from configuration.nix.
nix_remove_all() {
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "Error: The configuration file '$rc_file' does not exist." >&2
                exit 1
        fi
        
        # Count paths before removal
        path_count=$(extract_nix_paths | wc -l | tr -d ' ')
        
        if [ "$path_count" -eq 0 ]; then
                printf '%s\n' "No wizardry PATH entries found in '$rc_file'."
                return 0
        fi
        
        backup_nix_config_file
        remove_wizardry_nix_lines
        printf '%s\n' "Removed $path_count wizardry PATH entries from '$rc_file'. Rebuild your Nix environment to activate the change."
}

# Handle batch add mode - process all directories from file at once
if [ "$batch_mode" -eq 1 ]; then
        if [ "$format" != "nix" ]; then
                printf '%s\n' "Error: Batch add mode is only supported for nix format." >&2
                exit 1
        fi
        
        # Create a minimal config file if none exists
        if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
                ensure_rc_directory
                new_content_tmp=$(temp-file learn-spellbook-new) || exit 1
                {
                        printf '{ config, pkgs, ... }:\n'
                        printf '\n'
                        printf '{\n'
                        printf '}\n'
                } >"$new_content_tmp"
                if [ "$needs_sudo" -eq 1 ]; then
                        run_maybe_sudo cp "$new_content_tmp" "$rc_file"
                        cleanup-file "$new_content_tmp"
                else
                        mv "$new_content_tmp" "$rc_file"
                fi
        fi
        
        # Read all directories and build a newline-separated path list
        all_dirs=""
        added_count=0
        while IFS= read -r dir; do
                [ -d "$dir" ] || continue
                case $dir in
                /*) : ;;
                *) dir=$(cd "$dir" 2>/dev/null && pwd -P) || continue ;;
                esac
                if ! has_wizardry_nix_path "$dir"; then
                        if [ -z "$all_dirs" ]; then
                                all_dirs="$dir"
                        else
                                all_dirs="$all_dirs
$dir"
                        fi
                        added_count=$((added_count + 1))
                fi
        done <"$batch_add_file"
        
        # Add all directories at once
        if [ -n "$all_dirs" ]; then
                # Backup the config file before modifying
                backup_nix_config_file
                
                # Get existing paths and append them
                tmp_paths=$(temp-file learn-spellbook-paths) || exit 1
                extract_nix_paths >"$tmp_paths"
                
                full_path_list="$all_dirs"
                while IFS= read -r p; do
                        [ -z "$p" ] && continue
                        full_path_list="$full_path_list
$p"
                done <"$tmp_paths"
                cleanup-file "$tmp_paths"
                
                # Remove existing wizardry PATH block if present
                tmp_file=$(temp-file learn-spellbook-nix) || exit 1
                run_maybe_sudo cat "$rc_file" | awk '
                BEGIN { in_block = 0 }
                /environment\.sessionVariables\.PATH[[:space:]]*=/ {
                        in_block = 1
                        next
                }
                in_block && /\];/ {
                        in_block = 0
                        next
                }
                in_block && /# wizardry/ {
                        next
                }
                in_block {
                        next
                }
                { print }
                ' >"$tmp_file"
                if [ "$needs_sudo" -eq 1 ]; then
                        run_maybe_sudo cp "$tmp_file" "$rc_file"
                else
                        mv "$tmp_file" "$rc_file"
                fi
                cleanup-file "$tmp_file"
                
                # Write the new block with all paths
                write_wizardry_nix_path_block "$full_path_list"
        else
                added_count=0
        fi
        
        printf '%s\n' "Recorded $added_count directories in '$rc_file'. Rebuild your Nix environment to activate the change."
        exit 0
fi

# Handle dry-run mode for single directory (non-recursive case)
if [ "$dry_run" -eq 1 ] && [ "$action" = "add" ]; then
        printf '%s\n' "$directory"
        exit 0
fi

case $format in
shell)
        case $action in
        add)
                shell_add
                ;;
        remove)
                shell_remove
                ;;
        remove-all)
                shell_remove_all
                ;;
        status)
                shell_status
                ;;
        esac
        ;;
nix)
        case $action in
        add)
                nix_add
                ;;
        remove)
                nix_remove
                ;;
        remove-all)
                nix_remove_all
                ;;
        status)
                nix_status
                ;;
        esac
        ;;
esac
