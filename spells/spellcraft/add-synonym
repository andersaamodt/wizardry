#!/bin/sh
# This spell adds a synonym (alias) for an existing spell.
# Synonyms are stored in SPELLBOOK_DIR/.synonyms as shell aliases.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: add-synonym WORD SPELL [ARGS...]
       add-synonym  (interactive mode)

Add a synonym (alias) for an existing spell.

Arguments:
  WORD     The synonym word (simple name only)
  SPELL    The target spell or command
  ARGS     Optional arguments to pass to the spell

Examples:
  add-synonym ll "ls -l"
  add-synonym clone "git clone"
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

  # Parse arguments
  synonym_word=""
  target_spell=""

  if [ "$#" -ge 2 ]; then
    synonym_word=${1-}
    shift
    # Join remaining arguments as the target spell (allows quoting)
    target_spell="$*"
  elif [ "$#" -eq 1 ]; then
    printf '%s\n' "add-synonym: requires both WORD and SPELL arguments" >&2
    exit 2
  else
    # Interactive mode
    printf 'Synonym word (simple name only): ' >&2
    if ! IFS= read -r synonym_word; then
      printf '%s\n' "add-synonym: failed to read synonym word" >&2
      exit 1
    fi
    
    printf 'Target spell or command: ' >&2
    if ! IFS= read -r target_spell; then
      printf '%s\n' "add-synonym: failed to read target spell" >&2
      exit 1
    fi
  fi

  # Validate synonym word (must be non-empty and valid)
  if [ -z "$synonym_word" ]; then
    printf '%s\n' "add-synonym: synonym word cannot be empty" >&2
    exit 2
  fi

  # Check for invalid characters in synonym word
  case $synonym_word in
    *[/\ \	\'\"\$\`\\\|\&\;\(\)\<\>\*\?\[\]]*)
      printf '%s\n' "add-synonym: synonym word cannot contain spaces or special characters" >&2
      printf '%s\n' "Invalid characters: / \\ | & ; ( ) < > * ? [ ] \$ \` ' \" space tab" >&2
      exit 2
      ;;
    -*)
      printf '%s\n' "add-synonym: synonym word cannot start with a dash" >&2
      exit 2
      ;;
    .*)
      printf '%s\n' "add-synonym: synonym word cannot start with a dot" >&2
      exit 2
      ;;
    [0-9]*)
      printf '%s\n' "add-synonym: synonym word cannot start with a number" >&2
      exit 2
      ;;
  esac

  # Check if synonym word is a shell keyword or builtin
  case $synonym_word in
    if|then|else|elif|fi|case|esac|for|while|until|do|done|in| \
    function|time|select|\{|\}|\[\[|\]\]|!)
      printf '%s\n' "add-synonym: cannot override shell keyword: $synonym_word" >&2
      exit 2
      ;;
  esac

  # Check for common builtins that should not be overridden
  case $synonym_word in
    cd|echo|printf|test|true|false|exit|return|break|continue|eval|exec| \
    export|readonly|set|shift|source|trap|unset)
      warn "add-synonym: '$synonym_word' is a shell builtin"
      printf 'Aliases cannot override builtins. Continue anyway? (y/N): ' >&2
      IFS= read -r confirm || confirm="n"
      case $confirm in
        y|Y|yes|YES) ;;
        *) 
          printf '%s\n' "add-synonym: cancelled" >&2
          exit 1
          ;;
      esac
      ;;
  esac

  # Validate target spell
  if [ -z "$target_spell" ]; then
    printf '%s\n' "add-synonym: target spell cannot be empty" >&2
    exit 2
  fi

  # Check if target spell contains problematic characters that might not work in aliases
  case $target_spell in
    *\`*|\$\(*)
      warn "add-synonym: target contains command substitution"
      info "This may not work as expected in aliases"
      printf 'Continue anyway? (y/N): ' >&2
      IFS= read -r confirm || confirm="n"
      case $confirm in
        y|Y|yes|YES) ;;
        *) 
          printf '%s\n' "add-synonym: cancelled" >&2
          exit 1
          ;;
      esac
      ;;
  esac

  # Extract first word of target spell to check if it exists
  target_first_word=$(printf '%s' "$target_spell" | awk '{print $1}')
  if [ -n "$target_first_word" ]; then
    if ! command -v "$target_first_word" >/dev/null 2>&1; then
      warn "add-synonym: target command '$target_first_word' not found in PATH"
      printf 'Continue anyway? (y/N): ' >&2
      IFS= read -r confirm || confirm="n"
      case $confirm in
        y|Y|yes|YES) ;;
        *) 
          printf '%s\n' "add-synonym: cancelled" >&2
          exit 1
          ;;
      esac
    fi
  fi

  # Check if target spell must be sourced (affects synonym format)
  # This follows the same logic as invoke-thesaurus
  spell_must_be_sourced=0
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  
  # Try to find the spell file
  spell_path=""
  if [ -f "$wizardry_dir/spells/$target_first_word" ]; then
    spell_path="$wizardry_dir/spells/$target_first_word"
  else
    # Try common spell directories
    spell_dirs="translocation cantrips arcane divination enchant psi"
    spell_dirs="$spell_dirs crypto wards mud spellcraft menu system"
    for spell_dir in $spell_dirs; do
      if [ -f "$wizardry_dir/spells/$spell_dir/$target_first_word" ]; then
        spell_path="$wizardry_dir/spells/$spell_dir/$target_first_word"
        break
      fi
    done
  fi
  
  # Check if spell uses uncastable (requires sourcing)
  if [ -n "$spell_path" ] && [ -f "$spell_path" ]; then
    if head -30 "$spell_path" 2>/dev/null | grep -q "uncastable"; then
      spell_must_be_sourced=1
    fi
  fi

  # Check if synonym already exists (in either file)
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  custom_file="$spell_home/.synonyms"
  default_file="$spell_home/.default-synonyms"

  # Check for duplicates in both files
  # Look for both alias and function definitions
  already_exists=0
  existing_location=""
  existing_target=""

  # Check custom file for both alias and function definitions
  if [ -f "$custom_file" ]; then
    if grep -q "^alias $synonym_word=" "$custom_file" 2>/dev/null; then
      already_exists=1
      existing_location="custom"
      existing_target=$(grep "^alias $synonym_word=" "$custom_file" | \
        sed "s/^alias $synonym_word='\\(.*\\)'$/\\1/" | sed "s/'\\\\''/'/g")
    elif grep -q "^$synonym_word()" "$custom_file" 2>/dev/null; then
      already_exists=1
      existing_location="custom"
      # Extract target from function definition: word() { . target "$@"; }
      # Use [[:space:]] for POSIX compatibility instead of \s
      existing_target=$(grep "^$synonym_word()" "$custom_file" | \
        sed 's/.*{[[:space:]]*\.[[:space:]]*\([^ ]*\).*/\1/')
    fi
  fi

  # Only check default if not already found in custom
  if [ "$already_exists" -eq 0 ] && [ -f "$default_file" ]; then
    if grep -q "^alias $synonym_word=" "$default_file" 2>/dev/null; then
      already_exists=1
      existing_location="default"
      existing_target=$(grep "^alias $synonym_word=" "$default_file" | \
        sed "s/^alias $synonym_word='\\(.*\\)'$/\\1/" | sed "s/'\\\\''/'/g")
    elif grep -q "^$synonym_word()" "$default_file" 2>/dev/null; then
      already_exists=1
      existing_location="default"
      existing_target=$(grep "^$synonym_word()" "$default_file" | \
        sed 's/.*{[[:space:]]*\.[[:space:]]*\([^ ]*\).*/\1/')
    fi
  fi

  if [ "$already_exists" -eq 1 ]; then
    warn "add-synonym: synonym '$synonym_word' already exists"
    info "  Location: $existing_location"
    info "  Current: $synonym_word â†’ $existing_target"
    printf 'Overwrite with new target? (y/N): ' >&2
    IFS= read -r confirm || confirm="n"
    case $confirm in
      y|Y|yes|YES) ;;
      *) 
        printf '%s\n' "add-synonym: cancelled" >&2
        exit 1
        ;;
    esac
    
    # If overwriting, remove old definition (alias and function forms)
    if [ -f "$custom_file" ]; then
      has_alias=$(grep -q "^alias $synonym_word=" "$custom_file" 2>/dev/null && echo 1 || echo 0)
      has_func=$(grep -q "^$synonym_word()" "$custom_file" 2>/dev/null && echo 1 || echo 0)
      if [ "$has_alias" -eq 1 ] || [ "$has_func" -eq 1 ]; then
        temp_file=$(temp-file synonyms) || exit 1
        grep -v "^alias $synonym_word=" "$custom_file" | \
          grep -v "^$synonym_word()" > "$temp_file" || true
        mv "$temp_file" "$custom_file"
      fi
    fi
  fi

  # Ensure custom synonyms file exists
  if [ ! -f "$custom_file" ]; then
    mkdir -p "$spell_home" 2>/dev/null || true
    cat > "$custom_file" << 'HEADER'
# Wizardry Custom Synonyms
# This file contains your custom shell aliases.
# Loaded automatically by invoke-wizardry at shell startup.
# Reload with: . invoke-thesaurus

HEADER
  fi

  # Escape single quotes in target_spell for alias definition
  escaped_spell=$(printf '%s' "$target_spell" | sed "s/'/'\\\\''/g")

  # Determine whether to create an alias or function
  # Functions can only be created for non-hyphenated names (POSIX sh limitation)
  # And only when the target spell must be sourced
  if [ "$spell_must_be_sourced" -eq 1 ]; then
    case "$synonym_word" in
      *-*)
        # Hyphenated - must use alias (POSIX sh limitation)
        # Function names can't have hyphens in POSIX sh
        printf "alias %s='%s'\n" "$synonym_word" "$escaped_spell" >> "$custom_file"
        success "Synonym created: $synonym_word -> $target_spell"
        warn_msg="target requires sourcing, but aliases cannot source"
        warn "add-synonym: $warn_msg - function needed but hyphenated names not supported"
        info "Note: Hyphenated names cannot be functions in POSIX sh"
        info "To use this synonym, manually type: . leap-to-marker"
        info "Reload with: . invoke-thesaurus"
        ;;
      *)
        # Non-hyphenated name - create a sourcing function
        printf "%s() { . %s \"\$@\"; }\n" "$synonym_word" "$target_spell" >> "$custom_file"
        success "Synonym created: $synonym_word -> $target_spell (as function)"
        info "Note: Function created because target requires sourcing"
        info "Reload with: . invoke-thesaurus"
        ;;
    esac
  else
    # Regular spell - create an alias
    printf "alias %s='%s'\n" "$synonym_word" "$escaped_spell" >> "$custom_file"
    success "Synonym created: $synonym_word -> $target_spell"
    info "Reload with: . invoke-thesaurus"
    info "Note: Aliases only work in interactive shells, not in scripts"
  fi
