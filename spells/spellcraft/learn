#!/bin/sh

# This spell installs spells with an install() function into your shell
# environment. For rc file snippet management, use learn-rc directly.

show_usage() {
  cat <<'USAGE'
Usage: learn [PATH...]

Install spells that define an install() function. Scans paths for installable
spells and runs their install(). Defaults to current directory if no path given.
USAGE
}

# Handle help and detect rc mode for backward compatibility
for arg in "$@"; do
  case $arg in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --spell|--spell=*)
    # Backward compatibility: delegate to learn-rc
    SCRIPT_SOURCE=$0
    case $SCRIPT_SOURCE in
    */*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
    *) SCRIPT_DIR=. ;;
    esac
    SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
    LEARN_RC="$SCRIPT_DIR/learn-rc"
    if [ ! -x "$LEARN_RC" ]; then
      if command -v learn-rc >/dev/null 2>&1; then
        LEARN_RC=$(command -v learn-rc)
      else
        printf '%s\n' "learn: learn-rc helper is missing for rc mode." >&2
        exit 1
      fi
    fi
    exec "$LEARN_RC" "$@"
    ;;
  esac
done

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Find detect-rc-file helper
find_detect_rc_file() {
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    printf '%s' "$DETECT_RC_FILE"
    return 0
  fi
  helper="$SPELLS_DIR/divination/detect-rc-file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v detect-rc-file >/dev/null 2>&1; then
    command -v detect-rc-file
    return 0
  fi
  return 1
}

MEMORIZED_COUNT=0
SKIPPED_COUNT=0
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=${WIZARDRY_PLATFORM-}
MEMORIZE_RC_FILE=${WIZARDRY_RC_FILE-}
MEMORIZE_FORMAT=${WIZARDRY_RC_FORMAT-}

warn() {
  printf '%s: %s\n' "$SCRIPT_NAME" "$1" >&2
}

detect_environment() {
  if [ "$MEMORIZE_DETECTED" -eq 1 ]; then
    return 0
  fi
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing." >&2
    exit 1
  fi
  platform=$MEMORIZE_PLATFORM
  rc_file=$MEMORIZE_RC_FILE
  format=$MEMORIZE_FORMAT
  if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
    output=$("$detect_helper")
    while IFS='=' read -r key value; do
      case $key in
      platform) [ -z "$platform" ] && platform=$value ;;
      rc_file) [ -z "$rc_file" ] && rc_file=$value ;;
      format) [ -z "$format" ] && format=$value ;;
      esac
    done <<EOF_DETECT
$output
EOF_DETECT
  fi
  if [ -z "$rc_file" ]; then
    printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
    exit 1
  fi
  : "${platform:=unknown}"
  : "${format:=shell}"
  MEMORIZE_PLATFORM=$platform
  MEMORIZE_RC_FILE=$rc_file
  MEMORIZE_FORMAT=$format
  export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
  export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
  export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
  MEMORIZE_DETECTED=1
}

have_install_function() {
  file=$1
  [ -r "$file" ] || return 1
  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null
}

cleanup_wrapper() {
  [ -n "${MEMORIZE_WRAPPER-}" ] && [ -f "$MEMORIZE_WRAPPER" ] && rm -f "$MEMORIZE_WRAPPER"
}

create_wrapper() {
  MEMORIZE_WRAPPER=$(mktemp "${TMPDIR:-/tmp}/learn.XXXXXX") || exit 1
  cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
set -eu
TARGET=$1
shift
[ -f "$TARGET" ] || { printf '%s\n' "learn wrapper: missing target '$TARGET'" >&2; exit 1; }
WIZARDRY_MEMORIZE_TARGET="$TARGET"
export WIZARDRY_MEMORIZE_TARGET
. "$TARGET"
command -v install >/dev/null 2>&1 || { printf '%s\n' "learn wrapper: $TARGET does not define install()" >&2; exit 1; }
install "$@"
WRAPPER
  trap cleanup_wrapper EXIT HUP INT TERM
}

get_interpreter() {
  target=$1
  first_line=''
  IFS= read -r first_line <"$target" || true
  case $first_line in
  '#!'*) first_line=${first_line#\#!} ;;
  *) first_line=/bin/sh ;;
  esac
  printf '%s' "$first_line" | tr -d '\r'
}

run_install() {
  target=$1
  [ -z "${MEMORIZE_WRAPPER-}" ] || [ ! -f "$MEMORIZE_WRAPPER" ] && create_wrapper
  detect_environment || return 1
  interpreter=$(get_interpreter "$target")
  : "${interpreter:=/bin/sh}"
  (
    export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
    export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
    export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
    set -- $interpreter
    [ "$#" -eq 0 ] && set -- /bin/sh
    "$@" "$MEMORIZE_WRAPPER" "$target"
  )
}

scribe_file() {
  path=$1
  if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  printf 'Memorizing %s...\n' "$path"
  if run_install "$path"; then
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
  else
    warn "Installation failed for '$path'."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
}

scan_directory() {
  dir=$1
  if [ ! -d "$dir" ]; then
    warn "'$dir' is not a directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  for entry in "$dir"/*; do
    [ -e "$entry" ] || continue
    [ -f "$entry" ] && scribe_file "$entry"
  done
}

# Parse arguments - default to current directory
paths=""
while [ $# -gt 0 ]; do
  case $1 in
  --)
    shift
    break
    ;;
  -*)
    warn "Unknown option: $1"
    show_usage >&2
    exit 1
    ;;
  *)
    paths="$paths $1"
    shift
    ;;
  esac
done

# Add remaining args after --
for arg in "$@"; do
  paths="$paths $arg"
done

# Default to current directory
if [ -z "$paths" ]; then
  paths="."
fi

# Process paths
for path in $paths; do
  if [ -d "$path" ]; then
    scan_directory "$path"
  else
    scribe_file "$path"
  fi
done

printf 'Memorized %d spell(s).\n' "$MEMORIZED_COUNT"
exit 0
