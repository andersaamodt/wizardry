#!/bin/sh

# This spell is a smart wrapper that delegates to specialized spells:
# - learn-spell for files (installs spells with install() functions)
# - learn-spellbook for folders (adds directories to PATH)
# It also handles --spell mode for RC file snippet management.

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

usage() {
  cat <<USAGE >&2
Usage: $SCRIPT_NAME [-r] PATH...
       $SCRIPT_NAME --spell NAME {add|remove|status}

Smart wrapper that delegates to learn-spell (files) or learn-spellbook (folders).
Use -r for recursive processing. Use --spell mode for RC file snippets.
USAGE
}

# Check for --spell mode first (RC file management)
for arg in "$@"; do
  case $arg in
  --help|-h)
    usage
    exit 0
    ;;
  --spell|--spell=*)
    MODE=rc
    ;;
  esac
done

# Find helpers
find_learn_spell() {
  helper="$SCRIPT_DIR/learn-spell"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v learn-spell >/dev/null 2>&1; then
    command -v learn-spell
    return 0
  fi
  return 1
}

find_learn_spellbook() {
  helper="$SCRIPT_DIR/learn-spellbook"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v learn-spellbook >/dev/null 2>&1; then
    command -v learn-spellbook
    return 0
  fi
  return 1
}

# Helper function for non-empty check
nonempty() {
  [ -n "$1" ]
}

# ---------------------
# RC MODE IMPLEMENTATION
# ---------------------

rc_usage() {
  cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
}

# Find detect-rc-file helper
find_detect_rc_file() {
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    printf '%s' "$DETECT_RC_FILE"
    return 0
  fi
  helper="$SPELLS_DIR/divination/detect-rc-file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v detect-rc-file >/dev/null 2>&1; then
    command -v detect-rc-file
    return 0
  fi
  return 1
}

auto_detect_rc() {
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "learn: detect-rc-file helper not found." >&2
    return 1
  fi
  output=$("$detect_helper")
  rc_file_detected=''
  platform_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    platform) platform_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn: detect-rc-file did not provide an rc file." >&2
    return 1
  fi
  printf '%s\n' "rc_file=$rc_file_detected"
  printf '%s\n' "platform=${platform_detected:-unknown}"
  printf '%s\n' "format=${format_detected:-shell}"
}

rc_run() {
  action=""
  spell=""
  rc_format=""
  shell_type="bash"

  while [ "$#" -gt 0 ]; do
    case $1 in
    --spell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --spell expects a name." >&2
        rc_usage
        exit 1
      fi
      spell=$2
      shift 2
      ;;
    --spell=*)
      spell=${1#*=}
      shift
      ;;
    --shell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --shell expects a value." >&2
        rc_usage
        exit 1
      fi
      shell_type=$2
      shift 2
      ;;
    --shell=*)
      shell_type=${1#*=}
      shift
      ;;
    add|remove|status)
      if [ -n "$action" ]; then
        printf '%s\n' "learn: only one action may be specified." >&2
        rc_usage
        exit 1
      fi
      action=$1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "learn: unknown option '$1'." >&2
      rc_usage
      exit 1
      ;;
    *)
      printf '%s\n' "learn: unexpected argument '$1'." >&2
      rc_usage
      exit 1
      ;;
    esac
  done

  if [ -z "$action" ] || [ -z "$spell" ]; then
    rc_usage
    exit 1
  fi

  # Always auto-detect rc file and format
  if ! detect_output=$(auto_detect_rc); then
    exit 1
  fi
  rc_file=""
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT

  if [ -z "$rc_file" ]; then
    printf '%s\n' "learn: unable to determine rc file." >&2
    exit 1
  fi

  # Default format to shell if not detected
  if [ -z "$rc_format" ]; then
    rc_format="shell"
  fi

  # Auto-detect format from file extension (overrides detected format)
  case $rc_file in
  *.nix) rc_format=nix ;;
  esac

  case $spell in
  *[!A-Za-z0-9._:-]*)
    printf '%s\n' "learn: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
    exit 1
    ;;
  esac

  spell_tag="# wizardry: $spell"
  legacy_spell_tag="# wizardry-spell: $spell"
  inline_marker=" $spell_tag"
  legacy_inline_marker=" $legacy_spell_tag"
  block_start="$spell_tag begin"
  legacy_block_start="$legacy_spell_tag begin"
  block_end="$spell_tag end"
  legacy_block_end="$legacy_spell_tag end"
  block_prefix="$spell_tag lines="
  legacy_prefix="$legacy_spell_tag lines="

  ensure_rc_directory() {
    dir=${rc_file%/*}
    if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
      mkdir -p "$dir"
    fi
  }

  spell_status() {
    if [ ! -f "$rc_file" ]; then
      return 1
    fi
    if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    return 1
  }

  ensure_trailing_newline() {
    if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
      return 0
    fi
    last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
    if [ "$last_char" != "012" ]; then
      printf '\n' >>"$rc_file"
    fi
  }

  add_spell() {
    ensure_rc_directory
    tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn.XXXXXX") || exit 1
    line_count=0
    while IFS= read -r line || nonempty "$line"; do
      printf '%s\n' "$line" >>"$tmp_file"
      line_count=$((line_count + 1))
    done
    if [ "$line_count" -eq 0 ]; then
      rm -f "$tmp_file"
      printf '%s\n' "learn: no spell content provided on stdin." >&2
      exit 1
    fi
    if spell_status; then
      rm -f "$tmp_file"
      return 0
    fi
    if [ ! -f "$rc_file" ]; then
      : >"$rc_file"
    fi
    ensure_trailing_newline
    if [ "$line_count" -eq 1 ]; then
      first_line=$(sed -n '1p' "$tmp_file")
      printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
      rm -f "$tmp_file"
      return 0
    fi
    block_header="$block_start lines=$line_count"
    printf '%s\n' "$block_header" >>"$rc_file"
    cat "$tmp_file" >>"$rc_file"
    printf '%s\n' "$block_end" >>"$rc_file"
    rm -f "$tmp_file"
  }

  remove_spell() {
    if [ ! -f "$rc_file" ]; then
      printf '%s\n' "learn: cannot remove from missing file '$rc_file'." >&2
      exit 1
    fi
    tmp_file=$(mktemp "${TMPDIR:-/tmp}/learn.XXXXXX") || exit 1
    removing_block=0
    to_skip=0
    removed=0
    while IFS= read -r line || nonempty "$line"; do
      if [ "$removing_block" -eq 1 ]; then
        case $line in
        "$block_end"|"$legacy_block_end")
          removing_block=0
          ;;
        esac
        continue
      fi
      if [ "$to_skip" -gt 0 ]; then
        to_skip=$((to_skip - 1))
        continue
      fi
      case $line in
      "$block_start"*|"$legacy_block_start"*)
        removing_block=1
        removed=1
        continue
        ;;
      "$block_prefix"*)
        count=${line#"$block_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      "$legacy_prefix"*)
        count=${line#"$legacy_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      *"$inline_marker"|*"$legacy_inline_marker")
        removed=1
        continue
        ;;
      esac
      printf '%s\n' "$line" >>"$tmp_file"
    done <"$rc_file"
    if [ "$removed" -eq 0 ]; then
      rm -f "$tmp_file"
      printf '%s\n' "learn: spell '$spell' not found in '$rc_file'." >&2
      exit 1
    fi
    mv "$tmp_file" "$rc_file"
  }

  # Find nix-shell-init helper
  find_nix_shell_init() {
    if [ -n "${NIX_SHELL_INIT-}" ] && [ -x "$NIX_SHELL_INIT" ]; then
      printf '%s' "$NIX_SHELL_INIT"
      return 0
    fi
    helper="$SCRIPT_DIR/../.imps/sys/nix-shell-init"
    if [ -x "$helper" ]; then
      printf '%s' "$helper"
      return 0
    fi
    if command -v nix-shell-init >/dev/null 2>&1; then
      command -v nix-shell-init
      return 0
    fi
    return 1
  }

  nix_spell_status() {
    if ! nix_helper=$(find_nix_shell_init); then
      printf '%s\n' "learn: nix-shell-init imp not found." >&2
      exit 1
    fi
    "$nix_helper" status --shell "$shell_type" --name "$spell" --file "$rc_file"
  }

  nix_add_spell() {
    if ! nix_helper=$(find_nix_shell_init); then
      printf '%s\n' "learn: nix-shell-init imp not found." >&2
      exit 1
    fi
    "$nix_helper" add --shell "$shell_type" --name "$spell" --file "$rc_file"
  }

  nix_remove_spell() {
    if ! nix_helper=$(find_nix_shell_init); then
      printf '%s\n' "learn: nix-shell-init imp not found." >&2
      exit 1
    fi
    "$nix_helper" remove --shell "$shell_type" --name "$spell" --file "$rc_file"
  }

  if [ "$rc_format" = "nix" ]; then
    case $action in
    add) nix_add_spell ;;
    remove) nix_remove_spell ;;
    status)
      if nix_spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  else
    case $action in
    add) add_spell ;;
    remove) remove_spell ;;
    status)
      if spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  fi
}

if [ "${MODE-}" = "rc" ]; then
  rc_run "$@"
  exit $?
fi

# ---------------------
# PATH MODE - Delegate to learn-spell or learn-spellbook
# ---------------------

RECURSIVE=0
paths=""

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  -h|--help)
    usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn: unknown option '$1'." >&2
    usage
    exit 1
    ;;
  *)
    paths="$paths $1"
    shift
    ;;
  esac
done

# Add remaining args
for arg in "$@"; do
  paths="$paths $arg"
done

# Require at least one path
if [ -z "$paths" ]; then
  usage
  exit 1
fi

# Find helpers
LEARN_SPELL=""
LEARN_SPELLBOOK=""
if ! LEARN_SPELL=$(find_learn_spell); then
  printf '%s\n' "learn: learn-spell helper not found." >&2
  exit 1
fi
if ! LEARN_SPELLBOOK=$(find_learn_spellbook); then
  printf '%s\n' "learn: learn-spellbook helper not found." >&2
  exit 1
fi

# Process each path
for path in $paths; do
  if [ -f "$path" ]; then
    # File -> learn-spell
    "$LEARN_SPELL" "$path"
  elif [ -d "$path" ]; then
    # Directory -> learn-spellbook (with -r if recursive)
    if [ "$RECURSIVE" -eq 1 ]; then
      "$LEARN_SPELLBOOK" -r add "$path"
    else
      "$LEARN_SPELLBOOK" add "$path"
    fi
  else
    printf '%s\n' "learn: '$path' is not a file or directory." >&2
  fi
done

exit 0
