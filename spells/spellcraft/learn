#!/bin/sh

# This spell helps with learning spells:
# - For files: installs spells with install() functions via learn-spell
# - For directories: informs that they are automatically available via invoke-wizardry
# It also handles --spell mode for RC file snippet management.


script_name=$(basename "$0")
script_source=$0
case $script_source in
*/*) script_dir=${script_source%/*} ;;
*) script_dir=. ;;
esac

show_usage() {
  cat <<USAGE >&2
Usage: $script_name [-r] PATH...
       $script_name --spell NAME {add|remove|status}

For files: installs spells with install() functions via learn-spell.
For directories: informs that they are automatically available via invoke-wizardry.
Use --spell mode for RC file snippet management.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

script_dir=$(cd "$script_dir" && pwd -P)
spells_dir=${script_dir%/*}

# Check for --spell mode first (RC file management)
for arg in "$@"; do
  case $arg in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --spell|--spell=*)
    mode=rc
    ;;
  esac
done

# Find helpers
find_learn_spell() {
  helper="$script_dir/learn-spell"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v learn-spell >/dev/null 2>&1; then
    command -v learn-spell
    return 0
  fi
  return 1
}

# Helper function for non-empty check
nonempty() {
  [ -n "$1" ]
}

# ---------------------
# RC mode IMPLEMENTATION
# ---------------------

rc_usage() {
  cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
}

# Find detect-rc-file helper
find_detect_rc_file() {
  # Try from PATH first (allows test override)
  if command -v detect-rc-file >/dev/null 2>&1; then
    command -v detect-rc-file
    return 0
  fi
  # Fallback to relative path from spells dir
  helper="$spells_dir/divination/detect-rc-file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  return 1
}

auto_detect_rc() {
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "learn: detect-rc-file helper not found." >&2
    return 1
  fi
  output=$("$detect_helper")
  rc_file_detected=''
  platform_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    platform) platform_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn: detect-rc-file did not provide an rc file." >&2
    return 1
  fi
  printf '%s\n' "rc_file=$rc_file_detected"
  printf '%s\n' "platform=${platform_detected:-unknown}"
  printf '%s\n' "format=${format_detected:-shell}"
}

rc_run() {
  action=""
  spell=""
  rc_format=""
  shell_type="bash"

  while [ "$#" -gt 0 ]; do
    case $1 in
    --spell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --spell expects a name." >&2
        rc_usage
        exit 1
      fi
      spell=$2
      shift 2
      ;;
    --spell=*)
      spell=${1#*=}
      shift
      ;;
    --shell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --shell expects a value." >&2
        rc_usage
        exit 1
      fi
      shell_type=$2
      shift 2
      ;;
    --shell=*)
      shell_type=${1#*=}
      shift
      ;;
    add|remove|status)
      if [ -n "$action" ]; then
        printf '%s\n' "learn: only one action may be specified." >&2
        rc_usage
        exit 1
      fi
      action=$1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "learn: unknown option '$1'." >&2
      rc_usage
      exit 1
      ;;
    *)
      printf '%s\n' "learn: unexpected argument '$1'." >&2
      rc_usage
      exit 1
      ;;
    esac
  done

  if [ -z "$action" ] || [ -z "$spell" ]; then
    rc_usage
    exit 1
  fi

  # Always auto-detect rc file and format
  if ! detect_output=$(auto_detect_rc); then
    exit 1
  fi
  rc_file=""
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT

  if [ -z "$rc_file" ]; then
    printf '%s\n' "learn: unable to determine rc file." >&2
    exit 1
  fi

  # Default format to shell if not detected
  if [ -z "$rc_format" ]; then
    rc_format="shell"
  fi

  # Auto-detect format from file extension (overrides detected format)
  case $rc_file in
  *.nix) rc_format=nix ;;
  esac

  case $spell in
  *[!A-Za-z0-9._:-]*)
    printf '%s\n' "learn: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
    exit 1
    ;;
  esac

  spell_tag="# wizardry: $spell"
  legacy_spell_tag="# wizardry-spell: $spell"
  inline_marker=" $spell_tag"
  legacy_inline_marker=" $legacy_spell_tag"
  block_start="$spell_tag begin"
  legacy_block_start="$legacy_spell_tag begin"
  block_end="$spell_tag end"
  legacy_block_end="$legacy_spell_tag end"
  block_prefix="$spell_tag lines="
  legacy_prefix="$legacy_spell_tag lines="

  ensure_rc_directory() {
    dir=${rc_file%/*}
    if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
      mkdir -p "$dir"
    fi
  }

  spell_status() {
    if [ ! -f "$rc_file" ]; then
      return 1
    fi
    if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    return 1
  }

  ensure_trailing_newline() {
    if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
      return 0
    fi
    last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
    if [ "$last_char" != "012" ]; then
      printf '\n' >>"$rc_file"
    fi
  }

  add_spell() {
    ensure_rc_directory
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    line_count=0
    while IFS= read -r line || nonempty "$line"; do
      printf '%s\n' "$line" >>"$tmp_file"
      line_count=$((line_count + 1))
    done
    if [ "$line_count" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: no spell content provided on stdin." >&2
      exit 1
    fi
    if spell_status; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    if [ ! -f "$rc_file" ]; then
      : >"$rc_file"
    fi
    ensure_trailing_newline
    if [ "$line_count" -eq 1 ]; then
      first_line=$(sed -n '1p' "$tmp_file")
      printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    block_header="$block_start lines=$line_count"
    printf '%s\n' "$block_header" >>"$rc_file"
    cat "$tmp_file" >>"$rc_file"
    printf '%s\n' "$block_end" >>"$rc_file"
    trap - EXIT HUP INT TERM
    rm -f "$tmp_file"
  }

  remove_spell() {
    if [ ! -f "$rc_file" ]; then
      printf '%s\n' "learn: cannot remove from missing file '$rc_file'." >&2
      exit 1
    fi
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    removing_block=0
    to_skip=0
    removed=0
    while IFS= read -r line || nonempty "$line"; do
      if [ "$removing_block" -eq 1 ]; then
        case $line in
        "$block_end"|"$legacy_block_end")
          removing_block=0
          ;;
        esac
        continue
      fi
      if [ "$to_skip" -gt 0 ]; then
        to_skip=$((to_skip - 1))
        continue
      fi
      case $line in
      "$block_start"*|"$legacy_block_start"*)
        removing_block=1
        removed=1
        continue
        ;;
      "$block_prefix"*)
        count=${line#"$block_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      "$legacy_prefix"*)
        count=${line#"$legacy_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      *"$inline_marker"|*"$legacy_inline_marker")
        removed=1
        continue
        ;;
      esac
      printf '%s\n' "$line" >>"$tmp_file"
    done <"$rc_file"
    if [ "$removed" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: spell '$spell' not found in '$rc_file'." >&2
      exit 1
    fi
    trap - EXIT HUP INT TERM
    mv "$tmp_file" "$rc_file"
  }

  # Find nix-shell-* helpers
  find_nix_shell_imp() {
    _imp_name=$1
    if [ -x "$script_dir/../.imps/sys/$_imp_name" ]; then
      printf '%s' "$script_dir/../.imps/sys/$_imp_name"
      return 0
    fi
    if command -v "$_imp_name" >/dev/null 2>&1; then
      command -v "$_imp_name"
      return 0
    fi
    return 1
  }

  nix_spell_status() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-status); then
      printf '%s\n' "learn: nix-shell-status imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  nix_add_spell() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-add); then
      printf '%s\n' "learn: nix-shell-add imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file" "$shell_type"
  }

  nix_remove_spell() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-remove); then
      printf '%s\n' "learn: nix-shell-remove imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  if [ "$rc_format" = "nix" ]; then
    case $action in
    add) nix_add_spell ;;
    remove) nix_remove_spell ;;
    status)
      if nix_spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  else
    case $action in
    add) add_spell ;;
    remove) remove_spell ;;
    status)
      if spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  fi
}

if [ "${mode-}" = "rc" ]; then
  rc_run "$@"
  exit $?
fi

# ---------------------
# FILE/DIR mode - Process paths
# With the word-of-binding paradigm, directories are automatically available
# via invoke-wizardry. For files with install() functions, use learn-spell.
# ---------------------

recursive=0
paths=""

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    recursive=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn: unknown option '$1'." >&2
    show_usage
    exit 1
    ;;
  *)
    paths="$paths $1"
    shift
    ;;
  esac
done

# Add remaining args
for arg in "$@"; do
  paths="$paths $arg"
done

# Require at least one path
if [ -z "$paths" ]; then
  show_usage
  exit 1
fi

# Find learn-spell helper for files
learn_spell=""
if ! learn_spell=$(find_learn_spell); then
  printf '%s\n' "learn: learn-spell helper not found." >&2
  exit 1
fi

# Process each path
for path in $paths; do
  if [ -f "$path" ]; then
    # File -> learn-spell (for spells with install() functions)
    "$learn_spell" "$path"
  elif [ -d "$path" ]; then
    # With the word-of-binding paradigm (PR #410), directories no longer need
    # to be manually added to PATH. invoke-wizardry handles this automatically.
    # Inform the user instead.
    printf '%s\n' "learn: directories are now automatically available via invoke-wizardry."
    printf '%s\n' "learn: spells in '$path' will be accessible after opening a new terminal."
  else
    printf '%s\n' "learn: '$path' is not a file or directory." >&2
  fi
done

exit 0
