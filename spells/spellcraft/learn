#!/bin/sh

# This spell helps with learning spells:
# - For files: installs spells with install() functions via learn-spell
# - For directories: informs that they are automatically available via invoke-wizardry
# It also handles --spell mode for RC file snippet management.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac

show_usage() {
  cat <<USAGE >&2
Usage: $SCRIPT_NAME [-r] PATH...
       $SCRIPT_NAME --spell NAME {add|remove|status}

For files: installs spells with install() functions via learn-spell.
For directories: informs that they are automatically available via invoke-wizardry.
Use --spell mode for RC file snippet management.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Check for --spell mode first (RC file management)
for arg in "$@"; do
  case $arg in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --spell|--spell=*)
    MODE=rc
    ;;
  esac
done

# Inlined nonempty check for efficient use in read loops
# (no longer a function, directly used as: [ -n "$var" ])

rc_run() {
  action=""
  spell=""
  rc_format=""
  shell_type="bash"

  while [ "$#" -gt 0 ]; do
    case $1 in
    --spell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --spell expects a name." >&2
        cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
        exit 1
      fi
      spell=$2
      shift 2
      ;;
    --spell=*)
      spell=${1#*=}
      shift
      ;;
    --shell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --shell expects a value." >&2
        cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
        exit 1
      fi
      shell_type=$2
      shift 2
      ;;
    --shell=*)
      shell_type=${1#*=}
      shift
      ;;
    add|remove|status)
      if [ -n "$action" ]; then
        printf '%s\n' "learn: only one action may be specified." >&2
        cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
        exit 1
      fi
      action=$1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "learn: unknown option '$1'." >&2
      cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
      exit 1
      ;;
    *)
      printf '%s\n' "learn: unexpected argument '$1'." >&2
      cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
      exit 1
      ;;
    esac
  done

  if [ -z "$action" ] || [ -z "$spell" ]; then
    cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
    exit 1
  fi

  # Inline auto_detect_rc logic
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    detect_helper="$DETECT_RC_FILE"
  elif [ -x "$SPELLS_DIR/divination/detect-rc-file" ]; then
    detect_helper="$SPELLS_DIR/divination/detect-rc-file"
  elif command -v detect-rc-file >/dev/null 2>&1; then
    detect_helper=$(command -v detect-rc-file)
  else
    printf '%s\n' "learn: detect-rc-file helper not found." >&2
    exit 1
  fi
  
  output=$("$detect_helper")
  rc_file_detected=''
  platform_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    platform) platform_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn: detect-rc-file did not provide an rc file." >&2
    exit 1
  fi
  detect_output=$(printf '%s\n' "rc_file=$rc_file_detected" "platform=${platform_detected:-unknown}" "format=${format_detected:-shell}")
  
  rc_file=""
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT

  if [ -z "$rc_file" ]; then
    printf '%s\n' "learn: unable to determine rc file." >&2
    exit 1
  fi

  # Default format to shell if not detected
  if [ -z "$rc_format" ]; then
    rc_format="shell"
  fi

  # Auto-detect format from file extension (overrides detected format)
  case $rc_file in
  *.nix) rc_format=nix ;;
  esac

  case $spell in
  *[!A-Za-z0-9._:-]*)
    printf '%s\n' "learn: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
    exit 1
    ;;
  esac

  spell_tag="# wizardry: $spell"
  legacy_spell_tag="# wizardry-spell: $spell"
  inline_marker=" $spell_tag"
  legacy_inline_marker=" $legacy_spell_tag"
  block_start="$spell_tag begin"
  legacy_block_start="$legacy_spell_tag begin"
  block_end="$spell_tag end"
  legacy_block_end="$legacy_spell_tag end"
  block_prefix="$spell_tag lines="
  legacy_prefix="$legacy_spell_tag lines="

  ensure_rc_directory() {
    dir=${rc_file%/*}
    if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
      mkdir -p "$dir"
    fi
  }

  spell_status() {
    if [ ! -f "$rc_file" ]; then
      return 1
    fi
    if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    return 1
  }

  ensure_trailing_newline() {
    if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
      return 0
    fi
    last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
    if [ "$last_char" != "012" ]; then
      printf '\n' >>"$rc_file"
    fi
  }

  add_spell() {
    ensure_rc_directory
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    line_count=0
    while IFS= read -r line || [ -n "$line" ]; do
      printf '%s\n' "$line" >>"$tmp_file"
      line_count=$((line_count + 1))
    done
    if [ "$line_count" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: no spell content provided on stdin." >&2
      exit 1
    fi
    if spell_status; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    if [ ! -f "$rc_file" ]; then
      : >"$rc_file"
    fi
    ensure_trailing_newline
    if [ "$line_count" -eq 1 ]; then
      first_line=$(sed -n '1p' "$tmp_file")
      printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    block_header="$block_start lines=$line_count"
    printf '%s\n' "$block_header" >>"$rc_file"
    cat "$tmp_file" >>"$rc_file"
    printf '%s\n' "$block_end" >>"$rc_file"
    trap - EXIT HUP INT TERM
    rm -f "$tmp_file"
  }

  remove_spell() {
    if [ ! -f "$rc_file" ]; then
      printf '%s\n' "learn: cannot remove from missing file '$rc_file'." >&2
      exit 1
    fi
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    removing_block=0
    to_skip=0
    removed=0
    while IFS= read -r line || [ -n "$line" ]; do
      if [ "$removing_block" -eq 1 ]; then
        case $line in
        "$block_end"|"$legacy_block_end")
          removing_block=0
          ;;
        esac
        continue
      fi
      if [ "$to_skip" -gt 0 ]; then
        to_skip=$((to_skip - 1))
        continue
      fi
      case $line in
      "$block_start"*|"$legacy_block_start"*)
        removing_block=1
        removed=1
        continue
        ;;
      "$block_prefix"*)
        count=${line#"$block_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      "$legacy_prefix"*)
        count=${line#"$legacy_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      *"$inline_marker"|*"$legacy_inline_marker")
        removed=1
        continue
        ;;
      esac
      printf '%s\n' "$line" >>"$tmp_file"
    done <"$rc_file"
    if [ "$removed" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: spell '$spell' not found in '$rc_file'." >&2
      exit 1
    fi
    trap - EXIT HUP INT TERM
    mv "$tmp_file" "$rc_file"
  }

  # Find nix-shell-* helpers (inlined find_nix_shell_imp)
  nix_spell_status() {
    _imp_name="nix-shell-status"
    if [ -x "$SCRIPT_DIR/../.imps/sys/$_imp_name" ]; then
      nix_helper="$SCRIPT_DIR/../.imps/sys/$_imp_name"
    elif command -v "$_imp_name" >/dev/null 2>&1; then
      nix_helper=$(command -v "$_imp_name")
    else
      printf '%s\n' "learn: nix-shell-status imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  nix_add_spell() {
    _imp_name="nix-shell-add"
    if [ -x "$SCRIPT_DIR/../.imps/sys/$_imp_name" ]; then
      nix_helper="$SCRIPT_DIR/../.imps/sys/$_imp_name"
    elif command -v "$_imp_name" >/dev/null 2>&1; then
      nix_helper=$(command -v "$_imp_name")
    else
      printf '%s\n' "learn: nix-shell-add imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file" "$shell_type"
  }

  nix_remove_spell() {
    _imp_name="nix-shell-remove"
    if [ -x "$SCRIPT_DIR/../.imps/sys/$_imp_name" ]; then
      nix_helper="$SCRIPT_DIR/../.imps/sys/$_imp_name"
    elif command -v "$_imp_name" >/dev/null 2>&1; then
      nix_helper=$(command -v "$_imp_name")
    else
      printf '%s\n' "learn: nix-shell-remove imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  if [ "$rc_format" = "nix" ]; then
    case $action in
    add) nix_add_spell ;;
    remove) nix_remove_spell ;;
    status)
      if nix_spell_status; then exit 0; fi
      exit 1
      ;;
    *) cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
; exit 1 ;;
    esac
  else
    case $action in
    add) add_spell ;;
    remove) remove_spell ;;
    status)
      if spell_status; then exit 0; fi
      exit 1
      ;;
    *) cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via detect-rc-file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
; exit 1 ;;
    esac
  fi
}

if [ "${MODE-}" = "rc" ]; then
  rc_run "$@"
  exit $?
fi

# ---------------------
# FILE/DIR MODE - Process paths
# With the word-of-binding paradigm, directories are automatically available
# via invoke-wizardry. For files with install() functions, use learn-spell.
# ---------------------

RECURSIVE=0
paths=""

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn: unknown option '$1'." >&2
    show_usage
    exit 1
    ;;
  *)
    paths="$paths $1"
    shift
    ;;
  esac
done

# Add remaining args
for arg in "$@"; do
  paths="$paths $arg"
done

# Require at least one path
if [ -z "$paths" ]; then
  show_usage
  exit 1
fi

# Process each path
for path in $paths; do
  if [ -f "$path" ]; then
    # File -> learn-spell (for spells with install() functions)
    # Inline find_learn_spell logic
    helper="$SCRIPT_DIR/learn-spell"
    if [ -x "$helper" ]; then
      LEARN_SPELL="$helper"
    elif command -v learn-spell >/dev/null 2>&1; then
      LEARN_SPELL=$(command -v learn-spell)
    else
      printf '%s\n' "learn: learn-spell helper not found." >&2
      exit 1
    fi
    "$LEARN_SPELL" "$path"
  elif [ -d "$path" ]; then
    # With the word-of-binding paradigm (PR #410), directories no longer need
    # to be manually added to PATH. invoke-wizardry handles this automatically.
    # Inform the user instead.
    printf '%s\n' "learn: directories are now automatically available via invoke-wizardry."
    printf '%s\n' "learn: spells in '$path' will be accessible after opening a new terminal."
  else
    printf '%s\n' "learn: '$path' is not a file or directory." >&2
  fi
done

exit 0
