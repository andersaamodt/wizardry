#!/bin/sh

# Manages shell RC file snippets with wizardry comment markers.
# Used by learn-spellbook to add/remove PATH entries in RC files.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac

show_usage() {
  cat <<USAGE >&2
Usage: $SCRIPT_NAME --spell NAME {add|remove|status}

Manages shell RC file snippets. Reads spell content from stdin for 'add' action
and wraps it with wizardry comment markers for deterministic removal.

Single-line spells receive an inline \`# wizardry: NAME\` suffix.
Multi-line spells are wrapped with begin/end sentinels.

The rc file and format are auto-detected via detect-rc-file. For nix files,
uses programs.bash.initExtra or programs.zsh.initExtra.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

rc_usage() {
  show_usage
}

# Find detect-rc-file helper
find_detect_rc_file() {
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    printf '%s' "$DETECT_RC_FILE"
    return 0
  fi
  helper="$SPELLS_DIR/divination/detect-rc-file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v detect-rc-file >/dev/null 2>&1; then
    command -v detect-rc-file
    return 0
  fi
  return 1
}

auto_detect_rc() {
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "learn: detect-rc-file helper not found." >&2
    return 1
  fi
  output=$("$detect_helper")
  rc_file_detected=''
  platform_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    platform) platform_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn: detect-rc-file did not provide an rc file." >&2
    return 1
  fi
  printf '%s\n' "rc_file=$rc_file_detected"
  printf '%s\n' "platform=${platform_detected:-unknown}"
  printf '%s\n' "format=${format_detected:-shell}"
}

# Helper for checking non-empty strings (used in read loops)
nonempty() {
  [ -n "$1" ]
}

rc_run() {
  action=""
  spell=""
  rc_format=""
  shell_type="bash"

  while [ "$#" -gt 0 ]; do
    case $1 in
    --spell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --spell expects a name." >&2
        rc_usage
        exit 1
      fi
      spell=$2
      shift 2
      ;;
    --spell=*)
      spell=${1#*=}
      shift
      ;;
    --shell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --shell expects a value." >&2
        rc_usage
        exit 1
      fi
      shell_type=$2
      shift 2
      ;;
    --shell=*)
      shell_type=${1#*=}
      shift
      ;;
    add|remove|status)
      if [ -n "$action" ]; then
        printf '%s\n' "learn: only one action may be specified." >&2
        rc_usage
        exit 1
      fi
      action=$1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "learn: unknown option '$1'." >&2
      rc_usage
      exit 1
      ;;
    *)
      printf '%s\n' "learn: unexpected argument '$1'." >&2
      rc_usage
      exit 1
      ;;
    esac
  done

  if [ -z "$action" ] || [ -z "$spell" ]; then
    rc_usage
    exit 1
  fi

  # Always auto-detect rc file and format
  if ! detect_output=$(auto_detect_rc); then
    exit 1
  fi
  rc_file=""
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT

  if [ -z "$rc_file" ]; then
    printf '%s\n' "learn: unable to determine rc file." >&2
    exit 1
  fi

  # Default format to shell if not detected
  if [ -z "$rc_format" ]; then
    rc_format="shell"
  fi

  # Auto-detect format from file extension (overrides detected format)
  case $rc_file in
  *.nix) rc_format=nix ;;
  esac

  case $spell in
  *[!A-Za-z0-9._:-]*)
    printf '%s\n' "learn: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
    exit 1
    ;;
  esac

  spell_tag="# wizardry: $spell"
  legacy_spell_tag="# wizardry-spell: $spell"
  inline_marker=" $spell_tag"
  legacy_inline_marker=" $legacy_spell_tag"
  block_start="$spell_tag begin"
  legacy_block_start="$legacy_spell_tag begin"
  block_end="$spell_tag end"
  legacy_block_end="$legacy_spell_tag end"
  block_prefix="$spell_tag lines="
  legacy_prefix="$legacy_spell_tag lines="

  ensure_rc_directory() {
    dir=${rc_file%/*}
    if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
      mkdir -p "$dir"
    fi
  }

  spell_status() {
    if [ ! -f "$rc_file" ]; then
      return 1
    fi
    if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    return 1
  }

  ensure_trailing_newline() {
    if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
      return 0
    fi
    last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
    if [ "$last_char" != "012" ]; then
      printf '\n' >>"$rc_file"
    fi
  }

  add_spell() {
    ensure_rc_directory
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    line_count=0
    while IFS= read -r line || nonempty "$line"; do
      printf '%s\n' "$line" >>"$tmp_file"
      line_count=$((line_count + 1))
    done
    if [ "$line_count" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: no spell content provided on stdin." >&2
      exit 1
    fi
    if spell_status; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    if [ ! -f "$rc_file" ]; then
      : >"$rc_file"
    fi
    ensure_trailing_newline
    if [ "$line_count" -eq 1 ]; then
      first_line=$(sed -n '1p' "$tmp_file")
      printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    block_header="$block_start lines=$line_count"
    printf '%s\n' "$block_header" >>"$rc_file"
    cat "$tmp_file" >>"$rc_file"
    printf '%s\n' "$block_end" >>"$rc_file"
    trap - EXIT HUP INT TERM
    rm -f "$tmp_file"
  }

  remove_spell() {
    if [ ! -f "$rc_file" ]; then
      printf '%s\n' "learn: cannot remove from missing file '$rc_file'." >&2
      exit 1
    fi
    tmp_file=$(temp-file learn) || exit 1
    trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
    removing_block=0
    to_skip=0
    removed=0
    while IFS= read -r line || nonempty "$line"; do
      if [ "$removing_block" -eq 1 ]; then
        case $line in
        "$block_end"|"$legacy_block_end")
          removing_block=0
          ;;
        esac
        continue
      fi
      if [ "$to_skip" -gt 0 ]; then
        to_skip=$((to_skip - 1))
        continue
      fi
      case $line in
      "$block_start"*|"$legacy_block_start"*)
        removing_block=1
        removed=1
        continue
        ;;
      "$block_prefix"*)
        count=${line#"$block_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      "$legacy_prefix"*)
        count=${line#"$legacy_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      *"$inline_marker"|*"$legacy_inline_marker")
        removed=1
        continue
        ;;
      esac
      printf '%s\n' "$line" >>"$tmp_file"
    done <"$rc_file"
    if [ "$removed" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: spell '$spell' not found in '$rc_file'." >&2
      exit 1
    fi
    trap - EXIT HUP INT TERM
    mv "$tmp_file" "$rc_file"
  }

  # Find nix-shell-* helpers
  find_nix_shell_imp() {
    _imp_name=$1
    if [ -x "$SCRIPT_DIR/../.imps/sys/$_imp_name" ]; then
      printf '%s' "$SCRIPT_DIR/../.imps/sys/$_imp_name"
      return 0
    fi
    if command -v "$_imp_name" >/dev/null 2>&1; then
      command -v "$_imp_name"
      return 0
    fi
    return 1
  }

  nix_spell_status() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-status); then
      printf '%s\n' "learn: nix-shell-status imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  nix_add_spell() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-add); then
      printf '%s\n' "learn: nix-shell-add imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file" "$shell_type"
  }

  nix_remove_spell() {
    if ! nix_helper=$(find_nix_shell_imp nix-shell-remove); then
      printf '%s\n' "learn: nix-shell-remove imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  if [ "$rc_format" = "nix" ]; then
    case $action in
    add) nix_add_spell ;;
    remove) nix_remove_spell ;;
    status)
      if nix_spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  else
    case $action in
    add) add_spell ;;
    remove) remove_spell ;;
    status)
      if spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  fi
}

# Run RC mode
rc_run "$@"

