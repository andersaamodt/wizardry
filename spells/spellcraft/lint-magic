#!/bin/sh

# This spell lints spells for formatting and style guide violations.
# Run it against spell files to check formatting, linting, and code style compliance.

show_usage() {
  cat <<'USAGE'
Usage: lint-magic [--only PATTERN] [--list] [--verbose] [file...]

Lint and format-check spells for style-guide compliance. With no files provided it scans the whole spellbook; use --only to filter by pattern, --list to show targets, and --verbose for detailed output.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

# Add imps to PATH so we can use temp-file and cleanup-file directly
if [ -d "$repo_dir/spells/.imps" ]; then
  PATH="$repo_dir/spells/.imps:$PATH"
  for impdir in "$repo_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

verbose=0
list_only=0
pattern=''

while [ "$#" -gt 0 ]; do
  case $1 in
    --verbose)
      verbose=1
      shift
      ;;
    --list)
      list_only=1
      shift
      ;;
    --only)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "lint-magic: --only requires a pattern argument." >&2
        exit 2
      fi
      pattern=$2
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "lint-magic: unknown option: $1" >&2
      show_usage >&2
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

gather_default_targets() {
  find "$repo_dir/spells" -type f \( -perm -u+x -o -perm -g+x -o -perm -o+x \) \
    -print | sort | while IFS= read -r file; do
      first_line=$(head -1 "$file")
      case $first_line in
        '#!/bin/sh'|'#! /bin/sh')
          rel_path=${file#"$repo_dir/"}
          if [ -n "$pattern" ]; then
            case $rel_path in
              *"$pattern"*)
                printf '%s\n' "$rel_path"
                ;;
            esac
          else
            printf '%s\n' "$rel_path"
          fi
          ;;
      esac
    done
}

collect_targets() {
  if [ "$#" -gt 0 ]; then
    for arg in "$@"; do
      case $arg in
        /*)
          printf '%s\n' "$arg"
          ;;
        *)
          printf '%s\n' "$arg"
          ;;
      esac
    done
  else
    gather_default_targets
  fi
}

check_description_comment() {
  file=$1
  # Read lines 2, 3, and 4 to allow up to 3-line opening comments
  lines=$(sed -n '2p;3p;4p' "$file")
  second_line=$(printf '%s\n' "$lines" | sed -n '1p')
  third_line=$(printf '%s\n' "$lines" | sed -n '2p')
  fourth_line=$(printf '%s\n' "$lines" | sed -n '3p')
  
  # Check if second line is empty and third line is a comment
  if [ -z "$second_line" ] && [ -n "$third_line" ]; then
    case $third_line in
      '#'*)
        return 0
        ;;
    esac
  fi
  
  # Check if second line is a comment (allows up to 3 comment lines)
  case $second_line in
    '#'*)
      return 0
      ;;
    *)
      printf 'missing opening description comment after shebang'
      return 1
      ;;
  esac
}

check_posix_compliance() {
  file=$1
  checkbashisms_cmd=${CHECKBASHISMS-}
  if [ -z "$checkbashisms_cmd" ] && command -v checkbashisms >/dev/null 2>&1; then
    checkbashisms_cmd=$(command -v checkbashisms)
  fi
  
  if [ -z "$checkbashisms_cmd" ]; then
    # Skip POSIX check if checkbashisms not available
    return 0
  fi
  
  if "$checkbashisms_cmd" "$file" >/dev/null 2>&1; then
    return 0
  fi
  printf 'POSIX compliance violation (run checkbashisms for details)'
  return 1
}

check_function_naming() {
  file=$1
  is_imp_file=$2
  
  # For imps, underscore-prefixed functions (_function_name) are allowed for "true names"
  # For spells, all functions should use snake_case without underscore prefix
  
  # Create temp file for awk script to filter out heredoc content
  # This prevents false positives from function definitions inside heredocs
  awk_script=$(mktemp "${TMPDIR:-/tmp}/lint-magic-naming-awk.XXXXXX") || return 1
  cat >"$awk_script" <<'AWKSCRIPT'
BEGIN { in_heredoc = 0; heredoc_end = "" }
# Detect heredoc start - handles <<'DELIM', <<"DELIM", and <<DELIM
/<<-?[ \t]*'[A-Za-z_][A-Za-z0-9_]*'/ {
  match($0, /<<-?[ \t]*'([A-Za-z_][A-Za-z0-9_]*)'/)
  delim = $0
  sub(/.*<<-?[ \t]*'/, "", delim)
  sub(/'.*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*"[A-Za-z_][A-Za-z0-9_]*"/ {
  match($0, /<<-?[ \t]*"([A-Za-z_][A-Za-z0-9_]*)"/)
  delim = $0
  sub(/.*<<-?[ \t]*"/, "", delim)
  sub(/".*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*$/ {
  delim = $0
  sub(/.*<<-?[ \t]*/, "", delim)
  sub(/[ \t]*$/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
in_heredoc && $0 == heredoc_end { in_heredoc = 0; next }
in_heredoc { next }
/^[ \t]*#/ { next }
{ print }
AWKSCRIPT
  
  # Find underscore-prefixed function definitions in spells (excluding heredoc content)
  if [ "$is_imp_file" -eq 0 ]; then
    func_violations=$(awk -f "$awk_script" "$file" 2>/dev/null | grep -nE '^[[:space:]]*_[a-zA-Z][a-zA-Z0-9_]*\(\)[[:space:]]*\{' || true)
    
    if [ -n "$func_violations" ]; then
      # Spell (non-imp) has underscore-prefixed functions
      line_num=$(printf '%s' "$func_violations" | head -1 | cut -d: -f1)
      printf 'spell has underscore-prefixed function at line %s (spells should use snake_case without prefix)' "$line_num"
      rm -f "$awk_script"
      return 1
    fi
  fi
  
  # Check for hyphenated function names (not allowed in any context, excluding heredoc content)
  hyphen_violations=$(awk -f "$awk_script" "$file" 2>/dev/null | grep -nE '^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*-[a-zA-Z0-9_-]*\(\)[[:space:]]*\{' || true)
  
  if [ -n "$hyphen_violations" ]; then
    line_num=$(printf '%s' "$hyphen_violations" | head -1 | cut -d: -f1)
    printf 'function name contains hyphen at line %s (use snake_case)' "$line_num"
    rm -f "$awk_script"
    return 1
  fi
  
  rm -f "$awk_script"
  return 0
}

check_imp_no_flags() {
  file=$1
  # Imps should use space-separated arguments, not --flags
  # Look for case patterns that match flags: --flag) or -f) patterns
  # Filter out heredoc content since imps may generate code that handles flags
  # Only match case statement flag handlers, not flag arguments being passed to other commands
  
  # Create temp file for awk script to avoid quoting issues
  # The awk script filters out heredoc content and comments, leaving only code
  # that could contain flag parsing case statements
  awk_script=$(mktemp "${TMPDIR:-/tmp}/lint-magic-awk.XXXXXX") || return 0
  cat >"$awk_script" <<'AWKSCRIPT'
BEGIN { in_heredoc = 0; heredoc_end = "" }
# Detect heredoc start - handles <<'DELIM', <<"DELIM", and <<DELIM
# Extract delimiter by removing prefix and suffix
/<<-?[ \t]*'[A-Za-z_][A-Za-z0-9_]*'/ {
  match($0, /<<-?[ \t]*'([A-Za-z_][A-Za-z0-9_]*)'/)
  delim = $0
  sub(/.*<<-?[ \t]*'/, "", delim)
  sub(/'.*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*"[A-Za-z_][A-Za-z0-9_]*"/ {
  match($0, /<<-?[ \t]*"([A-Za-z_][A-Za-z0-9_]*)"/)
  delim = $0
  sub(/.*<<-?[ \t]*"/, "", delim)
  sub(/".*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*$/ {
  delim = $0
  sub(/.*<<-?[ \t]*/, "", delim)
  sub(/[ \t]*$/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
in_heredoc && $0 == heredoc_end { in_heredoc = 0; next }
in_heredoc { next }
/^[ \t]*#/ { next }
{ print }
AWKSCRIPT
  
  result=0
  # Regex explanation for case statement flag detection:
  # ^[[:space:]]*                  - line starts with optional whitespace
  # (--[a-zA-Z][-a-zA-Z0-9_=]*)    - long flag like --verbose or --name=value
  # (\|--[a-zA-Z][-a-zA-Z0-9_=]*)* - additional long flags with | separator
  # (\|-[a-zA-Z])*                 - short flags like |-v
  # |-[a-zA-Z](...)                - OR short flag as first option
  # [[:space:]]*\)                 - ends with ) for case pattern
  if awk -f "$awk_script" "$file" 2>/dev/null | grep -E '^[[:space:]]*(--[a-zA-Z][-a-zA-Z0-9_=]*(\|--[a-zA-Z][-a-zA-Z0-9_=]*)*(\|-[a-zA-Z])*|-[a-zA-Z](\|--[a-zA-Z][-a-zA-Z0-9_=]*|\|-[a-zA-Z])*)[[:space:]]*\)' >/dev/null 2>&1; then
    printf 'imp uses --flags (imps should use space-separated arguments only)'
    result=1
  fi
  rm -f "$awk_script"
  return $result
}

# Count parameters from opening comment
# Returns: parameter count, or -1 if no parameter info found
# The opening comment format is: # command-name ARG1 ARG2 [OPTIONAL] - description
count_parameters() {
  file=$1
  # Find the first comment line after shebang (skip blank lines)
  # Look at lines 2-5 for the description comment
  comment_line=""
  for linenum in 2 3 4 5; do
    line=$(sed -n "${linenum}p" "$file" 2>/dev/null)
    case "$line" in
      '#'*)
        comment_line="$line"
        break
        ;;
      '')
        # Skip empty lines
        continue
        ;;
      *)
        # Non-comment, non-empty line - no description found
        break
        ;;
    esac
  done
  
  # Check if we found a comment line
  if [ -z "$comment_line" ]; then
    printf '%s' "-1"
    return 0
  fi
  
  # Remove the leading # and any leading spaces
  comment_line=${comment_line#'#'}
  comment_line=${comment_line#' '}
  
  # Check if it has the expected format: name PARAMS - description
  # Extract everything before the first " - " (the description separator)
  case "$comment_line" in
    *' - '*)
      param_part=${comment_line%% - *}
      ;;
    *)
      # No description separator, can't determine params
      printf '%s' "-1"
      return 0
      ;;
  esac
  
  # Now count the words after the command name
  # The first word is the command name, the rest are parameters
  # Parameters ending with ... (e.g., MORE...) are variadic and don't count toward limit
  param_count=0
  first_word=1
  for word in $param_part; do
    if [ "$first_word" -eq 1 ]; then
      first_word=0
      continue
    fi
    # Skip variadic parameters (ending with ...)
    case "$word" in
      *'...') continue ;;
    esac
    param_count=$((param_count + 1))
  done
  
  printf '%s' "$param_count"
}

check_imp_param_count() {
  file=$1
  count=$(count_parameters "$file")
  if [ "$count" = "-1" ]; then
    # Can't determine param count, skip check
    return 0
  fi
  if [ "$count" -gt 3 ]; then
    printf 'imp has %d parameters (max 3 allowed)' "$count"
    return 1
  fi
  return 0
}

check_long_lines() {
  file=$1
  # Check for lines longer than 100 characters (excluding comments and heredocs)
  # FAIL if long line contains commands that could be logically split
  # ALLOW if long line is primarily a long string literal (error messages, help text, etc.)
  
  # Hardcoded exemptions for files that have long lines that cannot be split
  # without breaking doppelganger compilation or other tools
  # See .github/EXEMPTIONS.md for justification
  case "$file" in
    */spells/.imps/cond/is)
      # The 'empty' case in the is imp has a long conditional that spans one line.
      # Splitting it across multiple lines breaks doppelganger compilation because
      # compile-spell's case label detection expects `case_label) ... ;;` on same line
      # or matching pattern. This is documented in EXEMPTIONS.md.
      return 0
      ;;
    */spells/divination/identify-room)
      # The list_recognized function has a long directory path list in a case statement.
      # Splitting it breaks doppelganger compilation similar to the is imp issue above.
      # This is documented in EXEMPTIONS.md.
      return 0
      ;;
  esac
  
  # Create temp file for awk script with robust heredoc detection and string detection
  awk_script=$(mktemp "${TMPDIR:-/tmp}/lint-magic-lines-awk.XXXXXX") || return 0
  cat >"$awk_script" <<'AWKSCRIPT'
BEGIN { in_heredoc = 0; heredoc_end = ""; max_len = 100; sq = sprintf("%c", 39) }
# Detect heredoc start - handles <<'DELIM', <<"DELIM", and <<DELIM
/<<-?[ \t]*'[A-Za-z_][A-Za-z0-9_]*'/ {
  delim = $0
  sub(/.*<<-?[ \t]*'/, "", delim)
  sub(/'.*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*"[A-Za-z_][A-Za-z0-9_]*"/ {
  delim = $0
  sub(/.*<<-?[ \t]*"/, "", delim)
  sub(/".*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*$/ {
  delim = $0
  sub(/.*<<-?[ \t]*/, "", delim)
  sub(/[ \t]*$/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
in_heredoc && $0 == heredoc_end { in_heredoc = 0; next }
in_heredoc { next }
/^[[:space:]]*#/ { next }
length($0) > max_len {
  # Check if line is primarily a long string literal
  # Count quoted content vs total length
  line = $0
  
  # Remove leading whitespace for analysis
  gsub(/^[[:space:]]*/, "", line)
  
  # Check if line contains a long quoted string (single or double quotes)
  # A line is considered "string-heavy" if >60% is inside quotes
  quoted_len = 0
  in_quote = 0
  quote_char = ""
  escaped = 0
  
  for (i = 1; i <= length(line); i++) {
    c = substr(line, i, 1)
    
    if (escaped) {
      if (in_quote) quoted_len++
      escaped = 0
      continue
    }
    
    if (c == "\\") {
      escaped = 1
      if (in_quote) quoted_len++
      continue
    }
    
    if (!in_quote && (c == "\"" || c == sq)) {
      in_quote = 1
      quote_char = c
      quoted_len++
      continue
    }
    
    if (in_quote && c == quote_char) {
      in_quote = 0
      quote_char = ""
      quoted_len++
      continue
    }
    
    if (in_quote) {
      quoted_len++
    }
  }
  
  # Calculate percentage of line that is quoted
  line_len = length(line)
  if (line_len > 0 && quoted_len > 0) {
    quote_pct = (quoted_len * 100) / line_len
    # If >60% of line is quoted text, allow it (likely error message/help text)
    if (quote_pct >= 60) {
      next
    }
  }
  
  # Line is long and NOT primarily a string - should be split
  print NR ": " substr($0, 1, 50) "..."
}
AWKSCRIPT
  
  long_lines=$(awk -f "$awk_script" "$file" 2>/dev/null | head -3) || true
  rm -f "$awk_script"
  
  if [ -n "$long_lines" ]; then
    first_line=$(printf '%s' "$long_lines" | head -1 | cut -d: -f1)
    printf 'lines exceed 100 characters (line %s and possibly others); split logically or use intermediate variables' "$first_line"
    return 1
  fi
  return 0
}

check_echo_usage() {
  file=$1
  # Prefer printf over echo for better portability
  # Skip lines that are comments or inside heredocs
  
  # Create temp file for awk script with robust heredoc detection
  awk_script=$(mktemp "${TMPDIR:-/tmp}/lint-magic-echo-awk.XXXXXX") || return 0
  cat >"$awk_script" <<'AWKSCRIPT'
BEGIN { in_heredoc = 0; heredoc_end = "" }
# Detect heredoc start
/<<-?[ \t]*'[A-Za-z_][A-Za-z0-9_]*'/ {
  delim = $0
  sub(/.*<<-?[ \t]*'/, "", delim)
  sub(/'.*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*"[A-Za-z_][A-Za-z0-9_]*"/ {
  delim = $0
  sub(/.*<<-?[ \t]*"/, "", delim)
  sub(/".*/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
/<<-?[ \t]*[A-Za-z_][A-Za-z0-9_]*[ \t]*$/ {
  delim = $0
  sub(/.*<<-?[ \t]*/, "", delim)
  sub(/[ \t]*$/, "", delim)
  in_heredoc = 1
  heredoc_end = delim
  next
}
in_heredoc && $0 == heredoc_end { in_heredoc = 0; next }
in_heredoc { next }
/^[[:space:]]*#/ { next }
/\becho[[:space:]]/ {
  print NR
  exit
}
AWKSCRIPT
  
  line_num=$(awk -f "$awk_script" "$file" 2>/dev/null) || true
  rm -f "$awk_script"
  
  if [ -n "$line_num" ]; then
    printf 'uses echo (prefer printf for portability) at line %s' "$line_num"
    return 1
  fi
  return 0
}

failures=0
total=0
passed=0
failed_targets=''
spell_param_warnings=''
spell_param_warning_count=0

targets_file=$(temp-file lint-magic-targets) || exit 1
trap 'cleanup-file "$targets_file"' EXIT HUP INT TERM
collect_targets "$@" >"$targets_file"

if [ "$list_only" -eq 1 ]; then
  cat "$targets_file"
  trap - EXIT HUP INT TERM
  rm -f "$targets_file"
  exit 0
fi

while IFS= read -r target; do
  [ -n "$target" ] || continue
  total=$((total + 1))
  
  case $target in
    /*)
      path="$target"
      ;;
    *)
      path="$repo_dir/$target"
      ;;
  esac
  
  if [ ! -e "$path" ]; then
    printf 'FAIL %s: file not found\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi
  
  if [ ! -f "$path" ]; then
    printf 'FAIL %s: not a regular file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi
  
  is_imp_file=0
  case "$target" in
    */.imps/*|*/.imps) is_imp_file=1 ;;
  esac
  case "$path" in
    */.imps/*|*/.imps) is_imp_file=1 ;;
  esac
  
  issues=''
  issue_count=0
  
  # Check shebang (required for all)
  first_line=$(head -1 "$path")
  case $first_line in
    '#!/bin/sh'|'#! /bin/sh') ;;
    *)
      issues=${issues:+$issues; }'missing or incorrect shebang (expected #!/bin/sh)'
      issue_count=$((issue_count + 1))
      ;;
  esac
  
  # Check description comment (required for all)
  if ! result=$(check_description_comment "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check usage function (not required for imps)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! grep -qE '^[[:space:]]*show_usage\(\)' "$path" 2>/dev/null; then
      issues=${issues:+$issues; }'missing usage function (show_usage)'
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check help handler (not required for imps)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! grep -qF -- '--help|--usage|-h)' "$path" 2>/dev/null; then
      issues=${issues:+$issues; }'missing --help|--usage|-h handler'
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check strict mode (not required for imps - they often use exit codes for flow control)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! grep -qE 'set -e' "$path" 2>/dev/null; then
      issues=${issues:+$issues; }'missing strict mode (set -e or set -eu)'
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check trailing space assignment (required for all)
  match=$(grep -En '^[a-zA-Z_][a-zA-Z0-9_]*= $' "$path" 2>/dev/null | head -1) || true
  if [ -n "$match" ]; then
    line_num=$(printf '%s' "$match" | cut -d: -f1)
    issues=${issues:+$issues; }"trailing space in variable assignment at line $line_num"
    issue_count=$((issue_count + 1))
  fi
  
  # Check POSIX compliance (required for all)
  if ! result=$(check_posix_compliance "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check which usage (required for all)
  # Check for 'which' command usage patterns: which command, $(which ...), or `which ...`
  # Excludes English prose containing "which" in comments or heredocs
  if grep -E '(^|[;|&])[[:space:]]*which[[:space:]]+[a-zA-Z0-9_-]+|`which[[:space:]]|\$\(which[[:space:]]' "$path" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
    issues=${issues:+$issues; }'uses "which" (prefer "command -v" for POSIX compliance)'
    issue_count=$((issue_count + 1))
  fi
  
  # Check backtick usage (required for all)
  if grep -E '\`[^\`]+\`' "$path" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
    issues=${issues:+$issues; }'uses backticks (prefer $() for command substitution)'
    issue_count=$((issue_count + 1))
  fi
  
  # Check spell naming convention (required for all)
  spell_name=$(basename "$path")
  case $spell_name in
    *_*)
      issues=${issues:+$issues; }'spell name uses underscore (prefer hyphens)'
      issue_count=$((issue_count + 1))
      ;;
  esac
  case $spell_name in
    *.sh)
      issues=${issues:+$issues; }'spell has .sh extension (spells should have no extension)'
      issue_count=$((issue_count + 1))
      ;;
  esac
  
  # Check function naming convention (required for all)
  if ! result=$(check_function_naming "$path" "$is_imp_file"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Imp-specific checks (only for imps)
  if [ "$is_imp_file" -eq 1 ]; then
    # Imps should not have --help handlers
    if grep -qF -- '--help|--usage|-h)' "$path" 2>/dev/null; then
      issues=${issues:+$issues; }'imp has --help handler (imps use opening comment as spec, not --help)'
      issue_count=$((issue_count + 1))
    fi
    
    # Imps should use space-separated arguments, not flags
    if ! result=$(check_imp_no_flags "$path"); then
      issues=${issues:+$issues; }$result
      issue_count=$((issue_count + 1))
    fi
    
    # Imps must have 3 or fewer parameters (FAIL)
    if ! result=$(check_imp_param_count "$path"); then
      issues=${issues:+$issues; }$result
      issue_count=$((issue_count + 1))
    fi
  else
    # Non-imp spells: warn (don't fail) if >3 parameters
    param_count=$(count_parameters "$path")
    if [ "$param_count" != "-1" ] && [ "$param_count" -gt 3 ]; then
      spell_param_warnings="${spell_param_warnings}${spell_param_warnings:+
}  $target: $param_count parameters"
      spell_param_warning_count=$((spell_param_warning_count + 1))
    fi
  fi
  
  # Formatting checks (required for all)
  
  # Check for inconsistent indentation (mixed tabs and spaces)
  tab=$(printf '\t')
  has_tab_indent=$(grep -E "^[[:space:]]*${tab}" "$path" 2>/dev/null | head -1) || true
  has_space_indent=$(grep -E '^  ' "$path" 2>/dev/null | head -1) || true
  if [ -n "$has_tab_indent" ] && [ -n "$has_space_indent" ]; then
    issues=${issues:+$issues; }'mixed tabs and spaces for indentation (prefer 2 spaces)'
    issue_count=$((issue_count + 1))
  fi
  
  # Check for long lines (now enforced - fails build)
  # Allows long lines that are primarily string literals (>60% quoted)
  # Fails on long lines that should be logically split (pipelines, commands, etc.)
  if ! result=$(check_long_lines "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check for echo usage (prefer printf)
  if ! result=$(check_echo_usage "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  if [ "$issue_count" -eq 0 ]; then
    if [ "$verbose" -eq 1 ]; then
      printf 'PASS %s\n' "$target"
    fi
    passed=$((passed + 1))
  else
    printf 'FAIL %s: %s\n' "$target" "$issues"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
  fi
done <"$targets_file"

trap - EXIT HUP INT TERM
rm -f "$targets_file"

# Print parameter count warnings for non-imp spells (non-failing)
if [ -n "$spell_param_warnings" ]; then
  printf '\nWarning: %d spell(s) have more than 3 parameters:\n' "$spell_param_warning_count"
  printf '%s\n' "$spell_param_warnings"
fi

if [ "$failures" -eq 0 ]; then
  printf 'All %d spells passed style checks.\n' "$total"
  exit 0
else
  printf '%d of %d spells failed style checks.\n' "$failures" "$total"
  if [ -n "$failed_targets" ]; then
    printf 'Failing spells: %s\n' "$failed_targets"
  fi
  exit 1
fi
