#!/bin/sh
# This spell interactively creates a custom command in the spellbook.
# It prompts for category, name, and command text, then records the command.

set -eu

SCRIPT_NAME=$(basename "$0")

# Resolve the spell home directory
resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)
commands_file=${SPELLBOOK_COMMANDS_FILE-$spell_home/custom-commands}
custom_spells_dir=${SPELLBOOK_CUSTOM_DIR-$spell_home/custom}

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: names may contain only letters, digits, dots, underscores, and dashes." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must not be empty." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command may not contain tabs." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must be a single line." >&2
                return 1
        fi
}

custom_spell_path() {
        printf '%s/%s' "$custom_spells_dir" "$1"
}

write_custom_script() {
        script_name=$1
        cmd_text=$2
        ensure_parent_dir "$(custom_spell_path "$script_name")"
        mkdir -p "$custom_spells_dir"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$(custom_spell_path "$script_name")" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$(custom_spell_path "$script_name")"
}

record_custom_command() {
        cat_name=$1
        cmd_name=$2
        shift 2
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name" || return 1
        validate_command "$cmd" || return 1
        ensure_parent_dir "$commands_file"
        mkdir -p "$custom_spells_dir"
        write_custom_script "$cmd_name" "$cmd"
        tmp=$(mktemp "${TMPDIR:-/tmp}/scribe-command.XXXXXX") || exit 1
        if [ -f "$commands_file" ]; then
                while IFS= read -r line || [ -n "$line" ]; do
                        entry_category=${line%%$(printf '\t')*}
                        case $line in
                        *$(printf '\t')*)
                                entry_rest=${line#*$(printf '\t')}
                                entry_name=${entry_rest%%$(printf '\t')*}
                                ;;
                        *)
                                entry_name=''
                                ;;
                        esac
                        if [ "$entry_category" = "$cat_name" ] && [ "$entry_name" = "$cmd_name" ]; then
                                continue
                        fi
                        printf '%s\n' "$line" >>"$tmp"
                done <"$commands_file"
        fi
        printf '%s\t%s\t%s\n' "$cat_name" "$cmd_name" "$cmd" >>"$tmp"
        mv "$tmp" "$commands_file"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt" >&2
        IFS= read -r value
        printf '%s' "$value"
}

usage() {
        cat <<USAGE
Usage: $SCRIPT_NAME [CATEGORY NAME COMMAND...]
       $SCRIPT_NAME

Interactively create a custom command in the spellbook, or provide
arguments directly to scribe a command non-interactively.

Without arguments, prompts for category, name, and command text.
With arguments, uses CATEGORY NAME and remaining args as COMMAND.

Custom commands are stored as executable spells under the user spell home
(default: ~/.spellbook/custom or \$XDG_DATA_HOME/wizardry/spellbook/custom).
USAGE
}

# Handle --help
case ${1-} in
        --help|-h)
                usage
                exit 0
                ;;
esac

# Non-interactive mode with arguments
if [ "$#" -ge 3 ]; then
        category=$1
        name=$2
        shift 2
        record_custom_command "$category" "$name" "$@" || exit 1
        printf "Scribed '%s' into %s.\n" "$name" "$category"
        printf "Custom spells live in %s (add it to PATH to run by name).\n" "$custom_spells_dir"
        exit 0
fi

# Check for partial arguments
if [ "$#" -gt 0 ] && [ "$#" -lt 3 ]; then
        usage >&2
        exit 1
fi

# Interactive mode
cat_name=$(prompt_for_input "Category: ")
cmd_name=$(prompt_for_input "Name: ")
cmd_text=$(prompt_for_input "Command: ")

if [ -z "$cat_name" ] || [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
        printf '%s\n' "A category, name, and command are required." >&2
        exit 1
fi

record_custom_command "$cat_name" "$cmd_name" "$cmd_text" || exit 1
printf "Scribed '%s' into %s.\n" "$cmd_name" "$cat_name"
printf "Custom spells live in %s (add it to PATH to run by name).\n" "$custom_spells_dir"
