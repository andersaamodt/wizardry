#!/bin/sh
# This spell interactively creates a custom command in the spellbook.
# It prompts for name and command text, then records the command.

set -eu

SCRIPT_NAME=$(basename "$0")

# Resolve the spell home directory
resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must not be empty." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command may not contain tabs." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must be a single line." >&2
                return 1
        fi
}

spell_path() {
        printf '%s/%s' "$spell_home" "$1"
}

write_spell_script() {
        script_name=$1
        cmd_text=$2
        ensure_parent_dir "$(spell_path "$script_name")"
        mkdir -p "$spell_home"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$(spell_path "$script_name")" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$(spell_path "$script_name")"
}

record_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name" || return 1
        validate_command "$cmd" || return 1
        mkdir -p "$spell_home"
        write_spell_script "$cmd_name" "$cmd"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt" >&2
        IFS= read -r value
        printf '%s' "$value"
}

usage() {
        cat <<USAGE
Usage: $SCRIPT_NAME [NAME COMMAND...]
       $SCRIPT_NAME

Interactively create a custom command in the spellbook, or provide
arguments directly to scribe a command non-interactively.

Without arguments, prompts for name and command text.
With arguments, uses NAME and remaining args as COMMAND.

Custom commands are stored as executable scripts in ~/.spellbook
(or \$XDG_DATA_HOME/wizardry/spellbook). Each command is a separate
file with the name as filename and the command as content.
USAGE
}

# Handle --help
case ${1-} in
        --help|-h)
                usage
                exit 0
                ;;
esac

# Non-interactive mode with arguments
if [ "$#" -ge 2 ]; then
        name=$1
        shift
        record_command "$name" "$@" || exit 1
        printf "Scribed '%s' to %s.\n" "$name" "$spell_home"
        exit 0
fi

# Check for partial arguments
if [ "$#" -eq 1 ]; then
        usage >&2
        exit 1
fi

# Interactive mode
cmd_name=$(prompt_for_input "Name: ")
cmd_text=$(prompt_for_input "Command: ")

if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
        printf '%s\n' "A name and command are required." >&2
        exit 1
fi

record_command "$cmd_name" "$cmd_text" || exit 1
printf "Scribed '%s' to %s.\n" "$cmd_name" "$spell_home"
