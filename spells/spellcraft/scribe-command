#!/bin/sh
# This spell scribes (creates) a custom spell in your spellbook.
# It prompts for name, command text, and optionally a category.

set -eu

SCRIPT_NAME=$(basename "$0")

# Resolve the spell home directory
resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                printf '%s' "$WIZARDRY_SPELL_HOME"
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                printf '%s' "$SPELLBOOK_HOME"
        elif [ -n "${SPELL_HOME-}" ]; then
                printf '%s' "$SPELL_HOME"
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                printf '%s' "$XDG_DATA_HOME/wizardry/spellbook"
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                printf '%s' "$HOME/.spellbook"
        else
                printf '%s' ".spellbook"
        fi
}

spell_home=$(resolve_spell_home)

# Category can be passed via --category argument
current_category=""

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

# Check if a spell name conflicts with an existing command or spell
check_duplicate_name() {
        name=$1
        # Check if name conflicts with an existing command in PATH
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s\n' "$SCRIPT_NAME: '$name' conflicts with an existing command." >&2
                return 1
        fi
        # Check if spell already exists in the spellbook directory
        if [ -e "$spell_home/$name" ]; then
                printf '%s\n' "$SCRIPT_NAME: '$name' already exists in your spellbook." >&2
                return 1
        fi
        # Check subfolders of the spellbook for existing spells
        if [ -d "$spell_home" ]; then
                for subdir in "$spell_home"/*; do
                        [ -d "$subdir" ] || continue
                        if [ -e "$subdir/$name" ]; then
                                printf '%s\n' "$SCRIPT_NAME: '$name' already exists in your spellbook." >&2
                                return 1
                        fi
                done
        fi
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must not be empty." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command may not contain tabs." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must be a single line." >&2
                return 1
        fi
}

# Validate category name (folder name)
validate_category() {
        cat_name=$1
        case $cat_name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: category names may contain only letters, digits, dots, underscores, and dashes." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: category names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

spell_path() {
        if [ -n "$current_category" ]; then
                printf '%s/%s/%s' "$spell_home" "$current_category" "$1"
        else
                printf '%s/%s' "$spell_home" "$1"
        fi
}

write_spell_script() {
        script_name=$1
        cmd_text=$2
        target_path=$(spell_path "$script_name")
        ensure_parent_dir "$target_path"
        if [ -n "$current_category" ]; then
                mkdir -p "$spell_home/$current_category"
        else
                mkdir -p "$spell_home"
        fi
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$target_path" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$target_path"
}

# Add a new category folder to PATH using learn-spellbook
add_category_to_path() {
        cat_name=$1
        cat_path="$spell_home/$cat_name"
        
        # Find learn-spellbook
        if command -v learn-spellbook >/dev/null 2>&1; then
                learn_spellbook=$(command -v learn-spellbook)
        else
                # Try relative path from this script
                SCRIPT_SOURCE=$0
                case $SCRIPT_SOURCE in
                */*)
                        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
                        ;;
                *)
                        SCRIPT_DIR=.
                        ;;
                esac
                SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
                learn_spellbook="$SCRIPT_DIR/learn-spellbook"
                if [ ! -x "$learn_spellbook" ]; then
                        printf '%s\n' "Note: learn-spellbook not found; category folder created but not added to PATH." >&2
                        return 0
                fi
        fi
        
        "$learn_spellbook" add "$cat_path" 2>/dev/null || true
}

record_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name" || return 1
        check_duplicate_name "$cmd_name" || return 1
        validate_command "$cmd" || return 1
        if [ -n "$current_category" ]; then
                mkdir -p "$spell_home/$current_category"
        else
                mkdir -p "$spell_home"
        fi
        write_spell_script "$cmd_name" "$cmd"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt" >&2
        IFS= read -r value
        printf '%s' "$value"
}

usage() {
        cat <<USAGE
Usage: $SCRIPT_NAME [--category CATEGORY] [--dir DIR] [NAME COMMAND...]
       $SCRIPT_NAME

Scribe (create) a custom spell in your spellbook, or provide
arguments directly to scribe non-interactively.

Without arguments, prompts for command text first, then name, and optionally a category.
With arguments, uses NAME and remaining args as COMMAND.

Spell names must be unique. A spell cannot be created if its name
conflicts with an existing command in PATH or a spell already in your
spellbook (including subfolders).

Options:
  --category CATEGORY  Place the spell in a category folder within ~/.spellbook.
                       If the category doesn't exist, it will be created and
                       added to your PATH.
  --dir DIR            Create the spell directly in DIR instead of ~/.spellbook.
                       Used when scribing in a specific subfolder.

Custom spells are stored as executable scripts in ~/.spellbook
(or \$XDG_DATA_HOME/wizardry/spellbook). Each spell is a separate
file with the name as filename and the command as content.
USAGE
}

# Override directory (for creating spells in subfolders)
override_dir=""

# Parse arguments
while [ "$#" -gt 0 ]; do
        case ${1-} in
                --help|-h)
                        usage
                        exit 0
                        ;;
                --category)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "$SCRIPT_NAME: --category requires a value." >&2
                                exit 1
                        fi
                        current_category=$2
                        validate_category "$current_category" || exit 1
                        shift 2
                        ;;
                --category=*)
                        current_category=${1#*=}
                        validate_category "$current_category" || exit 1
                        shift
                        ;;
                --dir)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "$SCRIPT_NAME: --dir requires a value." >&2
                                exit 1
                        fi
                        override_dir=$2
                        shift 2
                        ;;
                --dir=*)
                        override_dir=${1#*=}
                        shift
                        ;;
                --)
                        shift
                        break
                        ;;
                -*)
                        printf '%s\n' "$SCRIPT_NAME: unknown option '$1'" >&2
                        exit 1
                        ;;
                *)
                        break
                        ;;
        esac
done

# If override_dir is set, use it instead of spell_home
if [ -n "$override_dir" ]; then
        spell_home=$override_dir
        # Clear category since we're using a specific dir
        current_category=""
fi

# Non-interactive mode with arguments
if [ "$#" -ge 2 ]; then
        name=$1
        shift
        record_command "$name" "$@" || exit 1
        if [ -n "$current_category" ]; then
                printf "Scribed '%s' to %s/%s.\n" "$name" "$spell_home" "$current_category"
        else
                printf "Scribed '%s' to %s.\n" "$name" "$spell_home"
        fi
        exit 0
fi

# Check for partial arguments
if [ "$#" -eq 1 ]; then
        usage >&2
        exit 1
fi

# Interactive mode - ask for command FIRST, then name
cmd_text=$(prompt_for_input "Command: ")
cmd_name=$(prompt_for_input "Name: ")

if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
        printf '%s\n' "A name and command are required." >&2
        exit 1
fi

# If no category was provided via --category or --dir, ask if user wants to categorize
if [ -z "$current_category" ] && [ -z "$override_dir" ]; then
        printf 'Would you like to categorize this spell? [y/N] ' >&2
        read -r categorize_answer
        case $categorize_answer in
                y|Y|yes|YES)
                        category_name=$(prompt_for_input "Category name: ")
                        if [ -n "$category_name" ]; then
                                validate_category "$category_name" || exit 1
                                current_category=$category_name
                                # Create the category folder and add to PATH if it's new
                                if [ ! -d "$spell_home/$current_category" ]; then
                                        mkdir -p "$spell_home/$current_category"
                                        add_category_to_path "$current_category"
                                fi
                        fi
                        ;;
        esac
fi

record_command "$cmd_name" "$cmd_text" || exit 1
if [ -n "$current_category" ]; then
        printf "Scribed '%s' to %s/%s.\n" "$cmd_name" "$spell_home" "$current_category"
else
        printf "Scribed '%s' to %s.\n" "$cmd_name" "$spell_home"
fi
