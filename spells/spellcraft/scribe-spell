#!/bin/sh

# This spell scribes knowledge into your shell: it can either install
# installable spells (those with an install() function) or edit rc files to
# add, remove, or inspect snippets. The install flow mirrors the classic
# memorize spell while the rc flow preserves the original scribe-spell magic.

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

usage() {
        cat <<USAGE >&2
Usage: $SCRIPT_NAME --rc-file FILE --spell NAME {add|remove|status}
       $SCRIPT_NAME [OPTIONS] [PATH ...]

RC mode:
  add|remove|status  Manage rc snippets tagged with the given spell name.

Install mode:
  -a, --all          Scan the current directory (or supplied PATHS) for spells
                     with an install() function and scribe them.
  -r, --recursive    Recursively scan supplied PATHS for installable spells.
                     Implies --all and requires at least one directory.
  -h, --help         Show this message.

Provide no rc options to use install mode.
USAGE
}

for arg in "$@"; do
        case $arg in
        --help|-h)
                usage
                exit 0
                ;;
        --rc-file|--rc-file=*|--spell|--spell=*)
                MODE=rc
                ;;
        esac
done

# ---------------------
# RC MODE IMPLEMENTATION
# ---------------------

rc_usage() {
        cat <<'RCUSAGE' >&2
Usage: scribe-spell --rc-file FILE --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.
Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
}

rc_run() {
        action=""
        rc_file=""
        spell=""

        while [ "$#" -gt 0 ]; do
                case $1 in
                --rc-file)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "scribe-spell: --rc-file expects a file path." >&2
                                rc_usage
                                exit 1
                        fi
                        rc_file=$2
                        shift 2
                        ;;
                --rc-file=*)
                        rc_file=${1#*=}
                        shift
                        ;;
                --spell)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "scribe-spell: --spell expects a name." >&2
                                rc_usage
                                exit 1
                        fi
                        spell=$2
                        shift 2
                        ;;
                --spell=*)
                        spell=${1#*=}
                        shift
                        ;;
                add|remove|status)
                        if [ -n "$action" ]; then
                                printf '%s\n' "scribe-spell: only one action may be specified." >&2
                                rc_usage
                                exit 1
                        fi
                        action=$1
                        shift
                        ;;
                --)
                        shift
                        break
                        ;;
                -*)
                        printf '%s\n' "scribe-spell: unknown option '$1'." >&2
                        rc_usage
                        exit 1
                        ;;
                *)
                        printf '%s\n' "scribe-spell: unexpected argument '$1'." >&2
                        rc_usage
                        exit 1
                        ;;
                esac
        done

        if [ -z "$action" ] || [ -z "$rc_file" ] || [ -z "$spell" ]; then
                rc_usage
                exit 1
        fi

        case $spell in
        *[!A-Za-z0-9._:-]*)
                printf '%s\n' "scribe-spell: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
                exit 1
                ;;
        *) : ;;
        esac

        spell_tag="# wizardry: $spell"
        legacy_spell_tag="# wizardry-spell: $spell"
        inline_marker=" $spell_tag"
        legacy_inline_marker=" $legacy_spell_tag"
        block_start="$spell_tag begin"
        legacy_block_start="$legacy_spell_tag begin"
        block_end="$spell_tag end"
        legacy_block_end="$legacy_spell_tag end"
        block_prefix="$spell_tag lines="
        legacy_prefix="$legacy_spell_tag lines="

        ensure_rc_directory() {
                dir=${rc_file%/*}
                if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
                        mkdir -p "$dir"
                fi
        }

        spell_status() {
                if [ ! -f "$rc_file" ]; then
                        return 1
                fi
                if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
                        return 0
                fi
                if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
                        return 0
                fi
                return 1
        }

        ensure_trailing_newline() {
                if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
                        return 0
                fi
                last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
                if [ "$last_char" != "012" ]; then
                        printf '\n' >>"$rc_file"
                fi
        }

        add_spell() {
                ensure_rc_directory
                tmp_file=$(mktemp "${TMPDIR:-/tmp}/scribe-spell.XXXXXX") || exit 1
                line_count=0
                while IFS= read -r line || [ -n "$line" ]; do
                        printf '%s\n' "$line" >>"$tmp_file"
                        line_count=$((line_count + 1))
                done
                if [ "$line_count" -eq 0 ]; then
                        rm -f "$tmp_file"
                        printf '%s\n' "scribe-spell: no spell content provided on stdin." >&2
                        exit 1
                fi
                if spell_status; then
                        rm -f "$tmp_file"
                        return 0
                fi
                if [ ! -f "$rc_file" ]; then
                        : >"$rc_file"
                fi
                ensure_trailing_newline
                if [ "$line_count" -eq 1 ]; then
                        first_line=$(sed -n '1p' "$tmp_file")
                        printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
                        rm -f "$tmp_file"
                        return 0
                fi
                block_header="$block_start lines=$line_count"
                printf '%s\n' "$block_header" >>"$rc_file"
                cat "$tmp_file" >>"$rc_file"
                printf '%s\n' "$block_end" >>"$rc_file"
                rm -f "$tmp_file"
        }

        remove_spell() {
                if [ ! -f "$rc_file" ]; then
                        printf '%s\n' "scribe-spell: cannot remove from missing file '$rc_file'." >&2
                        exit 1
                fi
                tmp_file=$(mktemp "${TMPDIR:-/tmp}/scribe-spell.XXXXXX") || exit 1
                removing_block=0
                to_skip=0
                removed=0
                while IFS= read -r line || [ -n "$line" ]; do
                        if [ "$removing_block" -eq 1 ]; then
                                case $line in
                                "$block_end"|"$legacy_block_end")
                                        removing_block=0
                                        ;;
                                esac
                                continue
                        fi
                        if [ "$to_skip" -gt 0 ]; then
                                to_skip=$((to_skip - 1))
                                continue
                        fi
                        case $line in
                        "$block_start"*|"$legacy_block_start"*)
                                removing_block=1
                                removed=1
                                continue
                                ;;
                        "$block_prefix"*)
                                count=${line#"$block_prefix"}
                                case $count in
                                *[!0-9]*)
                                        to_skip=0
                                        ;;
                                *)
                                        to_skip=$count
                                        ;;
                                esac
                                removed=1
                                continue
                                ;;
                        "$legacy_prefix"*)
                                count=${line#"$legacy_prefix"}
                                case $count in
                                *[!0-9]*)
                                        to_skip=0
                                        ;;
                                *)
                                        to_skip=$count
                                        ;;
                                esac
                                removed=1
                                continue
                                ;;
                        *"$inline_marker"|*"$legacy_inline_marker")
                                removed=1
                                continue
                                ;;
                        esac
                        printf '%s\n' "$line" >>"$tmp_file"
                done <"$rc_file"
                if [ "$removed" -eq 0 ]; then
                        rm -f "$tmp_file"
                        printf '%s\n' "scribe-spell: spell '$spell' not found in '$rc_file'." >&2
                        exit 1
                fi
                mv "$tmp_file" "$rc_file"
        }

        case $action in
        add)
                add_spell
                ;;
        remove)
                remove_spell
                ;;
        status)
                if spell_status; then
                        exit 0
                fi
                        exit 1
                ;;
        *)
                rc_usage
                exit 1
                ;;
        esac
}

if [ "${MODE-}" = "rc" ]; then
        rc_run "$@"
        exit $?
fi

# ------------------------
# INSTALL MODE (MEMORIZE)
# ------------------------

if [ -n "${MEMORIZE_ASK_YN-}" ]; then
        ASK_YN_HELPER=$MEMORIZE_ASK_YN
elif [ -x "$SPELLS_DIR/cantrips/ask_yn" ]; then
        ASK_YN_HELPER="$SPELLS_DIR/cantrips/ask_yn"
elif command -v ask_yn >/dev/null 2>&1; then
        ASK_YN_HELPER=$(command -v ask_yn)
else
        printf '%s\n' "$SCRIPT_NAME: ask_yn spell not found; cannot prompt." >&2
        exit 1
fi

ALL_MODE=0
RECURSIVE=0
MEMORIZED_COUNT=0
SKIPPED_COUNT=0
PROMPTED_PATHS=''
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=${WIZARDRY_PLATFORM-${MEMORIZE_PLATFORM-}}
MEMORIZE_RC_FILE=${WIZARDRY_RC_FILE-${MEMORIZE_RC_FILE-}}
MEMORIZE_FORMAT=${WIZARDRY_RC_FORMAT-${MEMORIZE_RC_FORMAT-}}
DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE-}

warn() {
        printf '%s: %s\n' "$SCRIPT_NAME" "$1" >&2
}

ask_yes_no() {
        question=$1
        default=${2:-no}
        if "$ASK_YN_HELPER" "$question" "$default" >/dev/null; then
                return 0
        fi
        return 1
}

detect_environment() {
        if [ "$MEMORIZE_DETECTED" -eq 1 ]; then
                return 0
        fi
        if [ -z "$DETECT_RC_FILE" ]; then
                DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE:-$SPELLS_DIR/divination/detect-rc-file}
        fi
        if [ ! -x "$DETECT_RC_FILE" ]; then
                if command -v detect-rc-file >/dev/null 2>&1; then
                        DETECT_RC_FILE=$(command -v detect-rc-file)
                else
                        printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing; cannot determine rc file." >&2
                        exit 1
                fi
        fi
        platform=$MEMORIZE_PLATFORM
        rc_file=$MEMORIZE_RC_FILE
        format=$MEMORIZE_FORMAT
        if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
                output=$("$DETECT_RC_FILE")
                while IFS='=' read -r key value; do
                        case $key in
                        platform)
                                if [ -z "$platform" ]; then
                                        platform=$value
                                fi
                                ;;
                        rc_file)
                                if [ -z "$rc_file" ]; then
                                        rc_file=$value
                                fi
                                ;;
                        format)
                                if [ -z "$format" ]; then
                                        format=$value
                                fi
                                ;;
                        esac
                done <<EOF_DETECT
$output
EOF_DETECT
        fi
        if [ -z "$rc_file" ]; then
                printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
                exit 1
        fi
        if [ -z "$platform" ]; then
                platform=unknown
        fi
        if [ -z "$format" ]; then
                format=shell
        fi
        MEMORIZE_PLATFORM=$platform
        MEMORIZE_RC_FILE=$rc_file
        MEMORIZE_FORMAT=$format
        export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
        export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
        export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
        MEMORIZE_DETECTED=1
}

have_install_function() {
        file=$1
        if ! [ -r "$file" ]; then
                return 1
        fi
        if ! grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null; then
                return 1
        fi
        return 0
}

cleanup_wrapper() {
        if [ -n "${MEMORIZE_WRAPPER-}" ] && [ -f "$MEMORIZE_WRAPPER" ]; then
                rm -f "$MEMORIZE_WRAPPER"
        fi
}

create_wrapper() {
        MEMORIZE_WRAPPER=$(mktemp "${TMPDIR:-/tmp}/scribe-spell.XXXXXX") || exit 1
cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
set -eu
TARGET=$1
shift
if [ ! -f "$TARGET" ]; then
        printf '%s\n' "scribe-spell wrapper: missing target '$TARGET'" >&2
        exit 1
fi
WIZARDRY_MEMORIZE_TARGET="$TARGET"
export WIZARDRY_MEMORIZE_TARGET
. "$TARGET"
if ! command -v install >/dev/null 2>&1; then
        printf '%s\n' "scribe-spell wrapper: $TARGET does not define install()" >&2
        exit 1
fi
install "$@"
WRAPPER
        trap cleanup_wrapper EXIT HUP INT TERM
}

get_interpreter() {
        target=$1
        first_line=''
        if IFS= read -r first_line <"$target"; then
                :
        fi
        case $first_line in
                '#!'*)
                        first_line=${first_line#\#!}
                        ;;
                *)
                        first_line=/bin/sh
                        ;;
        esac
        first_line=$(printf '%s' "$first_line" | tr -d '\r')
        printf '%s' "$first_line"
}

run_install() {
        target=$1
        if [ -z "${MEMORIZE_WRAPPER-}" ] || [ ! -f "$MEMORIZE_WRAPPER" ]; then
                create_wrapper
        fi
        if ! detect_environment; then
                return 1
        fi
        interpreter=$(get_interpreter "$target")
        if [ -z "$interpreter" ]; then
                interpreter=/bin/sh
        fi
        (
                export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
                export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
                export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
                set -- $interpreter
                if [ "$#" -eq 0 ]; then
                        set -- /bin/sh
                fi
                "$@" "$MEMORIZE_WRAPPER" "$target"
        )
}

scribe_file() {
        path=$1
        if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                return
        fi
        printf 'Memorizing %s...\n' "$path"
        if run_install "$path"; then
                MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
        else
                warn "Installation failed for '$path'."
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
        fi
}

scan_directory() {
        dir=$1
        if [ ! -d "$dir" ]; then
                warn "'$dir' is not a directory."
                SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                return
        fi
        for entry in "$dir"/*; do
                if [ ! -e "$entry" ]; then
                        continue
                fi
                if [ -d "$entry" ] && [ "$RECURSIVE" -eq 1 ]; then
                        scan_directory "$entry"
                        continue
                fi
                if [ -f "$entry" ]; then
                        scribe_file "$entry"
                fi
        done
}

prompt_for_all() {
        if ask_yes_no "No spells specified. Memorize everything in $PWD?" no; then
                ALL_MODE=1
                PROMPTED_PATHS='.'
                return
        fi
        printf 'No spells memorized.\n'
        exit 0
}

while [ $# -gt 0 ]; do
        case $1 in
                -a|--all)
                        ALL_MODE=1
                        shift
                        ;;
                -r|--recursive)
                        ALL_MODE=1
                        RECURSIVE=1
                        shift
                        ;;
                -h|--help)
                        usage
                        exit 0
                        ;;
                --)
                        shift
                        break
                        ;;
                -*)
                        warn "Unknown option: $1"
                        usage >&2
                        exit 1
                        ;;
                *)
                        break
                        ;;
        esac

done

if [ $ALL_MODE -eq 0 ] && [ $# -eq 0 ]; then
        if [ -t 0 ] && [ -t 1 ] && [ -t 2 ]; then
                prompt_for_all
                if [ -n "$PROMPTED_PATHS" ]; then
                        set -- "$PROMPTED_PATHS"
                fi
        else
                usage
                exit 1
        fi
fi

if [ $ALL_MODE -eq 1 ]; then
        if [ $RECURSIVE -eq 1 ]; then
                if [ $# -eq 0 ]; then
                        warn '--recursive requires an explicit directory path.'
                        exit 1
                fi
        elif [ $# -eq 0 ]; then
                set -- .
        fi
        for path in "$@"; do
                if [ $RECURSIVE -eq 1 ]; then
                        scan_directory "$path"
                else
                        if [ -d "$path" ]; then
                                scan_directory "$path"
                        else
                                scribe_file "$path"
                        fi
                fi
        done
else
        if [ $# -eq 0 ]; then
                warn 'No spells provided.'
                exit 1
        fi
        for path in "$@"; do
                scribe_file "$path"
        done
fi

printf 'Memorized %d spell(s); %d skipped.\n' "$MEMORIZED_COUNT" "$SKIPPED_COUNT"

exit 0
