#!/bin/sh
# This spell scribes (creates) a custom spell in your spellbook.
# It prompts for name, command text, and optionally a category.

require-wizardry || exit 1
script_name=$(basename "$0")
scribe_spell_usage() {
        cat <<USAGE
Usage: $script_name [--category CAT] [NAME COMMAND...]
       $script_name --new-category [NAME]
Scribe (create) a custom spell in your spellbook. Without arguments,
prompts interactively. Names must be unique and not conflict with PATH.
Use --new-category to create an empty category folder.
USAGE
}
scribe_spell() {
case "${1-}" in
--help|--usage|-h)
  scribe_spell_usage
  return 0
  ;;
esac
set -eu
# env-clear: compliant
spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
# Category can be passed via --category argument
current_category=""
prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt" >&2
        IFS= read -r value
        printf '%s' "$value"
# Override directory (for creating spells in subfolders)
override_dir=""
# Flag for creating a new category only (no spell)
new_category_mode=0
# Parse arguments
while [ "$#" -gt 0 ]; do
        case ${1-} in
                --help|--usage|-h)
                        scribe_spell_usage
                        return 0
                        ;;
                --new-category)
                        new_category_mode=1
                        shift
                --category)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "$script_name: --category requires a value." >&2
                                return 1
                        fi
                        current_category=$2
                        # Validate category
                        case $current_category in
                        ''|*[!A-Za-z0-9._-]*)
                                printf '%s\n' "$script_name: category names may contain only letters, digits, dots, underscores, and dashes." >&2
                                ;;
                        -*)
                                printf '%s\n' "$script_name: category names may not begin with a dash." >&2
                        esac
                        shift 2
                --category=*)
                        current_category=${1#*=}
                --dir)
                                printf '%s\n' "$script_name: --dir requires a value." >&2
                        override_dir=$2
                --dir=*)
                        override_dir=${1#*=}
                --)
                        break
                -*)
                        printf '%s\n' "$script_name: unknown option '$1'" >&2
                        return 1
                *)
        esac
done
# If override_dir is set, use it instead of spell_home
if [ -n "$override_dir" ]; then
        spell_home=$override_dir
        # Clear category since we're using a specific dir
        current_category=""
fi
# Handle --new-category mode
if [ "$new_category_mode" -eq 1 ]; then
        if [ "$#" -ge 1 ]; then
                category_name=$1
        else
                category_name=$(prompt_for_input "Category name: ")
        fi
        if [ -z "$category_name" ]; then
                printf '%s\n' "A category name is required." >&2
                return 1
        # Validate category name
        case $category_name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$script_name: category names may contain only letters, digits, dots, underscores, and dashes." >&2
                ;;
        -*)
                printf '%s\n' "$script_name: category names may not begin with a dash." >&2
        if [ -d "$spell_home/$category_name" ]; then
                printf '%s\n' "Category '$category_name' already exists." >&2
        mkdir -p "$spell_home/$category_name"
        display_path=$(tilde-path "$spell_home")
        printf "Created category '%s' in %s.\n" "$category_name" "$display_path"
        return 0
# Non-interactive mode with arguments
if [ "$#" -ge 2 ]; then
        name=$1
        shift
        # Build command from remaining arguments
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        
        # Validate name
        case $name in
                printf '%s\n' "$script_name: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                printf '%s\n' "$script_name: names may not begin with a dash." >&2
        # Check for duplicate name
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s\n' "$script_name: '$name' conflicts with an existing command." >&2
        if [ -e "$spell_home/$name" ]; then
                printf '%s\n' "$script_name: '$name' already exists in your spellbook." >&2
        if [ -d "$spell_home" ]; then
                for subdir in "$spell_home"/*; do
                        [ -d "$subdir" ] || continue
                        if [ -e "$subdir/$name" ]; then
                                printf '%s\n' "$script_name: '$name' already exists in your spellbook." >&2
                done
        # Validate command
        if [ -z "$cmd" ]; then
                printf '%s\n' "$script_name: command must not be empty." >&2
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "$script_name: command may not contain tabs." >&2
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "$script_name: command must be a single line." >&2
        # Create spell directory
        if [ -n "$current_category" ]; then
                mkdir -p "$spell_home/$current_category"
                mkdir -p "$spell_home"
        # Write spell script
                target_path="$spell_home/$current_category/$name"
                target_path="$spell_home/$name"
        target_dir=${target_path%/*}
        if [ "$target_dir" != "$target_path" ] && [ ! -d "$target_dir" ]; then
                mkdir -p "$target_dir"
        escaped_cmd=$(printf '%s' "$cmd" | sed "s/'/'\\''/g")
        cat >"$target_path" <<EOF_SCRIPT
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$target_path"
                display_path=$(tilde-path "$spell_home")
                printf "Scribed '%s' to %s/%s.\n" "$name" "$display_path" "$current_category"
                printf "Scribed '%s' to %s.\n" "$name" "$display_path"
# Check for partial arguments
if [ "$#" -eq 1 ]; then
        scribe_spell_usage >&2
        return 1
# Interactive mode - ask for command FIRST, then name
cmd_text=$(prompt_for_input "Command: ")
cmd_name=$(prompt_for_input "Name: ")
if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
        printf '%s\n' "A name and command are required." >&2
# If no category was provided via --category or --dir, ask if user wants to categorize
if [ -z "$current_category" ] && [ -z "$override_dir" ]; then
        printf 'Would you like to categorize this spell? [y/N] ' >&2
        read -r categorize_answer
        case $categorize_answer in
                y|Y|yes|YES)
                        category_name=$(prompt_for_input "Category name: ")
                        if [ -n "$category_name" ]; then
                                # Validate category
                                case $category_name in
                                ''|*[!A-Za-z0-9._-]*)
                                        printf '%s\n' "$script_name: category names may contain only letters, digits, dots, underscores, and dashes." >&2
                                        return 1
                                        ;;
                                -*)
                                        printf '%s\n' "$script_name: category names may not begin with a dash." >&2
                                esac
                                current_category=$category_name
                                # Create the category folder
                                if [ ! -d "$spell_home/$current_category" ]; then
                                        mkdir -p "$spell_home/$current_category"
                                fi
# Validate name
case $cmd_name in
''|*[!A-Za-z0-9._-]*)
        printf '%s\n' "$script_name: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
        ;;
-*)
        printf '%s\n' "$script_name: names may not begin with a dash." >&2
# Check for duplicate name
if command -v "$cmd_name" >/dev/null 2>&1; then
        printf '%s\n' "$script_name: '$cmd_name' conflicts with an existing command." >&2
if [ -e "$spell_home/$cmd_name" ]; then
        printf '%s\n' "$script_name: '$cmd_name' already exists in your spellbook." >&2
if [ -d "$spell_home" ]; then
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                if [ -e "$subdir/$cmd_name" ]; then
                        printf '%s\n' "$script_name: '$cmd_name' already exists in your spellbook." >&2
                fi
# Validate command
if [ -z "$cmd_text" ]; then
        printf '%s\n' "$script_name: command must not be empty." >&2
if [ "$(printf '%s' "$cmd_text" | tr -d '\t')" != "$cmd_text" ]; then
        printf '%s\n' "$script_name: command may not contain tabs." >&2
if [ "$(printf '%s' "$cmd_text" | tr -d '\n')" != "$cmd_text" ]; then
        printf '%s\n' "$script_name: command must be a single line." >&2
# Create spell directory
if [ -n "$current_category" ]; then
        mkdir -p "$spell_home/$current_category"
else
        mkdir -p "$spell_home"
# Write spell script
        target_path="$spell_home/$current_category/$cmd_name"
        target_path="$spell_home/$cmd_name"
target_dir=${target_path%/*}
if [ "$target_dir" != "$target_path" ] && [ ! -d "$target_dir" ]; then
        mkdir -p "$target_dir"
escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
cat >"$target_path" <<EOF_SCRIPT
chmod +x "$target_path"
        printf "Scribed '%s' to %s/%s.\n" "$cmd_name" "$display_path" "$current_category"
        printf "Scribed '%s' to %s.\n" "$cmd_name" "$display_path"
# Self-execute when run directly (not sourced)
case "$0" in
  */scribe-spell) scribe_spell "$@" ;; esac
