#!/bin/sh

# This spell vets other spells for style guide violations.
# Run it against spell files to check formatting and code style compliance.

show_usage() {
  cat <<'USAGE'
Usage: vet-spell [--only PATTERN] [--list] [--verbose] [file...]

Check spells for style-guide compliance. With no files provided it scans the whole spellbook; use --only to filter by pattern, --list to show targets, and --verbose for detailed output.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

verbose=0
list_only=0
pattern=''

while [ "$#" -gt 0 ]; do
  case $1 in
    --verbose)
      verbose=1
      shift
      ;;
    --list)
      list_only=1
      shift
      ;;
    --only)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "vet-spell: --only requires a pattern argument." >&2
        exit 2
      fi
      pattern=$2
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "vet-spell: unknown option: $1" >&2
      show_usage >&2
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

is_imp() {
  file=$1
  case $file in
    */.imps/*|*/.imps)
      return 0
      ;;
  esac
  return 1
}

gather_default_targets() {
  find "$repo_dir/spells" -type f \( -perm -u+x -o -perm -g+x -o -perm -o+x \) \
    -print | sort | while IFS= read -r file; do
      first_line=$(head -1 "$file")
      case $first_line in
        '#!/bin/sh'|'#! /bin/sh'|'#!/usr/bin/env sh'|'#! /usr/bin/env sh')
          rel_path=${file#"$repo_dir/"}
          if [ -n "$pattern" ]; then
            case $rel_path in
              *"$pattern"*)
                printf '%s\n' "$rel_path"
                ;;
            esac
          else
            printf '%s\n' "$rel_path"
          fi
          ;;
      esac
    done
}

collect_targets() {
  if [ "$#" -gt 0 ]; then
    for arg in "$@"; do
      case $arg in
        /*)
          printf '%s\n' "$arg"
          ;;
        *)
          printf '%s\n' "$arg"
          ;;
      esac
    done
  else
    gather_default_targets
  fi
}

check_shebang() {
  file=$1
  first_line=$(head -1 "$file")
  case $first_line in
    '#!/bin/sh'|'#! /bin/sh'|'#!/usr/bin/env sh'|'#! /usr/bin/env sh')
      return 0
      ;;
    *)
      printf 'missing or incorrect shebang (expected #!/bin/sh)'
      return 1
      ;;
  esac
}

check_description_comment() {
  file=$1
  # Read lines 2, 3, and 4 to allow up to 3-line opening comments
  lines=$(sed -n '2p;3p;4p' "$file")
  second_line=$(printf '%s\n' "$lines" | sed -n '1p')
  third_line=$(printf '%s\n' "$lines" | sed -n '2p')
  fourth_line=$(printf '%s\n' "$lines" | sed -n '3p')
  
  # Check if second line is empty and third line is a comment
  if [ -z "$second_line" ] && [ -n "$third_line" ]; then
    case $third_line in
      '#'*)
        return 0
        ;;
    esac
  fi
  
  # Check if second line is a comment (allows up to 3 comment lines)
  case $second_line in
    '#'*)
      return 0
      ;;
    *)
      printf 'missing opening description comment after shebang'
      return 1
      ;;
  esac
}

check_usage_function() {
  file=$1
  if grep -qE '^[[:space:]]*show_usage\(\)' "$file" 2>/dev/null; then
    return 0
  fi
  printf 'missing usage function (show_usage)'
  return 1
}

check_help_handler() {
  file=$1
  if grep -qF -- '--help|--usage|-h)' "$file" 2>/dev/null; then
    return 0
  fi
  printf 'missing --help|--usage|-h handler'
  return 1
}

check_strict_mode() {
  file=$1
  # Accept set -eu, set -e, or set -e -u as valid strict mode
  if grep -qE 'set -e' "$file" 2>/dev/null; then
    return 0
  fi
  printf 'missing strict mode (set -e or set -eu)'
  return 1
}

check_trailing_space_assignment() {
  file=$1
  # Look for pattern: variable= followed by newline (trailing space assignment)
  match=$(grep -En '^[a-zA-Z_][a-zA-Z0-9_]*= $' "$file" 2>/dev/null | head -1) || true
  if [ -n "$match" ]; then
    line_num=$(printf '%s' "$match" | cut -d: -f1)
    printf 'trailing space in variable assignment at line %s' "$line_num"
    return 1
  fi
  return 0
}

check_posix_compliance() {
  file=$1
  checkbashisms_cmd=${CHECKBASHISMS-}
  if [ -z "$checkbashisms_cmd" ] && command -v checkbashisms >/dev/null 2>&1; then
    checkbashisms_cmd=$(command -v checkbashisms)
  fi
  
  if [ -z "$checkbashisms_cmd" ]; then
    # Skip POSIX check if checkbashisms not available
    return 0
  fi
  
  if "$checkbashisms_cmd" "$file" >/dev/null 2>&1; then
    return 0
  fi
  printf 'POSIX compliance violation (run checkbashisms for details)'
  return 1
}

check_which_usage() {
  file=$1
  # Check for 'which' command usage patterns:
  # - which command (at start of line or after certain shell operators)
  # - $(which ...) or `which ...` patterns
  # Excludes English prose containing "which" in comments or heredocs
  # Only match if followed by a simple command name (letters, digits, hyphens, underscores)
  if grep -E '(^|[;|&])[[:space:]]*which[[:space:]]+[a-zA-Z0-9_-]+|`which[[:space:]]|\$\(which[[:space:]]' "$file" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
    printf 'uses "which" (prefer "command -v" for POSIX compliance)'
    return 1
  fi
  return 0
}

check_backtick_usage() {
  file=$1
  # Check for backtick usage (excluding comments)
  if grep -E '\`[^\`]+\`' "$file" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
    printf 'uses backticks (prefer $() for command substitution)'
    return 1
  fi
  return 0
}

check_spell_naming() {
  file=$1
  name=$(basename "$file")
  
  # Check for underscore in name (should use hyphens)
  case $name in
    *_*)
      printf 'spell name uses underscore (prefer hyphens)'
      return 1
      ;;
  esac
  
  # Check for .sh extension (spells shouldn't have extensions)
  case $name in
    *.sh)
      printf 'spell has .sh extension (spells should have no extension)'
      return 1
      ;;
  esac
  
  return 0
}

failures=0
total=0
passed=0
failed_targets=''

targets_file=$("$repo_dir/spells/.imps/fs/temp-file" vet-spell-targets) || exit 1
trap '"$repo_dir/spells/.imps/fs/cleanup-file" "$targets_file"' EXIT HUP INT TERM
collect_targets "$@" >"$targets_file"

if [ "$list_only" -eq 1 ]; then
  cat "$targets_file"
  trap - EXIT HUP INT TERM
  rm -f "$targets_file"
  exit 0
fi

while IFS= read -r target; do
  [ -n "$target" ] || continue
  total=$((total + 1))
  
  case $target in
    /*)
      path="$target"
      ;;
    *)
      path="$repo_dir/$target"
      ;;
  esac
  
  if [ ! -e "$path" ]; then
    printf 'FAIL %s: file not found\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi
  
  if [ ! -f "$path" ]; then
    printf 'FAIL %s: not a regular file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi
  
  is_imp_file=0
  if is_imp "$target" || is_imp "$path"; then
    is_imp_file=1
  fi
  
  issues=''
  issue_count=0
  
  # Check shebang (required for all)
  if ! result=$(check_shebang "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check description comment (required for all)
  if ! result=$(check_description_comment "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check usage function (not required for imps)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! result=$(check_usage_function "$path"); then
      issues=${issues:+$issues; }$result
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check help handler (not required for imps)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! result=$(check_help_handler "$path"); then
      issues=${issues:+$issues; }$result
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check strict mode (not required for imps - they often use exit codes for flow control)
  if [ "$is_imp_file" -eq 0 ]; then
    if ! result=$(check_strict_mode "$path"); then
      issues=${issues:+$issues; }$result
      issue_count=$((issue_count + 1))
    fi
  fi
  
  # Check trailing space assignment (required for all)
  if ! result=$(check_trailing_space_assignment "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check POSIX compliance (required for all)
  if ! result=$(check_posix_compliance "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check which usage (required for all)
  if ! result=$(check_which_usage "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check backtick usage (required for all)
  if ! result=$(check_backtick_usage "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  # Check spell naming convention (required for all)
  if ! result=$(check_spell_naming "$path"); then
    issues=${issues:+$issues; }$result
    issue_count=$((issue_count + 1))
  fi
  
  if [ "$issue_count" -eq 0 ]; then
    if [ "$verbose" -eq 1 ]; then
      printf 'PASS %s\n' "$target"
    fi
    passed=$((passed + 1))
  else
    printf 'FAIL %s: %s\n' "$target" "$issues"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
  fi
done <"$targets_file"

trap - EXIT HUP INT TERM
rm -f "$targets_file"

if [ "$failures" -eq 0 ]; then
  printf 'All %d spells passed style checks.\n' "$total"
  exit 0
else
  printf '%d of %d spells failed style checks.\n' "$failures" "$total"
  if [ -n "$failed_targets" ]; then
    printf 'Failing spells: %s\n' "$failed_targets"
  fi
  exit 1
fi
