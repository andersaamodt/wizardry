#!/bin/sh

# Compile a spell into a standalone script by inlining its dependencies.
# Creates a self-contained executable that works without wizardry installed.

show_usage() {
  cat <<'USAGE'
Usage: compile-spell <spell-name>

Compile a spell into a standalone script by inlining all dependencies.
The compiled spell can run without wizardry being installed.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
  printf '%s\n' "compile-spell: spell name required" >&2
  show_usage >&2
  exit 1
fi

spell_name=$1

# Find the spell
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
imps_dir="$repo_dir/spells/.imps"

# Find spell recursively
spell_path=$(find "$repo_dir/spells" -type f -name "$spell_name" \
  ! -path "*/.*" 2>/dev/null | head -1)

if [ -z "$spell_path" ] || [ ! -f "$spell_path" ]; then
  printf '%s\n' "compile-spell: spell '$spell_name' not found" >&2
  exit 1
fi

# Read spell content
spell_content=$(cat "$spell_path")

# Find all potential dependencies - both hyphenated and common imps
# Look in actual command positions (not in strings/comments)
dependencies=$(printf '%s\n' "$spell_content" | \
  grep -v "^#" | \
  grep -v "^[[:space:]]*#" | \
  grep -oE '\b(say|warn|die|fail|is|has|there|empty|full|given|lacks|[a-z][a-z0-9]*(-[a-z0-9]+)+)\b' | \
  sort -u || true)

# Collect inline implementations and track what was inlined
inlined_deps=""
inlined_names=""

for dep in $dependencies; do
  # Skip require-wizardry - doesn't make sense in standalone
  [ "$dep" = "require-wizardry" ] && continue
  
  # Skip if already inlined
  case " $inlined_names " in
    *" $dep "*) continue ;;
  esac
  
  # Find the imp/spell file
  dep_file=$(find "$imps_dir" -type f -name "$dep" 2>/dev/null | head -1)
  
  # If not found in imps, check spells
  if [ -z "$dep_file" ]; then
    dep_file=$(find "$repo_dir/spells" -type f -name "$dep" \
      ! -path "*/.*" ! -path "$spell_path" 2>/dev/null | head -1)
  fi
  
  # Skip if not found
  [ -z "$dep_file" ] || [ ! -f "$dep_file" ] && continue
  
  # Read dependency content
  dep_content=$(cat "$dep_file")
  
  # Extract function definition (lines from _funcname() to closing })
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  func_def=$(printf '%s\n' "$dep_content" | awk -v fname="$func_name" '
    /^'$func_name'\(\)/ { in_func=1 }
    in_func { print }
    in_func && /^}$/ { exit }
  ')
  
  # If we got a function, inline it
  if [ -n "$func_def" ]; then
    inlined_deps="$inlined_deps
# Inlined: $dep
$func_def
"
    inlined_names="$inlined_names $dep"
  fi
done

# Transform spell content:
# 1. Remove shebang and require-wizardry
# 2. Replace imp calls with underscore versions (e.g., say -> _say, clip-copy -> _clip_copy)
transformed=$(printf '%s\n' "$spell_content" | tail -n +2 | grep -v "^require-wizardry")

# For each inlined imp, replace calls in the spell
# Note: func_name comes from sanitized internal processing (tr '-' '_')
# so special regex characters are not a concern here
for dep in $inlined_names; do
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  
  # Use awk for more controlled replacement - skip USAGE blocks
  # Note: This handles common USAGE heredoc patterns including quoted delimiters
  transformed=$(printf '%s\n' "$transformed" | awk -v old="$dep" -v new="$func_name" '
    /^cat <<['\''"]?USAGE['\''"]?/ { usage_start=1 }
    usage_start && /^USAGE$/ { print; usage_start=0; next }
    usage_start { print; next }
    { gsub("\\<" old "\\>", new); print }
  ')
done

# Output compiled spell
printf '#!/bin/sh\n'
printf '# Compiled spell: %s\n' "$spell_name"
printf '# Generated by: compile-spell\n'
printf '#\n'
printf '# This is a standalone version that works without wizardry installed.\n'
printf '# Source: https://github.com/andersaamodt/wizardry\n'
printf '\n'

# Output inlined dependencies
if [ -n "$inlined_deps" ]; then
  printf '%s\n' "$inlined_deps"
fi

# Output transformed spell content
printf '%s\n' "$transformed"
