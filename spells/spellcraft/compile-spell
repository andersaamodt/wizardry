#!/bin/sh

# This spell compiles a spell into a standalone script by inlining all imp calls.
# Optionally compiles for a specific OS, removing cross-platform conditionals.

require-wizardry || exit 1

show_usage() {
  cat <<'USAGE'
Usage: compile-spell <spell-name> [os]

Compile a spell into a standalone script by inlining all of its imps. Optionally specify linux, mac, nixos, debian, or arch to tailor the output for one platform.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
  warn "compile-spell: spell name required"
  show_usage >&2
  exit 1
fi

spell_name=$1
target_os=${2-}

# Find the spell
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
imps_dir="$repo_dir/spells/.imps"

# Look for the spell in various locations
spell_path=""
for dir in "$repo_dir/spells" "$repo_dir/spells"/*; do
  if [ -f "$dir/$spell_name" ]; then
    spell_path="$dir/$spell_name"
    break
  fi
done

if [ -z "$spell_path" ] || [ ! -f "$spell_path" ]; then
  warn "compile-spell: spell '$spell_name' not found"
  exit 1
fi

# Read the spell
content=$(cat "$spell_path")

# Find all imp calls in the spell (hyphenated commands and known single-word imps)
# Look for patterns like: cmd-name, ask-text, is file, warn "...", say, etc.
known_imps="say warn die fail info step debug success is has there gone empty nonempty given full yes no lacks"

# Find hyphenated commands
hyphenated_imps=$(printf '%s\n' "$content" | grep -oE '\b[a-z][a-z0-9]*(-[a-z0-9]+)+\b' | sort -u)

# Find known single-word imps
single_word_imps=$(printf '%s\n' "$content" | grep -oE '\b(say|warn|die|fail|info|step|debug|success|is|has|there|gone|empty|nonempty|given|full|yes|no|lacks)\b' | sort -u)

# Combine both lists
imp_calls=$(printf '%s\n%s\n' "$hyphenated_imps" "$single_word_imps" | grep -v '^$' | sort -u)

# Collect imp definitions
inlined_imps=""
processed_imps=""

# Function to find and inline an imp
inline_imp() {
  imp_name=$1
  
  # Skip if already processed
  case " $processed_imps " in
    *" $imp_name "*) return 0 ;;
  esac
  
  # Find the imp file
  imp_file=""
  for family_dir in "$imps_dir"/*; do
    [ -d "$family_dir" ] || continue
    if [ -f "$family_dir/$imp_name" ]; then
      imp_file="$family_dir/$imp_name"
      break
    fi
    # Check subdirectories (daemonic complexes)
    for subdir in "$family_dir"/*; do
      [ -d "$subdir" ] || continue
      if [ -f "$subdir/$imp_name" ]; then
        imp_file="$subdir/$imp_name"
        break 2
      fi
    done
  done
  
  # If not found in imps, might be a spell (like ask-text)
  if [ -z "$imp_file" ]; then
    # Check if it's a spell that should be inlined (like cantrips)
    for spell_dir in "$repo_dir/spells"/*; do
      [ -d "$spell_dir" ] || continue
      if [ -f "$spell_dir/$imp_name" ]; then
        # Don't inline full spells - too complex
        return 1
      fi
    done
    return 1
  fi
  
  # Read imp content
  imp_content=$(cat "$imp_file")
  
  # Extract the function definition (lines between function name and case statement)
  # Look for pattern: _function_name() { ... }
  func_name="_$(printf '%s' "$imp_name" | tr '-' '_')"
  
  # Extract just the function definition
  func_def=$(printf '%s\n' "$imp_content" | awk -v fname="$func_name" '
    /^'"$func_name"'\(\)/ { in_func=1 }
    in_func { print }
    in_func && /^}$/ { exit }
  ')
  
  if [ -n "$func_def" ]; then
    inlined_imps="$inlined_imps
# Inlined imp: $imp_name
$func_def
"
    processed_imps="$processed_imps $imp_name"
    return 0
  fi
  
  return 1
}

# Try to inline each imp call found
if [ -n "$imp_calls" ]; then
  while IFS= read -r imp_call; do
    inline_imp "$imp_call" || true
  done <<EOF
$imp_calls
EOF
fi

# Transform the spell content to use function calls instead of command calls
transformed_content="$content"

# For each inlined imp, replace hyphenated calls with underscore function calls
for imp in $processed_imps; do
  func_name="_$(printf '%s' "$imp" | tr '-' '_')"
  # This is a simple replacement - more sophisticated parsing would be better
  # but this handles the most common cases
  transformed_content=$(printf '%s\n' "$transformed_content" | sed "s/\b$imp\b/$func_name/g")
done

# Remove require-wizardry line since we're making it standalone
transformed_content=$(printf '%s\n' "$transformed_content" | grep -v "^require-wizardry")

# Output the compiled spell
printf '#!/bin/sh\n'
printf '# Compiled from: %s\n' "$spell_name"
if [ -n "$target_os" ]; then
  printf '# Target OS: %s\n' "$target_os"
fi
printf '# Generated by compile-spell\n'
printf '# Inlined imps: %s\n' "$processed_imps"
printf '\n'

# Output inlined imp definitions first
if [ -n "$inlined_imps" ]; then
  printf '%s\n' "$inlined_imps"
fi

# Output the transformed spell (skip original shebang)
printf '%s\n' "$transformed_content" | tail -n +2
