#!/bin/sh

# This spell compiles a spell into a standalone script by inlining all imp and spell calls.
# Optionally compiles for a specific OS, removing cross-platform conditionals.

require-wizardry || exit 1

show_usage() {
  cat <<'USAGE'
Usage: compile-spell <spell-name> [os]

Compile a spell into a standalone script by inlining all of its imps and called spells. Optionally specify linux, mac, nixos, debian, or arch to tailor the output for one platform.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
  warn "compile-spell: spell name required"
  show_usage >&2
  exit 1
fi

spell_name=$1
target_os=${2-}

# Find the spell
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
imps_dir="$repo_dir/spells/.imps"

# Look for the spell in various locations
spell_path=""
for dir in "$repo_dir/spells" "$repo_dir/spells"/*; do
  if [ -f "$dir/$spell_name" ]; then
    spell_path="$dir/$spell_name"
    break
  fi
done

if [ -z "$spell_path" ] || [ ! -f "$spell_path" ]; then
  warn "compile-spell: spell '$spell_name' not found"
  exit 1
fi

# Read the spell
content=$(cat "$spell_path")

# Find all imp calls in the spell (hyphenated commands and known single-word imps)
# Look for patterns like: cmd-name, ask-text, is file, warn "...", say, etc.
known_imps="say warn die fail info step debug success is has there gone empty nonempty given full yes no lacks"

# Find hyphenated commands
hyphenated_imps=$(printf '%s\n' "$content" | grep -oE '\b[a-z][a-z0-9]*(-[a-z0-9]+)+\b' | sort -u)

# Find known single-word imps
single_word_imps=$(printf '%s\n' "$content" | grep -oE '\b(say|warn|die|fail|info|step|debug|success|is|has|there|gone|empty|nonempty|given|full|yes|no|lacks)\b' | sort -u)

# Combine both lists
imp_calls=$(printf '%s\n%s\n' "$hyphenated_imps" "$single_word_imps" | grep -v '^$' | sort -u)

# Collect imp definitions
inlined_imps=""
processed_imps=""

# Function to find and inline an imp or spell
inline_imp() {
  imp_name=$1
  is_dependency=${2:-0}  # 1 if this is being inlined as a dependency, 0 if it's the main spell
  
  # Skip require-wizardry - it checks for wizardry installation which doesn't make sense in standalone scripts
  [ "$imp_name" = "require-wizardry" ] && return 0
  
  # Skip if already processed
  case " $processed_imps " in
    *" $imp_name "*) return 0 ;;
  esac
  
  # Find the imp file
  imp_file=""
  for family_dir in "$imps_dir"/*; do
    [ -d "$family_dir" ] || continue
    if [ -f "$family_dir/$imp_name" ]; then
      imp_file="$family_dir/$imp_name"
      break
    fi
    # Check subdirectories (daemonic complexes)
    for subdir in "$family_dir"/*; do
      [ -d "$subdir" ] || continue
      if [ -f "$subdir/$imp_name" ]; then
        imp_file="$subdir/$imp_name"
        break 2
      fi
    done
  done
  
  # If not found in imps, check if it's a spell (like ask-text, ask-number)
  if [ -z "$imp_file" ]; then
    for spell_dir in "$repo_dir/spells"/*; do
      [ -d "$spell_dir" ] || continue
      # Skip special directories
      case "$spell_dir" in
        "$repo_dir/spells/.imps"|"$repo_dir/spells/.arcana") continue ;;
      esac
      if [ -f "$spell_dir/$imp_name" ]; then
        imp_file="$spell_dir/$imp_name"
        break
      fi
    done
  fi
  
  # If still not found, return
  [ -n "$imp_file" ] || return 1
  
  # Read imp/spell content
  imp_content=$(cat "$imp_file")
  
  # Check if it's an imp with a function definition
  func_name="_$(printf '%s' "$imp_name" | tr '-' '_')"
  
  # Extract the function definition for imps (lines between function name and case statement)
  # Look for pattern: _function_name() { ... }
  func_def=$(printf '%s\n' "$imp_content" | awk -v fname="$func_name" '
    /^'"$func_name"'\(\)/ { in_func=1 }
    in_func { print }
    in_func && /^}$/ { exit }
  ')
  
  if [ -n "$func_def" ]; then
    # It's an imp with a function - inline the function
    inlined_imps="$inlined_imps
# Inlined imp: $imp_name
$func_def
"
    processed_imps="$processed_imps $imp_name"
    return 0
  fi
  
  # If no function found and this is being inlined as a dependency (not the main spell)
  # Inline the entire spell as a function
  if [ "$is_dependency" = "1" ]; then
    # Remove shebang, help handler, and set -eu from the spell content
    spell_body=$(printf '%s\n' "$imp_content" | awk '
      BEGIN { in_usage=0; skip_help=0 }
      /^#!/ { next }
      /^show_usage\(\)/ { in_usage=1 }
      in_usage && /^}$/ { in_usage=0; next }
      in_usage { next }
      /^case.*--help.*--usage/ { skip_help=1; next }
      skip_help && /^esac/ { skip_help=0; next }
      skip_help { next }
      /^set -eu$/ { next }
      /^require-wizardry/ { next }
      { print }
    ')
    
    # Wrap the spell as a function
    inlined_imps="$inlined_imps
# Inlined spell: $imp_name
$func_name() {
$spell_body
}
"
    processed_imps="$processed_imps $imp_name"
    
    # Recursively process any dependencies in the spell
    # Look for actual command calls, not just words in comments
    spell_deps=$(printf '%s\n' "$imp_content" | grep -v "^#" | grep -v "^[[:space:]]*#" | grep -oE '\b[a-z][a-z0-9]*(-[a-z0-9]+)+\b' | sort -u)
    if [ -n "$spell_deps" ]; then
      while IFS= read -r dep; do
        # Skip if it's the spell itself
        [ "$dep" != "$imp_name" ] || continue
        inline_imp "$dep" 1 || true
      done <<DEPS
$spell_deps
DEPS
    fi
  fi
  
  return 0
}

# Try to inline each imp call found
if [ -n "$imp_calls" ]; then
  while IFS= read -r imp_call; do
    inline_imp "$imp_call" 1 || true
  done <<EOF
$imp_calls
EOF
fi

# Transform the spell content to use function calls instead of command calls
transformed_content="$content"

# For each inlined imp, replace hyphenated calls with underscore function calls
# This is a simple word-boundary replacement that will catch most cases
# More sophisticated AST parsing would be needed for 100% accuracy
for imp in $processed_imps; do
  func_name="_$(printf '%s' "$imp" | tr '-' '_')"
  # Replace imp name when it appears as a standalone command or function call
  # Using word boundaries to avoid replacing parts of other words
  # Note: This may still replace in strings/comments but handles most common cases
  transformed_content=$(printf '%s\n' "$transformed_content" | sed "s/\<$imp\>/$func_name/g")
done

# Remove require-wizardry line since we're making it standalone
transformed_content=$(printf '%s\n' "$transformed_content" | grep -v "^require-wizardry")

# Output the compiled spell
printf '#!/bin/sh\n'
printf '# Compiled from: %s\n' "$spell_name"
if [ -n "$target_os" ]; then
  printf '# Target OS: %s\n' "$target_os"
fi
printf '# Generated by compile-spell\n'
printf '# Inlined dependencies: %s\n' "$processed_imps"
printf '\n'

# Output inlined imp definitions first
if [ -n "$inlined_imps" ]; then
  printf '%s\n' "$inlined_imps"
fi

# Output the transformed spell (skip original shebang)
printf '%s\n' "$transformed_content" | tail -n +2
