#!/bin/sh





# Compile a spell into a standalone script by inlining its dependencies.
# Creates a self-contained executable that works without wizardry installed.

compile_spell_usage() {
  cat <<'USAGE'
Usage: compile-spell <spell-name-or-path>

Compile a spell into a standalone script by inlining all dependencies.
The compiled spell can run without wizardry being installed.

Arguments:
  spell-name-or-path   Name of spell (e.g., "hash") or path (e.g., "spells/cantrips/hash")

Examples:
  compile-spell hash                      # Find by name
  compile-spell spells/cantrips/hash      # Use path
  compile-spell ./my-custom-spell         # Current directory
USAGE
}


compile_spell() {
case "${1-}" in
--help|--usage|-h)
  compile_spell_usage
  return 0
  ;;
esac

# Handle require_wizardry availability (for script execution without invoke-wizardry)
if command -v require_wizardry >/dev/null 2>&1; then
  require_wizardry || exit 1
elif command -v require_wizardry >/dev/null 2>&1; then
  require_wizardry || return 1
else
  # Neither available - source it now
  if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry" ]; then
    . "${WIZARDRY_DIR}/spells/.imps/sys/require-wizardry"
    require_wizardry || exit 1
  else
    # Fall back to relative path from script location
    _cs_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    _cs_imp_path="$_cs_script_dir/../../.imps/sys/require-wizardry"
    if [ -f "$_cs_imp_path" ]; then
      . "$_cs_imp_path"
      require_wizardry || exit 1
    else
      printf 'Error: require_wizardry not found\n' >&2
      exit 1
    fi
  fi
fi

set -eu

# Source env_clear if not already available
if ! command -v env_clear >/dev/null 2>&1; then
  if [ -n "${WIZARDRY_DIR-}" ] && [ -f "${WIZARDRY_DIR}/spells/.imps/sys/env-clear" ]; then
    . "${WIZARDRY_DIR}/spells/.imps/sys/env-clear"
  else
    _cs_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    . "$_cs_script_dir/../../.imps/sys/env-clear"
  fi
fi

# Source output imps (say, warn, die, etc.)
if [ -n "${WIZARDRY_DIR-}" ] && [ -d "${WIZARDRY_DIR}/spells/.imps/out" ]; then
  for _cs_out_imp in "${WIZARDRY_DIR}"/spells/.imps/out/*; do
    [ -f "$_cs_out_imp" ] && . "$_cs_out_imp"
  done
else
  _cs_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  for _cs_out_imp in "$_cs_script_dir"/../../.imps/out/*; do
    [ -f "$_cs_out_imp" ] && . "$_cs_out_imp"
  done
fi

if [ "$#" -lt 1 ]; then
  compile_spell_usage >&2
  return 2
fi

spell_name=$1

# Find the spell
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
imps_dir="$repo_dir/spells/.imps"

# Determine if input is a path or just a name
spell_path=""
spell_basename=""
case "$spell_name" in
  */*) 
    # Contains slash - treat as path (relative or absolute)
    if [ -f "$spell_name" ]; then
      # Absolute or relative path that exists
      spell_path="$spell_name"
    elif [ -f "$repo_dir/$spell_name" ]; then
      # Relative to repo root
      spell_path="$repo_dir/$spell_name"
    fi
    spell_basename=$(basename "$spell_name")
    ;;
  *)
    # No slash - treat as spell name, search for it
    spell_basename="$spell_name"
    # First try current directory
    if [ -f "$spell_name" ]; then
      spell_path="$spell_name"
    else
      # Find spell recursively (include imps and .arcana)
      spell_path=$(find "$repo_dir/spells" -type f -name "$spell_name" 2>/dev/null | head -1)
    fi
    ;;
esac

if [ -z "$spell_path" ] || [ ! -f "$spell_path" ]; then
  die "compile-spell: spell '$spell_name' not found"
        return 1
fi

# Read spell content
spell_content=$(cat "$spell_path")

# Find all potential dependencies - hyphenated commands, common imps, and spell names
# Look in actual command positions (not in strings/comments)
dependencies=$(printf '%s\n' "$spell_content" | \
  grep -v "^#" | \
  grep -v "^[[:space:]]*#" | \
  grep -oE '\b(say|warn|die|fail|is|has|there|empty|full|given|lacks|memorize|env-or|[a-z][a-z0-9]*(-[a-z0-9]+)+)\b' | \
  sort -u || true)

# Collect inline implementations and track what was inlined
inlined_deps=""
inlined_names=""

for dep in $dependencies; do
  # Skip self-reference - spell cannot be its own dependency
  [ "$dep" = "$spell_basename" ] && continue
  
  # Skip require_wizardry and invoke-wizardry - they don't make sense in standalone
  # invoke-wizardry is the runtime environment, not a library function
  [ "$dep" = "require-wizardry" ] && continue
  [ "$dep" = "invoke-wizardry" ] && continue
  
  # Skip common English words that are rarely used as commands
  # These cause issues when replaced in strings
  # Note: Only add words here that are causing real problems, as this may
  # prevent legitimate imp calls from being inlined if needed in the future
  case "$dep" in
    is) continue ;;  # Too common as English word "is"
    fail) continue ;;  # Commonly used as variable name (e.g., fail=0 for counting)
    empty) continue ;;  # Too common as English word in error messages (e.g., "must not be empty")
  esac
  
  # Skip interactive spells - they must remain external for test stubbing
  # These contain terminal I/O code that can't be stubbed when inlined
  # Also skip test stubs themselves - they're test infrastructure, not dependencies
  case "$dep" in
    ask-number|ask-yn|ask-text|await-keypress|choose-input|read-line|tty-*|stub-*) continue ;;
  esac
  
  # Skip if already inlined
  case " $inlined_names " in
    *" $dep "*) continue ;;
  esac
  
  # Find the imp/spell file
  dep_file=$(find "$imps_dir" -type f -name "$dep" 2>/dev/null | head -1)
  
  # If not found in imps, check spells
  if [ -z "$dep_file" ]; then
    dep_file=$(find "$repo_dir/spells" -type f -name "$dep" \
      ! -path "*/\.*" ! -path "$spell_path" 2>/dev/null | head -1)
  fi
  
  # Skip if not found
  [ -z "$dep_file" ] || [ ! -f "$dep_file" ] && continue
  
  # Read dependency content
  dep_content=$(cat "$dep_file")
  
  # Extract function definition (lines from _funcname() to closing })
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  func_def=$(printf '%s\n' "$dep_content" | awk -v fname="$func_name" '
    /^'$func_name'\(\)/ { in_func=1 }
    in_func { print }
    in_func && /^}$/ { exit }
  ')
  
  # If we got a function (it's an imp), inline it
  if [ -n "$func_def" ]; then
    inlined_deps="$inlined_deps
# Inlined imp: $dep
$func_def
"
    inlined_names="$inlined_names $dep"
  else
     # It's a spell without _funcname() pattern - inline entire spell as function
    # Remove shebang, *_usage, --help handler, set -eu, env_clear, and loading patterns  
    # BUT preserve bootstrap code (if command -v require_wizardry blocks)
    spell_body=$(printf '%s\n' "$dep_content" | awk '
      BEGIN { skip=0; in_usage=0; skip_loading=0; in_bootstrap=0 }
      /^#!/ { next }
      /^[a-zA-Z_][a-zA-Z0-9_]*_usage\(\)/ { in_usage=1; next }
      in_usage && /^}$/ { in_usage=0; next }
      in_usage { next }
      /^case.*--help.*--usage/ { skip=1; next }
      skip && /^esac/ { skip=0; next }
      skip { next }
      /^set -eu$/ { next }
      /^set -u$/ { next }
      /^if command -v require_wizardry/ { in_bootstrap=1; print; next }
      /^elif command -v require_wizardry/ { in_bootstrap=1; print; next }
      in_bootstrap && /^fi$/ { in_bootstrap=0; print; next }
      in_bootstrap && /^else/ { print; next }
      in_bootstrap { print; next }
      /^require-wizardry/ { next }
      /^[[:space:]]*require_wizardry([[:space:]]|\|\||$)/ { next }
      /^[[:space:]]*\. env_clear([[:space:]]|$)/ { next }
      /^[[:space:]]*source env_clear([[:space:]]|$)/ { next }
      /^[[:space:]]*env_clear([[:space:]]|$)/ { next }
      /^# Load (castable|autocast|uncastable) imp/ { skip_loading=1; next }
      skip_loading && /^(castable|autocast|uncastable) / { skip_loading=0; next }
      skip_loading { next }
      { print }
    ')
    
    # Transform the spell body to replace calls to already-inlined deps
    # This ensures nested dependencies work correctly
    for already_inlined in $inlined_names; do
      already_func_name="_$(printf '%s' "$already_inlined" | tr '-' '_')"
      spell_body=$(printf '%s\n' "$spell_body" | \
        awk -v old="$already_inlined" -v new="$already_func_name" '
        /^[[:space:]]*cat <<.*USAGE/ { usage_start=1; print; next }
        usage_start && /^USAGE$/ { print; usage_start=0; next }
        usage_start { print; next }
        /^[[:space:]]*\. / { print; next }
        /^[[:space:]]*\. "/ { print; next }
        /\).*;;/ { print; next }
        /\$\(\(.*\<'"$already_inlined"'\>.*\)\)/ { print; next }
        /"[^"$]*\<'"$already_inlined"'\>[^"$]*"/ { print; next }
        /'\''[^'\''$]*\<'"$already_inlined"'\>[^'\''$]*'\''/ { print; next }
        { gsub("\\<" old "\\>", new); print }
      ')
    done
    
    # Wrap as function
    inlined_deps="$inlined_deps
# Inlined spell: $dep
$func_name() {
$spell_body
}
"
    inlined_names="$inlined_names $dep"
  fi
done

# Transform spell content:
# 1. Remove shebang, require_wizardry, and wizardry infrastructure sourcing
# 2. Replace imp calls with underscore versions (e.g., say -> say, clip-copy -> clip_copy)
# 3. Replace castable/autocast/uncastable loading patterns with direct function calls
# Remove lines that source wizardry infrastructure (env-clear, invoke-wizardry)
# These don't make sense in standalone compiled spells
# BUT preserve bootstrap blocks (if command -v require_wizardry)
transformed=$(printf '%s\n' "$spell_content" | \
  tail -n +2 | \
  awk -v spell="$spell_basename" '
    BEGIN { skip=0; in_bootstrap=0 }
    # Preserve bootstrap blocks
    /^if command -v require_wizardry/ { in_bootstrap=1; print; next }
    /^elif command -v require_wizardry/ { in_bootstrap=1; print; next }
    in_bootstrap && /^fi$/ { in_bootstrap=0; print; next }
    in_bootstrap && /^else/ { print; next }
    in_bootstrap { print; next }
    # Remove infrastructure calls (but not if in bootstrap)
    /^require-wizardry/ { next }
    /^[[:space:]]*require_wizardry([[:space:]]|\|\||$)/ { next }
    /^[[:space:]]*\. env_clear([[:space:]]|$)/ { next }
    /^[[:space:]]*source env_clear([[:space:]]|$)/ { next }
    /^[[:space:]]*env_clear([[:space:]]|$)/ { next }
    /^[[:space:]]*\. .*invoke-wizardry/ { next }
    /^[[:space:]]*source .*invoke-wizardry/ { next }
    # Skip loading pattern sections but remember what to call
    /^# Load (castable|autocast|uncastable) imp/ { 
      skip=1
      # Extract which type (castable/autocast/uncastable)
      if (/castable/) { pattern_type="castable" }
      else if (/autocast/) { pattern_type="autocast" }
      else if (/uncastable/) { pattern_type="uncastable" }
      next
    }
    skip && /^(castable|autocast|uncastable) / {
      skip=0
      # For castable/uncastable: replace with direct function call
      # For autocast: replace with direct function call (spell name with underscores)
      if (pattern_type == "autocast") {
        # autocast spells call the spell_name function directly
        func_name = spell
        gsub(/-/, "_", func_name)
        print "# Compiled spell - autocast declaration (inlined)"
        print "autocast() { :; }  # Stub - spell already executed via function call below"
        print func_name
      } else {
        # castable/uncastable spells call spell_name "$@"
        func_name = spell
        gsub(/-/, "_", func_name)
        print "# Compiled spell - " pattern_type " declaration (inlined)"
        print pattern_type "() { :; }  # Stub - spell executed via direct function call below"
        print func_name " \"$@\""
      }
      next
    }
    skip { next }
    { print }
  ')

# For each inlined imp, replace calls in the spell
# Note: func_name comes from sanitized internal processing (tr '-' '_')
# so special regex characters are not a concern here
for dep in $inlined_names; do
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  
  # Use awk for more controlled replacement - skip USAGE blocks, sourcing, case labels, string literals, and arithmetic
  # Note: This handles common USAGE heredoc patterns including quoted delimiters
  transformed=$(printf '%s\n' "$transformed" | awk -v old="$dep" -v new="$func_name" '
    /^[[:space:]]*cat <<.*USAGE/ { usage_start=1; print; next }
    usage_start && /^USAGE$/ { print; usage_start=0; next }
    usage_start { print; next }
    /^[[:space:]]*\. / { print; next }
    /^[[:space:]]*\. "/ { print; next }
    /\).*;;/ { print; next }
    # Skip arithmetic expansion where variables can be used without $
    /\$\(\(.*\<'"$dep"'\>.*\)\)/ { print; next }
    # Only skip lines where the dependency appears in string literals (between quotes, not in command substitution)
    # Pattern: "...dep..." but NOT "$(dep...)" or "...$(dep...)..."
    /"[^"$]*\<'"$dep"'\>[^"$]*"/ { print; next }
    /'\''[^'\''$]*\<'"$dep"'\>[^'\''$]*'\''/ { print; next }
    { gsub("\\<" old "\\>", new); print }
  ')
done

# For standalone imp compilation, fix the self-execute case statement
# Replace pattern like '*/imp-name)' with '*)' so it always executes
if [ -z "$inlined_names" ]; then
  # No dependencies inlined, likely compiling an imp directly
  # Escape special regex characters in spell_basename for safe sed usage
  escaped_basename=$(printf '%s\n' "$spell_basename" | sed 's/[.[\*^$]/\\&/g')
  transformed=$(printf '%s\n' "$transformed" | sed "s|\*/$escaped_basename)|*)|g")
fi

# Output compiled spell
printf '#!/bin/sh\n'
printf '#\n'


# Create centered separator with spell name (76 chars total width)
name_len=${#spell_name}
dash_space=$((76 - 2 - name_len - 2))  # 76 - "# " - name - spaces around
# Minimum dash space of 8 ensures readable formatting even with long names
if [ "$dash_space" -lt 8 ]; then
  # Name too long, truncate
  max_name_len=$((76 - 2 - 8 - 2))
  display_name=$(printf '%s' "$spell_name" | cut -c1-"$max_name_len")
  name_len=${#display_name}
  dash_space=$((76 - 2 - name_len - 2))
else
  display_name=$spell_name
fi
left_dashes=$((dash_space / 2))
right_dashes=$((dash_space - left_dashes))

# Build centered separator
separator="# "
i=0
while [ "$i" -lt "$left_dashes" ]; do
  separator="${separator}-"
  i=$((i + 1))
done
separator="${separator} ${display_name} "
i=0
while [ "$i" -lt "$right_dashes" ]; do
  separator="${separator}-"
  i=$((i + 1))
done

printf '%s\n' "$separator"
printf '#\n'
printf '# COMPILED WIZARDRY SPELL\n'
printf '#\n'
printf '# This is a compiled version of a wizardry spell.\n'
printf '# Wizardry is a collection of POSIX shell scripts themed as magical spells,\n'
printf '# turning folders into rooms and files into items, like a fantasy MUD.\n'
printf '#\n'
printf '# For the full clean version of this script and much more, please visit:\n'
printf '# https://github.com/andersaamodt/wizardry\n'
printf '#\n'
printf '# Original spell: %s\n' "$spell_name"
printf '# Generated by: compile-spell\n'
printf '#\n'
printf '# ----------------------------------------------------------------------------\n'
printf '#\n'
printf '#  ,___,   OPEN WIZARDRY LICENSE 1.1\n'
printf '#  (O,O)\n'
printf '#  /)  )   Permission: You may use, copy, modify, and share this project\n'
printf '# ="=="=   for non-commercial purposes, including private, educational,\n'
printf '#          research, and internal organizational use.\n'
printf '#\n'
printf '# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"\n'
printf '# means sale, subscription, paid access, monetized hosting, inclusion in any paid\n'
printf '# product or service, or use as part of any monetized system, even if not the\n'
printf '# primary component. Internal use by commercial entities is allowed.\n'
printf '#\n'
printf '# Reciprocity: If you make modified versions publicly available—either by\n'
printf '# distributing copies or by operating a public-facing service that meaningfully\n'
printf '# depends on those modified files—you must publish those modified files under\n'
printf '# this license. No other files must be published.\n'
printf '#\n'
printf '# No Enclosure: Modified files you share must remain exclusively under this\n'
printf '# license, without additional restrictions. This license must accompany any public\n'
printf '# distribution of modified files.\n'
printf '#\n'
printf '# Warranty: Provided without warranty or guarantee of any kind.\n'
printf '#\n'
printf '# ----------------------------------------------------------------------------\n'
printf '\n'

# Output inlined dependencies
if [ -n "$inlined_deps" ]; then
  printf '%s\n' "$inlined_deps"
fi

# Output transformed spell content
printf '%s\n' "$transformed"
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
