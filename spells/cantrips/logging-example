#!/bin/sh




# Example spell demonstrating the standardized logging framework.
# Shows usage of info, step, debug, success, and error handling.

logging_example_usage() {
  cat <<'USAGE'
Usage: logging-example [options]

Demonstrates the wizardry logging framework with different verbosity levels.

Options:
  --help, -h     Show this help message
  --simulate     Simulate a multi-step process

Environment:
  WIZARDRY_LOG_LEVEL
    0 (default)  Show only critical messages
    1            Show info and step messages
    2+           Show debug messages

Examples:
  logging-example --simulate
  WIZARDRY_LOG_LEVEL=1 logging-example --simulate
  WIZARDRY_LOG_LEVEL=2 logging-example --simulate
USAGE
}



logging_example() {
case "${1-}" in
--help|--usage|-h)
  logging_example_usage
  return 0
  ;;
esac

require_wizardry || return 1

set -eu
env_clear

# Source the logging imps (in real usage, these would be bound at startup)
# For this example, we'll source them directly
# These imps are used: say, info, step, debug, success, warn, die, on-exit, temp-file, cleanup-file
. spells/.imps/out/say
. spells/.imps/out/info
. spells/.imps/out/step
. spells/.imps/out/debug
. spells/.imps/out/success
. spells/.imps/out/warn
. spells/.imps/out/die
. spells/.imps/sys/on-exit
. spells/.imps/fs/temp-file
. spells/.imps/fs/cleanup-file

case "${1-}" in
--simulate)
  info "Starting multi-step process"
  debug "Current working directory: $(pwd)"
  
  step "Step 1: Creating temporary file"
  tmpfile=$(temp_file)
  on_exit cleanup_file "$tmpfile"
  debug "Created temp file: $tmpfile"
  
  step "Step 2: Writing data"
  printf '%s\n' "test data" > "$tmpfile"
  debug "Wrote test data to temp file"
  
  step "Step 3: Processing data"
  # Simulate some processing
  sleep 1
  debug "Processing complete"
  
  success "Multi-step process completed successfully"
  ;;
*)
  say "Welcome to the logging example!"
  say ""
  say "Set WIZARDRY_LOG_LEVEL to control verbosity:"
  say "  0 (default) - Critical messages only"
  say "  1           - Include info and step messages"
  say "  2+          - Include debug messages"
  say ""
  say "Try: WIZARDRY_LOG_LEVEL=1 logging-example --simulate"
  ;;
esac
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
