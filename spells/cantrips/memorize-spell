#!/bin/sh

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.

set -eu

spell_name="memorize-spell"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}

expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac
        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        resolve_spell_home
}

usage() {
        cat <<USAGE >&2
Usage: $spell_name {add NAME|remove NAME|list|path|dir}

add NAME          Add spell NAME to the Cast menu (spell must exist in PATH or ~/.spellbook).
remove NAME       Remove the named entry.
list              Print every stored spell name.
path              Print the command list file path.
dir               Print the directory holding generated cast spells.

The cast directory (dir) is safe for PATH addition (default: ~/.spellbook
or $XDG_DATA_HOME/wizardry/spellbook). Use it to run memorized spells by
name outside the Cast menu.
USAGE
}

resolve_command_file() {
        cast_dir=$1
        if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
                file=$(expand_tilde "$WIZARDRY_CAST_FILE")
        elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
                file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
        else
                file=$cast_dir/.memorized
        fi
        printf '%s' "$file"
}

resolve_spell_home() {
        if [ -n "${WIZARDRY_SPELL_HOME-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_SPELL_HOME")
        elif [ -n "${SPELLBOOK_HOME-}" ]; then
                dir=$(expand_tilde "$SPELLBOOK_HOME")
        elif [ -n "${SPELL_HOME-}" ]; then
                dir=$(expand_tilde "$SPELL_HOME")
        elif [ -n "${XDG_DATA_HOME-}" ] && [ -n "$XDG_DATA_HOME" ]; then
                dir=$XDG_DATA_HOME/wizardry/spellbook
        elif [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                dir=$HOME/.spellbook
        else
                dir=.spellbook
        fi
        printf '%s' "$dir"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
        if [ ! -d "$cast_dir" ]; then
                mkdir -p "$cast_dir"
        fi
        dir=${command_file%/*}
        if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

write_spell_script() {
        name=$1
        cmd=$2
        spell_path=$cast_dir/$name
        escaped_cmd=$(printf '%s' "$cmd" | sed "s/'/'\\''/g")
        cat >"$spell_path" <<EOF
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF
        chmod +x "$spell_path"
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
                exit 1
                ;;
        -*)
                printf '%s\n' "$spell_name: names may not begin with a dash." >&2
                exit 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "$spell_name: command must not be empty." >&2
                exit 1
        fi
        case $cmd in
        *"$tab_char"*)
                printf '%s\n' "$spell_name: command may not contain tabs." >&2
                exit 1
                ;;
        *"$newline_char"*)
                printf '%s\n' "$spell_name: command must be a single line." >&2
                exit 1
                ;;
        esac
}

add_entry() {
        name=$1
        validate_name "$name"
        ensure_parent_directory
        # Use the spell name as both the name and command (spell runs itself)
        cmd=$name
        tmp=$(mktemp "${TMPDIR:-/tmp}/memorize-spell.XXXXXX") || exit 1
        if [ -f "$command_file" ]; then
                while IFS= read -r line || nonempty "$line"; do
                        entry_name=$line
                        case $line in
                        *"$tab_char"*)
                                entry_name=${line%%"$tab_char"*}
                                ;;
                        esac
                        if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                                continue
                        fi
                        printf '%s\n' "$line" >>"$tmp"
                done <"$command_file"
        fi
        printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
        if [ -f "$tmp" ]; then
                cat "$tmp" >>"$command_file"
                rm -f "$tmp"
        fi
        write_spell_script "$name" "$cmd"
}

remove_entry() {
        name=$1
        validate_name "$name"
        if [ ! -f "$command_file" ]; then
                printf '%s\n' "$spell_name: spell '$name' is not memorized." >&2
                exit 1
        fi
        tmp=$(mktemp "${TMPDIR:-/tmp}/memorize-spell.XXXXXX") || exit 1
        removed=0
        while IFS= read -r line || nonempty "$line"; do
            entry_name=$line
            case $line in
            *"$tab_char"*)
                    entry_name=${line%%"$tab_char"*}
                    ;;
            esac
            if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                    if [ "$entry_name" = "$name" ]; then
                            removed=1
                            continue
                    fi
                    continue
            fi
            printf '%s\n' "$line" >>"$tmp"
        done <"$command_file"
        if [ "$removed" -eq 0 ]; then
                rm -f "$tmp"
                printf '%s\n' "$spell_name: spell '$name' is not memorized." >&2
                exit 1
        fi
        mv "$tmp" "$command_file"
        rm -f "$cast_dir/$name"
}

list_entries() {
        if [ -f "$command_file" ]; then
                cat "$command_file"
        fi
}

if [ "$#" -eq 0 ]; then
        usage
        exit 1
fi

action=$1
shift

case $action in
add)
        if [ "$#" -ne 1 ]; then
                printf '%s\n' "$spell_name: add expects a spell NAME." >&2
                usage
                exit 1
        fi
        add_entry "$1"
        ;;
remove)
        if [ "$#" -ne 1 ]; then
                printf '%s\n' "$spell_name: remove expects a NAME." >&2
                usage
                exit 1
        fi
        remove_entry "$1"
        ;;
list)
        if [ "$#" -ne 0 ]; then
                usage
                exit 1
        fi
        list_entries
        ;;
        path)
                if [ "$#" -ne 0 ]; then
                        usage
                        exit 1
                fi
                printf '%s\n' "$command_file"
                ;;
        dir)
                if [ "$#" -ne 0 ]; then
                        usage
                        exit 1
                fi
                printf '%s\n' "$cast_dir"
                ;;
        --help|-h)
                usage
                ;;
*)
        usage
        exit 1
        ;;
esac
