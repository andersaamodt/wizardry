#!/bin/sh

# Read a single key press from the controlling terminal and report it in a
# descriptive form ("enter", "up", literal text, etc.).

await_keypress_usage() {
        cat <<'USAGE' >&2
Usage: await-keypress

Listens for one key press on the controlling terminal, translating escape sequences into readable names and restoring the terminal to its prior state afterward.
USAGE
}




await_keypress() {
case "${1-}" in
--help|--usage|-h)
  await_keypress_usage
  return 0
  ;;
esac

require-wizardry || return 1

# Use conditional strictness based on execution context
# See .github/CODE_POLICY_SET_EU.md for details
case "$0" in
  */await-keypress)
    # Executed as script - use full strict mode
    set -eu
    ;;
  *)
    # Called as function (sourced) - only undefined variable protection
    # This prevents interactive shell exit while maintaining safety
    set -u
    ;;
esac
env-clear

# Prefer preloaded imp functions (underscore form) when available.
await_keypress_temp_file() {
    if command -v temp_file >/dev/null 2>&1; then
        temp_file "$@"
    else
        temp-file "$@"
    fi
}

# Resolve require-command location
# Use command -v to find require-command when preloaded as a function
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Using REQUIRE_COMMAND=%s\n' "$require_cmd" >&2
elif command -v require-command >/dev/null 2>&1; then
    require_cmd=require-command
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Found require-command via command -v\n' >&2
elif command -v require_command >/dev/null 2>&1; then
    require_cmd=require_command
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Found require_command via command -v\n' >&2
else
    # Fallback to path-based resolution for direct execution
    spell_dir_val=""
    case $0 in
        */*) spell_dir_val=$(CDPATH= cd -- "${0%/*}" && pwd -P) ;;
        *) spell_dir_val=$(CDPATH= cd -- . && pwd -P) ;;
    esac
    if [ -x "$spell_dir_val/require-command" ]; then
        require_cmd=$spell_dir_val/require-command
    else
        require_cmd=require-command
    fi
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Fallback require_cmd=%s\n' "$require_cmd" >&2
fi

# Capture raw bytes with dd; bail out immediately when it is missing.
if ! "$require_cmd" dd "The await-keypress spell needs 'dd' to capture raw key presses."; then
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] require-command dd check failed\n' >&2
    return 1
fi
[ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] dd check passed\n' >&2

tty_device=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
skip_stty=${AWAIT_KEYPRESS_SKIP_STTY:-0}
keep_raw=${AWAIT_KEYPRESS_KEEP_RAW:-0}

if [ "${AWAIT_KEYPRESS_BUFFER_FILE+set}" = "set" ]; then
    buffer_file=$AWAIT_KEYPRESS_BUFFER_FILE
else
    buffer_key=$(printf '%s' "$tty_device" | tr -c '[:alnum:]' '_')
    buffer_file=$(await_keypress_temp_file await-keypress-buffer-"$buffer_key") || return 1
fi

# Helper to restore terminal and close file descriptor
restore_terminal() {
    if [ "$skip_stty" -eq 0 ] && [ -n "${saved_state-}" ]; then
        stty "$saved_state" <&3 >/dev/null 2>&1 || :
    fi
    exec 3>&- 2>/dev/null || :
}

if [ "$skip_stty" -eq 1 ]; then
    # Allow tests to provide a preconfigured file descriptor instead of
    # toggling terminal attributes.
    if [ ! -r "$tty_device" ]; then
        warn "await-keypress: unable to read from '$tty_device'"
        return 1
    fi

    exec 3<"$tty_device" || return 1
else
    # When interacting with the real terminal, require stty for raw-mode
    # management and open the device read/write.
    if ! "$require_cmd" stty "The await-keypress spell needs 'stty' to manage terminal modes."; then
        return 1
    fi

    if [ ! -r "$tty_device" ] || [ ! -w "$tty_device" ]; then
        warn "await-keypress: unable to open controlling terminal '$tty_device'"
        return 1
    fi

    exec 3<>"$tty_device" || return 1

    # Persist the existing terminal configuration so we can restore it later.
    saved_state=$(stty -g <&3 2>/dev/null)
    if [ -z "$saved_state" ]; then
        warn 'await-keypress: unable to read terminal settings'
        return 1
    fi

    trap 'restore_terminal; exit 130' INT HUP TERM
    trap 'restore_terminal' EXIT
fi

# Configure canonical mode to wait for exactly one byte of input.
# CRITICAL: Always set terminal mode, even when KEEP_RAW=1, because previous
# calls may have changed min/time settings for escape sequence handling
if [ "$skip_stty" -eq 0 ]; then
    if ! stty -icanon -echo min 1 time 0 <&3 2>/dev/null; then
        warn 'await-keypress: unable to configure terminal'
        return 1
    fi
fi

# Read buffer if exists
buffer_codes=''
if [ -n "$buffer_file" ] && [ -f "$buffer_file" ] && [ -s "$buffer_file" ]; then
    buffer_codes=$(cat "$buffer_file")
    rm -f "$buffer_file"
fi

codes=''
had_buffer=0
read_extra=0
if [ -n "$buffer_codes" ]; then
    had_buffer=1
    codes=$buffer_codes
else
    # Read first byte
    first_codes=$(dd bs=1 count=1 2>/dev/null <&3 | od -An -t u1 -v | tr -s '[:space:]' ' ')
    first_codes=${first_codes# }
    first_codes=${first_codes% }
    if [ -z "$first_codes" ]; then
        return 1
    fi
    codes=$first_codes
fi

# Determine if we should read extra bytes for escape sequences
# When had_buffer=1, we only read extra if the buffer contains a partial escape
# When had_buffer=0, we always read extra in case of escape sequences
if [ "$had_buffer" -eq 0 ]; then
    # Freshly read from terminal - always read extra bytes
    read_extra=1
else
    # From buffer - only read extra if it's a partial escape sequence
    set -- $codes
    if [ "$#" -gt 0 ] && [ "$1" -eq 27 ]; then
        if [ "$#" -eq 1 ]; then
            # Just ESC - might be more coming
            read_extra=1
        elif [ "$2" -eq 91 ] || [ "$2" -eq 79 ]; then
            if [ "$#" -eq 2 ]; then
                # ESC[ or ESC O - incomplete
                read_extra=1
            elif [ "$2" -eq 91 ] && [ "$3" -eq 51 ] && [ "$#" -eq 3 ]; then
                # ESC[3 - incomplete (delete key is ESC[3~)
                read_extra=1
            fi
        fi
    fi
fi

# Allow escape sequences to provide additional bytes.
# Only adjust terminal timing if stty is available (skip_stty=0)
if [ "$read_extra" -eq 1 ] && [ "$skip_stty" -eq 0 ]; then
    if ! stty -icanon -echo min 0 time 1 <&3 2>/dev/null; then
        warn 'await-keypress: unable to update terminal timing'
        return 1
    fi
fi

# Read any additional bytes from escape sequences
# This works in both real terminal (with timing) and test mode (without timing)
if [ "$read_extra" -eq 1 ]; then
    while :; do
        extra=$(dd bs=1 count=1 2>/dev/null <&3 | od -An -t u1 -v | tr -s '[:space:]' ' ')
        extra=${extra# }
        extra=${extra% }
        [ -z "$extra" ] && break
        if [ -n "$codes" ]; then
            codes="$codes $extra"
        else
            codes=$extra
        fi
    done
fi

trap - EXIT
if [ "$skip_stty" -eq 0 ] && [ "$keep_raw" -eq 1 ]; then
    exec 3>&- 2>/dev/null || :
else
    restore_terminal
fi

codes=${codes# }
codes=${codes% }
if [ -z "$codes" ]; then
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] No codes read, returning empty\n' >&2
    printf '\n'
    return 0
fi

set -- $codes
if [ "$#" -eq 0 ]; then
    [ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Empty codes list, returning empty\n' >&2
    printf '\n'
    return 0
fi

[ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Read codes: %s\n' "$codes" >&2

first=$1
shift
leftover="$*"
output=''
buffer_leftover_codes=''

# Convert numeric byte values back to characters.
codes_to_string() {
    result=''
    for code in $1; do
        result=${result}$(printf '\\%03o' "$code")
    done
    printf '%b' "$result"
}

case "$first" in
    3)
        output='ctrl-c'
        ;;
    9)
        output='tab'
        ;;
    10|13)
        output='enter'
        ;;
    8|127)
        output='backspace'
        ;;
    27)
        escape_rest_codes="$leftover"
        consumed="$first"
        partial=0
        if [ "$#" -eq 0 ]; then
            output='escape'
            buffer_leftover_codes=''
        else
            second=$1
            shift
            consumed="$consumed $second"
            case "$second" in
                79)
                    if [ "$#" -eq 0 ]; then
                        partial=1
                    else
                        third=$1
                        shift
                        consumed="$consumed $third"
                        case "$third" in
                            65)
                                output='up'
                                buffer_leftover_codes="$*"
                                ;;
                            66)
                                output='down'
                                buffer_leftover_codes="$*"
                                ;;
                            67)
                                output='right'
                                buffer_leftover_codes="$*"
                                ;;
                            68)
                                output='left'
                                buffer_leftover_codes="$*"
                                ;;
                            *)
                                output="escaped key: $(codes_to_string "$escape_rest_codes")"
                                buffer_leftover_codes=''
                                ;;
                        esac
                    fi
                    ;;
                91)
                    if [ "$#" -eq 0 ]; then
                        partial=1
                    else
                        third=$1
                        shift
                        consumed="$consumed $third"
                        case "$third" in
                            65)
                                output='up'
                                buffer_leftover_codes="$*"
                                ;;
                            66)
                                output='down'
                                buffer_leftover_codes="$*"
                                ;;
                            67)
                                output='right'
                                buffer_leftover_codes="$*"
                                ;;
                            68)
                                output='left'
                                buffer_leftover_codes="$*"
                                ;;
                            51)
                                if [ "$#" -eq 0 ]; then
                                    partial=1
                                else
                                    fourth=$1
                                    shift
                                    consumed="$consumed $fourth"
                                    if [ "$fourth" -eq 126 ]; then
                                        output='delete'
                                        buffer_leftover_codes="$*"
                                    else
                                        key_str=$(codes_to_string "$escape_rest_codes")
                                        output="escaped key: $key_str"
                                        buffer_leftover_codes=''
                                    fi
                                fi
                                ;;
                            *)
                                output="escaped key: $(codes_to_string "$escape_rest_codes")"
                                buffer_leftover_codes=''
                                ;;
                        esac
                    fi
                    ;;
                *)
                    output="escaped key: $(codes_to_string "$escape_rest_codes")"
                    buffer_leftover_codes=''
                    ;;
            esac
        fi

        if [ "$partial" -eq 1 ]; then
            output=''
            buffer_leftover_codes="$consumed"
        fi
        ;;
    *)
        remainder=$first
        if [ -n "$leftover" ]; then
            remainder="$remainder $leftover"
        fi
        output=$(codes_to_string "$remainder")
        buffer_leftover_codes=''
        ;;
esac

buffer_leftover_codes=${buffer_leftover_codes# }
buffer_leftover_codes=${buffer_leftover_codes% }

if [ -n "$buffer_file" ]; then
    if [ -n "$buffer_leftover_codes" ]; then
        printf '%s\n' "$buffer_leftover_codes" >"$buffer_file"
    else
        rm -f "$buffer_file"
    fi
fi

printf '%s\n' "$output"
[ "${WIZARDRY_DEBUG_AWAIT:-0}" = "1" ] && printf '[await-keypress] Returning: %s\n' "$output" >&2
return 0
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
