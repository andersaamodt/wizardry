#!/bin/sh

# Guard a script against missing external commands by exiting with a
# descriptive error if the binary is absent.


show_usage() {
        cat <<'USAGE' >&2
Usage: require-command <command> [message...]

Checks for a required binary, optionally offers to install it through wizardry installers, and exits non-zero with a helpful message when the dependency is missing.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
    show_usage
fi

command_name=$1
shift

auto_install=${REQUIRE_COMMAND_ASSUME_YES:-0}

# Succeed immediately when the command is already available on PATH.
has "$command_name" && exit 0

# Try to find and run installer (inlined from find_install_spell and attempt_install)
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
install_spell=""

if has "install-$command_name"; then
    install_spell=$(where "install-$command_name")
elif [ -x "$script_dir/../install/core/install-$command_name" ]; then
    install_spell="$script_dir/../install/core/install-$command_name"
fi

if [ -n "$install_spell" ]; then
    if [ "$auto_install" = "1" ] || ! [ -t 0 ]; then
        if ASSUME_YES=1 "$install_spell" && has "$command_name"; then
            exit 0
        fi
    else
        printf "%s" "Install '$command_name'? [y/N] " >&2
        IFS= read -r reply || reply=""
        case $reply in
            y|Y|yes|YES)
                if ASSUME_YES=1 "$install_spell" && has "$command_name"; then
                    exit 0
                fi
                ;;
        esac
    fi
fi

if [ "$#" -gt 0 ]; then
    message=$*
else
    # Point users toward the core prerequisite menu so they can resolve the
    # missing dependency the Wizardry way instead of reaching for system
    # package managers.
    message="The '${command_name}' command is required. See 'core-menu' for installation options."
fi

warn "require-command: $message"
exit 1
