#!/usr/bin/env sh

# Guard a script against missing external commands by exiting with a
# descriptive error if the binary is absent.

usage() {
    # Avoid silent failures when the helper is invoked incorrectly.
    printf '%s\n' 'Usage: require-command <command> [message...]' >&2
    exit 1
}

if [ "$#" -lt 1 ]; then
    usage
fi

command_name=$1
shift

auto_install=${REQUIRE_COMMAND_ASSUME_YES:-0}

find_install_spell() {
    name=$1
    script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)

    if command -v "install-$name" >/dev/null 2>&1; then
        command -v "install-$name"
        return 0
    fi

    if [ -x "$script_dir/../install/core/install-$name" ]; then
        printf '%s\n' "$script_dir/../install/core/install-$name"
        return 0
    fi

    return 1
}

attempt_install() {
    install_spell=$(find_install_spell "$command_name") || return 1

    if [ "$auto_install" = "1" ] || ! [ -t 0 ]; then
        ASSUME_YES=1 "$install_spell" && command -v "$command_name" >/dev/null 2>&1
        return $?
    fi

    printf "%s" "Install '$command_name'? [y/N] " >&2
    IFS= read -r reply || reply=""
    case $reply in
        y|Y|yes|YES)
            ASSUME_YES=1 "$install_spell" && command -v "$command_name" >/dev/null 2>&1
            return $?
            ;;
        *)
            return 1
            ;;
    esac
}

# Succeed immediately when the command is already available on PATH.
if command -v "$command_name" >/dev/null 2>&1; then
    exit 0
fi

if attempt_install; then
    exit 0
fi

if [ "$#" -gt 0 ]; then
    message=$*
else
    # Point users toward the install menu so they can resolve the missing
    # dependency the “Wizardry” way instead of reaching for system package
    # managers manually.
    message="The '${command_name}' command is required. Run 'install-menu' to review installation options."
fi

printf '%s\n' "require-command: $message" >&2
exit 1
