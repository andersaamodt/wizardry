#!/bin/sh

# Guard against missing commands, offering to install them.


require_command_usage() {
  cat <<'USAGE' >&2
Usage: require-command <command> [message...]

Checks for a required binary, optionally offers to install it through wizardry installers, and exits non-zero with a helpful message when the dependency is missing.
USAGE
}


require_command() {
case "${1-}" in
--help|--usage|-h)
  require_command_usage
  return 0
  ;;
esac

require-wizardry || return 1

set -eu
env-clear

if [ "$#" -lt 1 ]; then
    require_command_usage
fi

command_name=$1
shift

auto_install=${REQUIRE_COMMAND_ASSUME_YES:-0}

# Use POSIX command -v instead of has imp (may not be loaded yet)
if command -v "$command_name" >/dev/null 2>&1; then
    return 0
fi
case "$command_name" in
    *-*)
        command_alt=$(printf '%s' "$command_name" | tr '-' '_')
        if command -v "$command_alt" >/dev/null 2>&1; then
            return 0
        fi
        ;;
esac

install_spell=""
# Use POSIX command -v instead of has imp (may not be loaded yet)
if command -v "install-$command_name" >/dev/null 2>&1; then
    # where might not be available, use command -v with which fallback
    install_spell=$(command -v "install-$command_name")
else
    # Only compute script_dir if needed for install spell lookup
    script_dir=""
    if [ "${_WIZARDRY_LOADING_SPELLS-}" != "1" ]; then
        script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    elif [ -n "${WIZARDRY_DIR-}" ]; then
        script_dir="$WIZARDRY_DIR/spells/cantrips"
    fi
    if [ -n "$script_dir" ] && [ -x "$script_dir/../install/core/install-$command_name" ]; then
        install_spell="$script_dir/../install/core/install-$command_name"
    fi
fi

if [ -n "$install_spell" ]; then
    if [ "$auto_install" = "1" ] || ! [ -t 0 ]; then
        # Use POSIX command -v instead of has imp (may not be loaded yet)
        if ASSUME_YES=1 "$install_spell" && command -v "$command_name" >/dev/null 2>&1; then
            return 0
        fi
    else
        printf "%s" "Install '$command_name'? [y/N] " >&2
        IFS= read -r reply || reply=""
        case $reply in
            y|Y|yes|YES)
                # Use POSIX command -v instead of has imp (may not be loaded yet)
                if ASSUME_YES=1 "$install_spell" && command -v "$command_name" >/dev/null 2>&1; then
                    return 0
                fi
                ;;
        esac
    fi
fi

if [ "$#" -gt 0 ]; then
    message=$*
else
    message="The '${command_name}' command is required. See 'core-menu' for installation options."
fi

# Use POSIX printf instead of warn imp (may not be loaded yet)
printf '%s\n' "require-command: $message" >&2
return 1
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
