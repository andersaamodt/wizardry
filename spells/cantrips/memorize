#!/bin/sh

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory

require-wizardry || exit 1

spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}

show_usage() {
        cat <<USAGE >&2
Usage: $spell_name <spell-name>
       $spell_name {list|path|dir}

Add a spell to the Cast menu, or use list/path/dir to inspect the spellbook.
Spells must exist in PATH or \$SPELLBOOK_DIR.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
  cast_dir=$1
  if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
    file=$(expand_tilde "$WIZARDRY_CAST_FILE")
  elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
    file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
  else
    file=$cast_dir/.memorized
  fi
  printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
  if [ ! -d "$cast_dir" ]; then
    mkdir -p "$cast_dir"
  fi
  dir=${command_file%/*}
  if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
    mkdir -p "$dir"
  fi
}

validate_name() {
  name=$1
  case $name in
  ''|*[!A-Za-z0-9._-]*)
    printf '%s\n' "$spell_name: names may contain only letters, digits, dots, " \
      "underscores, and dashes." >&2
    exit 1
    ;;
  -*)
    printf '%s\n' "$spell_name: names may not begin with a dash." >&2
    exit 1
    ;;
  esac
}

nonempty() {
  [ -n "$1" ]
}

add_spell() {
  name=$1
  validate_name "$name"
  ensure_parent_directory
  # Memorize just lists existing spells by name - no wrapper scripts needed
  # The spell must already exist in PATH or spellbook
  cmd=$name
  tmp=$(temp-file memorize) || exit 1
  trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
  if [ -f "$command_file" ]; then
    while IFS= read -r line || nonempty "$line"; do
      entry_name=$line
      case $line in
      *"$tab_char"*)
        entry_name=${line%%"$tab_char"*}
        ;;
      esac
      if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
        continue
      fi
      printf '%s\n' "$line" >>"$tmp"
    done <"$command_file"
  fi
  printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
  if [ -f "$tmp" ]; then
    cat "$tmp" >>"$command_file"
  fi
  trap - EXIT HUP INT TERM
  rm -f "$tmp"
}

list_entries() {
  if [ -f "$command_file" ]; then
    cat "$command_file"
  fi
}

if [ "$#" -eq 0 ]; then
  show_usage
  exit 1
fi

action=$1

case $action in
list)
  if [ "$#" -ne 1 ]; then
    show_usage
    exit 1
  fi
  list_entries
  ;;
path)
  if [ "$#" -ne 1 ]; then
    show_usage
    exit 1
  fi
  printf '%s\n' "$command_file"
  ;;
dir)
  if [ "$#" -ne 1 ]; then
    show_usage
    exit 1
  fi
  printf '%s\n' "$cast_dir"
  ;;
--help|--usage|-h)
  show_usage
  ;;
-*)
  printf '%s\n' "$spell_name: unknown option '$action'" >&2
  show_usage
  exit 1
  ;;
*)
  # Default action: memorize the spell
  if [ "$#" -ne 1 ]; then
    printf '%s\n' "$spell_name: expects exactly one spell name." >&2
    show_usage
    exit 1
  fi
  add_spell "$action"
  ;;
esac
