#!/bin/sh

# This spell manages the spellbook storage file for quick-access spell shortcuts.
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}
spellbook_store_usage() {
        cat <<'USAGE' >&2
Usage: spellbook-store {add NAME CMD|remove NAME|list|path}
Manage the spellbook storage file for quick-access spell shortcuts. Use add to
save a named command, remove to drop it, list to review entries, and path to
print the backing file location.
USAGE
}
spellbook_store() {
case "${1-}" in
--help|--usage|-h)
  spellbook_store_usage
  return 0
  ;;
esac
set -eu
# env-clear: compliant
# Helper for reading non-empty lines
# Resolve spellbook file with tilde expansion
if [ -n "${WIZARDRY_SPELLBOOK_FILE-}" ]; then
  spellbook_file=$WIZARDRY_SPELLBOOK_FILE
else
  if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
    spellbook_file=$HOME/.tower/spellbook
  else
    spellbook_file=.wizardry_spellbook
  fi
fi
case $spellbook_file in
\~)
    spellbook_file=$HOME
\~/*)
    spellbook_file=$HOME/${spellbook_file#\~/}
if [ "$#" -eq 0 ]; then
  return 1
action=$1
shift
case $action in
add)
  # Add entry to spellbook
  if [ "$#" -lt 2 ]; then
    printf '%s\n' "spellbook-store: add expects a NAME followed by COMMAND words." >&2
    spellbook_store_usage
    return 1
  name=$1
  shift
  cmd=$1
  shift || :
  while [ "$#" -gt 0 ]; do
    cmd="$cmd $1"
    shift
  done
  
  # Validate name
  case $name in
  ''|*[!A-Za-z0-9._-]*)
    printf '%s\n' "spellbook-store: alias names may contain only letters, digits, dots, underscores, and dashes." >&2
    ;;
  -*)
    printf '%s\n' "spellbook-store: alias names may not begin with a dash." >&2
  esac
  # Validate command
  if [ -z "$cmd" ]; then
    printf '%s\n' "spellbook-store: command must not be empty." >&2
  case $cmd in
  *"$tab_char"*)
    printf '%s\n' "spellbook-store: command may not contain tabs." >&2
  *"$newline_char"*)
    printf '%s\n' "spellbook-store: command must be a single line." >&2
  # Ensure parent directory exists
  dir=${spellbook_file%/*}
  if [ "$dir" != "$spellbook_file" ] && [ ! -d "$dir" ]; then
    mkdir -p "$dir"
  # Add entry (replacing if exists)
  tmp=$(temp-file spellbook-store) || return 1
  trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
  if [ -f "$spellbook_file" ]; then
    while IFS= read -r line || nonempty "$line"; do
      entry_name=$line
      entry_command=''
      case $line in
      *"$tab_char"*)
        entry_name=${line%%"$tab_char"*}
        entry_command=${line#*"$tab_char"}
        ;;
      esac
      if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
        continue
      fi
      printf '%s%s%s\n' "$entry_name" "$tab_char" "$entry_command" >>"$tmp"
    done <"$spellbook_file"
  printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >>"$tmp"
  trap - EXIT HUP INT TERM
  mv "$tmp" "$spellbook_file"
remove)
  # Remove entry from spellbook
  if [ "$#" -ne 1 ]; then
    printf '%s\n' "spellbook-store: remove expects a NAME." >&2
  if [ ! -f "$spellbook_file" ]; then
    printf '%s\n' "spellbook-store: spell '$name' is not recorded." >&2
  # Remove entry
  removed=0
  while IFS= read -r line || nonempty "$line"; do
    entry_name=$line
    case $line in
    *"$tab_char"*)
      entry_name=${line%%"$tab_char"*}
      ;;
    esac
    if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
      if [ "$entry_name" = "$name" ]; then
        removed=1
      continue
    fi
    printf '%s\n' "$line" >>"$tmp"
  done <"$spellbook_file"
  if [ "$removed" -eq 0 ]; then
    trap - EXIT HUP INT TERM
    rm -f "$tmp"
list)
  # List all entries
  if [ "$#" -ne 0 ]; then
    cat "$spellbook_file"
path)
  # Print spellbook path
  printf '%s\n' "$spellbook_file"
*)
# Self-execute when run directly (not sourced)
case "$0" in
  */spellbook-store) spellbook_store "$@" ;; esac
