#!/bin/sh

# This spell manages the spellbook storage file for quick-access spell shortcuts.


tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}

show_usage() {
        cat <<'USAGE' >&2
Usage: spellbook-store {add NAME CMD|remove NAME|list|path}

Manage the spellbook storage file for quick-access spell shortcuts. Use add to
save a named command, remove to drop it, list to review entries, and path to
print the backing file location.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

resolve_spellbook_file() {
	if [ -n "${WIZARDRY_SPELLBOOK_FILE-}" ]; then
		file=$WIZARDRY_SPELLBOOK_FILE
	else
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/.tower/spellbook
		else
			file=.wizardry_spellbook
		fi
	fi
	case $file in
	\~)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME
		fi
		;;
	\~/*)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/${file#\~/}
		fi
		;;
	esac
	printf '%s' "$file"
}

spellbook_file=$(resolve_spellbook_file)

ensure_parent_directory() {
	dir=${spellbook_file%/*}
	if [ "$dir" != "$spellbook_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_alias() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "spellbook-store: alias names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "spellbook-store: alias names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook-store: command must not be empty." >&2
                exit 1
        fi
        case $cmd in
        *"$tab_char"*)
                printf '%s\n' "spellbook-store: command may not contain tabs." >&2
                exit 1
                ;;
        *"$newline_char"*)
                printf '%s\n' "spellbook-store: command must be a single line." >&2
                exit 1
                ;;
        esac
}

nonempty() {
	[ -n "$1" ]
}

add_entry() {
        name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_alias "$name"
        validate_command "$cmd"
        ensure_parent_directory
        tmp=$(temp-file spellbook-store) || exit 1
        trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
        if [ -f "$spellbook_file" ]; then
                while IFS= read -r line || nonempty "$line"; do
                        entry_name=$line
                        entry_command=''
                        case $line in
                        *"$tab_char"*)
                                entry_name=${line%%"$tab_char"*}
                                entry_command=${line#*"$tab_char"}
                                ;;
                        esac
                        if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                                continue
                        fi
                        printf '%s%s%s\n' "$entry_name" "$tab_char" "$entry_command" >>"$tmp"
                done <"$spellbook_file"
        fi
        printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >>"$tmp"
        trap - EXIT HUP INT TERM
        mv "$tmp" "$spellbook_file"
}

remove_entry() {
	name=$1
	validate_alias "$name"
	if [ ! -f "$spellbook_file" ]; then
		printf '%s\n' "spellbook-store: spell '$name' is not recorded." >&2
		exit 1
	fi
	tmp=$(temp-file spellbook-store) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	removed=0
        while IFS= read -r line || nonempty "$line"; do
                entry_name=$line
                case $line in
                *"$tab_char"*)
                        entry_name=${line%%"$tab_char"*}
                        ;;
                esac
                if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                        if [ "$entry_name" = "$name" ]; then
                                removed=1
                                continue
                        fi
                        continue
                fi
                printf '%s\n' "$line" >>"$tmp"
        done <"$spellbook_file"
	if [ "$removed" -eq 0 ]; then
		trap - EXIT HUP INT TERM
		rm -f "$tmp"
		printf '%s\n' "spellbook-store: spell '$name' is not recorded." >&2
		exit 1
	fi
	trap - EXIT HUP INT TERM
	mv "$tmp" "$spellbook_file"
}

list_entries() {
	if [ -f "$spellbook_file" ]; then
		cat "$spellbook_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1
shift

case $action in
add)
	if [ "$#" -lt 2 ]; then
		printf '%s\n' "spellbook-store: add expects a NAME followed by COMMAND words." >&2
		show_usage
		exit 1
	fi
	add_entry "$@"
	;;
remove)
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "spellbook-store: remove expects a NAME." >&2
		show_usage
		exit 1
	fi
	remove_entry "$1"
	;;
list)
	if [ "$#" -ne 0 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 0 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$spellbook_file"
	;;
--help|--usage|-h)
	show_usage
	;;
*)
	show_usage
	exit 1
	;;
esac
