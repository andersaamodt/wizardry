#!/bin/sh

set -eu

tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}

usage() {
	cat <<'USAGE' >&2
Usage: spellbook-store {add NAME COMMAND...|remove NAME|list|path}

add NAME COMMAND  Add or update a spellbook entry. COMMAND must be a single line
                   without tabs.
remove NAME       Remove the named spellbook entry.
list              Print every stored entry as "NAME<TAB>COMMAND".
path              Print the spellbook file path.
USAGE
}

resolve_spellbook_file() {
	if [ -n "${WIZARDRY_SPELLBOOK_FILE-}" ]; then
		file=$WIZARDRY_SPELLBOOK_FILE
	else
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/.tower/spellbook
		else
			file=.wizardry_spellbook
		fi
	fi
	case $file in
	\~)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME
		fi
		;;
	\~/*)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/${file#\~/}
		fi
		;;
	esac
	printf '%s' "$file"
}

spellbook_file=$(resolve_spellbook_file)

ensure_parent_directory() {
	dir=${spellbook_file%/*}
	if [ "$dir" != "$spellbook_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_alias() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "spellbook-store: alias names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "spellbook-store: alias names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook-store: command must not be empty." >&2
                exit 1
        fi
        case $cmd in
        *"$tab_char"*)
                printf '%s\n' "spellbook-store: command may not contain tabs." >&2
                exit 1
                ;;
        *"$newline_char"*)
                printf '%s\n' "spellbook-store: command must be a single line." >&2
                exit 1
                ;;
        esac
}

add_entry() {
        name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_alias "$name"
        validate_command "$cmd"
        ensure_parent_directory
        tmp=$(mktemp "${TMPDIR:-/tmp}/spellbook-store.XXXXXX") || exit 1
        if [ -f "$spellbook_file" ]; then
                while IFS= read -r line || [ -n "$line" ]; do
                        entry_name=$line
                        entry_command=''
                        case $line in
                        *"$tab_char"*)
                                entry_name=${line%%"$tab_char"*}
                                entry_command=${line#*"$tab_char"}
                                ;;
                        esac
                        if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                                continue
                        fi
                        printf '%s%s%s\n' "$entry_name" "$tab_char" "$entry_command" >>"$tmp"
                done <"$spellbook_file"
        fi
        printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >>"$tmp"
        mv "$tmp" "$spellbook_file"
}

remove_entry() {
	name=$1
	validate_alias "$name"
	if [ ! -f "$spellbook_file" ]; then
		printf '%s\n' "spellbook-store: spell '$name' is not recorded." >&2
		exit 1
	fi
	tmp=$(mktemp "${TMPDIR:-/tmp}/spellbook-store.XXXXXX") || exit 1
	removed=0
        while IFS= read -r line || [ -n "$line" ]; do
                entry_name=$line
                case $line in
                *"$tab_char"*)
                        entry_name=${line%%"$tab_char"*}
                        ;;
                esac
                if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                        if [ "$entry_name" = "$name" ]; then
                                removed=1
                                continue
                        fi
                        continue
                fi
                printf '%s\n' "$line" >>"$tmp"
        done <"$spellbook_file"
	if [ "$removed" -eq 0 ]; then
		rm -f "$tmp"
		printf '%s\n' "spellbook-store: spell '$name' is not recorded." >&2
		exit 1
	fi
	mv "$tmp" "$spellbook_file"
}

list_entries() {
	if [ -f "$spellbook_file" ]; then
		cat "$spellbook_file"
	fi
}

if [ "$#" -eq 0 ]; then
	usage
	exit 1
fi

action=$1
shift

case $action in
add)
	if [ "$#" -lt 2 ]; then
		printf '%s\n' "spellbook-store: add expects a NAME followed by COMMAND words." >&2
		usage
		exit 1
	fi
	add_entry "$@"
	;;
remove)
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "spellbook-store: remove expects a NAME." >&2
		usage
		exit 1
	fi
	remove_entry "$1"
	;;
list)
	if [ "$#" -ne 0 ]; then
		usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 0 ]; then
		usage
		exit 1
	fi
	printf '%s\n' "$spellbook_file"
	;;
--help|-h)
	usage
	;;
*)
	usage
	exit 1
	;;
esac
