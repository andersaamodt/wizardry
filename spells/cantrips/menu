#!/bin/sh

# Present an interactive menu using only POSIX shell features. This variant
# relies on existing cantrips (await_keypress, move-cursor, etc.) to handle the
# terminal work so it can remain portable across macOS, Debian, and NixOS.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE' >&2
Usage: menu [--show-command] [--start-selection N] "Title" "Label%command"...

Draw a keyboard-driven terminal menu using wizardry's cursor and input helpers.
Provide a title followed by one or more "Label%command" entries; --show-command
displays the command text as the label, and --start-selection picks the initial
highlighted item. Use "---" to add a horizontal divider line.
USAGE
  exit 0
  ;;
esac

# Bootstrap: Load essential functions if not already available
# This allows menu to work when executed directly (tests) or when invoked (normal use)

# Use conditional strictness based on execution context
# See .github/CODE_POLICY_SET_EU.md for details
set -eu
. env-clear

# Wrapper functions for helper commands
# Only define if the underlying command is available
# This allows 'require' to properly detect missing dependencies
menu_temp_file() {
        temp-file "$@"
}

menu_cleanup_file() {
        cleanup-file "$@"
}

if command -v fathom-cursor >/dev/null 2>&1; then
        fathom_cursor() {
                fathom-cursor "$@"
        }
fi

if command -v fathom-terminal >/dev/null 2>&1; then
        fathom_terminal() {
                fathom-terminal "$@"
        }
fi

if command -v move-cursor >/dev/null 2>&1; then
        move_cursor() {
                move-cursor "$@"
        }
fi

if command -v await-keypress >/dev/null 2>&1; then
        await_keypress() {
                await-keypress "$@"
        }
fi

if command -v cursor-blink >/dev/null 2>&1; then
        cursor_blink() {
                cursor-blink "$@"
        }
fi

stty() {
        # stty is a system command, always use it directly
        command stty "$@"
}

# Verify that all helper spells are ready before drawing the menu.
# Uses the shared 'require' imp for dependency checking.
require fathom_cursor "The menu spell needs 'fathom-cursor' to place the menu." || exit 1
require fathom_terminal "The menu spell needs 'fathom-terminal' to measure the screen." || exit 1
require move_cursor "The menu spell needs 'move-cursor' to reposition the cursor." || exit 1
require await_keypress "The menu spell needs 'await_keypress' to read input." || exit 1
require cursor_blink "The menu spell needs 'cursor-blink' to restore the cursor." || exit 1
require stty "The menu spell needs 'stty' to manage terminal modes." || exit 1

menu_tty=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
if [ ! -r "$menu_tty" ] || [ ! -w "$menu_tty" ]; then
        die "menu: unable to access controlling terminal '$menu_tty'" || exit 1
fi

if menu_saved_tty_state=$(stty -g <"$menu_tty" 2>/dev/null); then
        :
else
        die "menu: unable to read terminal settings" || exit 1
fi

terminal_restored=0

AWAIT_KEYPRESS_KEEP_RAW=1
export AWAIT_KEYPRESS_KEEP_RAW
await_keypress_buffer_file=$(menu_temp_file await_keypress-buffer) || exit 1
AWAIT_KEYPRESS_BUFFER_FILE=$await_keypress_buffer_file
export AWAIT_KEYPRESS_BUFFER_FILE

# Load colour helpers when present; otherwise fall back to plain text.
# Try to find colors in the same directory when executed directly
if [ "${WIZARDRY_LOADING_SPELLS-}" != "1" ]; then
        script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
        if [ -r "$script_dir/colors" ]; then
                # shellcheck disable=SC1090
                . "$script_dir/colors"
        fi
fi

# If not loaded from script_dir, try function or PATH
if [ -z "${RESET-}" ]; then
        if has colors; then
                colors_path=$(command -v colors 2>/dev/null || printf '')
                if [ -n "$colors_path" ] && [ -f "$colors_path" ]; then
                        # shellcheck disable=SC1090
                        . "$colors_path"
                else
                        colors
                fi
        else
                RESET=''
                CYAN=''
                GREY=''
                WHITE=''
                BOLD=''
                THEME_HIGHLIGHT=''
                THEME_MUTED=''
                THEME_DIVIDER=''
                THEME_HEADING=''
        fi
fi

# Check for --show-command flag (displays command as label instead of description)
show_command=0
if [ "${1-}" = "--show-command" ]; then
        show_command=1
        shift
fi

# Check for --start-selection flag (start cursor on specific item)
start_selection=${MENU_START_SELECTION-1}
if [ "${1-}" = "--start-selection" ]; then
        shift
        start_selection=${1-1}
        shift
fi

if [ "$#" -lt 2 ]; then
  if command -v main-menu >/dev/null 2>&1; then
    main-menu
    exit 0
  fi
  printf '%s\n' "menu: no menu entries provided and main-menu not found" >&2
  exit 1
fi

description=$1
shift

cleanup_called=0
cleanup() {
        if [ "$cleanup_called" -eq 1 ]; then
                return
        fi
        cleanup_called=1
        if [ "$terminal_restored" -eq 0 ]; then
                terminal_restored=1
                stty "$menu_saved_tty_state" <"$menu_tty" >/dev/null 2>&1 || :
        fi
        cursor_blink on 2>/dev/null || :
        if [ -n "${await_keypress_buffer_file-}" ]; then
                menu_cleanup_file "$await_keypress_buffer_file"
        fi
}
trap 'cleanup; exit 1' INT TERM
trap 'cleanup' EXIT

max_name_length=0
menu_length=0
strip_ansi_pattern='s/\x1b\[[0-9;]*m//g'

# Cache labels, commands, and visible lengths in memory (avoid repeated sed calls)
cached_labels=''
cached_commands=''
cached_clean_labels=''
cached_visible_lengths=''
cached_raw_lengths=''
label_delimiter=$(printf '\036')  # ASCII RS (Record Separator)

for option in "$@"
do
        # Special case: "---" is a divider
        if [ "$option" = "---" ]; then
                label="---"
                command="---"
                clean_label="---"
                is_divider=1
        else
                label=${option%%\%*}
                case $option in
                *%*)
                        command=${option#*%}
                        ;;
                *)
                        command=''
                        ;;
                esac
                # Strip ANSI codes before calculating visible length
                clean_label=$(printf '%s' "$label" | sed "$strip_ansi_pattern")
                is_divider=0
        fi
        
        # Cache in memory
        if [ -z "$cached_labels" ]; then
                cached_labels=$label
                cached_commands=$command
                cached_clean_labels=$clean_label
                cached_is_divider=$is_divider
        else
                cached_labels="${cached_labels}${label_delimiter}${label}"
                cached_commands="${cached_commands}${label_delimiter}${command}"
                cached_clean_labels="${cached_clean_labels}${label_delimiter}${clean_label}"
                cached_is_divider="${cached_is_divider}${label_delimiter}${is_divider}"
        fi
        
        length=$(printf '%s' "$clean_label" | wc -c | tr -d ' ')
        raw_length=$(printf '%s' "$label" | wc -c | tr -d ' ')
        
        # Cache visible length and raw length
        if [ -z "$cached_visible_lengths" ]; then
                cached_visible_lengths=$length
                cached_raw_lengths=$raw_length
        else
                cached_visible_lengths="${cached_visible_lengths}${label_delimiter}${length}"
                cached_raw_lengths="${cached_raw_lengths}${label_delimiter}${raw_length}"
        fi
        
        if [ "$length" -gt "$max_name_length" ]; then
                max_name_length=$length
        fi
        menu_length=$((menu_length + 1))

done

if [ "$menu_length" -eq 0 ]; then
        die "menu: no menu entries provided" || exit 1
fi

# Helper function to access cached data by index (1-based) using pure shell
get_cached_item() {
        item_index=$1
        cached_data=$2
        if [ "$item_index" -lt 1 ] || [ "$item_index" -gt "$menu_length" ]; then
                return 1
        fi
        
        # Pure shell string splitting - much faster than awk for small datasets
        remaining="$cached_data"
        count=1
        while [ -n "$remaining" ]; do
                case "$remaining" in
                        *"$label_delimiter"*)
                                item="${remaining%%"$label_delimiter"*}"
                                if [ "$count" -eq "$item_index" ]; then
                                        printf '%s\n' "$item"
                                        return 0
                                fi
                                remaining="${remaining#*"$label_delimiter"}"
                                count=$((count + 1))
                                ;;
                        *)
                                if [ "$count" -eq "$item_index" ]; then
                                        printf '%s\n' "$remaining"
                                fi
                                return 0
                                ;;
                esac
        done
}

# Optimized function to get all cached items for a row at once (reduces function calls)
get_row_data() {
        row_idx=$1
        if [ "$row_idx" -lt 1 ] || [ "$row_idx" -gt "$menu_length" ]; then
                return 1
        fi
        
        # Extract all data for the row in a single pass
        remaining_labels="$cached_labels"
        remaining_commands="$cached_commands"
        remaining_clean="$cached_clean_labels"
        remaining_vlen="$cached_visible_lengths"
        remaining_rlen="$cached_raw_lengths"
        remaining_divider="$cached_is_divider"
        count=1
        
        while [ "$count" -le "$row_idx" ]; do
                # Extract current item from each cache
                case "$remaining_labels" in
                        *"$label_delimiter"*)
                                current_label="${remaining_labels%%"$label_delimiter"*}"
                                remaining_labels="${remaining_labels#*"$label_delimiter"}"
                                ;;
                        *)
                                current_label="$remaining_labels"
                                remaining_labels=""
                                ;;
                esac
                
                case "$remaining_commands" in
                        *"$label_delimiter"*)
                                current_command="${remaining_commands%%"$label_delimiter"*}"
                                remaining_commands="${remaining_commands#*"$label_delimiter"}"
                                ;;
                        *)
                                current_command="$remaining_commands"
                                remaining_commands=""
                                ;;
                esac
                
                case "$remaining_clean" in
                        *"$label_delimiter"*)
                                current_clean="${remaining_clean%%"$label_delimiter"*}"
                                remaining_clean="${remaining_clean#*"$label_delimiter"}"
                                ;;
                        *)
                                current_clean="$remaining_clean"
                                remaining_clean=""
                                ;;
                esac
                
                case "$remaining_vlen" in
                        *"$label_delimiter"*)
                                current_vlen="${remaining_vlen%%"$label_delimiter"*}"
                                remaining_vlen="${remaining_vlen#*"$label_delimiter"}"
                                ;;
                        *)
                                current_vlen="$remaining_vlen"
                                remaining_vlen=""
                                ;;
                esac
                
                case "$remaining_rlen" in
                        *"$label_delimiter"*)
                                current_rlen="${remaining_rlen%%"$label_delimiter"*}"
                                remaining_rlen="${remaining_rlen#*"$label_delimiter"}"
                                ;;
                        *)
                                current_rlen="$remaining_rlen"
                                remaining_rlen=""
                                ;;
                esac
                
                case "$remaining_divider" in
                        *"$label_delimiter"*)
                                current_divider="${remaining_divider%%"$label_delimiter"*}"
                                remaining_divider="${remaining_divider#*"$label_delimiter"}"
                                ;;
                        *)
                                current_divider="$remaining_divider"
                                remaining_divider=""
                                ;;
                esac
                
                if [ "$count" -eq "$row_idx" ]; then
                        # Export values for use by caller
                        row_label="$current_label"
                        row_command="$current_command"
                        row_clean="$current_clean"
                        row_vlen="$current_vlen"
                        row_rlen="$current_rlen"
                        row_is_divider="$current_divider"
                        return 0
                fi
                
                count=$((count + 1))
        done
        return 1
}

# Use start_selection if valid, otherwise default to 1
selected=1
case $start_selection in
        ''|*[!0-9]*)
                selected=1
                ;;
        *)
                if [ "$start_selection" -ge 1 ] && [ "$start_selection" -le "$menu_length" ]; then
                        selected=$start_selection
                fi
                ;;
esac
menu_column=1
menu_row=1
previous_selected=0
window_width=0
max_command_length=0
effective_max_name_length=0
last_window_width=0
last_max_command_length=0
render_row() {
        row_index=$1
        highlight=$2

        if [ "$row_index" -lt 1 ] || [ "$row_index" -gt "$menu_length" ]; then
                return
        fi

        # Use cached data - get all row data in one optimized call
        get_row_data "$row_index" || return 1
        label="$row_label"
        command="$row_command"
        clean_label="$row_clean"
        visible_length="$row_vlen"
        raw_length="$row_rlen"

        if [ "$command" = "---" ]; then
                menu_width=$((effective_max_name_length + 2))
                if [ "$window_width" -gt 0 ] && [ "$menu_width" -gt "$window_width" ]; then
                        menu_width=$window_width
                fi
                divider_width=16
                if [ "$divider_width" -gt "$menu_width" ]; then
                        divider_width=$menu_width
                fi
                padding=$(( (menu_width - divider_width) / 2 ))
                pad=''
                p=0
                while [ "$p" -lt "$padding" ]; do
                        pad="$pad "
                        p=$((p + 1))
                done
                line=''
                i=0
                while [ "$i" -lt "$divider_width" ]; do
                        line="${line}â”€"
                        i=$((i + 1))
                done

                target_row=$((menu_row + row_index - 1))
        if move_cursor "$menu_column" "$target_row"; then
                        printf '\033[K'
                        printf '%b  %s%s%b' "$THEME_DIVIDER" "$pad" "$line" "$RESET"
                        printf '\r'
                else
                        printf '%b  %s%s%b\n' "$THEME_DIVIDER" "$pad" "$line" "$RESET"
                fi
                return
        fi

        # Truncate command - keep using cut as it's actually efficient for this
        truncated_command=""
        if [ "$max_command_length" -gt 0 ] && [ -n "$command" ]; then
                cmd_len=${#command}
                if [ "$cmd_len" -le "$max_command_length" ]; then
                        truncated_command="$command"
                else
                        truncated_command=$(printf '%s' "$command" | cut -c -"$max_command_length")
                fi
        fi

        # Truncate label if it exceeds effective_max_name_length
        truncated_label="$label"
        truncated_clean_label="$clean_label"
        truncated_visible_length="$visible_length"
        truncated_raw_length="$raw_length"
        
        if [ "$visible_length" -gt "$effective_max_name_length" ]; then
                # Need to truncate the label
                # For clean_label (no ANSI), simple substring works
                max_len=$effective_max_name_length
                truncated_clean_label=$(printf '%s' "$clean_label" | cut -c -"$max_len")
                truncated_visible_length=$effective_max_name_length
                
                # For label with ANSI codes, preserve codes but truncate visible text
                # Simplified approach: strip ANSI and retruncate
                # This ensures consistent display even if we lose some color
                truncated_label=$(printf '%s' "$clean_label" | cut -c -"$max_len")
                truncated_raw_length=$effective_max_name_length
        fi

        # Calculate ANSI extra based on truncated values
        ansi_extra=$((truncated_raw_length - truncated_visible_length))
        adjusted_width=$((effective_max_name_length + ansi_extra))

        target_row=$((menu_row + row_index - 1))
        if move_cursor "$menu_column" "$target_row"; then
                printf '\033[K'
                if [ "$highlight" -eq 1 ]; then
                        if [ "$max_command_length" -gt 0 ]; then
                                # Highlighted row with command column
                                printf '%b> %-*s%b %b%-*s%b' \
                                        "$THEME_HIGHLIGHT" "$effective_max_name_length" \
                                        "$truncated_clean_label" "$RESET" \
                                        "$THEME_MUTED" "$max_command_length" \
                                        "$truncated_command" "$RESET"
                        else
                                # Highlighted row without command column
                                printf '%b> %-*s%b' \
                                        "$THEME_HIGHLIGHT" "$effective_max_name_length" \
                                        "$truncated_clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                # Normal row with command column
                                printf '  %-*s %b%-*s%b' \
                                        "$adjusted_width" "$truncated_label" \
                                        "$THEME_MUTED" "$max_command_length" \
                                        "$truncated_command" "$RESET"
                        else
                                # Normal row without command column
                                printf '  %-*s' "$adjusted_width" "$truncated_label"
                        fi
                fi
                printf '\r'
        else
                if [ "$highlight" -eq 1 ]; then
                        if [ "$max_command_length" -gt 0 ]; then
                                # Highlighted row with command column (no cursor move)
                                printf '%b> %-*s%b %b%-*s%b\n' \
                                        "$THEME_HIGHLIGHT" "$effective_max_name_length" \
                                        "$truncated_clean_label" "$RESET" \
                                        "$THEME_MUTED" "$max_command_length" \
                                        "$truncated_command" "$RESET"
                        else
                                # Highlighted row without command column (no cursor move)
                                printf '%b> %-*s%b\n' \
                                        "$THEME_HIGHLIGHT" "$effective_max_name_length" \
                                        "$truncated_clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                # Normal row with command column (no cursor move)
                                printf '  %-*s %b%-*s%b\n' \
                                        "$adjusted_width" "$truncated_label" \
                                        "$THEME_MUTED" "$max_command_length" \
                                        "$truncated_command" "$RESET"
                        else
                                # Normal row without command column (no cursor move)
                                printf '  %-*s\n' "$adjusted_width" "$truncated_label"
                        fi
                fi
        fi
}

position_cursor_below_menu() {
        below_row=$((menu_row + menu_length))
        if [ "$terminal_height" -gt 0 ] && [ "$below_row" -gt "$terminal_height" ]; then
                below_row=$terminal_height
        fi

        if ! move_cursor "$menu_column" "$below_row"; then
                printf '\n'
        fi
}

cursor_blink off

if [ -n "$description" ]; then
        # Show the caller-provided heading so the menu has context for the user.
        printf '%b%s%b\n' "$THEME_HEADING" "$description" "$RESET"
fi

menu_row=$(fathom_cursor -y)
case "$menu_row" in
        ''|*[!0-9]*)
                menu_row=1
                ;;
        0)
                menu_row=1
                ;;
esac

# At this stage the cursor sits on the row immediately following the menu
# heading (or at the top of the screen when no heading was provided). That row
# becomes the anchor for the first menu option so the items render directly
# beneath the title.

terminal_height=$(fathom_terminal --height)
case "$terminal_height" in
        ''|*[!0-9]*)
                terminal_height=0
                ;;
        0)
                terminal_height=0
                ;;
esac

# Reserve vertical space before drawing anything so that the menu can repaint
# in place without pushing the terminal history around as selections change.
padding=$menu_length
while [ "$padding" -gt 0 ]; do
        printf '\n'
        padding=$((padding - 1))
done

if [ "$terminal_height" -gt 0 ]; then
        max_row=$((terminal_height - menu_length))
        if [ "$max_row" -lt 1 ]; then
                max_row=1
        fi
        if [ "$menu_row" -gt "$max_row" ]; then
                menu_row=$max_row
        fi
fi

if [ "$menu_row" -lt 1 ]; then
        menu_row=1
fi

pending_step=0

needs_redraw=1
selection_pending=0
check_width_counter=0
width_check_interval=10  # Only check terminal width every N iterations

# Pre-calculate cursor position below menu for inlining
cursor_below_row=$((menu_row + menu_length))
if [ "$terminal_height" -gt 0 ] && [ "$cursor_below_row" -gt "$terminal_height" ]; then
        cursor_below_row=$terminal_height
fi

while :
do
        if [ "$pending_step" -eq 0 ]; then
                # Use cached divider flag instead of get_cached_item
                is_div=$(get_cached_item "$selected" "$cached_is_divider")
                if [ "$is_div" = "1" ]; then
                        pending_step=1
                fi
        fi
        # If the current position is a divider, queue a forward step to reach the next selectable row.
        # Apply queued navigation steps, wrapping around and skipping dividers.
        if [ "$pending_step" -ne 0 ]; then
                start=$selected
                pos=$selected
                while :
                do
                        pos=$((pos + pending_step))
                        if [ "$pos" -gt "$menu_length" ]; then
                                pos=1
                        elif [ "$pos" -le 0 ]; then
                                pos=$menu_length
                        fi
                        # Use cached divider flag instead of get_cached_item
                        pos_is_div=$(get_cached_item "$pos" "$cached_is_divider")
                        if [ "$pos_is_div" != "1" ]; then
                                selected=$pos
                                break
                        fi
                        if [ "$pos" -eq "$start" ]; then
                                break
                        fi
                done
                selection_pending=1
                pending_step=0
        fi

        # Only check terminal width periodically to reduce overhead
        check_width_counter=$((check_width_counter + 1))
        if [ "$check_width_counter" -ge "$width_check_interval" ] || [ "$needs_redraw" -eq 1 ]; then
                check_width_counter=0
                current_window_width=$(fathom_terminal --width)
        else
                current_window_width=$window_width
        fi
        case "$current_window_width" in
                ''|*[!0-9]*)
                        current_window_width=0
                        ;;
        esac
        
        # Truncate labels to preserve command column (minimum 20 chars)
        # Calculate effective max label width to ensure commands get at least 20 chars
        min_command_width=20
        current_effective_max_name_length=$max_name_length
        if [ "$current_window_width" -gt 0 ]; then
                max_allowed_name_length=$((current_window_width - min_command_width - 3))
                if [ "$max_allowed_name_length" -lt 10 ]; then
                        max_allowed_name_length=10
                fi
                if [ "$max_name_length" -gt "$max_allowed_name_length" ]; then
                        current_effective_max_name_length=$max_allowed_name_length
                fi
        fi
        
        current_max_command_length=$((current_window_width - current_effective_max_name_length - 3))
        if [ "$current_max_command_length" -lt 0 ]; then
                current_max_command_length=0
        fi
        width_changed=$((current_window_width != last_window_width))
        cmd_len_changed=$((current_max_command_length != last_max_command_length))
        if [ "$width_changed" -ne 0 ] || [ "$cmd_len_changed" -ne 0 ]; then
                needs_redraw=1
                selection_pending=0
        fi
        window_width=$current_window_width
        max_command_length=$current_max_command_length
        effective_max_name_length=$current_effective_max_name_length

        if [ "$needs_redraw" -eq 1 ]; then
                last_window_width=$current_window_width
                last_max_command_length=$current_max_command_length

                if move_cursor "$menu_column" "$menu_row"; then
                        printf '\033[J'
                fi

                row=1
                while [ "$row" -le "$menu_length" ]
                do
                        highlight=0
                        if [ "$row" -eq "$selected" ]; then
                                highlight=1
                        fi
                        render_row "$row" "$highlight"
                        row=$((row + 1))
                done

                # Inline position_cursor_below_menu for performance
                if ! move_cursor "$menu_column" "$cursor_below_row"; then
                        printf '\n'
                fi

                previous_selected=$selected
                selection_pending=0
                needs_redraw=0
        elif [ "$selection_pending" -eq 1 ]; then
                if [ "$previous_selected" -gt 0 ]; then
                        render_row "$previous_selected" 0
                fi
                render_row "$selected" 1

                # Inline position_cursor_below_menu for performance
                if ! move_cursor "$menu_column" "$cursor_below_row"; then
                        printf '\n'
                fi

                previous_selected=$selected
                selection_pending=0
        fi

        step=0
        key=$(await_keypress)
        [ "${WIZARDRY_DEBUG_MENU:-0}" = "1" ] && printf '[menu] await_keypress returned: "%s"\n' "$key" >&2
        case $key in
        ctrl-c)
                cleanup
                trap - EXIT INT TERM
                exit 130
                ;;
        up)
                step=-1
                ;;
        down)
                step=1
                ;;
        enter)
                # Use get_row_data for faster retrieval
                get_row_data "$selected"
                if [ "$show_command" -eq 1 ]; then
                        to_run="$row_label"
                else
                        to_run="$row_command"
                fi
                cleanup
                trap - EXIT INT TERM
                if [ -n "$to_run" ]; then
                        printf '\n'
                        # shellcheck disable=SC2039,SC3045 # POSIX sh allows eval
                        eval "$to_run"
                fi
                exit 0
                ;;
escape|ESC|esc)
        cleanup
        trap - EXIT INT TERM
        # Signal parent menu to exit only when explicitly nested.
        if [ "${MENU_NESTED:-0}" = "1" ] && [ -n "${MENU_PARENT_PID-}" ]; then
                if [ "${PPID:-0}" -eq "$MENU_PARENT_PID" ]; then
                        kill -TERM "$MENU_PARENT_PID" 2>/dev/null || :
                fi
        fi
        exit 130
        ;;
esac

        if [ "$step" -ne 0 ]; then
                pending_step=$step
        fi

        # Avoid a tight loop if await_keypress returned empty.
        if [ -z "$key" ]; then
                sleep 0.05
        fi
done
