#!/usr/bin/env sh

# Present an interactive menu using only POSIX shell features. This variant
# relies on existing cantrips (await-keypress, move-cursor, etc.) to handle the
# terminal work so it can remain portable across macOS, Debian, and NixOS.

set -eu

menu_escape_status=${MENU_ESCAPE_STATUS-0}
case $menu_escape_status in
        ''|*[!0-9]*)
                printf '%s\n' "menu: MENU_ESCAPE_STATUS must be a non-negative integer" >&2
                exit 1
                ;;
esac

if [ "$menu_escape_status" -gt 255 ]; then
        printf '%s\n' "menu: MENU_ESCAPE_STATUS must be between 0 and 255" >&2
        exit 1
fi

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Reuse the standard dependency checker when available so missing commands can
# be reported consistently.
if [ -n "${REQUIRE_COMMAND-}" ]; then
        require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/require-command" ]; then
        require_cmd="$script_dir/require-command"
else
        require_cmd=""
fi

require() {
        tool=$1
        shift
        if [ -n "$require_cmd" ]; then
                "$require_cmd" "$tool" "$@"
                return $?
        fi

        if command -v "$tool" >/dev/null 2>&1; then
                return 0
        fi

        if [ "$#" -gt 0 ]; then
                printf '%s\n' "$tool: $*" >&2
        else
                printf '%s\n' "menu: missing required command '$tool'" >&2
        fi
        printf '%s\n' "Visit 'install-menu' to review installation options." >&2
        return 1
}

# Verify that all helper spells are ready before drawing the menu.
require fathom-cursor "The menu spell needs 'fathom-cursor' to place the menu." || exit 1
require fathom-terminal "The menu spell needs 'fathom-terminal' to measure the screen." || exit 1
require move-cursor "The menu spell needs 'move-cursor' to reposition the cursor." || exit 1
require await-keypress "The menu spell needs 'await-keypress' to read input." || exit 1
require cursor-blink "The menu spell needs 'cursor-blink' to restore the cursor." || exit 1
require stty "The menu spell needs 'stty' to manage terminal modes." || exit 1

menu_tty=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
if [ ! -r "$menu_tty" ] || [ ! -w "$menu_tty" ]; then
        printf '%s\n' "menu: unable to access controlling terminal '$menu_tty'" >&2
        exit 1
fi

if ! menu_saved_tty_state=$(stty -g <"$menu_tty" 2>/dev/null); then
        printf '%s\n' 'menu: unable to read terminal settings' >&2
        exit 1
fi

terminal_restored=0
restore_terminal() {
        if [ "$terminal_restored" -eq 1 ]; then
                return
        fi
        terminal_restored=1
        stty "$menu_saved_tty_state" <"$menu_tty" >/dev/null 2>&1 || :
}

AWAIT_KEYPRESS_KEEP_RAW=1
export AWAIT_KEYPRESS_KEEP_RAW

# Load colour helpers when present; otherwise fall back to plain text.
if [ -r "$script_dir/colors" ]; then
        # shellcheck disable=SC1090
        . "$script_dir/colors"
elif command -v colors >/dev/null 2>&1; then
        # shellcheck disable=SC1091
        . colors
else
        RESET=''
        CYAN=''
        GREY=''
        WHITE=''
        THEME_HIGHLIGHT=''
        THEME_MUTED=''
        THEME_DIVIDER=''
fi

# Check for --spell-mode flag (label is command, right side is description)
spell_mode=0
if [ "${1-}" = "--spell-mode" ]; then
        spell_mode=1
        shift
fi

# Check for --start-selection flag (start cursor on specific item)
start_selection=${MENU_START_SELECTION-1}
if [ "${1-}" = "--start-selection" ]; then
        shift
        start_selection=${1-1}
        shift
fi

if [ "$#" -lt 2 ]; then
        if command -v main-menu >/dev/null 2>&1; then
                main-menu
                exit 0
        fi
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

description=$1
shift

TMPDIR=${TMPDIR:-/tmp}
items_file="$TMPDIR/wizardry-menu-items.$$"
commands_file="$TMPDIR/wizardry-menu-commands.$$"
: >"$items_file"
: >"$commands_file"
cleanup_called=0
cleanup() {
        if [ "$cleanup_called" -eq 1 ]; then
                return
        fi
        cleanup_called=1
        restore_terminal
        cursor-blink on >/dev/null 2>&1 || :
        rm -f "$items_file" "$commands_file"
}
trap 'cleanup; exit 1' INT TERM
trap 'cleanup' EXIT

max_name_length=0
menu_length=0

# Function to strip ANSI escape codes for length calculation
strip_ansi() {
        printf '%s' "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

for option in "$@"
do
        label=${option%%\%*}
        case $option in
        *%*)
                command=${option#*%}
                ;;
        *)
                command=''
                ;;
        esac
        printf '%s\n' "$label" >>"$items_file"
        printf '%s\n' "$command" >>"$commands_file"
        # Strip ANSI codes before calculating visible length
        clean_label=$(strip_ansi "$label")
        length=$(printf '%s' "$clean_label" | wc -c | tr -d ' ')
        if [ "$length" -gt "$max_name_length" ]; then
                max_name_length=$length
        fi
        menu_length=$((menu_length + 1))

done

if [ "$menu_length" -eq 0 ]; then
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

# Use start_selection if valid, otherwise default to 1
selected=1
case $start_selection in
        ''|*[!0-9]*)
                selected=1
                ;;
        *)
                if [ "$start_selection" -ge 1 ] && [ "$start_selection" -le "$menu_length" ]; then
                        selected=$start_selection
                fi
                ;;
esac
menu_column=1
menu_row=1
menu_drawn=0
previous_selected=0
last_window_width=0
last_max_command_length=0
dimensions_changed=1

find_next_selectable() {
        # Find the next selectable (non-divider) item after current position
        # Wraps around to beginning if needed
        start=$selected
        pos=$selected
        pos=$((pos + 1))
        if [ "$pos" -gt "$menu_length" ]; then
                pos=1
        fi
        while [ "$pos" -ne "$start" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos + 1))
                if [ "$pos" -gt "$menu_length" ]; then
                        pos=1
                fi
        done
        # No selectable items found (shouldn't happen in practice)
        return 1
}

find_prev_selectable() {
        # Find the previous selectable (non-divider) item before current position
        # Wraps around to end if needed
        start=$selected
        pos=$selected
        pos=$((pos - 1))
        if [ "$pos" -le 0 ]; then
                pos=$menu_length
        fi
        while [ "$pos" -ne "$start" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos - 1))
                if [ "$pos" -le 0 ]; then
                        pos=$menu_length
                fi
        done
        # No selectable items found (shouldn't happen in practice)
        return 1
}

find_first_selectable() {
        # Find the first selectable item (skip initial dividers)
        pos=1
        while [ "$pos" -le "$menu_length" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos + 1))
        done
        # No selectable items found
        return 1
}

update_dimensions() {
        # Measure the terminal so we know how much horizontal space each menu
        # row can safely use. We leave room for the two-character prefix ("> ")
        # and at least one separating space before any command preview.
        window_width=$(fathom-terminal -w)
        max_command_length=$((window_width - max_name_length - 3))
        if [ "$max_command_length" -lt 0 ]; then
                max_command_length=0
        fi

        dimensions_changed=0
        if [ "$window_width" -ne "$last_window_width" ] || [ "$max_command_length" -ne "$last_max_command_length" ]; then
                dimensions_changed=1
        fi

        last_window_width=$window_width
        last_max_command_length=$max_command_length
}

is_divider() {
        # Check if a row is an unselectable divider
        row_idx=$1
        cmd=$(sed -n "${row_idx}p" "$commands_file")
        case $cmd in
                --divider--) return 0 ;;
                *) return 1 ;;
        esac
}

render_divider() {
        # Render a horizontal divider line (~16 chars, centered within menu width)
        # Menu width is based on max item (label) width, limited by window width
        # The menu width should be the max_name_length + 2 (for "> " prefix)
        menu_width=$((max_name_length + 2))
        
        # Limit menu_width to window_width (whichever is less)
        if [ "$window_width" -gt 0 ] && [ "$menu_width" -gt "$window_width" ]; then
                menu_width=$window_width
        fi
        
        # Fixed divider width of 16 chars (or menu_width if smaller)
        divider_width=16
        if [ "$divider_width" -gt "$menu_width" ]; then
                divider_width=$menu_width
        fi
        # Calculate left padding to center the divider within menu_width
        padding=$(( (menu_width - divider_width) / 2 ))
        # Build padding string
        pad=""
        p=0
        while [ "$p" -lt "$padding" ]; do
                pad="$pad "
                p=$((p + 1))
        done
        # Build divider line
        line=""
        i=0
        while [ "$i" -lt "$divider_width" ]; do
                line="${line}â”€"
                i=$((i + 1))
        done
        printf '%b  %s%s%b' "$THEME_DIVIDER" "$pad" "$line" "$RESET"
}

render_row() {
        # Render a single menu row either in its normal state or highlighted
        # for the currently selected item. Each pass clears the existing row so
        # repeated renders replace text in place instead of scrolling.
        row_index=$1
        highlight=$2

        if [ "$row_index" -lt 1 ] || [ "$row_index" -gt "$menu_length" ]; then
                return
        fi

        label=$(sed -n "${row_index}p" "$items_file")
        command=$(sed -n "${row_index}p" "$commands_file")

        # Handle divider rows
        if [ "$command" = "--divider--" ]; then
                target_row=$((menu_row + row_index - 1))
                if move-cursor "$menu_column" "$target_row"; then
                        printf '\033[K'
                        render_divider
                        printf '\r'
                else
                        render_divider
                        printf '\n'
                fi
                return
        fi

        if [ "$max_command_length" -gt 0 ]; then
                truncated_command=$(printf '%s' "$command" | cut -c -"$max_command_length")
        else
                truncated_command=''
        fi

        # Calculate visible length (without ANSI codes) for proper padding
        clean_label=$(strip_ansi "$label")
        visible_length=$(printf '%s' "$clean_label" | wc -c | tr -d ' ')
        # Calculate extra padding needed to compensate for invisible ANSI codes
        raw_length=$(printf '%s' "$label" | wc -c | tr -d ' ')
        ansi_extra=$((raw_length - visible_length))
        # Adjust the padding width to account for ANSI codes in label
        adjusted_width=$((max_name_length + ansi_extra))

        target_row=$((menu_row + row_index - 1))
        if move-cursor "$menu_column" "$target_row"; then
                printf '\033[K'
                if [ "$highlight" -eq 1 ]; then
                        # Use clean_label (ANSI stripped) so highlight color takes precedence
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '%b> %-*s%b %b%-*s%b' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '%b> %-*s%b' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '  %-*s %b%-*s%b' "$adjusted_width" "$label" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '  %-*s' "$adjusted_width" "$label"
                        fi
                fi
                printf '\r'
        else
                if [ "$highlight" -eq 1 ]; then
                        # Use clean_label (ANSI stripped) so highlight color takes precedence
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '%b> %-*s%b %b%-*s%b\n' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '%b> %-*s%b\n' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '  %-*s %b%-*s%b\n' "$adjusted_width" "$label" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '  %-*s\n' "$adjusted_width" "$label"
                        fi
                fi
        fi
}

position_cursor_below_menu() {
        # Park the cursor just beneath the menu so that any subsequent output
        # (selected command logs, prompts, etc.) begins below the reserved
        # region. This keeps the menu intact while commands run.
        below_row=$((menu_row + menu_length))
        if [ "$terminal_height" -gt 0 ] && [ "$below_row" -gt "$terminal_height" ]; then
                below_row=$terminal_height
        fi

        if ! move-cursor "$menu_column" "$below_row"; then
                printf '\n'
        fi
}

draw_menu() {
        # Redraw the entire menu from scratch. This runs the first time we
        # display the menu or whenever the terminal size changes.
        if move-cursor "$menu_column" "$menu_row"; then
                printf '\033[J'
        fi

        row=1
        while [ "$row" -le "$menu_length" ]
        do
                if [ "$row" -eq "$selected" ]; then
                        highlight=1
                else
                        highlight=0
                fi
                render_row "$row" "$highlight"
                row=$((row + 1))
        done

        position_cursor_below_menu

        menu_drawn=1
        previous_selected=$selected
}

refresh_selection() {
        # Update only the rows that changed. If the dimensions changed or we
        # have not drawn the menu yet, fall back to a full redraw.
        if [ "$menu_drawn" -eq 0 ] || [ "$dimensions_changed" -eq 1 ]; then
                draw_menu
                return
        fi

        if [ "$selected" -ne "$previous_selected" ]; then
                if [ "$previous_selected" -gt 0 ]; then
                        render_row "$previous_selected" 0
                fi
                render_row "$selected" 1
                position_cursor_below_menu
                previous_selected=$selected
        fi
}

execute_selection() {
        # Run the command paired with the currently highlighted menu item. If
        # there is no command we simply exit after cleaning up.
        # In spell mode, run the label (spell name) instead of the command (description).
        if [ "$spell_mode" -eq 1 ]; then
                to_run=$(sed -n "${selected}p" "$items_file")
        else
                to_run=$(sed -n "${selected}p" "$commands_file")
        fi
        if [ -n "$to_run" ]; then
                cleanup
                trap - EXIT INT TERM
                # Print newline before running command for visual separation
                printf '\n'
                # shellcheck disable=SC2039,SC3045 # POSIX sh allows eval
                eval "$to_run"
        else
                cleanup
                trap - EXIT INT TERM
        fi
}

cursor-blink off

if [ -n "$description" ]; then
        # Show the caller-provided heading so the menu has context for the user.
        printf '%s\n' "$description"
fi

menu_row=$(fathom-cursor -y)
case "$menu_row" in
        ''|*[!0-9]*)
                menu_row=1
                ;;
        0)
                menu_row=1
                ;;
esac

# At this stage the cursor sits on the row immediately following the menu
# heading (or at the top of the screen when no heading was provided). That row
# becomes the anchor for the first menu option so the items render directly
# beneath the title.

terminal_height=$(fathom-terminal -h)
case "$terminal_height" in
        ''|*[!0-9]*)
                terminal_height=0
                ;;
        0)
                terminal_height=0
                ;;
esac

# Reserve vertical space before drawing anything so that the menu can repaint
# in place without pushing the terminal history around as selections change.
padding=$menu_length
while [ "$padding" -gt 0 ]; do
        printf '\n'
        padding=$((padding - 1))
done

if [ "$terminal_height" -gt 0 ]; then
        max_row=$((terminal_height - menu_length))
        if [ "$max_row" -lt 1 ]; then
                max_row=1
        fi
        if [ "$menu_row" -gt "$max_row" ]; then
                menu_row=$max_row
        fi
fi

if [ "$menu_row" -lt 1 ]; then
        menu_row=1
fi

update_dimensions
# Ensure we start on a selectable item - if selected position (from MENU_START_SELECTION)
# is valid and not a divider, use it; otherwise find the first selectable item
if [ "$selected" -ge 1 ] && [ "$selected" -le "$menu_length" ] && ! is_divider "$selected"; then
        : # selected position is valid and not a divider, use it
else
        find_first_selectable || :
fi
draw_menu

while :
do
        key=$(await-keypress)
        case $key in
        up)
                find_prev_selectable || :
                ;;
        down)
                find_next_selectable || :
                ;;
        enter)
                execute_selection
                exit 0
                ;;
        escape|ESC|esc)
                cleanup
                trap - EXIT INT TERM
                exit "$menu_escape_status"
                ;;
        esac
        update_dimensions
        refresh_selection
        # Avoid a tight loop if await-keypress returned empty.
        [ -n "$key" ] || sleep 0.05
done
