#!/usr/bin/env sh

# Present an interactive menu using only POSIX shell features. This spell does
# not implement any terminal control codes itself; instead it relies on the
# supporting cantrips to provide those capabilities in a portable way:
#   * `await-keypress` must emit tokens like "up", "down", and "enter" without
#     printing escape sequences so that the menu loop can stay shell-agnostic.
#   * `fathom-terminal` reports the terminal dimensions so the menu knows how
#     wide it can draw each row without wrapping.
#   * `fathom-cursor` and `move-cursor` work together so the script can anchor
#     the menu, redraw it in place, and avoid scrolling the rest of the screen.
#   * `cursor-blink` is used to restore the prompt on exit even if the user hits
#     Ctrl+C midway through navigation.
# If any of these helpers change their interfaces, the menu will need to be
# updated in tandem to preserve the seamless redraw behaviour.

# The spell is intentionally free of Bash extensions so that it can remain the
# canonical menu implementation across macOS, Debian, NixOS, and other
# POSIX-compatible systems.

set -eu

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Reuse the standard dependency checker when available so missing commands can
# be reported consistently.
if [ -n "${REQUIRE_COMMAND-}" ]; then
        require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/require-command" ]; then
        require_cmd="$script_dir/require-command"
else
        require_cmd=""
fi

require() {
        tool=$1
        shift
        if [ -n "$require_cmd" ]; then
                "$require_cmd" "$tool" "$@"
                return $?
        fi

        if command -v "$tool" >/dev/null 2>&1; then
                return 0
        fi

        if [ "$#" -gt 0 ]; then
                printf '%s\n' "$tool: $*" >&2
        else
                printf '%s\n' "menu: missing required command '$tool'" >&2
        fi
        printf '%s\n' "Visit 'install-menu' to review installation options." >&2
        return 1
}

# Verify that all helper spells are ready before drawing the menu.
require fathom-cursor "The menu spell needs 'fathom-cursor' to place the menu." || exit 1
require fathom-terminal "The menu spell needs 'fathom-terminal' to measure the screen." || exit 1
require move-cursor "The menu spell needs 'move-cursor' to reposition the cursor." || exit 1
require await-keypress "The menu spell needs 'await-keypress' to read input." || exit 1
require cursor-blink "The menu spell needs 'cursor-blink' to restore the cursor." || exit 1

# Load colour helpers when present; otherwise fall back to plain text.
if [ -r "$script_dir/colors" ]; then
        # shellcheck disable=SC1090
        . "$script_dir/colors"
elif command -v colors >/dev/null 2>&1; then
        # shellcheck disable=SC1091
        . colors
else
        RESET=''
        CYAN=''
        GREY=''
fi

if [ "$#" -lt 2 ]; then
        if command -v main-menu >/dev/null 2>&1; then
                main-menu
                exit 0
        fi
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

description=$1
shift

TMPDIR=${TMPDIR:-/tmp}
items_file="$TMPDIR/wizardry-menu-items.$$"
commands_file="$TMPDIR/wizardry-menu-commands.$$"
: >"$items_file"
: >"$commands_file"
cleanup_called=0
cleanup() {
        if [ "$cleanup_called" -eq 1 ]; then
                return
        fi
        cleanup_called=1
        cursor-blink on >/dev/null 2>&1 || :
        rm -f "$items_file" "$commands_file"
}
trap 'cleanup; exit 1' INT TERM
trap 'cleanup' EXIT

max_name_length=0
menu_length=0

for option in "$@"
do
        label=${option%%\%*}
        case $option in
        *%*)
                command=${option#*%}
                ;;
        *)
                command=''
                ;;
        esac
        printf '%s\n' "$label" >>"$items_file"
        printf '%s\n' "$command" >>"$commands_file"
        length=$(printf '%s' "$label" | wc -c | tr -d ' ')
        if [ "$length" -gt "$max_name_length" ]; then
                max_name_length=$length
        fi
        menu_length=$((menu_length + 1))

done

if [ "$menu_length" -eq 0 ]; then
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

selected=1
menu_column=1
menu_row=1
menu_drawn=0

# Draw the menu starting at the recorded cursor position.
display_menu() {
        window_width=$(fathom-terminal -w)
        max_command_length=$((window_width - max_name_length - 3))
        if [ "$max_command_length" -lt 0 ]; then
                max_command_length=0
        fi

        # Only attempt to clear previous output after the menu has been drawn
        # once. Clearing on the first render can erase the prompt that invoked
        # the menu and give the appearance of the screen scrolling.
        if [ "$menu_drawn" -eq 1 ]; then
                move-cursor "$menu_column" "$menu_row" || :
        else
                move-cursor "$menu_column" "$menu_row" || :
                menu_drawn=1
        fi

        if [ "$max_command_length" -gt 0 ]; then
                blank_command=$(printf '%*s' "$max_command_length" '')
        else
                blank_command=''
        fi

        row=1
        while IFS= read -r label || [ -n "$label" ]
        do
                command=$(sed -n "${row}p" "$commands_file")
                if [ "$max_command_length" -gt 0 ]; then
                        truncated_command=$(printf '%s' "$command" | cut -c -"$max_command_length")
                else
                        truncated_command=''
                fi

                if [ "$row" -eq "$selected" ]; then
                        if [ -n "$truncated_command" ]; then
                                printf '%s> %-*s%s %s%s%s\n' "$CYAN" "$max_name_length" "$label" "$RESET" "$GREY" "$truncated_command" "$RESET"
                        else
                                printf '%s> %-*s%s\n' "$CYAN" "$max_name_length" "$label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '  %-*s %s\n' "$max_name_length" "$label" "$blank_command"
                        else
                                printf '  %-*s\n' "$max_name_length" "$label"
                        fi
                fi

                row=$((row + 1))
        done <"$items_file"
}

execute_selection() {
        command=$(sed -n "${selected}p" "$commands_file")
        if [ -n "$command" ]; then
                printf '\n'
                cleanup
                trap - EXIT INT TERM
                # shellcheck disable=SC2039,SC3045 # POSIX sh allows eval
                eval "$command"
        else
                cleanup
                trap - EXIT INT TERM
        fi
}

cursor-blink off

if [ -n "$description" ]; then
        printf '%s\n' "$description"
fi

menu_row=$(fathom-cursor -y)
case "$menu_row" in
        ''|*[!0-9]*)
                menu_row=1
                ;;
        0)
                menu_row=1
                ;;
esac

display_menu

while :
do
        key=$(await-keypress)
        case $key in
        up)
                selected=$((selected - 1))
                if [ "$selected" -le 0 ]; then
                        selected=$menu_length
                fi
                ;;
        down)
                selected=$((selected + 1))
                if [ "$selected" -gt "$menu_length" ]; then
                        selected=1
                fi
                ;;
        enter)
                execute_selection
                exit 0
                ;;
        escape)
                cleanup
                trap - EXIT INT TERM
                printf '%s\n' 'ESC'
                exit 0
                ;;
        esac
        display_menu
        # Avoid a tight loop if await-keypress returned empty.
        [ -n "$key" ] || sleep 0.05
done
