#!/bin/sh

# ask-text poses gentle questions, echoing whatever reply the wanderer offers.
# When a default is whispered, pressing Enter adopts it so scripts can fall
# through gracefully even when silence answers back.


show_usage() {
        cat <<'USAGE' >&2
Usage: ask-text "Question" [default]

Prompts the user with the provided question and echoes their response.
When a default is supplied it will be used if the user presses Enter.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        show_usage
        exit 1
fi

question=$1
default_value=${2-}
default_hint=""
if [ "$#" -eq 2 ]; then
        default_hint=" [$default_value]"
fi

# Support both ASK_CANTRIP_INPUT (legacy) and SELECT_INPUT_MODE (imp convention)
if [ -n "${ASK_CANTRIP_INPUT-}" ] && [ -z "${SELECT_INPUT_MODE-}" ]; then
        SELECT_INPUT_MODE=$ASK_CANTRIP_INPUT
        export SELECT_INPUT_MODE
fi

# Prompt user
printf '%s%s ' "$question" "$default_hint" >&2

# Read input using select-input imp
if ! input=$(select-input); then
        if [ -n "$default_value" ]; then
                printf '%s\n' "$default_value"
                exit 0
        fi
        printf '%s\n' "ask-text: No interactive input available." >&2
        exit 1
fi

# Read line based on input source
case $input in
stdin)
        IFS= read -r response || response=
        ;;
tty)
        IFS= read -r response </dev/tty || response=
        ;;
*)
        if [ -n "$default_value" ]; then
                printf '%s\n' "$default_value"
                exit 0
        fi
        printf '%s\n' "ask-text: No interactive input available." >&2
        exit 1
        ;;
esac

# Use default if response is empty
if [ -z "$response" ] && [ -n "$default_value" ]; then
        response=$default_value
fi

printf '%s\n' "$response"
