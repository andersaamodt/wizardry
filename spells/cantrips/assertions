#!/usr/bin/env sh

# Minimal assertion helpers for shell-based tests. Each helper exits the
# process with a failure code so calling test suites stop immediately when an
# expectation is not met.

assert_equal() {
    # Confirm two strings match exactly.
    if [ "$#" -ne 2 ]; then
        printf '%s\n' 'assert_equal: expected 2 arguments' >&2
        exit 1
    fi

    if [ "$1" != "$2" ]; then
        printf "Assertion failed: '%s' != '%s'\n" "$1" "$2" >&2
        exit 1
    fi
}

assert_output() {
    # Run a command and compare its stdout to an expected literal.
    if [ "$#" -ne 2 ]; then
        printf '%s\n' 'assert_output: expected 2 arguments' >&2
        exit 1
    fi

    command=$1
    expected=$2

    output=$(sh -c "$command" sh)
    status=$?

    if [ $status -ne 0 ]; then
        printf "Assertion failed: '%s' exited with status %s\n" "$command" "$status" >&2
        exit 1
    fi

    if [ "$output" != "$expected" ]; then
        printf "Assertion failed: '%s' produced '%s' (expected '%s')\n" "$command" "$output" "$expected" >&2
        exit 1
    fi
}

assert_success() {
    # Ensure a command terminates successfully.
    if [ "$#" -ne 1 ]; then
        printf '%s\n' 'assert_success: expected 1 argument' >&2
        exit 1
    fi

    command=$1
    if ! sh -c "$command" sh; then
        printf "Assertion failed: '%s' did not succeed\n" "$command" >&2
        exit 1
    fi
}

assert_failure() {
    # Ensure a command exits with a non-zero status.
    if [ "$#" -ne 1 ]; then
        printf '%s\n' 'assert_failure: expected 1 argument' >&2
        exit 1
    fi

    command=$1
    if sh -c "$command" sh; then
        printf "Assertion failed: '%s' unexpectedly succeeded\n" "$command" >&2
        exit 1
    fi
}
