#!/bin/sh

# Report terminal dimensions using terminfo via tput.

fathom_terminal_usage() {
    cat <<'USAGE' >&2
Usage: fathom-terminal [-v|--verbose] [--width|--height]

Read terminal dimensions from terminfo and print the width, height, or both.
Pass --width or --height to request a single measurement; -v annotates the
numbers with friendly labels for menu output.
USAGE
}



fathom_terminal() {
case "${1-}" in
--help|--usage|-h)
  fathom_terminal_usage
  return 0
  ;;
esac

require_wizardry || return 1

# Use conditional strictness based on execution context
# See .github/CODE_POLICY_SET_EU.md for details
case "$0" in
  */fathom-terminal)
    # Executed as script - use full strict mode
    set -eu
    ;;
  *)
    # Called as function (sourced) - only undefined variable protection
    # This prevents interactive shell exit while maintaining safety
    set -u
    ;;
esac
env_clear

# Resolve require-command location
# Use command -v to find require-command when preloaded as a function
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
elif command -v require-command >/dev/null 2>&1; then
    require_cmd=require-command
elif command -v require_command >/dev/null 2>&1; then
    require_cmd=require_command
else
    # Fallback to path-based resolution for direct execution
    script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
    if [ -x "$script_dir/require-command" ]; then
        require_cmd="$script_dir/require-command"
    else
        require_cmd=require-command
    fi
fi

verbose=0
want_width=0
want_height=0

# Parse the small option set understood by the menu helper.
while [ "$#" -gt 0 ]; do
    case "$1" in
        -v|--verbose)
            verbose=1
            ;;
        -w|--width)
        want_width=1
        ;;
        --help|--usage|-h)
            fathom_terminal_usage
            return 0
            ;;
        --height)
            want_height=1
            ;;
        --)
            shift
            break
            ;;
        -*)
            fathom_terminal_usage >&2
            return 1
            ;;
        *)
            break
            ;;
        esac

        shift
done

# Unless told otherwise, report both width and height.
if [ "$want_width" -eq 0 ] && [ "$want_height" -eq 0 ]; then
    want_width=1
    want_height=1
fi

# tput is our interface to terminfo; fail loudly when it is absent.
if ! "$require_cmd" tput "The fathom-terminal spell needs 'tput' to query terminfo."; then
    return 1
fi

cols=$(tput cols 2>/dev/null)
cols_status=$?
lines=$(tput lines 2>/dev/null)
lines_status=$?

if [ "$want_width" -eq 1 ]; then
    if [ $cols_status -ne 0 ] || [ -z "$cols" ]; then
        die 'fathom-terminal: unable to determine terminal width'
    fi
fi

if [ "$want_height" -eq 1 ]; then
    if [ $lines_status -ne 0 ] || [ -z "$lines" ]; then
        die 'fathom-terminal: unable to determine terminal height'
    fi
fi

print_dimension() {
    label=$1
    value=$2
    if [ "$verbose" -eq 1 ]; then
        printf '%s: %s\n' "$label" "$value"
    else
        printf '%s\n' "$value"
    fi
}

# Honour the caller's selection of width, height, or both.
if [ "$want_width" -eq 1 ] && [ "$want_height" -eq 1 ]; then
    print_dimension 'Width' "$cols"
    print_dimension 'Height' "$lines"
elif [ "$want_width" -eq 1 ]; then
    print_dimension 'Width' "$cols"
else
    print_dimension 'Height' "$lines"
fi
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
