#!/bin/sh

# Report terminal dimensions using terminfo via tput.


fathom_terminal_usage() {
    cat <<'USAGE' >&2
Usage: fathom-terminal [-v|--verbose] [--width|--height]

Read terminal dimensions from terminfo and print the width, height, or both.
Pass --width or --height to request a single measurement; -v annotates the
numbers with friendly labels for menu output.
USAGE
}



fathom_terminal() {
case "${1-}" in
--help|--usage|-h)
  fathom_terminal_usage
  return 0
  ;;
esac

require-wizardry || return 1

set -eu
. env-clear

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Share the same require-command lookup logic with the other cantrips.
# Inline fathom_terminal_require - only used once
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/require-command" ]; then
    require_cmd="$script_dir/require-command"
else
    require_cmd=require-command
fi

verbose=0
want_width=0
want_height=0

# Parse the small option set understood by the menu helper.
while [ "$#" -gt 0 ]; do
    case "$1" in
        -v|--verbose)
            verbose=1
            ;;
        -w|--width)
        want_width=1
        ;;
        --help|--usage|-h)
            fathom_terminal_usage
            return 0
            ;;
        --height)
            want_height=1
            ;;
        --)
            shift
            break
            ;;
        -*)
            fathom_terminal_usage >&2
            return 1
            ;;
        *)
            break
            ;;
        esac

        shift
done

# Unless told otherwise, report both width and height.
if [ "$want_width" -eq 0 ] && [ "$want_height" -eq 0 ]; then
    want_width=1
    want_height=1
fi

# tput is our interface to terminfo; fail loudly when it is absent.
if ! "$require_cmd" tput "The fathom-terminal spell needs 'tput' to query terminfo."; then
    return 1
fi

cols=$(tput cols 2>/dev/null)
cols_status=$?
lines=$(tput lines 2>/dev/null)
lines_status=$?

if [ "$want_width" -eq 1 ]; then
    if [ $cols_status -ne 0 ] || [ -z "$cols" ]; then
        die 'fathom-terminal: unable to determine terminal width'
    fi
fi

if [ "$want_height" -eq 1 ]; then
    if [ $lines_status -ne 0 ] || [ -z "$lines" ]; then
        die 'fathom-terminal: unable to determine terminal height'
    fi
fi

print_dimension() {
    label=$1
    value=$2
    if [ "$verbose" -eq 1 ]; then
        printf '%s: %s\n' "$label" "$value"
    else
        printf '%s\n' "$value"
    fi
}

# Honour the caller's selection of width, height, or both.
if [ "$want_width" -eq 1 ] && [ "$want_height" -eq 1 ]; then
    print_dimension 'Width' "$cols"
    print_dimension 'Height' "$lines"
elif [ "$want_width" -eq 1 ]; then
    print_dimension 'Width' "$cols"
else
    print_dimension 'Height' "$lines"
fi
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
      _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
      _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
      _d=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
      _r=$(cd "$_d" && while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do cd ..; done; pwd)
      _i="${WIZARDRY_DIR:-${_r}}/spells/.imps/sys"
      [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
