#!/bin/sh
# Performance profiling for the wizardry test suite.
# Times each test individually and reports slowest tests.

# Ensure WIZARDRY_DIR is set for tests
if [ -z "${WIZARDRY_DIR-}" ]; then
  _script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  # Find repository root by looking for spells/.imps directory
  _wiz_root=$(
    cd "$_script_dir" && \
    while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do
      cd ..
    done
    pwd
  )
  WIZARDRY_DIR=$_wiz_root
  export WIZARDRY_DIR
fi

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: profile-tests [--only PATTERN] [--output FILE]

Time each test in the test suite individually and report performance metrics.

Options:
  --only PATTERN    Only profile tests matching PATTERN
  --output FILE     Write detailed report to FILE (default: stdout)
  
Output includes:
  - Total runtime for each test
  - Sorted list of slowest tests
  - Summary statistics

Examples:
  profile-tests
  profile-tests --only "arcane/*"
  profile-tests --output /tmp/test-profile.txt
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Find the script directory and root
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Parse arguments
only_pattern=""
output_file=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        fail "profile-tests: --only requires a pattern"
      fi
      only_pattern="$2"
      shift 2
      ;;
    --output)
      if [ "$#" -lt 2 ]; then
        fail "profile-tests: --output requires a file path"
      fi
      output_file="$2"
      shift 2
      ;;
    *)
      die 2 "profile-tests: unknown option: $1"
      ;;
  esac
done

# Get list of tests to profile
test_list=""
if [ -n "$only_pattern" ]; then
  test_list=$(
    find "$test_dir" -type f \( -name 'test-*.sh' -o -name 'common-*.sh' \) | \
      while IFS= read -r test_path; do
        rel=${test_path#"$test_dir/"}
        # Use fnmatch-style glob matching
        # shellcheck disable=SC2254
        case "$rel" in
          $only_pattern) printf '%s\n' "$test_path" ;;
          *) : ;;  # Explicit no-match case for compatibility
        esac
      done | sort
  )
else
  test_list=$(find "$test_dir" -maxdepth 1 -type f \
    \( -name 'test-*.sh' -o -name 'common-*.sh' \) 2>/dev/null | sort)
  test_list="$test_list
$(find "$test_dir" -mindepth 2 -type f -name 'test-*.sh' 2>/dev/null | sort)"
fi

if [ -z "$test_list" ]; then
  die "profile-tests: no tests found" || exit 1
fi

# Create temporary file for timing data
tmpfile=$(temp-file profile-tests)
on-exit cleanup-file "$tmpfile"

info "Profiling tests..."

# Time each test
test_count=$(printf '%s\n' "$test_list" | grep -c .)
current=0

printf '%s\n' "$test_list" | while IFS= read -r test_path; do
  [ -n "$test_path" ] || continue
  current=$((current + 1))
  
  test_name=$(basename "$test_path" .sh)
  rel_path=${test_path#"$test_dir/"}
  
  printf '\r[%d/%d] %s...' "$current" "$test_count" "$test_name" >&2
  
  # Time the test execution
  start_time=$(date +%s.%N 2>/dev/null || date +%s)
  
  # Run test and capture exit code but suppress output
  test_exit=0
  sh "$test_path" >/dev/null 2>&1 || test_exit=$?
  
  end_time=$(date +%s.%N 2>/dev/null || date +%s)
  
  # Calculate duration
  duration=$(awk -v start="$start_time" -v end="$end_time" \
    'BEGIN { printf "%.3f", end - start; exit }')
  
  # Record: duration|status|path
  printf '%s|%s|%s\n' "$duration" "$test_exit" "$rel_path" >> "$tmpfile"
done

printf '\n' >&2

# Sort results by duration (descending)
sorted_results=$(sort -t'|' -k1 -rn "$tmpfile")

# Calculate statistics
total_time=$(awk -F'|' '{ sum += $1 } END { printf "%.3f", sum }' "$tmpfile")
test_total=$(wc -l < "$tmpfile" | tr -d ' ')
avg_time=$(awk -v total="$total_time" -v count="$test_total" \
  'BEGIN { printf "%.3f", total / count; exit }')
passed=$(awk -F'|' '$2 == 0 { count++ } END { print count+0 }' "$tmpfile")
failed=$(awk -F'|' '$2 != 0 { count++ } END { print count+0 }' "$tmpfile")

# Generate and output report
if [ -n "$output_file" ]; then
  exec > "$output_file"
fi

printf '=================================================\n'
printf 'Test Suite Performance Profile\n'
printf '=================================================\n'
printf '\n'
printf 'Summary:\n'
printf '  Total tests:     %d\n' "$test_total"
printf '  Passed:          %d\n' "$passed"
printf '  Failed:          %d\n' "$failed"
printf '  Total time:      %ss\n' "$total_time"
printf '  Average time:    %ss\n' "$avg_time"
printf '\n'

# Show top 20 slowest tests
printf 'Top 20 Slowest Tests:\n'
printf '%-8s %-8s %s\n' 'TIME(s)' 'STATUS' 'TEST'
printf '%s\n' '-----------------------------------------------'

printf '%s\n' "$sorted_results" | head -20 | while IFS='|' read -r duration status path; do
  status_str="PASS"
  [ "$status" -ne 0 ] && status_str="FAIL"
  printf '%-8s %-8s %s\n' "$duration" "$status_str" "$path"
done

printf '\n'

# Show distribution by time ranges
printf 'Time Distribution:\n'

under_01=$(awk -F'|' '$1 < 0.1 { count++ } END { print count+0 }' "$tmpfile")
range_01_05=$(awk -F'|' '$1 >= 0.1 && $1 < 0.5 { count++ } END { print count+0 }' "$tmpfile")
range_05_1=$(awk -F'|' '$1 >= 0.5 && $1 < 1.0 { count++ } END { print count+0 }' "$tmpfile")
range_1_5=$(awk -F'|' '$1 >= 1.0 && $1 < 5.0 { count++ } END { print count+0 }' "$tmpfile")
range_5_10=$(awk -F'|' '$1 >= 5.0 && $1 < 10.0 { count++ } END { print count+0 }' "$tmpfile")
over_10=$(awk -F'|' '$1 >= 10.0 { count++ } END { print count+0 }' "$tmpfile")

printf '  < 0.1s:     %d tests\n' "$under_01"
printf '  0.1-0.5s:   %d tests\n' "$range_01_05"
printf '  0.5-1.0s:   %d tests\n' "$range_05_1"
printf '  1.0-5.0s:   %d tests\n' "$range_1_5"
printf '  5.0-10.0s:  %d tests\n' "$range_5_10"
printf '  > 10.0s:    %d tests\n' "$over_10"

printf '\n'
printf 'Complete Results (sorted by duration):\n'
printf '%-8s %-8s %s\n' 'TIME(s)' 'STATUS' 'TEST'
printf '%s\n' '-----------------------------------------------'

printf '%s\n' "$sorted_results" | while IFS='|' read -r duration status path; do
  status_str="PASS"
  [ "$status" -ne 0 ] && status_str="FAIL"
  printf '%-8s %-8s %s\n' "$duration" "$status_str" "$path"
done

if [ -n "$output_file" ]; then
  exec >&2
  printf 'Performance profile written to: %s\n' "$output_file"
fi

# Cleanup
trap - EXIT HUP INT TERM
rm -f "$tmpfile"
