#!/bin/sh
# Performance profiling for the wizardry test suite.
# Times each test individually and reports slowest tests.

# Ensure WIZARDRY_DIR is set for tests
if [ -z "${WIZARDRY_DIR-}" ]; then
  script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
  # Find repository root by looking for spells/.imps directory
  wiz_root=$(
    cd "$script_dir" && \
    while [ ! -d "spells/.imps" ] && [ "$(pwd)" != "/" ]; do
      cd ..
    done
    pwd
  )
  WIZARDRY_DIR=$wiz_root
  export WIZARDRY_DIR
fi

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: profile-tests [--only PATTERN] [--output FILE]

Time each test in the test suite individually and report performance metrics.

Options:
  --only PATTERN    Only profile tests matching PATTERN
  --output FILE     Write detailed report to FILE (default: stdout)
  
Output includes:
  - Total runtime for each test
  - Sorted list of slowest tests
  - Summary statistics

Examples:
  profile-tests
  profile-tests --only "arcane/*"
  profile-tests --output /tmp/test-profile.txt
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Find the script directory and root
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Helper function for pattern matching (defined outside command substitution to avoid macOS bash issues)
matches_pattern() {
  mp_path=$1
  mp_pattern=$2
  mp_rel=${mp_path#"$test_dir/"}
  case "$mp_rel" in
    $mp_pattern) return 0 ;;
    *) return 1 ;;
  esac
}

# Parse arguments
only_pattern=""
output_file=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        fail "profile-tests: --only requires a pattern"
      fi
      only_pattern="$2"
      shift 2
      ;;
    --output)
      if [ "$#" -lt 2 ]; then
        fail "profile-tests: --output requires a file path"
      fi
      output_file="$2"
      shift 2
      ;;
    *)
      die 2 "profile-tests: unknown option: $1"
      ;;
  esac
done

# Get list of tests to profile
test_list=""
if [ -n "$only_pattern" ]; then
  # Build list more efficiently using temporary file
  tmplist=$(temp-file profile-list)
  find "$test_dir" -type f \( -name 'test-*.sh' -o -name 'common-*.sh' \) 2>/dev/null | \
    while IFS= read -r test_path; do
      if matches_pattern "$test_path" "$only_pattern"; then
        printf '%s\n' "$test_path"
      fi
    done | sort > "$tmplist"
  test_list=$(cat "$tmplist")
  rm -f "$tmplist"
else
  # Use single find command for better performance
  test_list=$(find "$test_dir" -type f \
    \( -name 'test-*.sh' -o -name 'common-*.sh' \) 2>/dev/null | sort)
fi

if [ -z "$test_list" ]; then
  die "profile-tests: no tests found" || exit 1
fi

# Create temporary file for timing data
tmpfile=$(temp-file profile-tests)
on-exit cleanup-file "$tmpfile"

info "Profiling tests..."

# Time each test - optimized to reduce subshell spawns
test_count=$(printf '%s\n' "$test_list" | grep -c .)
current=0

# Check once if nanosecond timing is available
has_nanoseconds=0
if date +%s.%N >/dev/null 2>&1; then
  has_nanoseconds=1
fi

# Process tests - write directly to tmpfile to avoid subshell overhead
printf '%s\n' "$test_list" | {
  while IFS= read -r test_path; do
    [ -n "$test_path" ] || continue
    current=$((current + 1))
    
    test_name=$(basename "$test_path" .sh)
    rel_path=${test_path#"$test_dir/"}
    
    printf '\r[%d/%d] %s...' "$current" "$test_count" "$test_name" >&2
    
    # Time the test execution - timing method determined once above
    if [ "$has_nanoseconds" -eq 1 ]; then
      start_time=$(date +%s.%N)
      test_exit=0
      sh "$test_path" >/dev/null 2>&1 || test_exit=$?
      end_time=$(date +%s.%N)
      duration=$(awk -v start="$start_time" -v end="$end_time" \
        'BEGIN { printf "%.3f", end - start; exit }')
    else
      start_time=$(date +%s)
      test_exit=0
      sh "$test_path" >/dev/null 2>&1 || test_exit=$?
      end_time=$(date +%s)
      duration=$((end_time - start_time))
      duration=$(printf '%d.000' "$duration")
    fi
    
    # Record: duration|status|path
    printf '%s|%s|%s\n' "$duration" "$test_exit" "$rel_path"
  done
} >> "$tmpfile"

printf '\n' >&2

# Sort results by duration (descending) and calculate all statistics in one pass
sorted_results=$(sort -t'|' -k1 -rn "$tmpfile")

# Calculate all statistics in a single awk pass for efficiency
stats=$(awk -F'|' '
  {
    duration = $1
    status = $2
    
    # Collect data
    total_time += duration
    count++
    if (status == 0) passed++
    else failed++
    
    # Time distribution
    if (duration < 0.1) under_01++
    else if (duration < 0.5) range_01_05++
    else if (duration < 1.0) range_05_1++
    else if (duration < 5.0) range_1_5++
    else if (duration < 10.0) range_5_10++
    else over_10++
  }
  END {
    printf "%d|%d|%d|%.3f|%.3f|%d|%d|%d|%d|%d|%d\n", 
      count, passed, failed, total_time, (count > 0 ? total_time/count : 0),
      under_01, range_01_05, range_05_1, range_1_5, range_5_10, over_10
  }
' "$tmpfile")

# Parse statistics
test_total=$(printf '%s' "$stats" | cut -d'|' -f1)
passed=$(printf '%s' "$stats" | cut -d'|' -f2)
failed=$(printf '%s' "$stats" | cut -d'|' -f3)
total_time=$(printf '%s' "$stats" | cut -d'|' -f4)
avg_time=$(printf '%s' "$stats" | cut -d'|' -f5)
under_01=$(printf '%s' "$stats" | cut -d'|' -f6)
range_01_05=$(printf '%s' "$stats" | cut -d'|' -f7)
range_05_1=$(printf '%s' "$stats" | cut -d'|' -f8)
range_1_5=$(printf '%s' "$stats" | cut -d'|' -f9)
range_5_10=$(printf '%s' "$stats" | cut -d'|' -f10)
over_10=$(printf '%s' "$stats" | cut -d'|' -f11)

# Generate and output report
if [ -n "$output_file" ]; then
  exec > "$output_file"
fi

printf '=================================================\n'
printf 'Test Suite Performance Profile\n'
printf '=================================================\n'
printf '\n'
printf 'Summary:\n'
printf '  Total tests:     %d\n' "$test_total"
printf '  Passed:          %d\n' "$passed"
printf '  Failed:          %d\n' "$failed"
printf '  Total time:      %ss\n' "$total_time"
printf '  Average time:    %ss\n' "$avg_time"
printf '\n'

# Show top 20 slowest tests
printf 'Top 20 Slowest Tests:\n'
printf '%-8s %-8s %s\n' 'TIME(s)' 'STATUS' 'TEST'
printf '%s\n' '-----------------------------------------------'

printf '%s\n' "$sorted_results" | head -20 | while IFS='|' read -r duration status path; do
  status_str="PASS"
  [ "$status" -ne 0 ] && status_str="FAIL"
  printf '%-8s %-8s %s\n' "$duration" "$status_str" "$path"
done

printf '\n'

# Show distribution by time ranges
printf 'Time Distribution:\n'

printf '  < 0.1s:     %d tests\n' "$under_01"
printf '  0.1-0.5s:   %d tests\n' "$range_01_05"
printf '  0.5-1.0s:   %d tests\n' "$range_05_1"
printf '  1.0-5.0s:   %d tests\n' "$range_1_5"
printf '  5.0-10.0s:  %d tests\n' "$range_5_10"
printf '  > 10.0s:    %d tests\n' "$over_10"

printf '\n'
printf 'Complete Results (sorted by duration):\n'
printf '%-8s %-8s %s\n' 'TIME(s)' 'STATUS' 'TEST'
printf '%s\n' '-----------------------------------------------'

printf '%s\n' "$sorted_results" | while IFS='|' read -r duration status path; do
  status_str="PASS"
  [ "$status" -ne 0 ] && status_str="FAIL"
  printf '%-8s %-8s %s\n' "$duration" "$status_str" "$path"
done

if [ -n "$output_file" ]; then
  exec >&2
  printf 'Performance profile written to: %s\n' "$output_file"
fi

# Cleanup
trap - EXIT HUP INT TERM
rm -f "$tmpfile"
