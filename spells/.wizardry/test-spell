#!/bin/sh

# Run individual test files with optional subtest filtering.

# CRITICAL: Seed a baseline PATH BEFORE set -eu and before any commands
# On macOS GitHub Actions, PATH may be completely empty, causing immediate failure
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*)
    # Already has at least one standard directory
    ;;
  *)
    # PATH is empty or missing standard directories, prepend baseline
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac

# Parse options before help check
run_common_tests=1  # Default: run common tests
while [ "$#" -gt 0 ]; do
  case "$1" in
    --skip-common)
      run_common_tests=0
      shift
      ;;
    --help|--usage|-h)
      cat <<'USAGE'
Usage: test-spell [--skip-common] TEST_PATH [SUBTEST_NUM...]

Run a specific test file from the .tests/ directory with common structural tests.

By default, test-spell runs BOTH the spell's specific test file AND common
structural/behavioral tests on that spell. This ensures full test coverage.

Options:
  --skip-common  Skip common structural tests (only run the spell's test file)

Arguments:
  TEST_PATH      Path to test file (relative to .tests/)
  SUBTEST_NUM    Optional subtest number(s) to run (can specify multiple)

Examples:
  test-spell cantrips/test-ask-yn.sh              # Runs test + common tests
  test-spell --skip-common cantrips/test-ask-yn.sh # Runs test only
  test-spell cantrips/test-ask-yn.sh 5             # Runs subtest #5 only
  test-spell cantrips/test-ask-yn.sh 5 10 15       # Runs subtests 5, 10, 15

For AI: Use test-spell to test individual spells quickly. It automatically runs
both the spell's specific tests AND common structural checks. This is much faster
than running test-magic on all tests when you only changed one spell.

Use --skip-common only if you need to debug a specific test failure without
the additional common test output.

Environment variables:
  WIZARDRY_TEST_TIMEOUT    Timeout in seconds for the test (default: 180)
USAGE
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      cat <<'USAGE'
Usage: test-spell [--skip-common] TEST_PATH [SUBTEST_NUM...]

Run a specific test file from the .tests/ directory with common structural tests.

Options:
  --skip-common  Skip common structural tests (only run the spell's test file)

Arguments:
  TEST_PATH      Path to test file (relative to .tests/)
  SUBTEST_NUM    Optional subtest number(s) to run (can specify multiple)
USAGE
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

set -eu

cmd_name=$(basename "$0")
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH so we can use them directly
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

export PATH

# Set WIZARDRY_DIR for tests
WIZARDRY_DIR=$root_dir
export WIZARDRY_DIR

# Add boot imps to PATH so they're available as commands
# (Don't source them - they're meant to be executed as scripts)
for boot_dir in "$root_dir"/spells/.imps/test/boot; do
  [ -d "$boot_dir" ] || continue
  PATH="$boot_dir:$PATH"
done
export PATH

# With PATH-based approach, imps are available directly
# No need to preload with word_of_binding or clear environment

# Check required arguments
if [ "$#" -lt 1 ]; then
  cat >&2 <<'USAGE'
Usage: test-spell [--skip-common] TEST_PATH [SUBTEST_NUM...]

Run a specific test file from the .tests/ directory with common structural tests.

Options:
  --skip-common  Skip common structural tests (only run the spell's test file)

Arguments:
  TEST_PATH      Path to test file (relative to .tests/)
  SUBTEST_NUM    Optional subtest number(s) to run (can specify multiple)
USAGE
  exit 2
fi

test_path=$1
shift

# Convert test path to absolute path
# Support both relative paths (from .tests/) and absolute paths
case "$test_path" in
  /*)
    # Absolute path
    abs_test="$test_path"
    # Extract relative path from absolute
    rel_test=${abs_test#"$test_dir/"}
    ;;
  *)
    # Relative path from .tests/
    rel_test="$test_path"
    abs_test="$test_dir/$test_path"
    ;;
esac

# Verify test file exists
if [ ! -f "$abs_test" ]; then
  die "$cmd_name: test file not found: $abs_test"
fi

# Determine the spell path from the test path for common tests
spell_path=""
if [ "$run_common_tests" -eq 1 ]; then
  # Convert test path to spell path
  # Example: cantrips/test-ask-yn.sh -> cantrips/ask-yn
  dir=$(dirname "$rel_test")
  base=$(basename "$rel_test")
  base=${base#test-}
  base=${base%.sh}
  
  # Handle special cases
  case "$rel_test" in
    common-tests.sh)
      # Skip common tests on common-tests itself
      spell_path=""
      ;;
    *)
      # Construct spell path
      if [ "$dir" = "." ]; then
        spell_path="$base"
      else
        spell_path="$dir/$base"
      fi
      
      # Verify spell exists
      if [ ! -f "$root_dir/spells/$spell_path" ]; then
        warn "$cmd_name: cannot run common tests: spell not found at spells/$spell_path"
        spell_path=""
      fi
      ;;
  esac
fi

# Parse subtest numbers if provided
subtest_filter=""
if [ "$#" -gt 0 ]; then
  subtest_filter="$*"
fi

# Check if timeout command is available
timeout_cmd=""
if has timeout; then
  timeout_cmd="timeout"
fi

# Initialize global subtest counter for tests
WIZARDRY_GLOBAL_SUBTEST_NUM=0
export WIZARDRY_GLOBAL_SUBTEST_NUM

# Count total number of run_test_case calls in the test file to show [x/y] format
# This gives better context during test execution
# Count only the current test file, not common-tests (they run separately)
if [ -f "$abs_test" ]; then
  pattern="^run_test_case\|^_run_both_patterns"
  WIZARDRY_GLOBAL_SUBTEST_TOTAL=$(grep -c "$pattern" "$abs_test" 2>/dev/null || echo "0")
  export WIZARDRY_GLOBAL_SUBTEST_TOTAL
fi

# Run the test
test_timeout="${WIZARDRY_TEST_TIMEOUT:-180}"

if [ -n "$subtest_filter" ]; then
  # Filter mode: only run specified subtests
  # We need to intercept the test output and filter based on subtest numbers
  
  # Create temp file for full test output and set trap immediately
  output_file=$(temp-file test-spell-output) || return 1
  trap 'cleanup-file "$output_file"' EXIT HUP INT TERM
  
  # Run test and capture output
  if [ -n "$timeout_cmd" ]; then
    if ! "$timeout_cmd" "$test_timeout" sh < /dev/null "$abs_test" > "$output_file" 2>&1; then
      exit_code=$?
      if [ "$exit_code" -eq 124 ] || [ "$exit_code" -eq 143 ]; then
        die "$cmd_name: test timed out after ${test_timeout}s"
      fi
      # Test failed, but we'll show filtered output
    fi
  else
    sh < /dev/null "$abs_test" > "$output_file" 2>&1 || true
  fi
  
  # Parse and filter output
  # Show only the specified subtest lines
  current_subtest=0
  pass_count=0
  fail_count=0
  
  while IFS= read -r line; do
    # Detect subtest lines (PASS/FAIL #N format)
    case "$line" in
      "  PASS #"*|"  FAIL #"*|"PASS #"*|"FAIL #"*)
        # Extract subtest number (use extended regex for portability)
        num=$(printf '%s' "$line" | sed -E 's/^[[:space:]]*(PASS|FAIL) #([0-9]+).*/\2/')
        
        # Skip if number extraction failed (empty or non-numeric)
        case "$num" in
          ''|*[!0-9]*) continue ;;
        esac
        
        # Check if this subtest should be shown
        show_line=0
        for wanted in $subtest_filter; do
          if [ "$num" = "$wanted" ]; then
            show_line=1
            break
          fi
        done
        
        if [ "$show_line" -eq 1 ]; then
          printf '%s\n' "$line"
          case "$line" in
            *"PASS"*) pass_count=$((pass_count + 1)) ;;
            *"FAIL"*) fail_count=$((fail_count + 1)) ;;
          esac
        fi
        ;;
      *" tests passed"*)
        # Show summary line at end
        total=$((pass_count + fail_count))
        if [ "$total" -gt 0 ]; then
          printf '%d/%d tests passed\n' "$pass_count" "$total"
        fi
        ;;
    esac
  done < "$output_file"
  
  # Exit with success if all selected subtests passed
  # Trap will clean up the temp file automatically
  if [ "$fail_count" -eq 0 ] && [ "$pass_count" -gt 0 ]; then
    return 0
  else
    return 1
  fi
else
  # Normal mode: run full test in subshell (for isolation)
  # Functions from invoke-wizardry are already loaded in parent shell
  test_exit_code=0
  
  if [ "$run_common_tests" -eq 1 ] && [ -n "$spell_path" ]; then
    # Run in subshell - needs to inherit invoke-wizardry environment
    if [ -n "$timeout_cmd" ]; then
      # With timeout
      "$timeout_cmd" "$test_timeout" sh "$abs_test" < /dev/null || test_exit_code=$?
    else
      # No timeout
      sh "$abs_test" < /dev/null || test_exit_code=$?
    fi
  else
    # Can use exec - no common tests to run after
    if [ -n "$timeout_cmd" ]; then
      exec "$timeout_cmd" "$test_timeout" sh "$abs_test" < /dev/null
    else
      exec sh "$abs_test" < /dev/null
    fi
  fi
  
  # If main test failed, return failure immediately
  if [ "$test_exit_code" -ne 0 ]; then
    return "$test_exit_code"
  fi
  
  # Run common tests if requested and spell path was determined
  if [ "$run_common_tests" -eq 1 ] && [ -n "$spell_path" ]; then
    info ""
    info "Running common tests on spells/$spell_path..."
    
    # Reset counter and set total for common-tests
    # Common tests run in a separate shell, so we export these for them
    WIZARDRY_GLOBAL_SUBTEST_NUM=0
    if [ -f "$test_dir/common-tests.sh" ]; then
      pattern="^run_test_case\|^_run_both_patterns"
      count=$(grep -c "$pattern" "$test_dir/common-tests.sh" 2>/dev/null || echo "0")
      WIZARDRY_GLOBAL_SUBTEST_TOTAL=$count
    fi
    export WIZARDRY_GLOBAL_SUBTEST_NUM
    export WIZARDRY_GLOBAL_SUBTEST_TOTAL
    
    # Run common-tests.sh with the spell path
    if [ -n "$timeout_cmd" ]; then
      "$timeout_cmd" "$test_timeout" sh < /dev/null "$test_dir/common-tests.sh" "spells/$spell_path"
    else
      sh < /dev/null "$test_dir/common-tests.sh" "spells/$spell_path"
    fi
  fi
fi
