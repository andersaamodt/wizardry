#!/bin/sh
# Diagnostic script to test exit 139 hypotheses in parse/glosses system
#
# This script tests the top 5 most likely causes of SIGSEGV (exit 139):
# 1. Gloss→parse→gloss infinite recursion
# 2. Stack overflow from deep nesting
# 3. Memory exhaustion from too many functions
# 4. Exec misuse replacing process
# 5. ARG_MAX exceeded from very long commands

set -eu

say() { printf '%s\n' "$*" >&2; }
test_pass() { say "✓ $1"; }
test_fail() { say "✗ $1: $2"; }
test_skip() { say "⊘ $1 (skipped)"; }

# ==============================================================================
# Test 1: Gloss→Parse→Gloss Recursion Detection
# ==============================================================================
test_gloss_parse_recursion() {
  say ""
  say "=== Test 1: Gloss→Parse→Gloss Recursion ==="
  
  # Create a test gloss that calls parse
  _test_file=/tmp/test-recursion-$$
  cat > "$_test_file" << 'EOF'
#!/bin/sh
# Simulate gloss calling parse
_recursion_depth=${_GLOSS_DEPTH:-0}
if [ "$_recursion_depth" -gt 10 ]; then
  echo "RECURSION DETECTED: depth=$_recursion_depth"
  exit 1
fi
export _GLOSS_DEPTH=$((_recursion_depth + 1))
# This would normally call parse, creating recursion
echo "Depth: $_GLOSS_DEPTH"
EOF
  
  chmod +x "$_test_file"
  
  if sh "$_test_file" >/dev/null 2>&1; then
    test_pass "No recursion in isolated test"
  else
    test_fail "Recursion test" "depth limit hit"
  fi
  
  rm -f "$_test_file"
}

# ==============================================================================
# Test 2: Stack Depth Monitoring
# ==============================================================================
test_stack_depth() {
  say ""
  say "=== Test 2: Stack Overflow Detection ==="
  
  # Test deep function nesting
  _test_file=/tmp/test-stack-$$
  cat > "$_test_file" << 'EOF'
#!/bin/sh
recurse() {
  _depth=${1:-0}
  if [ "$_depth" -gt 1000 ]; then
    echo "Max depth: $_depth"
    return 0
  fi
  recurse $((_depth + 1))
}
recurse 0
EOF
  
  if timeout 5 sh "$_test_file" >/dev/null 2>&1; then
    test_pass "Stack depth test completed"
  else
    test_fail "Stack depth" "exceeded limits or timeout"
  fi
  
  rm -f "$_test_file"
}

# ==============================================================================
# Test 3: Memory Exhaustion from Function Generation
# ==============================================================================
test_memory_exhaustion() {
  say ""
  say "=== Test 3: Memory Exhaustion Detection ==="
  
  # Generate many functions and test eval
  _test_file=/tmp/test-memory-$$
  
  say "Generating 1000 test functions..."
  {
    echo "#!/bin/sh"
    _i=0
    while [ "$_i" -lt 1000 ]; do
      echo "test_fn_$_i() { echo 'fn$_i'; }"
      _i=$((_i + 1))
    done
    echo "test_fn_999"
  } > "$_test_file"
  
  if timeout 10 sh "$_test_file" >/dev/null 2>&1; then
    test_pass "1000 functions generated and executed"
  else
    test_fail "Memory exhaustion" "failed to execute 1000 functions"
  fi
  
  rm -f "$_test_file"
}

# ==============================================================================
# Test 4: Exec Behavior with Functions
# ==============================================================================
test_exec_behavior() {
  say ""
  say "=== Test 4: Exec Misuse Detection ==="
  
  _test_file=/tmp/test-exec-$$
  cat > "$_test_file" << 'EOF'
#!/bin/sh
# Test if exec replaces process when called on function
test_func() {
  echo "In function"
}

# This should NOT exec a function (functions can't be exec'd)
if command -v test_func >/dev/null 2>&1; then
  # Try to exec it (should fail gracefully)
  exec test_func 2>/dev/null || echo "Exec failed as expected"
fi
EOF
  
  if timeout 5 sh "$_test_file" 2>&1 | grep -q "expected"; then
    test_pass "Exec behavior normal"
  else
    test_fail "Exec behavior" "unexpected result"
  fi
  
  rm -f "$_test_file"
}

# ==============================================================================
# Test 5: ARG_MAX Limits
# ==============================================================================
test_arg_max() {
  say ""
  say "=== Test 5: ARG_MAX/Command Length Limits ==="
  
  # Get ARG_MAX limit
  if command -v getconf >/dev/null 2>&1; then
    _arg_max=$(getconf ARG_MAX 2>/dev/null || echo 131072)
    say "System ARG_MAX: $_arg_max bytes"
  else
    _arg_max=131072
    say "System ARG_MAX: unknown (assuming 128KB)"
  fi
  
  # Test with very long command line
  _long_str=""
  _i=0
  while [ $_i -lt 1000 ]; do
    _long_str="${_long_str}arg$_i "
    _i=$((_i + 1))
  done
  
  if printf '%s\n' "$_long_str" | wc -c >/dev/null 2>&1; then
    test_pass "Long command line handled"
  else
    test_fail "ARG_MAX" "failed with long arguments"
  fi
}

# ==============================================================================
# Test 6: Circular Synonym Detection
# ==============================================================================
test_circular_synonyms() {
  say ""
  say "=== Test 6: Circular Synonym Chain Detection ==="
  
  _test_file=/tmp/test-circular-$$
  cat > "$_test_file" << 'EOF'
#!/bin/sh
# Simulate circular synonym chain: a->b->c->a
_visited=""

check_synonym() {
  _name=$1
  case " $_visited " in
    *" $_name "*) echo "CIRCULAR: $_name"; return 1 ;;
  esac
  _visited="$_visited $_name"
  
  case "$_name" in
    a) check_synonym b ;;
    b) check_synonym c ;;
    c) check_synonym a ;;
    *) return 0 ;;
  esac
}

check_synonym a
EOF
  
  if sh "$_test_file" 2>&1 | grep -q "CIRCULAR"; then
    test_pass "Circular synonym detection works"
  else
    test_fail "Circular detection" "did not detect loop"
  fi
  
  rm -f "$_test_file"
}

# ==============================================================================
# Test 7: Generate-Glosses Safety Check
# ==============================================================================
test_generate_glosses_safety() {
  say ""
  say "=== Test 7: Generate-Glosses Safety Checks ==="
  
  if [ ! -f "./spells/.wizardry/generate-glosses" ]; then
    test_skip "generate-glosses not in current directory"
    return
  fi
  
  # Test that generate-glosses completes without hanging
  if timeout 60 ./spells/.wizardry/generate-glosses --quiet >/dev/null 2>&1; then
    test_pass "generate-glosses completes without timeout"
  else
    test_fail "generate-glosses" "timed out after 60s"
  fi
}

# ==============================================================================
# Test 8: Parse Safety Check
# ==============================================================================
test_parse_safety() {
  say ""
  say "=== Test 8: Parse Script Safety ==="
  
  if [ ! -f "./spells/.imps/lex/parse" ]; then
    test_skip "parse not in current directory"
    return
  fi
  
  # Test parse with safe input
  if timeout 5 ./spells/.imps/lex/parse echo hello 2>&1 | grep -q "DISABLED"; then
    test_pass "parse returns expected DISABLED message"
  else
    test_skip "parse not disabled or not found"
  fi
}

# ==============================================================================
# Main Execution
# ==============================================================================
say "========================================"
say "Exit 139 Diagnostic Test Suite"
say "========================================"
say ""
say "Testing top hypotheses for SIGSEGV in parse/glosses system"

test_gloss_parse_recursion
test_stack_depth  
test_memory_exhaustion
test_exec_behavior
test_arg_max
test_circular_synonyms
test_generate_glosses_safety
test_parse_safety

say ""
say "========================================"
say "Diagnostic Tests Complete"
say "========================================"
say ""
say "If any tests failed, they indicate potential causes"
say "of exit 139 in your environment."
