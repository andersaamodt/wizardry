#!/bin/sh

# Validate that specified spells and imps exist in wizardry installation.
# Used by banish, test-magic, and demo-magic to verify spell availability.

validate_spells_usage() {
  cat <<'USAGE'
Usage: validate-spells [OPTIONS] SPELL...

Validate that specified spells or imps exist in the wizardry installation.

Arguments:
  SPELL...              One or more spells to validate
                        Format: "spell" or "spell:dir" or "imp:.imps/family/name"

Options:
  --quiet, -q           Only report missing spells (no success messages)
  --missing-only        Return list of missing spells on stdout
  --imps                Validate imps instead of spells
  --show-status         Show detailed status (loaded vs available)

Examples:
  validate-spells ask-yn menu                    # Check cantrips
  validate-spells hash:crypto evoke-hash:crypto  # Check crypto spells  
  validate-spells --imps sys/has cond/there      # Check imps
  missing=$(validate-spells --missing-only ask-yn menu)  # Get missing list

Exit Codes:
  0  All spells/imps found
  1  One or more spells/imps missing
  2  Invalid usage
USAGE
}

case "${1-}" in
--help|--usage|-h)
  validate_spells_usage
  exit 0
  ;;
esac

set -eu

# Validate WIZARDRY_DIR is set and valid
if [ -z "${WIZARDRY_DIR-}" ]; then
  printf 'validate-spells: WIZARDRY_DIR not set\n' >&2
  printf 'Run this from banish or set WIZARDRY_DIR explicitly\n' >&2
  exit 1
fi

if [ ! -d "${WIZARDRY_DIR}/spells" ]; then
  printf 'validate-spells: invalid WIZARDRY_DIR: %s\n' "$WIZARDRY_DIR" >&2
  exit 1
fi

_vs_pluralize="${WIZARDRY_DIR}/spells/.imps/text/pluralize"
_vs_count_words="${WIZARDRY_DIR}/spells/.imps/text/count-words"

# Parse options
quiet=0
missing_only=0
validate_imps=0
show_status=0
default_dir="cantrips"

while [ "$#" -gt 0 ]; do
  case "$1" in
    --quiet|-q)
      quiet=1
      shift
      ;;
    --missing-only)
      missing_only=1
      quiet=1
      shift
      ;;
    --imps)
      validate_imps=1
      default_dir=".imps"
      shift
      ;;
    --show-status)
      show_status=1
      shift
      ;;
    -*)
      printf 'validate-spells: unknown option: %s\n' "$1" >&2
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

if [ "$#" -eq 0 ]; then
  printf 'validate-spells: no spells specified\n' >&2
  exit 2
fi

# Validate each spell
missing=""
found_count=0
loaded_count=0
available_count=0

# For imps with --show-status, we'll collect results for grouped output
# Store results as newline-separated "status|name" entries
imp_results=""
imp_unavailable=""

# For spells with --show-status, collect grouped output
spell_loaded=""
spell_available=""
spell_unavailable=""

for spell_info in "$@"; do
  status_override=""
  # Parse spell:dir format (or category:status:name for imps)
  if [ "$validate_imps" -eq 1 ]; then
    case "$spell_info" in
      *:*:*)
        category=${spell_info%%:*}
        rest=${spell_info#*:}
        status=${rest%%:*}
        name_rest=${rest#*:}
        case "$status" in
          L|A) status_override=$status ;;
          *) status_override="" ;;
        esac
        spell="${category}/${name_rest}"
        dir=$default_dir
        ;;
      *)
        spell=$spell_info
        dir=$default_dir
        ;;
    esac
  else
    case "$spell_info" in
      *:*)
        spell=$(printf '%s' "$spell_info" | cut -d: -f1)
        dir=$(printf '%s' "$spell_info" | cut -d: -f2)
        ;;
      *)
        spell=$spell_info
        dir=$default_dir
        ;;
    esac
  fi
  
  # Check if spell/imp exists
  if [ "$validate_imps" -eq 1 ]; then
    spell_path="${WIZARDRY_DIR}/spells/.imps/$spell"
  else
    spell_path="${WIZARDRY_DIR}/spells/$dir/$spell"
  fi
  
  # Determine function name
  if [ "$validate_imps" -eq 1 ]; then
    # For imps, extract just the name part after the family/
    # Keep hyphens as-is (imps use hyphenated names)
    func_name=$(printf '%s' "$spell" | sed 's|.*/||')
  else
    # For spells, use hyphenated name as-is
    func_name=$(printf '%s' "$spell" | sed 's|.*/||')
  fi
  
  # Check if loaded as function (try both hyphenated and underscored versions)
  is_loaded=0
  if [ -n "$status_override" ]; then
    if [ "$status_override" = "L" ]; then
      is_loaded=1
    fi
  else
    for name_variant in "$func_name" "$(printf '%s' "$func_name" | tr '-' '_')"; do
      if command -v "$name_variant" >/dev/null 2>&1; then
        func_type=$(type "$name_variant" 2>/dev/null || true)
        case "$func_type" in
          *"function"*|*"shell function"*)
            is_loaded=1
            break
            ;;
        esac
      fi
    done
  fi
  
  if [ -f "$spell_path" ]; then
    found_count=$((found_count + 1))
    
    if [ "$is_loaded" -eq 1 ]; then
      loaded_count=$((loaded_count + 1))
      
      # For imps with --show-status, store result for later output
      if [ "$validate_imps" -eq 1 ] && [ "$show_status" -eq 1 ]; then
        imp_name=$(printf '%s' "$spell" | sed 's|.*/||')
        # Format: status|name (status: L=loaded, A=available)
        imp_results="${imp_results}${imp_results:+
}L|${imp_name}"
      elif [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
        # For spells, collect grouped output
        spell_loaded="${spell_loaded}${spell_loaded:+ }${spell}"
      fi
    else
      available_count=$((available_count + 1))
      
      # For imps with --show-status, store result for later output
      if [ "$validate_imps" -eq 1 ] && [ "$show_status" -eq 1 ]; then
        imp_name=$(printf '%s' "$spell" | sed 's|.*/||')
        # Format: status|name (status: L=loaded, A=available)
        imp_results="${imp_results}${imp_results:+
}A|${imp_name}"
      elif [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
        # For spells, collect grouped output
        spell_available="${spell_available}${spell_available:+ }${spell}"
      fi
    fi
    
    if [ "$quiet" -eq 0 ] && [ "$show_status" -eq 0 ]; then
      if [ "$validate_imps" -eq 1 ]; then
        printf '✓ Found imp: %s\n' "$spell"
      else
        printf '✓ Found spell: %s\n' "$spell"
      fi
    fi
  else
    missing="${missing:+$missing }$spell"
    if [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
      if [ "$validate_imps" -eq 1 ]; then
        imp_name=$(printf '%s' "$spell" | sed 's|.*/||')
        imp_unavailable="${imp_unavailable}${imp_unavailable:+ }${imp_name}"
      else
        spell_unavailable="${spell_unavailable}${spell_unavailable:+ }${spell}"
      fi
    fi
  fi
done

# Output grouped results for spells with --show-status
if [ "$validate_imps" -eq 0 ] && [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
  if [ -n "$spell_loaded" ]; then
    spell_loaded_count=$("$_vs_count_words" "$spell_loaded")
    label=$("$_vs_pluralize" "spell" "$spell_loaded_count" "spells")
    printf '\033[32m✓\033[0m Loaded %s\n' "$label"
    printf '%s\n' "$spell_loaded" | tr ' ' '\n' | while IFS= read -r spell; do
      [ -n "$spell" ] && printf '  \033[32m✓\033[0m %s\n' "$spell"
    done
  fi

  if [ -n "$spell_available" ]; then
    spell_available_count=$("$_vs_count_words" "$spell_available")
    label=$("$_vs_pluralize" "spell" "$spell_available_count" "spells")
    printf '\033[34m●\033[0m Available %s\n' "$label"
    printf '%s\n' "$spell_available" | tr ' ' '\n' | while IFS= read -r spell; do
      [ -n "$spell" ] && printf '  \033[34m●\033[0m %s\n' "$spell"
    done
  fi

  if [ -n "$spell_unavailable" ]; then
    spell_unavailable_count=$("$_vs_count_words" "$spell_unavailable")
    label=$("$_vs_pluralize" "spell" "$spell_unavailable_count" "spells")
    printf '\033[31m✗\033[0m Missing %s\n' "$label"
    printf '%s\n' "$spell_unavailable" | tr ' ' '\n' | while IFS= read -r spell; do
      [ -n "$spell" ] && printf '  \033[31m✗\033[0m %s\n' "$spell"
    done
  fi
fi

# Output grouped results for imps with --show-status
if [ "$validate_imps" -eq 1 ] && [ "$quiet" -eq 0 ] && [ "$show_status" -eq 1 ]; then
  loaded_imps=""
  available_imps=""

  if [ -n "$imp_results" ]; then
    while IFS='|' read -r result_status result_name; do
      [ -z "$result_status" ] && continue
      if [ "$result_status" = "L" ]; then
        loaded_imps="${loaded_imps}${loaded_imps:+ }${result_name}"
      else
        available_imps="${available_imps}${available_imps:+ }${result_name}"
      fi
    done <<EOF
$imp_results
EOF
  fi

  if [ -n "$loaded_imps" ]; then
    loaded_count=$("$_vs_count_words" "$loaded_imps")
    label=$("$_vs_pluralize" "imp" "$loaded_count" "imps")
    printf '\033[32m✓\033[0m Loaded %s: %s\n' "$label" "$loaded_imps"
  fi

  if [ -n "$available_imps" ]; then
    available_count=$("$_vs_count_words" "$available_imps")
    label=$("$_vs_pluralize" "imp" "$available_count" "imps")
    printf '\033[34m●\033[0m Available %s: %s\n' "$label" "$available_imps"
  fi

  if [ -n "$imp_unavailable" ]; then
    unavailable_count=$("$_vs_count_words" "$imp_unavailable")
    label=$("$_vs_pluralize" "imp" "$unavailable_count" "imps")
    printf '\033[31m✗\033[0m Unavailable %s: %s\n' "$label" "$imp_unavailable"
  fi
fi

# Output results
if [ "$missing_only" -eq 1 ]; then
  printf '%s' "$missing"
  [ -n "$missing" ] && exit 1
  exit 0
fi

if [ -n "$missing" ]; then
  missing_count=$("$_vs_count_words" "$missing")
  if [ "$validate_imps" -eq 1 ]; then
    label=$("$_vs_pluralize" "imp" "$missing_count" "imps")
    printf 'Missing %s: %s\n' "$label" "$missing" >&2
  else
    label=$("$_vs_pluralize" "spell" "$missing_count" "spells")
    printf 'Missing %s: %s\n' "$label" "$missing" >&2
  fi
  exit 1
fi

exit 0
