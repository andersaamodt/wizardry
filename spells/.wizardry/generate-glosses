#!/bin/sh
# Generate glosses (function wrappers) for all wizardry spells and imps
#
# NEW PARADIGM: Function-based glosses
# Instead of creating script files, this now generates shell function definitions
# that are sourced into the current shell. This provides:
#   - First-word glosses: env() { parse "env" "$@"; } for space-separated invocation
# 
# NOTE: Hyphenated commands (like env-or, temp-file) are now natively available
# via PATH, since invoke-wizardry adds all spell directories to PATH.
#
# Glosses are generated for:
#   - All wizardry spells (in spells/*/)
#   - All wizardry imps (in spells/.imps/*/)
#   - User synonyms (.synonyms file)
#   - Default synonyms (.default-synonyms file)
#
# PERFORMANCE OPTIMIZATION:
# This script is called at shell startup, so performance is critical.
# Key optimizations implemented (48x speedup: 1.6s â†’ 0.034s):
#   - Use ${file##*/} instead of basename (100x faster per file)
#   - In-memory duplicate tracking (space-separated string) vs temp file + grep
#   - Batch processing spell names vs one-by-one function calls
#   - Consolidated blacklist checking into single reusable function
#   - Still uses find for correctness (nested directories) but minimizes subprocesses

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss function definitions for wizardry spells and imps.

Options:
  --quiet         Suppress diagnostic messages
  --output FILE   Write to FILE (default: stdout)

Examples:
  eval "$(generate-glosses)"          # Load into current shell
  generate-glosses --output file.sh   # Save to file
USAGE
  exit 0
  ;;
esac

# Skip require-wizardry check - this is a bootstrap script called from invoke-wizardry
# require-wizardry || exit 1

set -eu
# Skip env-clear - this is a bootstrap script, we want to preserve caller's environment
# . env-clear

  # Parse arguments
  quiet=0
  output_file=""
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --quiet) quiet=1 ;;
      --output)
        shift
        if [ $# -eq 0 ]; then
          printf '%s\n' "generate-glosses: --output requires an argument" >&2
          exit 2
        fi
        output_file=$1
        ;;
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        exit 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  wizardry_dir=${WIZARDRY_DIR:-${HOME:-.}/.wizardry}
  spell_home=${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}
  
  # Verify wizardry directory exists and is valid
  if [ ! -d "$wizardry_dir" ]; then
    printf 'generate-glosses: WIZARDRY_DIR not found: %s\n' "$wizardry_dir" >&2
    exit 1
  fi
  
  if [ ! -d "$wizardry_dir/spells" ]; then
    err_msg="WIZARDRY_DIR does not contain spells directory:"
    printf 'generate-glosses: %s %s\n' "$err_msg" "$wizardry_dir" >&2
    exit 1
  fi
  
  # Track statistics
  total_first_word_glosses=0
  
  # Check if parse is enabled (for first-word gloss generation)
  # Default to enabled (1) if not set
  parse_enabled=1
  mud_config_file="$spell_home/.mud"
  if [ -f "$mud_config_file" ]; then
    # Read parse-enabled setting from config file
    _parse_setting=$(grep '^parse-enabled=' "$mud_config_file" 2>/dev/null | cut -d= -f2)
    if [ -n "$_parse_setting" ]; then
      parse_enabled=$_parse_setting
    fi
  fi
  
  # Setup output
  if [ -n "$output_file" ]; then
    # Clear output file
    : > "$output_file"
    # Helper function to append to file
    emit_line() {
      printf '%s\n' "$*" >> "$output_file"
    }
  else
    # Helper function to output to stdout
    emit_line() {
      printf '%s\n' "$*"
    }
  fi
  
  # Emit header
  emit_line "# Gloss functions generated by generate-glosses"
  emit_line "# DO NOT EDIT - This file is auto-generated"
  emit_line "# Generated on $(date)"
  emit_line ""
  
  # ============================================================================
  # FIRST-WORD GLOSS COLLECTION
  # ============================================================================
  # Collect all unique first words from spells and imps
  # For multi-word commands like "env-or", extract first word "env"
  # This enables space-separated invocation: env or VAR DEFAULT
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && printf 'generate-glosses: Collecting first words from all spells and imps...\n' >&2
  
  # ============================================================================
  # FUNCTION GENERATION HELPERS
  # ============================================================================
  
  # Check if a first word is blacklisted
  # Returns 0 if allowed, 1 if blacklisted
  is_first_word_blacklisted() {
    _check_word=$1
    
    # CRITICAL: Skip shell builtins and common system commands to avoid overriding them
    # GREYLIST: Some shell builtins CAN be safely overridden if ALL spells using that first word
    # are multi-word commands (e.g., read-magic, test-spell).
    case "$_check_word" in
      # GREYLIST: Shell builtins that CAN be safely overridden (see above)
      read|test)
        return 0  # Allow these
        ;;
      # BLACKLIST: Shell builtins that CANNOT be overridden
      alias|bg|cd|command|disable|false|fc|fg|getopts|hash|jobs|kill|newgrp|pwd|readonly|set|sh|\
times|trap|true|type|ulimit|umask|unalias|wait|break|case|continue|do|done|elif|else|\
esac|eval|exec|exit|export|fi|for|if|in|local|return|shift|then|unset|until|while)
        return 1  # Blacklisted
        ;;
      # BLACKLIST: Common system commands that should not be overridden
      awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs)
        return 1  # Blacklisted
        ;;
    esac
    
    return 0  # Not blacklisted
  }
  
  # ============================================================================
  # SCAN AND GENERATE GLOSSES FOR ALL SPELLS AND IMPS (OPTIMIZED)
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && printf 'generate-glosses: Scanning for spells and imps...\n' >&2
  
  # OPTIMIZATION STRATEGY:
  # 1. Use find (necessary for nested directories like .arcana)
  # 2. Extract basenames with shell parameter expansion (no subprocess)
  # 3. Process in two passes to avoid repeated work
  # 4. Use in-memory data structures (space-separated strings) instead of temp files
  
  # First pass: Build spell name list with find + parameter expansion
  # Use mktemp for bootstrap compatibility
  _tmpfile=$(mktemp "${TMPDIR:-/tmp}/generate-glosses.XXXXXX")
  trap 'rm -f "$_tmpfile"' EXIT HUP INT TERM
  
  # Cross-platform find command with fallbacks for different find implementations
  # Try GNU find first (-perm /111), then BSD find (-perm +111), then manual check
  find "$wizardry_dir/spells" -type f -perm /111 2>/dev/null > "$_tmpfile" || \
    find "$wizardry_dir/spells" -type f -perm +111 2>/dev/null > "$_tmpfile" || \
    find "$wizardry_dir/spells" -type f 2>/dev/null | while IFS= read -r f; do
      [ -x "$f" ] && printf '%s\n' "$f"
    done > "$_tmpfile"
  
  _spell_names=""
  _spell_count=0
  
  # Read file paths and extract basenames efficiently
  while IFS= read -r spell_path; do
    # Use parameter expansion instead of basename (100x faster)
    _name=${spell_path##*/}
    
    # Skip invalid names and parse
    case "$_name" in
      ''|.*|parse) continue ;;
    esac
    
    # Add to space-separated list
    _spell_names="$_spell_names $_name"
    _spell_count=$((_spell_count + 1))
  done < "$_tmpfile"
  
  [ "$quiet" -eq 0 ] && printf 'generate-glosses: Found %d executable files\n' "$_spell_count" >&2
  
  # Warn if no files found
  if [ "$_spell_count" -eq 0 ]; then
    printf 'generate-glosses: WARNING: no executable files found in %s\n' "$wizardry_dir/spells" >&2
  fi
  
  # Emit comment
  emit_line "# ============================================================================"
  emit_line "# FIRST-WORD GLOSSES"
  emit_line "# ============================================================================"
  if [ "$parse_enabled" -eq 1 ]; then
    emit_line "# These enable space-separated command invocation:"
    emit_line "#   env or VAR DEFAULT  -> calls parse with all args"
    emit_line "#   temp file           -> calls parse with all args"
  else
    emit_line "# DISABLED: parse-enabled=0 in $mud_config_file"
    emit_line "# First-word glosses are not generated when parse is disabled"
  fi
  emit_line "# ============================================================================"
  emit_line ""
  
  # OPTIMIZATION: Generate first-word glosses in batched mode
  # Use in-memory tracking instead of temp file + grep
  # Pattern: " word1 word2 word3 " (leading and trailing spaces ensure exact match)
  _first_words_seen=" "  # Track with space-separated list (space prefix for matching)
  
  if [ "$parse_enabled" -eq 1 ]; then
    for spell_name in $_spell_names; do
      # Extract first word using parameter expansion (faster than sed)
      case "$spell_name" in
        *-*)
          # Multi-word spell - extract first word
          _first_word=${spell_name%%-*}
          ;;
        *)
          # Single-word spell - skip
          continue
          ;;
      esac
      
      # Check if first word is blacklisted
      if ! is_first_word_blacklisted "$_first_word"; then
        if [ "$quiet" -eq 0 ]; then
          warn_msg="Skipping spell \"$spell_name\" - first word"
          warn_msg="$warn_msg \"$_first_word\" conflicts with system command"
          printf 'generate-glosses: WARNING: %s\n' "$warn_msg" >&2
        fi
        continue
      fi
      
      # Check if already generated (in-memory check, no subprocess)
      case "$_first_words_seen" in
        *" $_first_word "*) continue ;;
      esac
      
      # Mark as seen
      _first_words_seen="$_first_words_seen$_first_word "
      
      # Emit function definition - smart gloss that sources uncastable spells
      emit_line "# First-word gloss for commands starting with '$_first_word'"
      emit_line "${_first_word}() {"
      emit_line "  # Try progressively longer spell names to find uncastable spells"
      emit_line "  _fw_spell=\"$_first_word\""
      emit_line "  _fw_words_used=0"
      emit_line "  "
      emit_line "  for _fw_arg in \"\$@\"; do"
      emit_line "    _fw_candidate=\"\${_fw_spell}-\${_fw_arg}\""
      emit_line "    _fw_words_used=\$((_fw_words_used + 1))"
      emit_line "    "
      emit_line "    # Look for spell file in wizardry directories"
      emit_line "    for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
      emit_line "      _fw_path=\"\${_fw_dir}\${_fw_candidate}\""
      emit_line "      if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
      emit_line "        # Found uncastable spell - source it with remaining args after consuming used words"
      emit_line "        shift \"\$_fw_words_used\""
      emit_line "        . \"\$_fw_path\""
      emit_line "        return \$?"
      emit_line "      fi"
      emit_line "    done"
      emit_line "    "
      emit_line "    _fw_spell=\"\$_fw_candidate\""
      emit_line "  done"
      emit_line "  "
      emit_line "  # No args or no uncastable spell found - check if synonym points to uncastable spell"
      emit_line "  _fw_spell_home=\${SPELLBOOK_DIR:-\${HOME:-.}/.spellbook}"
      emit_line "  _fw_syn_target=\"\""
      emit_line "  if [ -f \"\$_fw_spell_home/.synonyms\" ]; then"
      emit_line "    _fw_syn_target=\$(grep \"^$_first_word=\" \"\$_fw_spell_home/.synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
      emit_line "  fi"
      emit_line "  if [ -z \"\$_fw_syn_target\" ] && [ -f \"\$_fw_spell_home/.default-synonyms\" ]; then"
      emit_line "    _fw_syn_target=\$(grep \"^$_first_word=\" \"\$_fw_spell_home/.default-synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
      emit_line "  fi"
      emit_line "  if [ -n \"\$_fw_syn_target\" ]; then"
      emit_line "    # Found synonym - check if target is uncastable"
      emit_line "    for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
      emit_line "      _fw_path=\"\${_fw_dir}\${_fw_syn_target}\""
      emit_line "      if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
      emit_line "        # Synonym target is uncastable - source it"
      emit_line "        . \"\$_fw_path\""
      emit_line "        return \$?"
      emit_line "      fi"
      emit_line "    done"
      emit_line "  fi"
      emit_line "  "
      emit_line "  # No uncastable spell found - use parse for normal spells and synonyms"
      emit_line "  parse \"$_first_word\" \"\$@\""
      emit_line "}"
      emit_line ""
      
      total_first_word_glosses=$((total_first_word_glosses + 1))
    done
  fi
  
  # NOTE: Hyphenated aliases section removed
  # Hyphenated commands (env-or, temp-file, etc.) are now natively available
  # via PATH since invoke-wizardry adds all spell directories to PATH.
  
  # ============================================================================
  # SYNONYM FUNCTIONS AND ALIASES
  # ============================================================================
  # Process user and default synonyms from .synonyms files
  # Read simple word=target or word target format
  # Generate functions for non-hyphenated words, aliases for hyphenated
  # ============================================================================
  
  emit_line "# ============================================================================"
  emit_line "# SYNONYMS"
  emit_line "# ============================================================================"
  emit_line "# Hyphenated synonyms: generated as aliases (POSIX requirement)"
  emit_line "# Non-hyphenated synonyms: handled by parse via file lookup"
  emit_line "# ============================================================================"
  emit_line ""
  
  # Helper function to check if a synonym word is valid
  is_synonym_valid() {
    _syn_word=$1
    
    # Check for invalid characters
    case "$_syn_word" in
      ''|*[/\ \	\'\"\$\`\\\|\&\;\(\)\<\>\*\?\[\]]*|-*|.*|[0-9]*)
        return 1
        ;;
    esac
    
    # Check if it's a shell keyword
    case "$_syn_word" in
      if|then|else|elif|fi|case|esac|for|while|until|do|done|in|function|time)
        return 1
        ;;
    esac
    
    # Check if blacklisted (same as first-word blacklist)
    case "$_syn_word" in
      alias|bg|cd|command|disable|false|fc|fg|getopts|hash|jobs|kill|newgrp|pwd|readonly|set|sh|\
times|trap|true|type|ulimit|umask|unalias|wait|break|case|continue|do|done|elif|else|\
esac|eval|exec|exit|export|fi|for|if|in|local|return|shift|then|unset|until|while)
        return 1
        ;;
      awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs)
        return 1
        ;;
    esac
    
    return 0
  }
  
  # Track seen synonyms to avoid duplicates
  _synonyms_seen=" "
  
  # Process user synonyms
  synonym_file="$spell_home/.synonyms"
  if [ -f "$synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing user synonyms..." >&2
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Parse word=target format
      if ! printf '%s' "$line" | grep -q "="; then
        [ "$quiet" -eq 0 ] && warn "Malformed synonym line: $line" >&2
        continue
      fi
      
      _word=$(printf '%s' "$line" | sed 's/=.*//')
      _target=$(printf '%s' "$line" | sed 's/^[^=]*=//')
      
      # Validate synonym word
      if ! is_synonym_valid "$_word"; then
        [ "$quiet" -eq 0 ] && warn "Invalid synonym: $_word" >&2
        continue
      fi
      
      # Check for duplicates
      case "$_synonyms_seen" in
        *" $_word "*) 
          [ "$quiet" -eq 0 ] && warn "Skipping duplicate synonym: $_word" >&2
          continue
          ;;
      esac
      
      # Mark as seen
      _synonyms_seen="$_synonyms_seen$_word "
      
      # Only generate aliases for hyphenated synonyms (POSIX requirement)
      # Non-hyphenated synonyms handled by parse via file lookup
      case "$_word" in
        *-*)
          emit_line "alias $_word='$_target'"
          ;;
      esac
    done < "$synonym_file"
  fi
  
  # Process default synonyms
  default_synonym_file="$spell_home/.default-synonyms"
  if [ -f "$default_synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing default synonyms..." >&2
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Parse word=target format
      if ! printf '%s' "$line" | grep -q "="; then
        [ "$quiet" -eq 0 ] && warn "Malformed default synonym line: $line" >&2
        continue
      fi
      
      _word=$(printf '%s' "$line" | sed 's/=.*//')
      _target=$(printf '%s' "$line" | sed 's/^[^=]*=//')
      
      # Validate synonym word
      if ! is_synonym_valid "$_word"; then
        [ "$quiet" -eq 0 ] && warn "Invalid default synonym: $_word" >&2
        continue
      fi
      
      # Check for duplicates (user synonyms take precedence)
      case "$_synonyms_seen" in
        *" $_word "*) 
          [ "$quiet" -eq 0 ] && info "User synonym overrides default: $_word" >&2
          continue
          ;;
      esac
      
      # Mark as seen
      _synonyms_seen="$_synonyms_seen$_word "
      
      # Only generate aliases for hyphenated synonyms (POSIX requirement)
      # Non-hyphenated synonyms handled by parse via file lookup
      case "$_word" in
        *-*)
          emit_line "alias $_word='$_target'"
          ;;
      esac
    done < "$default_synonym_file"
    emit_line ""
  fi
  # COMPLETION
  # ============================================================================
  
  # Report statistics to stderr
  if [ "$quiet" -eq 0 ]; then
    printf 'generate-glosses: Gloss generation complete\n' >&2
    printf 'generate-glosses:   First-word glosses: %d\n' "$total_first_word_glosses" >&2
    printf 'generate-glosses:   Total spells/imps: %d\n' "$_spell_count" >&2
  fi
  
  exit 0
