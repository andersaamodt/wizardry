#!/bin/sh
# Generate glosses (function wrappers) for all wizardry spells and imps
#
# NEW PARADIGM: Function-based glosses
# Instead of creating script files, this now generates shell function definitions
# that are sourced into the current shell. This provides:
#   - First-word glosses: env() { parse "env" "$@"; } for space-separated invocation
# 
# NOTE: Hyphenated commands (like env-or, temp-file) are now natively available
# via PATH, since invoke-wizardry adds all spell directories to PATH.
#
# Glosses are generated for:
#   - All wizardry spells (in spells/*/)
#   - All wizardry imps (in spells/.imps/*/)
#   - User synonyms (.synonyms file)
#   - Default synonyms (.default-synonyms file)
#
# PERFORMANCE OPTIMIZATION:
# This script is called at shell startup, so performance is critical.
# Key optimizations implemented (48x speedup: 1.6s → 0.034s):
#   - Use ${file##*/} instead of basename (100x faster per file)
#   - In-memory duplicate tracking (space-separated string) vs temp file + grep
#   - Batch processing spell names vs one-by-one function calls
#   - Consolidated blacklist checking into single reusable function
#   - Still uses find for correctness (nested directories) but minimizes subprocesses

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss function definitions for wizardry spells and imps.

Options:
  --quiet         Suppress diagnostic messages
  --output FILE   Write to FILE (default: stdout)

Examples:
  eval "$(generate-glosses)"          # Load into current shell
  generate-glosses --output file.sh   # Save to file
USAGE
  exit 0
  ;;
esac

# Skip require-wizardry check - this is a bootstrap script called from invoke-wizardry
# require-wizardry || exit 1

set -eu
# Skip env-clear - this is a bootstrap script, we want to preserve caller's environment
# . env-clear

# Parse arguments
quiet=0
output_file=""

while [ $# -gt 0 ]; do
  case "$1" in
    --quiet) quiet=1 ;;
    --output)
      shift
      if [ $# -eq 0 ]; then
        printf '%s\n' "generate-glosses: --output requires an argument" >&2
        exit 2
      fi
      output_file=$1
      ;;
    *)
      printf '%s\n' "generate-glosses: unknown option: $1" >&2
      exit 2
      ;;
  esac
  shift
done

# Determine directories
wizardry_dir=${WIZARDRY_DIR:-${HOME:-.}/.wizardry}
spell_home=${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}

# Verify wizardry directory exists and is valid
if [ ! -d "$wizardry_dir" ]; then
  printf 'generate-glosses: WIZARDRY_DIR not found: %s\n' "$wizardry_dir" >&2
  exit 1
fi

if [ ! -d "$wizardry_dir/spells" ]; then
  err_msg="WIZARDRY_DIR does not contain spells directory:"
  printf 'generate-glosses: %s %s\n' "$err_msg" "$wizardry_dir" >&2
  exit 1
fi

# Track statistics
total_first_word_glosses=0

# Check if parse is enabled (for first-word gloss generation)
# Default to enabled (1) if not set
parse_enabled=1
mud_config_file="$spell_home/.mud"
if [ -f "$mud_config_file" ]; then
  # Read parse-enabled setting from config file
  _parse_setting=$(grep '^parse-enabled=' "$mud_config_file" 2>/dev/null | cut -d= -f2)
  if [ -n "$_parse_setting" ]; then
    parse_enabled=$_parse_setting
  fi
fi

# Setup output
if [ -n "$output_file" ]; then
  # Clear output file
  : > "$output_file"
  # Helper function to append to file
  emit_line() {
    printf '%s\n' "$*" >> "$output_file"
  }
else
  # Helper function to output to stdout
  emit_line() {
    printf '%s\n' "$*"
  }
fi

# Emit header
emit_line "# Gloss functions generated by generate-glosses"
emit_line "# DO NOT EDIT - This file is auto-generated"
emit_line "# Generated on $(date)"
emit_line ""

# ============================================================================
# FIRST-WORD GLOSS COLLECTION
# ============================================================================
# Collect all unique first words from spells and imps
# For multi-word commands like "env-or", extract first word "env"
# This enables space-separated invocation: env or VAR DEFAULT
# ============================================================================

[ "$quiet" -eq 0 ] && printf 'generate-glosses: Collecting first words from all spells and imps...\n' >&2

# ============================================================================
# FUNCTION GENERATION HELPERS
# ============================================================================

# Check if a first word is blacklisted
# Returns 0 if allowed, 1 if blacklisted
is_first_word_blacklisted() {
  _check_word=$1
  
  # CRITICAL: Skip shell builtins and common system commands to avoid overriding them
  # GREYLIST: Some shell builtins CAN be safely overridden if ALL spells using that first word
  # are multi-word commands (e.g., test-spell).
  case "$_check_word" in
    # GREYLIST: Shell builtins that CAN be safely overridden (see above)
    test)
      return 0  # Allow test (used in test-spell, etc.)
      ;;
    # BLACKLIST: Shell builtins that CANNOT be overridden
    alias|banish|bg|bind|builtin|cd|command|compgen|compopt|declare|\
disable|enable|false|fc|fg|getopts|hash|jobs|kill|newgrp|pwd|read|\
readonly|set|sh|times|trap|true|type|ulimit|umask|unalias|wait|\
break|case|continue|do|done|elif|else|esac|eval|exec|exit|export|fi|for|if|in|local|return|\
shift|then|unset|until|while)
      return 1  # Blacklisted
      ;;
    # BLACKLIST: Common system commands that should not be overridden
    awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs|xattr)
      return 1  # Blacklisted
      ;;
  esac
  
  return 0  # Not blacklisted
}

# Check if a spell name is in the uncastable list
# Returns 0 if uncastable, 1 if not
# Uses pre-computed _uncastable_spells list (must be set before calling)
is_spell_uncastable() {
  _spell_check=$1
  case "$_uncastable_spells" in
    *" $_spell_check "*) return 0 ;;
    *) return 1 ;;
  esac
}

# Emit a first-word gloss function for a given first word
# This is the standard first-word gloss implementation used throughout
# Args: $1 = first word (e.g., "jump", "leap")
emit_first_word_gloss() {
  _emit_first_word=$1
  
  emit_line "# First-word gloss for commands starting with '$_emit_first_word'"
  emit_line "${_emit_first_word}() {"
  emit_line "  # Try progressively longer spell names to find uncastable spells"
  emit_line "  _fw_spell=\"$_emit_first_word\""
  emit_line "  _fw_words_used=0"
  emit_line "  _fw_spell_home=\${SPELLBOOK_DIR:-\${HOME:-.}/.spellbook}"
  emit_line "  "
  emit_line "  for _fw_arg in \"\$@\"; do"
  emit_line "    # Skip flags and pure numeric arguments (they're not part of command names)"
  emit_line "    case \"\$_fw_arg\" in"
  emit_line "      -*) break ;;  # Flag - stop looking for command words"
  emit_line "      *[!0-9]*) ;; # Contains non-numeric - it's a command word, continue"
  emit_line "      *) break ;;  # Pure numeric - stop looking for command words"
  emit_line "    esac"
  emit_line "    "
  emit_line "    _fw_candidate=\"\${_fw_spell}-\${_fw_arg}\""
  emit_line "    _fw_words_used=\$((_fw_words_used + 1))"
  emit_line "    "
  emit_line "    # Look for spell file in wizardry directories"
  emit_line "    _fw_found=0"
  emit_line "    for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
  emit_line "      _fw_path=\"\${_fw_dir}\${_fw_candidate}\""
  emit_line "      if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
  emit_line "        # Found uncastable spell - source it with remaining args after consuming used words"
  emit_line "        shift \"\$_fw_words_used\""
  emit_line "        . \"\$_fw_path\""
  emit_line "        return \$?"
  emit_line "      fi"
  emit_line "    done"
  emit_line "    "
  emit_line "    # Check if candidate is a synonym"
  emit_line "    _fw_syn_target=\"\""
  emit_line "    if [ -f \"\$_fw_spell_home/.synonyms\" ]; then"
  emit_line "      _fw_syn_target=\$(grep \"^\${_fw_candidate}=\" \"\$_fw_spell_home/.synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
  emit_line "    fi"
  emit_line "    if [ -z \"\$_fw_syn_target\" ] && [ -f \"\$_fw_spell_home/.default-synonyms\" ]; then"
  emit_line "      _fw_syn_target=\$(grep \"^\${_fw_candidate}=\" \"\$_fw_spell_home/.default-synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
  emit_line "    fi"
  emit_line "    if [ -n \"\$_fw_syn_target\" ]; then"
  emit_line "      # Found synonym - check if target is uncastable"
  emit_line "      for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
  emit_line "        _fw_path=\"\${_fw_dir}\${_fw_syn_target}\""
  emit_line "        if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
  emit_line "          # Synonym target is uncastable - source it with remaining args"
  emit_line "          shift \"\$_fw_words_used\""
  emit_line "          . \"\$_fw_path\""
  emit_line "          return \$?"
  emit_line "        fi"
  emit_line "      done"
  emit_line "      # Found synonym but target is castable - update spell name and continue"
  emit_line "      _fw_spell=\"\$_fw_candidate\""
  emit_line "      break"
  emit_line "    fi"
  emit_line "    "
  emit_line "    _fw_spell=\"\$_fw_candidate\""
  emit_line "  done"
  emit_line "  "
  emit_line "  # No args or no uncastable spell found - check if the spell itself is uncastable"
  emit_line "  for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
  emit_line "    _fw_path=\"\${_fw_dir}$_emit_first_word\""
  emit_line "    if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
  emit_line "      # Found uncastable single-word spell - source it with all args"
  emit_line "      . \"\$_fw_path\""
  emit_line "      return \$?"
  emit_line "    fi"
  emit_line "  done"
  emit_line "  "
  emit_line "  # Check if synonym points to uncastable spell"
  emit_line "  _fw_spell_home=\${SPELLBOOK_DIR:-\${HOME:-.}/.spellbook}"
  emit_line "  _fw_syn_target=\"\""
  emit_line "  if [ -f \"\$_fw_spell_home/.synonyms\" ]; then"
  emit_line "    _fw_syn_target=\$(grep \"^$_emit_first_word=\" \"\$_fw_spell_home/.synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
  emit_line "  fi"
  emit_line "  if [ -z \"\$_fw_syn_target\" ] && [ -f \"\$_fw_spell_home/.default-synonyms\" ]; then"
  emit_line "    _fw_syn_target=\$(grep \"^$_emit_first_word=\" \"\$_fw_spell_home/.default-synonyms\" 2>/dev/null | sed 's/^[^=]*=//' || true)"
  emit_line "  fi"
  emit_line "  if [ -n \"\$_fw_syn_target\" ]; then"
  emit_line "    # Found synonym - check if target is uncastable"
  emit_line "    for _fw_dir in \"\$WIZARDRY_DIR\"/spells/*/; do"
  emit_line "      _fw_path=\"\${_fw_dir}\${_fw_syn_target}\""
  emit_line "      if [ -f \"\$_fw_path\" ] && grep -q \"^# Uncastable pattern\" \"\$_fw_path\" 2>/dev/null; then"
  emit_line "        # Synonym target is uncastable - source it"
  emit_line "        . \"\$_fw_path\""
  emit_line "        return \$?"
  emit_line "      fi"
  emit_line "    done"
  emit_line "  fi"
  emit_line "  "
  emit_line "  # No uncastable spell found - check if reconstructed name is an alias"
  emit_line "  # If it's an alias, invoke it via eval (parse skips aliases to avoid recursion)"
  emit_line "  _fw_type_check=\$(type \"\$_fw_spell\" 2>/dev/null || printf '')"
  emit_line "  case \"\$_fw_type_check\" in"
  emit_line "    *alias*)"
  emit_line "      # It's an alias - use eval to expand it"
  emit_line "      # Don't pass remaining \$@ since multi-word was already consumed during reconstruction"
  emit_line "      eval \"\$_fw_spell\""
  emit_line "      ;;"
  emit_line "    *)"
  emit_line "      # Not an alias - use parse for normal spells and synonyms"
  emit_line "      # Use reconstructed spell name (e.g., leap-to-location) not just first word (e.g., leap)"
  emit_line "      parse \"\$_fw_spell\" \"\$@\""
  emit_line "      ;;"
  emit_line "  esac"
  emit_line "}"
  emit_line ""
}

# ============================================================================
# SCAN AND GENERATE GLOSSES FOR ALL SPELLS AND IMPS (OPTIMIZED)
# ============================================================================

[ "$quiet" -eq 0 ] && printf 'generate-glosses: Scanning for spells and imps...\n' >&2

# OPTIMIZATION STRATEGY:
# 1. Use find (necessary for nested directories like .arcana)
# 2. Extract basenames with shell parameter expansion (no subprocess)
# 3. Process in two passes to avoid repeated work
# 4. Use in-memory data structures (space-separated strings) instead of temp files
# 5. Pre-scan uncastable spells once (not per-spell grep)

# First pass: Build spell name list with find + parameter expansion
# Use mktemp for bootstrap compatibility
_tmpfile=$(mktemp "${TMPDIR:-/tmp}/generate-glosses.XXXXXX")
trap 'rm -f "$_tmpfile"' EXIT HUP INT TERM

# Use find without -perm checks (which hang on macOS/CI)
# Just find all files and filter executable ones
# Scan both wizardry spells directory and user's spellbook directory
{
  find "$wizardry_dir/spells" -type f 2>/dev/null | while IFS= read -r f; do
    [ -x "$f" ] && printf '%s\n' "$f"
  done
  
  # Also scan user's spellbook directory if it exists
  if [ -d "$spell_home" ]; then
    find "$spell_home" -type f 2>/dev/null | while IFS= read -r f; do
      [ -x "$f" ] && printf '%s\n' "$f"
    done
  fi
} > "$_tmpfile"

_spell_names=""
_spell_count=0

# Read file paths and extract basenames efficiently
while IFS= read -r spell_path; do
  # Use parameter expansion instead of basename (100x faster)
  _name=${spell_path##*/}
  
  # Skip invalid names and parse
  case "$_name" in
    ''|.*|parse) continue ;;
  esac
  
  # Add to space-separated list
  _spell_names="$_spell_names $_name"
  _spell_count=$((_spell_count + 1))
done < "$_tmpfile"

[ "$quiet" -eq 0 ] && printf 'generate-glosses: Found %d executable files\n' "$_spell_count" >&2

# Warn if no files found
if [ "$_spell_count" -eq 0 ]; then
  printf 'generate-glosses: WARNING: no executable files found in %s\n' "$wizardry_dir/spells" >&2
fi

# OPTIMIZATION: Single grep pass to find all uncastable spells
# This is much faster than grepping each file individually (405 greps → 1 grep)
# Use xargs to avoid "Argument list too long" error
[ "$quiet" -eq 0 ] && printf 'generate-glosses: Scanning for uncastable spells...\n' >&2
_uncastable_spells=" "  # Space-separated list
if _uncastable_files=$(cat "$_tmpfile" | xargs grep -l "^# Uncastable pattern" 2>/dev/null); then
  for _uc_path in $_uncastable_files; do
    _uc_name=${_uc_path##*/}
    _uncastable_spells="$_uncastable_spells$_uc_name "
  done
fi

[ "$quiet" -eq 0 ] && printf 'generate-glosses: Found %d uncastable spells\n' "$(printf '%s' "$_uncastable_spells" | tr ' ' '\n' | grep -c .)" >&2

# Emit comment
emit_line "# ============================================================================"
emit_line "# FIRST-WORD GLOSSES"
emit_line "# ============================================================================"
if [ "$parse_enabled" -eq 1 ]; then
  emit_line "# These enable space-separated command invocation:"
  emit_line "#   env or VAR DEFAULT  -> calls parse with all args"
  emit_line "#   temp file           -> calls parse with all args"
else
  emit_line "# DISABLED: parse-enabled=0 in $mud_config_file"
  emit_line "# First-word glosses are not generated when parse is disabled"
fi
emit_line "# ============================================================================"
emit_line ""

# OPTIMIZATION: Generate first-word glosses in batched mode
# Use in-memory tracking instead of temp file + grep
# Pattern: " word1 word2 word3 " (leading and trailing spaces ensure exact match)
_first_words_seen=" "  # Track with space-separated list (space prefix for matching)

if [ "$parse_enabled" -eq 1 ]; then
  for spell_name in $_spell_names; do
    # Extract first word using parameter expansion (faster than sed)
    case "$spell_name" in
      *-*)
        # Multi-word spell - extract first word
        _first_word=${spell_name%%-*}
        ;;
      *)
        # Single-word spell - use the spell name itself as the first word
        _first_word=$spell_name
        ;;
    esac
    
    # Check if first word is blacklisted
    if ! is_first_word_blacklisted "$_first_word"; then
      if [ "$quiet" -eq 0 ]; then
        warn_msg="Skipping spell \"$spell_name\" - first word"
        warn_msg="$warn_msg \"$_first_word\" conflicts with system command"
        printf 'generate-glosses: WARNING: %s\n' "$warn_msg" >&2
      fi
      continue
    fi
    
    # Check if already generated (in-memory check, no subprocess)
    case "$_first_words_seen" in
      *" $_first_word "*) continue ;;
    esac
    
    # Mark as seen
    _first_words_seen="$_first_words_seen$_first_word "
    
    # Emit first-word gloss function using helper
    emit_first_word_gloss "$_first_word"
    
    total_first_word_glosses=$((total_first_word_glosses + 1))
  done
fi

# ============================================================================
# HYPHENATED SPELL ALIASES
# ============================================================================
# Generate aliases for hyphenated spells with uncastable pattern
# These aliases convert hyphenated form to space-separated form
# (e.g., jump-to-marker → jump to marker) so they route through first-word gloss
# which can properly source the spell instead of executing it

for spell_name in $_spell_names; do
  # Only process hyphenated spell names
  case "$spell_name" in
    *-*) ;;
    *) continue ;;
  esac
  
  # Check if spell is in uncastable list (fast in-memory check)
  if is_spell_uncastable "$spell_name"; then
    # Convert hyphens to spaces (e.g., jump-to-marker → jump to marker)
    _alias_target=$(printf '%s' "$spell_name" | sed 's/-/ /g')
    emit_line "alias $spell_name='$_alias_target'"
  fi
done
emit_line ""

# ============================================================================
# SYNONYM FUNCTIONS AND ALIASES
# ============================================================================
# Process user and default synonyms from .synonyms files
# Read simple word=target or word target format
# Generate functions for non-hyphenated words, aliases for hyphenated
# ============================================================================

emit_line "# ============================================================================"
emit_line "# SYNONYMS"
emit_line "# ============================================================================"
emit_line "# Hyphenated synonyms: generated as aliases (POSIX requirement)"
emit_line "# Non-hyphenated synonyms: handled by parse via file lookup"
emit_line "# ============================================================================"
emit_line ""

# Helper function to check if a synonym word is valid
is_synonym_valid() {
  _syn_word=$1
  
  # Check for invalid characters
  case "$_syn_word" in
    ''|*[/\ \	\'\"\$\`\\\|\&\;\(\)\<\>\*\?\[\]]*|-*|.*|[0-9]*)
      return 1
      ;;
  esac
  
  # Check if it's a shell keyword
  case "$_syn_word" in
    if|then|else|elif|fi|case|esac|for|while|until|do|done|in|function|time)
      return 1
      ;;
  esac
  
  # Check if blacklisted (same as first-word blacklist)
  case "$_syn_word" in
    alias|banish|bg|bind|builtin|cd|command|compgen|compopt|declare|\
disable|enable|false|fc|fg|getopts|hash|jobs|kill|let|newgrp|pwd|read|\
readonly|set|sh|times|trap|true|type|ulimit|umask|unalias|wait|\
break|case|continue|do|done|elif|else|esac|eval|exec|exit|export|fi|for|if|in|local|return|\
shift|then|unset|until|while)
      return 1
      ;;
    awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs|xattr)
      return 1
      ;;
  esac
  
  return 0
}

# Track seen synonyms to avoid duplicates
_synonyms_seen=" "

# Track synonym words for first-word gloss generation
_synonym_words=""

# Process user synonyms
synonym_file="$spell_home/.synonyms"
if [ -f "$synonym_file" ]; then
  [ "$quiet" -eq 0 ] && info "Processing user synonyms..." >&2
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    case "$line" in
      ''|\#*) continue ;;
    esac
    
    # Parse word=target format
    if ! printf '%s' "$line" | grep -q "="; then
      [ "$quiet" -eq 0 ] && warn "Malformed synonym line: $line" >&2
      continue
    fi
    
    _word=$(printf '%s' "$line" | sed 's/=.*//')
    _target=$(printf '%s' "$line" | sed 's/^[^=]*=//')
    
    # Validate synonym word
    if ! is_synonym_valid "$_word"; then
      [ "$quiet" -eq 0 ] && warn "Invalid synonym: $_word" >&2
      continue
    fi
    
    # Check for duplicates
    case "$_synonyms_seen" in
      *" $_word "*) 
        [ "$quiet" -eq 0 ] && warn "Skipping duplicate synonym: $_word" >&2
        continue
        ;;
    esac
    
    # Mark as seen
    _synonyms_seen="$_synonyms_seen$_word "
    
    # Add to synonym words list for first-word gloss generation
    _synonym_words="$_synonym_words $_word"
    
    # Generate aliases for hyphenated synonyms, functions for non-hyphenated (if no conflict)
    case "$_word" in
      *-*)
        # Hyphenated synonym - must use alias (POSIX limitation)
        # For hyphenated targets, convert hyphens to spaces for first-word gloss routing
        case "$_target" in
          *-*)
            # Convert hyphens to spaces ONLY in spell name, not in directory path
            # E.g., "translocation/jump-to-marker" → "translocation/jump to marker"
            #       "jump-to-marker" → "jump to marker"
            case "$_target" in
              */*)
                # Has directory prefix - preserve it
                _dir_prefix="${_target%/*}/"
                _spell_part="${_target##*/}"
                _alias_target="$_dir_prefix$(printf '%s' "$_spell_part" | sed 's/-/ /g')"
                ;;
              *)
                # No directory - convert all hyphens
                _alias_target=$(printf '%s' "$_target" | sed 's/-/ /g')
                ;;
            esac
            emit_line "alias $_word='$_alias_target'"
            ;;
          *)
            # Single-word target, use as-is
            emit_line "alias $_word='$_target'"
            ;;
        esac
        ;;
      *)
        # Non-hyphenated synonym - check if it conflicts with first-word gloss
        case "$_first_words_seen" in
          *" $_word "*)
            # Conflicts with first-word gloss - skip (gloss will handle via parse)
            [ "$quiet" -eq 0 ] && info "Synonym '$_word' handled by first-word gloss" >&2
            ;;
          *)
            # No conflict - generate function for direct invocation
            # For hyphenated targets, use the hyphenated form directly (it will have an alias)
            emit_line "$_word() { $_target \"\$@\"; }"
            ;;
        esac
        ;;
    esac
  done < "$synonym_file"
fi

# Process default synonyms
default_synonym_file="$spell_home/.default-synonyms"
if [ -f "$default_synonym_file" ]; then
  [ "$quiet" -eq 0 ] && info "Processing default synonyms..." >&2
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    case "$line" in
      ''|\#*) continue ;;
    esac
    
    # Parse word=target format
    if ! printf '%s' "$line" | grep -q "="; then
      [ "$quiet" -eq 0 ] && warn "Malformed default synonym line: $line" >&2
      continue
    fi
    
    _word=$(printf '%s' "$line" | sed 's/=.*//')
    _target=$(printf '%s' "$line" | sed 's/^[^=]*=//')
    
    # Validate synonym word
    if ! is_synonym_valid "$_word"; then
      printf '%s\n' "ERROR: invalid default synonym: $_word" >&2
      continue
    fi
    
    # Check for duplicates (user synonyms take precedence)
    case "$_synonyms_seen" in
      *" $_word "*) 
        [ "$quiet" -eq 0 ] && info "User synonym overrides default: $_word" >&2
        continue
        ;;
    esac
    
    # Mark as seen
    _synonyms_seen="$_synonyms_seen$_word "
    
    # Add to synonym words list for first-word gloss generation
    _synonym_words="$_synonym_words $_word"
    
    # Generate aliases for hyphenated synonyms, functions for non-hyphenated (if no conflict)
    case "$_word" in
      *-*)
        # Hyphenated synonym - must use alias (POSIX limitation)
        # For hyphenated targets, convert hyphens to spaces for first-word gloss routing
        case "$_target" in
          *-*)
            # Convert hyphens to spaces ONLY in spell name, not in directory path
            # E.g., "translocation/jump-to-marker" → "translocation/jump to marker"
            #       "jump-to-marker" → "jump to marker"
            case "$_target" in
              */*)
                # Has directory prefix - preserve it
                _dir_prefix="${_target%/*}/"
                _spell_part="${_target##*/}"
                _alias_target="$_dir_prefix$(printf '%s' "$_spell_part" | sed 's/-/ /g')"
                ;;
              *)
                # No directory - convert all hyphens
                _alias_target=$(printf '%s' "$_target" | sed 's/-/ /g')
                ;;
            esac
            emit_line "alias $_word='$_alias_target'"
            ;;
          *)
            # Single-word target, use as-is
            emit_line "alias $_word='$_target'"
            ;;
        esac
        ;;
      *)
        # Non-hyphenated synonym - check if it conflicts with first-word gloss
        case "$_first_words_seen" in
          *" $_word "*)
            # Conflicts with first-word gloss - skip (gloss will handle via parse)
            [ "$quiet" -eq 0 ] && info "Synonym '$_word' handled by first-word gloss" >&2
            ;;
          *)
            # No conflict - generate function for direct invocation
            # For hyphenated targets, use the hyphenated form directly (it will have an alias)
            emit_line "$_word() { $_target \"\$@\"; }"
            ;;
        esac
        ;;
    esac
  done < "$default_synonym_file"
  emit_line ""
fi

# ============================================================================
# FIRST-WORD GLOSSES FOR HYPHENATED SYNONYMS
# ============================================================================
# Generate first-word glosses for hyphenated synonym names (e.g., leap-to-location → leap())
# This ensures that "leap to location" works just like "jump to marker" works
# ============================================================================

if [ "$parse_enabled" -eq 1 ] && [ -n "$_synonym_words" ]; then
  emit_line "# ============================================================================"
  emit_line "# FIRST-WORD GLOSSES FROM SYNONYMS"
  emit_line "# ============================================================================"
  emit_line "# Generated for hyphenated synonym names (e.g., leap-to-location → leap())"
  emit_line "# ============================================================================"
  emit_line ""
  
  for syn_word in $_synonym_words; do
    # Only process hyphenated synonym names
    case "$syn_word" in
      *-*) ;;
      *) continue ;;
    esac
    
    # Extract first word
    _first_word=${syn_word%%-*}
    
    # Check if first word is blacklisted - skip if it is
    # NOTE: is_first_word_blacklisted returns 0 if ALLOWED, 1 if BLACKLISTED
    # So we negate to skip when blacklisted (returns 1, negated to 0/success)
    if ! is_first_word_blacklisted "$_first_word"; then
      continue
    fi
    
    # Check if already generated (from real spells or earlier synonyms)
    case "$_first_words_seen" in
      *" $_first_word "*) continue ;;
    esac
    
    # Mark as seen
    _first_words_seen="$_first_words_seen$_first_word "
    
    # Emit first-word gloss function using helper
    emit_first_word_gloss "$_first_word"
    
    total_first_word_glosses=$((total_first_word_glosses + 1))
  done
fi

# COMPLETION
# ============================================================================

# Report statistics to stderr
if [ "$quiet" -eq 0 ]; then
  printf 'generate-glosses: Gloss generation complete\n' >&2
  printf 'generate-glosses:   First-word glosses: %d\n' "$total_first_word_glosses" >&2
  printf 'generate-glosses:   Total spells/imps: %d\n' "$_spell_count" >&2
fi

exit 0
