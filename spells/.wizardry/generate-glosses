#!/bin/sh
# Generate glosses (function wrappers) for all wizardry spells and imps
#
# NEW PARADIGM: Function-based glosses
# Instead of creating script files, this now generates shell function definitions
# that are sourced into the current shell. This provides:
#   - First-word glosses: env() { parse "env" "$@"; } for space-separated invocation
#   - Hyphenated aliases: alias env-or='env_or' for hyphenated invocation
#   - Direct access to preloaded true-name functions: env_or()
#
# Glosses are generated for:
#   - All wizardry spells (in spells/*/)
#   - All wizardry imps (in spells/.imps/*/)
#   - User synonyms (.synonyms file)
#   - Default synonyms (.default-synonyms file)

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss function definitions for all wizardry spells and imps.
Outputs function definitions to stdout that should be sourced into the shell.

This creates first-word gloss functions that enable space-separated invocation:
  env or VAR DEFAULT    # calls parse "env" "or" "VAR" "DEFAULT"
  temp file             # calls parse "temp" "file"

Options:
  --quiet    Suppress diagnostic messages to stderr
  --output FILE  Write function definitions to FILE (default: stdout)

Examples:
  generate-glosses                    # Output functions to stdout
  eval "$(generate-glosses)"          # Load functions into current shell
  generate-glosses --output file.sh   # Save to file for later sourcing
USAGE
  exit 0
  ;;
esac

require-wizardry || exit 1

set -eu
env-clear

  # Parse arguments
  quiet=0
  output_file=""
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --quiet) quiet=1 ;;
      --output)
        shift
        if [ $# -eq 0 ]; then
          printf '%s\n' "generate-glosses: --output requires an argument" >&2
          exit 2
        fi
        output_file=$1
        ;;
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        exit 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  
  # Verify wizardry directory exists and is valid
  if [ ! -d "$wizardry_dir" ]; then
    printf 'generate-glosses: WIZARDRY_DIR not found: %s\n' "$wizardry_dir" >&2
    exit 1
  fi
  
  if [ ! -d "$wizardry_dir/spells" ]; then
    printf 'generate-glosses: WIZARDRY_DIR does not contain spells directory: %s\n' "$wizardry_dir" >&2
    exit 1
  fi
  
  # Track statistics
  total_first_word_glosses=0
  total_full_name_glosses=0
  total_true_name_glosses=0
  
  # Setup output
  if [ -n "$output_file" ]; then
    # Clear output file
    : > "$output_file"
    # Helper function to append to file
    _emit() {
      printf '%s\n' "$*" >> "$output_file"
    }
  else
    # Helper function to output to stdout
    _emit() {
      printf '%s\n' "$*"
    }
  fi
  
  # Emit header
  _emit "# Gloss functions generated by generate-glosses"
  _emit "# DO NOT EDIT - This file is auto-generated"
  _emit "# Generated on $(date)"
  _emit ""
  
  # ============================================================================
  # FIRST-WORD GLOSS COLLECTION
  # ============================================================================
  # Collect all unique first words from spells and imps
  # For multi-word commands like "env-or", extract first word "env"
  # This enables space-separated invocation: env or VAR DEFAULT
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && info "Collecting first words from all spells and imps..." >&2
  
  _first_words_file=$(temp-file)
  on-exit cleanup-file "$_first_words_file"
  
  # ============================================================================
  # FUNCTION GENERATION HELPERS
  # ============================================================================
  
  # Generate first-word gloss function
  # For "env-or", generates: env() { parse "env" "$@"; }
  # This ensures parse receives the full command as user typed it
  _generate_first_word_gloss() {
    _cmd_name=$1
    _first_word=$(printf '%s' "$_cmd_name" | sed 's/-.*$//')
    
    # Skip single-word commands (no hyphen)
    if [ "$_first_word" = "$_cmd_name" ]; then
      return 0
    fi
    
    # CRITICAL: Skip shell builtins and common system commands to avoid overriding them
    # This prevents errors like "Bad function name" when trying to define certain builtins
    # Also prevents overriding critical system utilities like find, grep, sed, etc.
    # FAIL if we would create a blacklisted command - this indicates spell naming conflict
    #
    # GREYLIST: Some shell builtins CAN be safely overridden if ALL spells using that first word
    # are multi-word commands (e.g., read-magic, test-spell). The gloss delegates to
    # parse, which tries to find matching spells and falls back to the system builtin if no match.
    #
    # Current greylist (safe to override):
    #   - read: All read-* spells are 2+ words (read-magic, read-contact, read-file, read-line)
    #   - test: All test-* spells are 2+ words (test-spell, test-magic, test-bootstrap, etc.)
    case "$_first_word" in
      # GREYLIST: Shell builtins that CAN be safely overridden (see above)
      read|test)
        # Allow these - they route through parse and fall back to system builtin
        ;;
      # BLACKLIST: Shell builtins that CANNOT be overridden
      alias|bg|cd|command|false|fc|fg|getopts|hash|jobs|kill|newgrp|pwd|readonly|set|sh|\
times|trap|true|type|ulimit|umask|unalias|wait|break|case|continue|do|done|elif|else|\
esac|eval|exec|exit|export|fi|for|if|in|local|return|shift|then|unset|until|while)
        printf 'generate-glosses: WARNING: Skipping spell "%s" - first word "%s" conflicts with shell builtin\n' "$_cmd_name" "$_first_word" >&2
        return 1
        ;;
      # BLACKLIST: Common system commands that should not be overridden
      awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs)
        printf 'generate-glosses: WARNING: Skipping spell "%s" - first word "%s" conflicts with system command\n' "$_cmd_name" "$_first_word" >&2
        return 1
        ;;
    esac
    
    # Check if already generated
    if grep -q "^$_first_word()" "$_first_words_file" 2>/dev/null; then
      return 0
    fi
    
    # Mark as generated
    printf '%s\n' "$_first_word()" >> "$_first_words_file"
    
    # Emit function definition - CRITICAL: pass first word to parse
    _emit "# First-word gloss for commands starting with '$_first_word'"
    _emit "${_first_word}() { parse \"${_first_word}\" \"\$@\"; }"
    _emit ""
    
    total_first_word_glosses=$((total_first_word_glosses + 1))
  }
  
  # Generate full hyphenated gloss alias
  # For "env-or", generates: alias env-or='env_or'
  _generate_full_name_alias() {
    _cmd_name=$1
    _true_name=$(printf '%s' "$_cmd_name" | tr '-' '_')
    
    # Skip if command has no hyphens (same as true name)
    if [ "$_cmd_name" = "$_true_name" ]; then
      return 0
    fi
    
    # Emit alias definition
    _emit "# Full-name alias for '$_cmd_name' -> '$_true_name'"
    _emit "alias ${_cmd_name}='${_true_name}'"
    _emit ""
    
    total_full_name_glosses=$((total_full_name_glosses + 1))
  }
  
  # ============================================================================
  # SCAN AND GENERATE GLOSSES FOR ALL SPELLS AND IMPS
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && info "Scanning for spells and imps..." >&2
  
  # Use temp file for spell list
  _spell_list=$(temp-file)
  on-exit cleanup-file "$_spell_list"
  
  # Find all executable files in wizardry
  if command -v find-executable >/dev/null 2>&1; then
    find-executable "$wizardry_dir/spells" > "$_spell_list"
  else
    # Fallback: execute find-executable imp directly
    _find_exec_imp="$wizardry_dir/spells/.imps/fs/find-executable"
    if [ -x "$_find_exec_imp" ]; then
      "$_find_exec_imp" "$wizardry_dir/spells" > "$_spell_list"
    else
      # Last resort: use find directly
      warn "generate-glosses: find-executable not available, using basic find" >&2
      find "$wizardry_dir/spells" -type f -perm /111 2>/dev/null > "$_spell_list" || \
      find "$wizardry_dir/spells" -type f -perm +111 2>/dev/null > "$_spell_list" || \
      find "$wizardry_dir/spells" -type f 2>/dev/null | while IFS= read -r f; do
        [ -x "$f" ] && printf '%s\n' "$f"
      done > "$_spell_list"
    fi
  fi
  
  # Count files found
  _spell_count=$(wc -l < "$_spell_list")
  [ "$quiet" -eq 0 ] && info "Found $_spell_count executable files" >&2
  
  # Warn if no files found
  if [ "$_spell_count" -eq 0 ]; then
    warn "generate-glosses: no executable files found in $wizardry_dir/spells" >&2
  fi
  
  # Emit comment
  _emit "# ============================================================================"
  _emit "# FIRST-WORD GLOSSES"
  _emit "# ============================================================================"
  _emit "# These enable space-separated command invocation:"
  _emit "#   env or VAR DEFAULT  -> calls parse with all args"
  _emit "#   temp file           -> calls parse with all args"
  _emit "# ============================================================================"
  _emit ""
  
  # Generate first-word glosses
  while IFS= read -r spell_path; do
    [ -n "$spell_path" ] && [ -f "$spell_path" ] || continue
    spell_name=$(basename "$spell_path")
    
    # Skip invalid names and parse
    case "$spell_name" in
      ''|.*|parse) continue ;;
    esac
    
    # Try to generate first-word gloss, skip on conflict (warning already printed)
    _generate_first_word_gloss "$spell_name" || continue
  done < "$_spell_list"
  
  # Emit separator
  _emit "# ============================================================================"
  _emit "# FULL-NAME HYPHENATED ALIASES"
  _emit "# ============================================================================"
  _emit "# These provide hyphenated command aliases:"
  _emit "#   env-or -> env_or"
  _emit "#   temp-file -> temp_file"
  _emit "# Aliases work in all shells (bash, zsh, dash, sh)"
  _emit "# ============================================================================"
  _emit ""
  
  # Generate full-name aliases
  # Reset file pointer
  while IFS= read -r spell_path; do
    [ -n "$spell_path" ] && [ -f "$spell_path" ] || continue
    spell_name=$(basename "$spell_path")
    
    # Skip invalid names and parse
    case "$spell_name" in
      ''|.*|parse) continue ;;
    esac
    
    _generate_full_name_alias "$spell_name"
  done < "$_spell_list"
  
  # ============================================================================
  # SYNONYM ALIASES
  # ============================================================================
  # Process user and default synonyms from .synonyms files
  # These are just passed through as-is (already in alias format)
  # ============================================================================
  
  _emit "# ============================================================================"
  _emit "# USER AND DEFAULT SYNONYMS"
  _emit "# ============================================================================"
  _emit "# From .synonyms and .default-synonyms files"
  _emit "# ============================================================================"
  _emit ""
  
  # User synonyms
  synonym_file="$spell_home/.synonyms"
  if [ -f "$synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing user synonyms..." >&2
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Pass through alias lines as-is
      if printf '%s' "$line" | grep -q "^alias "; then
        _emit "$line"
      fi
    done < "$synonym_file"
    _emit ""
  fi
  
  # Default synonyms
  default_synonym_file="$spell_home/.default-synonyms"
  if [ -f "$default_synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing default synonyms..." >&2
    while IFS= read -r line || [ -n "$line" ]; do
      # Skip empty lines and comments
      case "$line" in
        ''|\#*) continue ;;
      esac
      
      # Pass through alias lines as-is
      if printf '%s' "$line" | grep -q "^alias "; then
        _emit "$line"
      fi
    done < "$default_synonym_file"
    _emit ""
  fi
  
  # ============================================================================
  # COMPLETION
  # ============================================================================
  
  # Report statistics to stderr
  if [ "$quiet" -eq 0 ]; then
    success "Gloss generation complete" >&2
    info "  First-word glosses: $total_first_word_glosses" >&2
    info "  Full-name aliases: $total_full_name_glosses" >&2
    info "  Total spells/imps: $_spell_count" >&2
  fi
  
  exit 0
