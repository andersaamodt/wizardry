#!/bin/sh
# Generate glosses (function wrappers) for all wizardry spells and imps
#
# NEW PARADIGM: Function-based glosses
# Instead of creating script files, this now generates shell function definitions
# that are sourced into the current shell. This provides:
#   - First-word glosses: env() { parse "env" "$@"; } for space-separated invocation
# 
# NOTE: Hyphenated commands (like env-or, temp-file) are now natively available
# via PATH, since invoke-wizardry adds all spell directories to PATH.
#
# Glosses are generated for:
#   - All wizardry spells (in spells/*/)
#   - All wizardry imps (in spells/.imps/*/)
#   - User synonyms (.synonyms file)
#   - Default synonyms (.default-synonyms file)
#
# PERFORMANCE OPTIMIZATION:
# This script is called at shell startup, so performance is critical.
# Key optimizations implemented (48x speedup: 1.6s â†’ 0.034s):
#   - Use ${file##*/} instead of basename (100x faster per file)
#   - In-memory duplicate tracking (space-separated string) vs temp file + grep
#   - Batch processing spell names vs one-by-one function calls
#   - Consolidated blacklist checking into single reusable function
#   - Still uses find for correctness (nested directories) but minimizes subprocesses

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: generate-glosses [OPTIONS]

Generate gloss function definitions for wizardry spells and imps.

Options:
  --quiet         Suppress diagnostic messages
  --output FILE   Write to FILE (default: stdout)

Examples:
  eval "$(generate-glosses)"          # Load into current shell
  generate-glosses --output file.sh   # Save to file
USAGE
  exit 0
  ;;
esac

require-wizardry || exit 1

set -eu
. env-clear

  # Parse arguments
  quiet=0
  output_file=""
  
  while [ $# -gt 0 ]; do
    case "$1" in
      --quiet) quiet=1 ;;
      --output)
        shift
        if [ $# -eq 0 ]; then
          printf '%s\n' "generate-glosses: --output requires an argument" >&2
          exit 2
        fi
        output_file=$1
        ;;
      *)
        printf '%s\n' "generate-glosses: unknown option: $1" >&2
        exit 2
        ;;
    esac
    shift
  done
  
  # Determine directories
  wizardry_dir=$(env-or WIZARDRY_DIR "${HOME:-.}/.wizardry")
  spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
  
  # Verify wizardry directory exists and is valid
  if [ ! -d "$wizardry_dir" ]; then
    printf 'generate-glosses: WIZARDRY_DIR not found: %s\n' "$wizardry_dir" >&2
    exit 1
  fi
  
  if [ ! -d "$wizardry_dir/spells" ]; then
    printf 'generate-glosses: WIZARDRY_DIR does not contain spells directory: %s\n' "$wizardry_dir" >&2
    exit 1
  fi
  
  # Track statistics
  total_first_word_glosses=0
  
  # Check if parse is enabled (for first-word gloss generation)
  # Default to enabled (1) if not set
  parse_enabled=1
  mud_config_file="$spell_home/.mud"
  if [ -f "$mud_config_file" ]; then
    # Read parse-enabled setting from config file
    _parse_setting=$(grep '^parse-enabled=' "$mud_config_file" 2>/dev/null | cut -d= -f2)
    if [ -n "$_parse_setting" ]; then
      parse_enabled=$_parse_setting
    fi
  fi
  
  # Setup output
  if [ -n "$output_file" ]; then
    # Clear output file
    : > "$output_file"
    # Helper function to append to file
    emit_line() {
      printf '%s\n' "$*" >> "$output_file"
    }
  else
    # Helper function to output to stdout
    emit_line() {
      printf '%s\n' "$*"
    }
  fi
  
  # Emit header
  emit_line "# Gloss functions generated by generate-glosses"
  emit_line "# DO NOT EDIT - This file is auto-generated"
  emit_line "# Generated on $(date)"
  emit_line ""
  
  # ============================================================================
  # FIRST-WORD GLOSS COLLECTION
  # ============================================================================
  # Collect all unique first words from spells and imps
  # For multi-word commands like "env-or", extract first word "env"
  # This enables space-separated invocation: env or VAR DEFAULT
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && info "Collecting first words from all spells and imps..." >&2
  
  # ============================================================================
  # FUNCTION GENERATION HELPERS
  # ============================================================================
  
  # Check if a first word is blacklisted
  # Returns 0 if allowed, 1 if blacklisted
  is_first_word_blacklisted() {
    _check_word=$1
    
    # CRITICAL: Skip shell builtins and common system commands to avoid overriding them
    # GREYLIST: Some shell builtins CAN be safely overridden if ALL spells using that first word
    # are multi-word commands (e.g., read-magic, test-spell).
    case "$_check_word" in
      # GREYLIST: Shell builtins that CAN be safely overridden (see above)
      read|test)
        return 0  # Allow these
        ;;
      # BLACKLIST: Shell builtins that CANNOT be overridden
      alias|bg|cd|command|disable|false|fc|fg|getopts|hash|jobs|kill|newgrp|pwd|readonly|set|sh|\
times|trap|true|type|ulimit|umask|unalias|wait|break|case|continue|do|done|elif|else|\
esac|eval|exec|exit|export|fi|for|if|in|local|return|shift|then|unset|until|while)
        return 1  # Blacklisted
        ;;
      # BLACKLIST: Common system commands that should not be overridden
      awk|cat|cp|cut|date|df|diff|dirname|du|echo|egrep|env|expr|fgrep|file|find|grep|head|\
hostname|id|ln|ls|mkdir|mv|printf|ps|rm|rmdir|sed|sleep|sort|stat|tail|tar|tee|touch|tr|\
uname|uniq|wc|xargs)
        return 1  # Blacklisted
        ;;
    esac
    
    return 0  # Not blacklisted
  }
  
  # ============================================================================
  # SCAN AND GENERATE GLOSSES FOR ALL SPELLS AND IMPS (OPTIMIZED)
  # ============================================================================
  
  [ "$quiet" -eq 0 ] && info "Scanning for spells and imps..." >&2
  
  # OPTIMIZATION STRATEGY:
  # 1. Use find (necessary for nested directories like .arcana)
  # 2. Extract basenames with shell parameter expansion (no subprocess)
  # 3. Process in two passes to avoid repeated work
  # 4. Use in-memory data structures (space-separated strings) instead of temp files
  
  # First pass: Build spell name list with find + parameter expansion
  _tmpfile=$(temp-file)
  on-exit cleanup-file "$_tmpfile"
  
  # Cross-platform find command with fallbacks for different find implementations
  # Try GNU find first (-perm /111), then BSD find (-perm +111), then manual check
  find "$wizardry_dir/spells" -type f -perm /111 2>/dev/null > "$_tmpfile" || \
    find "$wizardry_dir/spells" -type f -perm +111 2>/dev/null > "$_tmpfile" || \
    find "$wizardry_dir/spells" -type f 2>/dev/null | while IFS= read -r f; do
      [ -x "$f" ] && printf '%s\n' "$f"
    done > "$_tmpfile"
  
  _spell_names=""
  _spell_count=0
  
  # Read file paths and extract basenames efficiently
  while IFS= read -r spell_path; do
    # Use parameter expansion instead of basename (100x faster)
    _name=${spell_path##*/}
    
    # Skip invalid names and parse
    case "$_name" in
      ''|.*|parse) continue ;;
    esac
    
    # Add to space-separated list
    _spell_names="$_spell_names $_name"
    _spell_count=$((_spell_count + 1))
  done < "$_tmpfile"
  
  [ "$quiet" -eq 0 ] && info "Found $_spell_count executable files" >&2
  
  # Warn if no files found
  if [ "$_spell_count" -eq 0 ]; then
    warn "generate-glosses: no executable files found in $wizardry_dir/spells" >&2
  fi
  
  # Emit comment
  emit_line "# ============================================================================"
  emit_line "# FIRST-WORD GLOSSES"
  emit_line "# ============================================================================"
  if [ "$parse_enabled" -eq 1 ]; then
    emit_line "# These enable space-separated command invocation:"
    emit_line "#   env or VAR DEFAULT  -> calls parse with all args"
    emit_line "#   temp file           -> calls parse with all args"
  else
    emit_line "# DISABLED: parse-enabled=0 in $mud_config_file"
    emit_line "# First-word glosses are not generated when parse is disabled"
  fi
  emit_line "# ============================================================================"
  emit_line ""
  
  # OPTIMIZATION: Generate first-word glosses in batched mode
  # Use in-memory tracking instead of temp file + grep
  # Pattern: " word1 word2 word3 " (leading and trailing spaces ensure exact match)
  _first_words_seen=" "  # Track with space-separated list (space prefix for matching)
  
  if [ "$parse_enabled" -eq 1 ]; then
    for spell_name in $_spell_names; do
      # Extract first word using parameter expansion (faster than sed)
      case "$spell_name" in
        *-*)
          # Multi-word spell - extract first word
          _first_word=${spell_name%%-*}
          ;;
        *)
          # Single-word spell - skip
          continue
          ;;
      esac
      
      # Check if first word is blacklisted
      if ! is_first_word_blacklisted "$_first_word"; then
        [ "$quiet" -eq 0 ] && printf 'generate-glosses: WARNING: Skipping spell "%s" - first word "%s" conflicts with system command\n' "$spell_name" "$_first_word" >&2
        continue
      fi
      
      # Check if already generated (in-memory check, no subprocess)
      case "$_first_words_seen" in
        *" $_first_word "*) continue ;;
      esac
      
      # Mark as seen
      _first_words_seen="$_first_words_seen$_first_word "
      
      # Emit function definition
      emit_line "# First-word gloss for commands starting with '$_first_word'"
      emit_line "${_first_word}() { parse \"${_first_word}\" \"\$@\"; }"
      emit_line ""
      
      total_first_word_glosses=$((total_first_word_glosses + 1))
    done
  fi
  
  # NOTE: Hyphenated aliases section removed
  # Hyphenated commands (env-or, temp-file, etc.) are now natively available
  # via PATH since invoke-wizardry adds all spell directories to PATH.
  
  # ============================================================================
  # SYNONYM GLOSSES
  # ============================================================================
  # Process user and default synonyms from .synonyms files
  # Synonym files contain simple key-value pairs (word spell-name)
  # We generate function-based glosses using parse for multi-word resolution
  # Aliases are only used for hyphenated names (POSIX sh limitation)
  # ============================================================================
  
  emit_line "# ============================================================================"
  emit_line "# USER AND DEFAULT SYNONYMS"
  emit_line "# ============================================================================"
  emit_line "# Generated from .synonyms and .default-synonyms files"
  emit_line "# ============================================================================"
  emit_line ""
  
  # User synonyms
  synonym_file="$spell_home/.synonyms"
  if [ -f "$synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing user synonyms..." >&2
    while IFS=' ' read -r _syn_word _syn_spell || [ -n "$_syn_word" ]; do
      # Skip empty lines, comments, and lines without both word and spell
      case "$_syn_word" in
        ''|\#*) continue ;;
      esac
      [ -n "$_syn_spell" ] || continue
      
      # Generate appropriate function or alias
      # Synonyms call parse with the target spell for proper resolution
      case "$_syn_word" in
        *-*)
          # POSIX sh doesn't allow hyphens in function names, must use alias
          emit_line "alias ${_syn_word}='${_syn_spell}'"
          ;;
        *)
          # Check if a first-word gloss already exists for this word
          # If so, skip creating a synonym function to avoid overriding it
          case "$_first_words_seen" in
            *" $_syn_word "*)
              # First-word gloss exists, skip synonym function
              [ "$quiet" -eq 0 ] && info "Skipping synonym function for '$_syn_word' (first-word gloss exists)" >&2
              ;;
            *)
              # No first-word gloss, create synonym function
              emit_line "${_syn_word}() { parse \"${_syn_spell}\" \"\$@\"; }"
              ;;
          esac
          ;;
      esac
    done < "$synonym_file"
    emit_line ""
  fi
  
  # Default synonyms
  default_synonym_file="$spell_home/.default-synonyms"
  if [ -f "$default_synonym_file" ]; then
    [ "$quiet" -eq 0 ] && info "Processing default synonyms..." >&2
    while IFS=' ' read -r _syn_word _syn_spell || [ -n "$_syn_word" ]; do
      # Skip empty lines, comments, and lines without both word and spell
      case "$_syn_word" in
        ''|\#*) continue ;;
      esac
      [ -n "$_syn_spell" ] || continue
      
      # Generate appropriate function or alias
      # Synonyms call parse with the target spell for proper resolution
      case "$_syn_word" in
        *-*)
          # POSIX sh doesn't allow hyphens in function names, must use alias
          emit_line "alias ${_syn_word}='${_syn_spell}'"
          ;;
        *)
          # Check if a first-word gloss already exists for this word
          # If so, skip creating a synonym function to avoid overriding it
          case "$_first_words_seen" in
            *" $_syn_word "*)
              # First-word gloss exists, skip synonym function
              [ "$quiet" -eq 0 ] && info "Skipping synonym function for '$_syn_word' (first-word gloss exists)" >&2
              ;;
            *)
              # No first-word gloss, create synonym function
              emit_line "${_syn_word}() { parse \"${_syn_spell}\" \"\$@\"; }"
              ;;
          esac
          ;;
      esac
    done < "$default_synonym_file"
    emit_line ""
  fi
  
  # ============================================================================
  # COMPLETION
  # ============================================================================
  
  # Report statistics to stderr
  if [ "$quiet" -eq 0 ]; then
    success "Gloss generation complete" >&2
    info "  First-word glosses: $total_first_word_glosses" >&2
    info "  Total spells/imps: $_spell_count" >&2
  fi
  
  exit 0
