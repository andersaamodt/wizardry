#!/bin/sh

# This spell teleports you to your system trash directory.
# Must be sourced (not executed) to change your shell's directory.

case "${1-}" in
--help|--usage|-h)
  cat << 'USAGE'
Usage: . jump-trash

Teleport to your system trash directory.
This spell must be sourced (note the dot) to change your current directory.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
jump_trash_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) jump_trash_sourced=1 ;;
  esac
else
  jump_trash_base=${0##*/}
  case "$jump_trash_base" in
    sh|dash|bash|zsh|ksh|mksh) jump_trash_sourced=1 ;;
    jump-trash) jump_trash_sourced=0 ;;
    *) jump_trash_sourced=1 ;;
  esac
fi

if [ "$jump_trash_sourced" -eq 0 ]; then
  printf '%s\n' "This spell cannot be cast directly. Invoke it with: jump trash" >&2
  return 1 2>/dev/null || exit 1
fi
unset jump_trash_sourced jump_trash_base

# Uncastable spells must remember shell mode and restore on all exits
jump_trash_saved_opts=$(set +o)
set -eu
. env-clear

# Detect trash directory
if command -v divine-trash >/dev/null 2>&1; then
  trash_path=$(divine-trash)
else
  # Inline fallback if divine-trash is not available
  platform=''
  if command -v detect-distro >/dev/null 2>&1; then
    platform=$(detect-distro 2>/dev/null || printf 'unknown')
  else
    kernel=$(uname -s 2>/dev/null || printf 'unknown')
    case "$kernel" in
    Darwin) platform='mac' ;;
    Linux) platform='linux' ;;
    *) platform='unknown' ;;
    esac
  fi
  
  case "$platform" in
  mac)
    trash_path="$HOME/.Trash"
    ;;
  *)
    xdg_data="${XDG_DATA_HOME:-$HOME/.local/share}"
    trash_path="$xdg_data/Trash/files"
    ;;
  esac
fi

if [ -z "$trash_path" ]; then
  printf '%s\n' "jump-trash: could not determine trash directory" >&2
  eval "$jump_trash_saved_opts"
  unset jump_trash_saved_opts
  return 1
fi

if [ ! -d "$trash_path" ]; then
  printf '%s\n' "jump-trash: trash directory does not exist: $trash_path" >&2
  printf '%s\n' "The trash may be empty or the directory has not been created yet." >&2
  eval "$jump_trash_saved_opts"
  unset jump_trash_saved_opts
  return 1
fi

# Check if already in trash (handle symlinks by resolving paths)
current_dir=$(pwd -P 2>/dev/null || pwd)
trash_resolved=$(cd "$trash_path" && pwd -P 2>/dev/null || printf '%s' "$trash_path")
current_resolved=$(printf '%s' "$current_dir" | sed 's|//|/|g')
trash_resolved=$(printf '%s' "$trash_resolved" | sed 's|//|/|g')

if [ "$current_resolved" = "$trash_resolved" ]; then
  printf '%s\n' "You are already in the trash directory."
  eval "$jump_trash_saved_opts"
  unset jump_trash_saved_opts
  return 0
fi

if ! cd "$trash_path"; then
  eval "$jump_trash_saved_opts"
  unset jump_trash_saved_opts
  return 1
fi
printf '%s\n' "You teleport to the trash at $trash_path"

# Restore opts
eval "$jump_trash_saved_opts"
unset jump_trash_saved_opts
