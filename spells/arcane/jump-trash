#!/bin/sh

# This spell teleports you to your system trash directory.
# Source this file or use word-of-binding to invoke it.

show_usage() {
  cat <<'USAGE'
Usage: jump-trash

Teleport to your system trash directory.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

RUNNING_AS_SCRIPT=0
case $0 in
*/jump-trash|jump-trash)
  RUNNING_AS_SCRIPT=1
  set -eu
  ;;
*) : ;;
esac

# The actual jump function that changes directory
jump_trash() {
  case "${1-}" in
  --help|--usage|-h)
    cat <<'USAGE'
Usage: jump-trash

Teleport to the system trash directory (macOS: ~/.Trash; Linux: ~/.local/share/Trash/files or $XDG_DATA_HOME/Trash/files).
USAGE
    return 0
    ;;
  esac

  # Try to use detect-trash imp, fall back to inline detection
  if command -v detect-trash >/dev/null 2>&1; then
    trash_path=$(detect-trash)
  else
    # Inline fallback
    kernel=$(uname -s 2>/dev/null || printf 'unknown')
    case "$kernel" in
      Darwin)
        trash_path="$HOME/.Trash"
        ;;
      Linux)
        xdg_data="${XDG_DATA_HOME:-$HOME/.local/share}"
        trash_path="$xdg_data/Trash/files"
        ;;
      *)
        printf '%s\n' "jump-trash: unsupported operating system: $kernel" >&2
        return 1
        ;;
    esac
  fi

  if [ -z "$trash_path" ]; then
    return 1
  fi

  if [ ! -d "$trash_path" ]; then
    printf '%s\n' "jump-trash: trash directory does not exist: $trash_path" >&2
    printf '%s\n' "The trash may be empty or the directory has not been created yet." >&2
    return 1
  fi

  cd "$trash_path" || return 1
  printf '%s\n' "You teleport to the trash at $trash_path"
}

alias jump-trash=jump_trash 2>/dev/null || true

if [ "$RUNNING_AS_SCRIPT" -eq 1 ]; then
  case ${1-} in
  --help|--usage|-h)
    show_usage
    ;;
  "")
    jump_trash || true
    ;;
  *)
    printf '%s\n' "jump-trash: unknown option '$1'." >&2
    exit 1
    ;;
  esac
fi
