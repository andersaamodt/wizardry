#!/bin/sh

# This spell teleports you to your system trash directory.
# Source this file or use word-of-binding to invoke it.

jump_trash_usage() {
  cat <<'USAGE'
Usage: jump-trash

Teleport to your system trash directory.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  jump_trash_usage
  exit 0
  ;;
esac

running_as_script=0
case $0 in
*/jump-trash|jump-trash)
  running_as_script=1
  set -eu
  . env-clear
  ;;
*) : ;;
esac

# The actual jump function that changes directory
jump_trash() {
  case "${1-}" in
  --help|--usage|-h)
    cat <<'USAGE'
Usage: jump-trash

Teleport to the system trash directory (macOS: ~/.Trash; Linux: ~/.local/share/Trash/files or $XDG_DATA_HOME/Trash/files).
USAGE
    return 0
    ;;
  esac

  # Inline get_trash_path - only used once
  if has detect-trash; then
    trash_path=$(detect-trash)
  else
    # Inline fallback if detect-trash is not available
    platform=''
    if has detect-distro; then
      platform=$(detect-distro 2>/dev/null || printf 'unknown')
    else
      kernel=$(uname -s 2>/dev/null || printf 'unknown')
      case "$kernel" in
      Darwin) platform='mac' ;;
      Linux) platform='linux' ;;
      *) platform='unknown' ;;
      esac
    fi
    
    case "$platform" in
    mac)
      trash_path="$HOME/.Trash"
      ;;
    *)
      xdg_data="${XDG_DATA_HOME:-$HOME/.local/share}"
      trash_path="$xdg_data/Trash/files"
      ;;
    esac
  fi
  
  if [ -z "$trash_path" ]; then
    return 1
  fi

  if [ ! -d "$trash_path" ]; then
    warn "jump-trash: trash directory does not exist: $trash_path"
    info "The trash may be empty or the directory has not been created yet."
    return 1
  fi

  cd "$trash_path" || return 1
  say "You teleport to the trash at $trash_path"
}

alias jump-trash=jump_trash 2>/dev/null || true

if [ "$running_as_script" -eq 1 ]; then
  # Inline jump_trash_cli logic - only used once
  case ${1-} in
  --help|--usage|-h)
    jump_trash_usage
    ;;
  "")
    jump_trash || true
    ;;
  *)
    usage-error "jump-trash" "unknown option '$1'"
    exit 2
    ;;
  esac
fi

# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="$(cd "$(dirname "$0")" && cd .. && cd .. && pwd)/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="$(cd "$(dirname "$0")" && cd .. && cd .. && pwd)/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
