#!/bin/sh

# This spell teleports you to your system trash directory.
# Must be sourced (not executed) to change your shell's directory.

case "${1-}" in
--help|--usage|-h)
  cat << 'USAGE'
Usage: . jump-trash

Teleport to your system trash directory.
This spell must be sourced (note the dot) to change your current directory.
USAGE
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - ensures spell is sourced, not executed
jump_trash_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) jump_trash_sourced=1 ;;
  esac
else
  jump_trash_base=${0##*/}
  case "$jump_trash_base" in
    sh|dash|bash|zsh|ksh|mksh) jump_trash_sourced=1 ;;
    jump-trash) jump_trash_sourced=0 ;;
    *) jump_trash_sourced=1 ;;
  esac
fi

if [ "$jump_trash_sourced" -eq 0 ]; then
  printf '%s\n' "This spell cannot be cast directly. Invoke it with: jump trash" >&2
  return 1 2>/dev/null || exit 1
fi
unset jump_trash_sourced jump_trash_base

set -eu
. env-clear

# Detect trash directory
if command -v detect-trash >/dev/null 2>&1; then
  trash_path=$(detect-trash)
else
  # Inline fallback if detect-trash is not available
  platform=''
  if command -v detect-distro >/dev/null 2>&1; then
    platform=$(detect-distro 2>/dev/null || printf 'unknown')
  else
    kernel=$(uname -s 2>/dev/null || printf 'unknown')
    case "$kernel" in
    Darwin) platform='mac' ;;
    Linux) platform='linux' ;;
    *) platform='unknown' ;;
    esac
  fi
  
  case "$platform" in
  mac)
    trash_path="$HOME/.Trash"
    ;;
  *)
    xdg_data="${XDG_DATA_HOME:-$HOME/.local/share}"
    trash_path="$xdg_data/Trash/files"
    ;;
  esac
fi

if [ -z "$trash_path" ]; then
  printf '%s\n' "jump-trash: could not determine trash directory" >&2
  return 1 2>/dev/null || exit 1
fi

if [ ! -d "$trash_path" ]; then
  printf '%s\n' "jump-trash: trash directory does not exist: $trash_path" >&2
  printf '%s\n' "The trash may be empty or the directory has not been created yet." >&2
  return 1 2>/dev/null || exit 1
fi

# Check if already in trash (handle symlinks by resolving paths)
current_dir=$(pwd -P 2>/dev/null || pwd)
trash_resolved=$(cd "$trash_path" && pwd -P 2>/dev/null || printf '%s' "$trash_path")
current_resolved=$(printf '%s' "$current_dir" | sed 's|//|/|g')
trash_resolved=$(printf '%s' "$trash_resolved" | sed 's|//|/|g')

if [ "$current_resolved" = "$trash_resolved" ]; then
  printf '%s\n' "You are already in the trash directory."
  return 0 2>/dev/null || exit 0
fi

cd "$trash_path" || { return 1 2>/dev/null || exit 1; }
printf '%s\n' "You teleport to the trash at $trash_path"
