#!/bin/sh

# Convert a text file to a folder. If the file had any contents, they are moved to "project notes" inside the new folder.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: file-to-folder <file>

Convert a text file to a folder of the same name. If the text file had any contents, these contents are moved to be in the new folder and renamed "project notes" (with the same extension the text file had before). Extended attributes (xattrs) are preserved.
USAGE
  exit 0
  ;;
esac

set -eu
. env-clear

# Check if file argument is provided
if [ "$#" -eq 0 ]; then
  printf '%s\n' "file-to-folder: file path required" >&2
  exit 2
fi

file="$1"

# Check if file exists
if ! there "$file"; then
  printf '%s\n' "file-to-folder: file does not exist" >&2
  exit 1
fi

# Check if it's actually a file (not a directory)
if [ -d "$file" ]; then
  printf '%s\n' "file-to-folder: path is already a folder" >&2
  exit 1
fi

# Check if file is a plain text file
if ! has file; then
  printf '%s\n' "file-to-folder: 'file' command required to detect file type" >&2
  exit 1
fi

mime_type=$(file -b --mime-type "$file" 2>/dev/null || printf '')
case "$mime_type" in
  text/*|inode/x-empty)
    # Plain text file or empty file - OK to proceed
    ;;
  *)
    printf '%s\n' "file-to-folder: file is not a plain text file (type: $mime_type)" >&2
    exit 1
    ;;
esac

# Try to read priority attributes and hash from the file (if they exist)
echelon=""
priority=""
old_hash=""
if has read-magic && has disenchant && has enchant; then
  # Try to read the echelon and priority attributes
  echelon=$(read-magic "$file" echelon 2>/dev/null || printf '')
  priority=$(read-magic "$file" priority 2>/dev/null || printf '')
  # Try to read the hash attribute (if file was previously hashed)
  old_hash=$(read-magic "$file" hash 2>/dev/null || printf '')
fi

# Get the directory containing the file
parent_dir=$(dirname "$file")
if [ "$parent_dir" = "." ]; then
  parent_dir=$(pwd -P)
fi

# Get the base name (filename without path)
filename=$(basename "$file")

# Extract extension if present
case "$filename" in
  *.*)
    # Has extension
    extension="${filename##*.}"
    basename_no_ext="${filename%.*}"
    ;;
  *)
    # No extension
    extension=""
    basename_no_ext="$filename"
    ;;
esac

# Check if file has any non-whitespace content
has_content=0
if [ -s "$file" ]; then
  # File has size, check if it contains non-whitespace
  if grep -q '[^[:space:]]' "$file" 2>/dev/null; then
    has_content=1
  fi
fi

# Create temporary file in the same directory to preserve xattrs
temp_file=$(temp-file file-to-folder)

# Move the original file to temp location (preserves xattrs)
mv "$file" "$temp_file"

# Create folder with the original file's name
mkdir -p "$file"

# Only move the temp file into the new folder if it has non-whitespace content
if [ "$has_content" -eq 1 ]; then
  # Move the temp file into the new folder and rename it
  if [ -n "$extension" ]; then
    mv "$temp_file" "$file/project notes.$extension"
    moved_file="$file/project notes.$extension"
  else
    mv "$temp_file" "$file/project notes"
    moved_file="$file/project notes"
  fi
  
  # If echelon/priority were found, transfer them from the file to the folder
  if [ -n "$echelon" ]; then
    # Remove echelon from the moved file (the original file's xattrs were preserved via mv)
    disenchant "$moved_file" echelon 2>/dev/null || true
    # Apply the echelon to the folder
    enchant "$file" "echelon=$echelon" 2>/dev/null || true
  fi
  if [ -n "$priority" ]; then
    # Remove priority from the moved file (the original file's xattrs were preserved via mv)
    disenchant "$moved_file" priority 2>/dev/null || true
    # Apply the priority to the folder
    enchant "$file" "priority=$priority" 2>/dev/null || true
  fi
else
  # Remove the empty/whitespace-only temp file
  rm -f "$temp_file"
  
  # If echelon/priority were found, still apply them to the folder
  if [ -n "$echelon" ]; then
    enchant "$file" "echelon=$echelon" 2>/dev/null || true
  fi
  if [ -n "$priority" ]; then
    enchant "$file" "priority=$priority" 2>/dev/null || true
  fi
fi

# If the original file had a hash and was in the parent's priorities list,
# update the priorities list to use the new folder's hash instead
if [ -n "$old_hash" ] && has hashchant; then
  # Hash the new folder
  if hashchant "$file" >/dev/null 2>&1; then
    new_hash=$(read-magic "$file" hash 2>/dev/null || printf '')
    
    # If we successfully got both hashes and they're different
    if [ -n "$new_hash" ] && [ "$old_hash" != "$new_hash" ]; then
      # Read the parent directory's priorities list
      parent_priorities=$(read-magic "$parent_dir" priorities 2>/dev/null || printf '')
      
      # If the priorities list exists and contains the old hash, replace it with the new hash
      case "$parent_priorities" in
        *"$old_hash"*)
          # Replace old hash with new hash in the priorities list
          updated_priorities=$(printf '%s' "$parent_priorities" | sed "s/^${old_hash},/${new_hash},/;s/,${old_hash},/,${new_hash},/;s/,${old_hash}\$$/,${new_hash}/;s/^${old_hash}\$/${new_hash}/")
          enchant "$parent_dir" "priorities=$updated_priorities" 2>/dev/null || true
          ;;
      esac
    fi
  fi
fi

printf '%s\n' "Converted file to folder: $file"
