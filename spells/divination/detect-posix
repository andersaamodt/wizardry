#!/bin/sh

# Load required imps for direct execution
if ! command -v require_wizardry >/dev/null 2>&1; then
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _i="$WIZARDRY_DIR/spells/.imps/sys"
  elif [ -n "${ROOT_DIR-}" ]; then
    _i="$ROOT_DIR/spells/.imps/sys"
  else
    _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
  fi
  [ -f "$_i/require-wizardry" ] && . "$_i/require-wizardry"
fi


# Probe for POSIX toolchain availability and baseline POSIX shell behaviors.
# Reports missing tools and simple capability checks to guide portability.
# BOOTSTRAP: This spell works in bootstrap mode without requiring wizardry imps.

detect_posix_usage() {
  cat <<'USAGE'
Usage: detect-posix [--verbose]

Report POSIX toolchain availability and probe baseline POSIX behaviors. Use --verbose for a per-tool report.
USAGE
}


detect_posix() {
case "${1-}" in
--help|--usage|-h)
  detect_posix_usage
  return 0
  ;;
esac

# Optional: try to use wizardry if available (for when used in normal mode)
# But don't fail if wizardry isn't set up yet (for bootstrap use)
if command -v require_wizardry >/dev/null 2>&1; then
  require_wizardry || return 1
fi

set -eu

# Inline helper functions (detect-posix needs to work as a bootstrap tool)
detect_posix_has() {
  command -v "$1" >/dev/null 2>&1
}

detect_posix_temp_dir() {
  mktemp -d "${TMPDIR:-/tmp}/detect-posix.XXXXXX"
}

detect_posix_cleanup_dir() {
  [ -n "${1-}" ] && [ -d "$1" ] && rm -rf "$1"
}

detect_posix_print_pass() {
  printf '  ✓ %s\n' "$*"
}

detect_posix_print_fail() {
  printf '  ✗ %s: %s\n' "$1" "$2" >&2
}

verbose=0
while [ "$#" -gt 0 ]; do
  case $1 in
    --verbose|-v)
      verbose=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -* )
      detect_posix_usage >&2
      return 2
      ;;
    *)
      break
      ;;
  esac
done

if [ "$#" -gt 0 ]; then
  detect_posix_usage >&2
  return 2
fi

toolchain=${DETECT_POSIX_TOOLS-}
if [ -z "$toolchain" ]; then
  toolchain="sh awk sed grep find xargs sort cut head tail tr wc uname mktemp"
fi

probe_set=${DETECT_POSIX_PROBES-}
if [ -z "$probe_set" ]; then
  probe_set="sh awk sed grep find"
fi

missing_tools=''
tool_fail=0
probe_fail=0

tmpdir=''
case " $probe_set " in
  *" find "*)
    tmpdir=$(detect_posix_temp_dir) || return 1
    touch "$tmpdir/probe"
    trap 'detect_posix_cleanup_dir "$tmpdir"' EXIT HUP INT TERM
    ;;
esac

if [ "$verbose" -eq 1 ]; then
  printf '%s\n' 'POSIX toolchain:'
fi

for tool in $toolchain; do
  if detect_posix_has "$tool"; then
    if [ "$verbose" -eq 1 ]; then
      detect_posix_print_pass "$tool"
    fi
  else
    tool_fail=1
    missing_tools="${missing_tools:+$missing_tools }$tool"
    if [ "$verbose" -eq 1 ]; then
      detect_posix_print_fail "$tool" "missing"
    fi
  fi
done

if [ "$verbose" -eq 1 ]; then
  printf '\n%s\n' 'POSIX capability probes:'
fi

for probe in $probe_set; do
  case $probe in
    sh)
      if sh -c 'foo=bar; [ "$foo" = "bar" ]'; then
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_pass "sh basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_fail "sh basics" "failed"
        fi
      fi
      ;;
    awk)
      if sh -c "printf 'a\\n' | awk 'NR==1 {print \$1}' | grep -q '^a$'"; then
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_pass "awk basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_fail "awk basics" "failed"
        fi
      fi
      ;;
    sed)
      if sh -c "printf 'a\\n' | sed 's/a/b/' | grep -q '^b$'"; then
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_pass "sed basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_fail "sed basics" "failed"
        fi
      fi
      ;;
    grep)
      if sh -c "printf 'a\\n' | grep -q 'a'"; then
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_pass "grep basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_fail "grep basics" "failed"
        fi
      fi
      ;;
    find)
      if [ -n "$tmpdir" ] && sh -c "find '$tmpdir' -type f -name probe | grep -q 'probe'"; then
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_pass "find basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          detect_posix_print_fail "find basics" "failed"
        fi
      fi
      ;;
    *)
      detect_posix_print_fail "detect-posix" "unknown probe '$probe'"
      return 2
      ;;
  esac
done

if [ "$tool_fail" -eq 0 ] && [ "$probe_fail" -eq 0 ]; then
  printf '%s\n' 'POSIX toolchain and probes look healthy.'
  return 0
fi

if [ "$tool_fail" -ne 0 ]; then
  printf '%s\n' "detect-posix: missing tools: $missing_tools" >&2
fi
if [ "$probe_fail" -ne 0 ]; then
  printf '%s\n' 'detect-posix: one or more POSIX probes failed.' >&2
fi
return 1
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
