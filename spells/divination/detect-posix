#!/bin/sh

# Probe for POSIX toolchain availability and baseline POSIX shell behaviors.
# Reports missing tools and simple capability checks to guide portability.

detect_posix_usage() {
  cat <<'USAGE'
Usage: detect-posix [--verbose]

Report POSIX toolchain availability and probe baseline POSIX behaviors. Use --verbose for a per-tool report.
USAGE
}


detect_posix() {
case "${1-}" in
--help|--usage|-h)
  detect_posix_usage
  return 0
  ;;
esac

set -eu
. env-clear

verbose=0
while [ "$#" -gt 0 ]; do
  case $1 in
    --verbose|-v)
      verbose=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -* )
      detect_posix_usage >&2
      return 2
      ;;
    *)
      break
      ;;
  esac
done

if [ "$#" -gt 0 ]; then
  detect_posix_usage >&2
  return 2
fi

toolchain=${DETECT_POSIX_TOOLS-}
if [ -z "$toolchain" ]; then
  toolchain="sh awk sed grep find xargs sort cut head tail tr wc uname mktemp"
fi

probe_set=${DETECT_POSIX_PROBES-}
if [ -z "$probe_set" ]; then
  probe_set="sh awk sed grep find"
fi

missing_tools=''
tool_fail=0
probe_fail=0

tmpdir=''
case " $probe_set " in
  *" find "*)
    tmpdir=$(temp-dir detect-posix) || return 1
    touch "$tmpdir/probe"
    trap 'cleanup-dir "$tmpdir"' EXIT HUP INT TERM
    ;;
esac

if [ "$verbose" -eq 1 ]; then
  printf '%s\n' 'POSIX toolchain:'
fi

for tool in $toolchain; do
  if has "$tool"; then
    if [ "$verbose" -eq 1 ]; then
      print-pass "$tool"
    fi
  else
    tool_fail=1
    missing_tools="${missing_tools:+$missing_tools }$tool"
    if [ "$verbose" -eq 1 ]; then
      print-fail "$tool" "missing"
    fi
  fi
done

if [ "$verbose" -eq 1 ]; then
  printf '\n%s\n' 'POSIX capability probes:'
fi

for probe in $probe_set; do
  case $probe in
    sh)
      if sh -c 'foo=bar; [ "$foo" = "bar" ]'; then
        if [ "$verbose" -eq 1 ]; then
          print-pass "sh basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          print-fail "sh basics" "failed"
        fi
      fi
      ;;
    awk)
      if sh -c "printf 'a\\n' | awk 'NR==1 {print \$1}' | grep -q '^a$'"; then
        if [ "$verbose" -eq 1 ]; then
          print-pass "awk basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          print-fail "awk basics" "failed"
        fi
      fi
      ;;
    sed)
      if sh -c "printf 'a\\n' | sed 's/a/b/' | grep -q '^b$'"; then
        if [ "$verbose" -eq 1 ]; then
          print-pass "sed basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          print-fail "sed basics" "failed"
        fi
      fi
      ;;
    grep)
      if sh -c "printf 'a\\n' | grep -q 'a'"; then
        if [ "$verbose" -eq 1 ]; then
          print-pass "grep basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          print-fail "grep basics" "failed"
        fi
      fi
      ;;
    find)
      if [ -n "$tmpdir" ] && sh -c "find '$tmpdir' -type f -name probe | grep -q 'probe'"; then
        if [ "$verbose" -eq 1 ]; then
          print-pass "find basics"
        fi
      else
        probe_fail=1
        if [ "$verbose" -eq 1 ]; then
          print-fail "find basics" "failed"
        fi
      fi
      ;;
    *)
      print-fail "detect-posix" "unknown probe '$probe'"
      return 2
      ;;
  esac
done

if [ "$tool_fail" -eq 0 ] && [ "$probe_fail" -eq 0 ]; then
  printf '%s\n' 'POSIX toolchain and probes look healthy.'
  return 0
fi

if [ "$tool_fail" -ne 0 ]; then
  printf '%s\n' "detect-posix: missing tools: $missing_tools" >&2
fi
if [ "$probe_fail" -ne 0 ]; then
  printf '%s\n' 'detect-posix: one or more POSIX probes failed.' >&2
fi
return 1
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
