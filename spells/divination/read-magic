#!/bin/sh

# This spell lists extended attributes from a file, optionally narrowing to one key.
# It walks through existence checks and available helpers in a linear, didactic order.

show_usage() {
        cat <<'USAGE'
Usage: read-magic <file> [attribute]

List all extended attributes on a file, or print the value of a named
attribute when provided. Supports attr, xattr, and getfattr as available.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

require_args() {
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    printf '%s\n' "Error: This spell requires one or two arguments: a file path and an optional attribute name."
    return 1
  fi
}

file_exists() {
  if [ ! -e "$1" ]; then
    printf '%s\n' "Error: The file does not exist."
    return 1
  fi
}

parse_attr_output() {
  printf '%s\n' "$1" | awk '
    NF {
      # Track the last non-empty line so we can pick the raw value when attr
      # prints a header followed by the payload on the next line.
      lines[NR] = $0
      last = NR
      last_nonempty = NR
    }
    END {
      if (last > 1 && last_nonempty > 0) {
        print lines[last_nonempty]
        exit
      }

      line = lines[last]

      # attr -g verbose output (and similar stubs) often look like:
      #   Attribute "user.beta" has a value: beta-value
      if (match(line, /has a [^:]*:[[:space:]]*(.*)$/, m)) {
        print m[1]
        exit
      }

      # Prefer a colon-delimited value on the sole line when present.
      if (match(line, /:[[:space:]]*(.*)$/, m)) {
        print m[1]
        exit
      }

      # As a last resort, trim after "value for" phrases to avoid returning file paths.
      if (match(line, /value for[[:space:]]*([^:]+)$/, m)) {
        print m[1]
        exit
      }

      # Fall back to the raw line.
      print line
    }
  '
}

helper_usable() {
  helper=$1
  if ! command -v "$helper" >/dev/null 2>&1; then
    return 1
  fi

  # read-magic needs to exercise system-provided attr/xattr/getfattr during
  # tests, even when helper filtering is enabled, because GitHub runners only
  # ship those binaries in system locations.
  case "$helper" in
    attr|xattr|getfattr)
      return 0 ;;
  esac

  if [ "${WIZARDRY_TEST_HELPERS_ONLY-0}" -eq 1 ]; then
    helper_path=$(command -v "$helper")
    case "$helper_path" in
      /usr/*|/bin/*|/sbin/*|/usr/local/*)
        return 1 ;;
    esac
  fi

  return 0
}

read_value() {
  key=$1
  file=$2

  if helper_usable attr; then
    if output=$(attr -q -g "$key" "$file" 2>/dev/null); then
      printf '%s' "$output"
      return 0
    elif output=$(attr -g "$key" "$file" 2>/dev/null); then
      parse_attr_output "$output"
      return 0
    fi
  fi

  if helper_usable xattr; then
    if output=$(xattr -p "$key" "$file" 2>/dev/null); then
      printf '%s' "$output"
      return 0
    fi
  fi

  if helper_usable getfattr; then
    if output=$(getfattr -n "$key" --only-values "$file" 2>/dev/null); then
      printf '%s' "$output"
      return 0
    fi
  fi

  return 1
}

list_keys() {
  file=$1

  if helper_usable attr; then
    if keys=$(attr -l "$file" 2>/dev/null); then
      parsed=$(printf '%s\n' "$keys" | awk '
        match($0,/Attribute "([^"]+)"/,m){print m[1]; next}
        NF{print}
      ')
      if [ -n "$parsed" ]; then
        printf '%s\n' "$parsed"
        return 0
      fi
    fi
  fi

  if helper_usable xattr; then
    if keys=$(xattr "$file" 2>/dev/null); then
      if [ -n "$keys" ]; then
        printf '%s\n' "$keys"
        return 0
      fi
    fi
  fi

  if helper_usable getfattr; then
    if keys=$(getfattr -d "$file" 2>/dev/null); then
      parsed=$(printf '%s' "$keys" | awk -F '=' '/^# / {next} {print $1}')
      if [ -n "$parsed" ]; then
        printf '%s' "$parsed"
        return 0
      fi
    fi
  fi

  return 1
}

print_all_attributes() {
  file=$1

  keys=$(list_keys "$file" || printf '')

  if [ -z "$keys" ]; then
    printf '%s\n' "No enchanted attributes found."
    return
  fi

  printf '%s\n' "$keys" | while IFS= read -r key || [ -n "$key" ]; do
    [ -z "$key" ] && continue
    value=$(read_value "$key" "$file" || printf '')
    printf '%s: %s\n' "$key" "$value"
  done
}

main() {
  if ! require_args "$@"; then
    exit 1
  fi

  file=$1
  attribute=${2-}

  if ! file_exists "$file"; then
    exit 1
  fi

  if [ -z "$attribute" ]; then
    print_all_attributes "$file"
    exit 0
  fi

  if value=$(read_value "$attribute" "$file"); then
    printf '%s\n' "$value"
  else
    printf '%s\n' "Error: The attribute does not exist."
    exit 1
  fi
}

main "$@"
