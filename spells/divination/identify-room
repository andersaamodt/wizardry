#!/bin/sh

# This spell names common system rooms and describes their usual roles.
# Use it to learn what important directories are for or to list recognized rooms.

require-wizardry || return 1

identify_room_usage() {
cat <<'USAGE'
Usage: identify-room [--list] [path]

Identify whether a path is a special system room. Prints a title and description
when recognized, or notes when a room has no special meaning. Use --list to show
recognized locations for this platform.
USAGE
}



identify_room() {
case "${1-}" in
--help|--usage|-h)
  identify_room_usage
  return 0
  ;;
esac

set -eu
env-clear

list_only=0
case "${1-}" in
--list)
  list_only=1
  shift
  ;;
esac
while getopts hl opt
do
  case $opt in
  l)
    list_only=1
    ;;
  h)
    identify_room_usage
    return 0
    ;;
  *)
    identify_room_usage >&2
    return 1
    ;;
  esac
done
shift $((OPTIND - 1))

if [ "$list_only" -eq 1 ] && [ "$#" -gt 0 ]; then
  identify_room_usage >&2
  return 1
fi

root_path=/
tmp_path=$(strip-trailing-slashes "$(abs-path "${TMPDIR:-/tmp}")")
default_tmp_path=$(strip-trailing-slashes "$(abs-path /tmp)")
var_tmp_path=''
if [ -d /var/tmp ]; then
  var_tmp_path=$(strip-trailing-slashes "$(abs-path /var/tmp)")
fi
have_home=0
normalized_home=''
home_parent=''
home_name=''

# Inline home_path logic - only used once
if [ -n "${IDENTIFY_ROOM_HOME-}" ]; then
  resolved_home=$IDENTIFY_ROOM_HOME
  have_home=1
elif [ -n "${LOOK_HOME_PATH-}" ]; then
  resolved_home=$LOOK_HOME_PATH
  have_home=1
elif [ -n "${HOME-}" ]; then
  resolved_home=$HOME
  have_home=1
fi

if [ "$have_home" -eq 1 ]; then
  normalized_home=$(strip-trailing-slashes "$(abs-path "$resolved_home")")
  home_parent=$(dirname -- "$normalized_home")
  home_name=$(basename -- "$normalized_home")
fi

# Use detect-distro spell (exists and is available)
if has detect-distro; then
  distro=$(detect-distro 2>/dev/null || true)
else
  kernel=$(uname -s 2>/dev/null || printf '')
  case $kernel in
  Darwin) distro='mac' ;;
  Linux) distro='linux' ;;
  *) distro='' ;;
  esac
fi

recognize_room() {
  room=$1

  if [ "$room" = "$root_path" ]; then
    printf '%s\n' "Root"
    printf '%s\n' "The root of the filesystem."
    return 0
  fi

  # Check if room is a temporary directory
  is_tmp=0
  if [ "$room" = "$tmp_path" ]; then
    is_tmp=1
  elif [ "$room" = "$default_tmp_path" ] && [ "$default_tmp_path" != "$tmp_path" ]; then
    is_tmp=1
  elif [ -n "$var_tmp_path" ] && [ "$room" = "$var_tmp_path" ]; then
    is_tmp=1
  fi
  
  if [ "$is_tmp" -eq 1 ]; then
    printf '%s\n' "Temporary Directory"
    printf '%s\n' "A temporary workspace where creations are fleeting."
    return 0
  fi

  if [ "$have_home" -eq 1 ]; then
    if [ "$room" = "$normalized_home" ]; then
      printf '%s\n' "Home"
      printf '%s\n' "Your home folder."
      return 0
    fi

    if [ "$home_parent" != "$normalized_home" ] && [ "$home_parent" != '/' ]; then
      case "$room" in
      "$home_parent"/*)
        other_user=${room#"$home_parent"/}
        case "$other_user" in
        ""|*/*) ;;
        "$home_name") ;;
        *)
          # Inline possessive_name logic - only used once in this spell
          if has possessive; then
            owner=$(possessive "$other_user")
          else
            case $other_user in
            *[sS]) owner="${other_user}'" ;;
            *) owner="${other_user}'s" ;;
            esac
          fi
          printf '%s\n' "$owner Home"
          printf '%s\n' "$owner home folder."
          return 0
          ;;
        esac
        ;;
      esac
    fi
  fi

  case "$room" in
  /etc|/private/etc)
    printf '%s\n' "Configuration Library"
    printf '%s\n' "System configuration archives line the shelves."
    return 0
    ;;
  /var|/private/var)
    printf '%s\n' "Variable Data"
    printf '%s\n' "Changing state, caches, and queues gather here."
    return 0
    ;;
  /var/log|/private/var/log)
    printf '%s\n' "Log Archive"
    printf '%s\n' "A hall of chronicles where logs accumulate."
    return 0
    ;;
  /usr)
    printf '%s\n' "System Domain"
    printf '%s\n' "Shared system utilities and libraries reside here."
    return 0
    ;;
  /usr/local)
    printf '%s\n' "Local Workshop"
    printf '%s\n' "Locally installed tools gather in this workshop."
    return 0
    ;;
  /bin)
    printf '%s\n' "Essential Binaries"
    printf '%s\n' "Core user commands live here."
    return 0
    ;;
  /sbin)
    printf '%s\n' "System Binaries"
    printf '%s\n' "Administration tools and daemons gather here."
    return 0
    ;;
  /opt)
    printf '%s\n' "Optional Packages"
    printf '%s\n' "Third-party or optional software installs dwell here."
    return 0
    ;;
  /srv)
    printf '%s\n' "Service Data"
    printf '%s\n' "Data served by system services is kept here."
    return 0
    ;;
  /run)
    printf '%s\n' "Runtime State"
    printf '%s\n' "Volatile runtime data for processes."
    return 0
    ;;
  /dev)
    printf '%s\n' "Device Files"
    printf '%s\n' "Entries that represent devices and pseudo-devices."
    return 0
    ;;
  /proc)
    printf '%s\n' "Process Registry"
    printf '%s\n' "A virtual view into the kernel and running processes."
    return 0
    ;;
  /boot)
    printf '%s\n' "Boot Artifacts"
    printf '%s\n' "Kernel images and bootloader data are stored here."
    return 0
    ;;
  /home)
    printf '%s\n' "Home Dwellings"
    printf '%s\n' "User home directories gather in this district."
    return 0
    ;;
  esac

  if [ "$distro" = "mac" ]; then
    case "$room" in
    /Users)
      printf '%s\n' "User Homes"
      printf '%s\n' "Personal home folders reside in this province."
      return 0
      ;;
    /Applications)
      printf '%s\n' "Applications"
      printf '%s\n' "Graphical applications installed for all users."
      return 0
      ;;
    /System)
      printf '%s\n' "System Domain"
      printf '%s\n' "Core system components curated by the OS."
      return 0
      ;;
    /Library)
      printf '%s\n' "System Library"
      printf '%s\n' "System-wide support files and frameworks."
      return 0
      ;;
    esac
  fi

  return 1
}

if [ "$list_only" -eq 1 ]; then
  # Inline list_recognized and list_rooms - both only used once
  previous=''
  for dir in \
    "$root_path" \
    "$tmp_path" \
    "$default_tmp_path" \
    "$var_tmp_path" \
    "$normalized_home" \
    "$home_parent" \
    /etc /var /var/log /usr /usr/local /bin /sbin /opt \
    /srv /run /dev /proc /boot /home /Users \
    /Applications /System /Library
  do
    [ -n "$dir" ] || continue
    if [ "$dir" = "$previous" ]; then
      continue
    fi
    previous=$dir
    [ -d "$dir" ] || continue
    # Inline list_rooms logic
    if room_output=$(recognize_room "$dir" 2>/dev/null); then
      room_title=$(printf '%s' "$room_output" | sed -n '1p')
      printf '%s - %s\n' "$dir" "$room_title"
    fi
  done
  return 0
fi

target_path=${1:-$PWD}
normalized_target=$(strip-trailing-slashes "$(abs-path "$target_path")")

if recognize_room "$normalized_target"; then
  return 0
fi

printf '%s\n' 'This room has no special meaning within the UNIX system.'
return 1
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
