#!/bin/sh

# This spell names common system rooms and describes their usual roles.
# Use it to learn what important directories are for or to list recognized rooms.
require-wizardry || exit 1
identify_room_usage() {
cat <<'USAGE'
Usage: identify-room [--list] [path]
Identify whether a path is a special system room. Prints a title and description
when recognized, or notes when a room has no special meaning. Use --list to show
recognized locations for this platform.
USAGE
}
identify_room() {
case "${1-}" in
--help|--usage|-h)
  identify_room_usage
  return 0
  ;;
esac
set -eu
# env-clear: compliant
list_only=0
--list)
  list_only=1
  shift
while getopts hl opt
do
  case $opt in
  l)
    list_only=1
    ;;
  h)
    identify_room_usage
    return 0
  *)
    identify_room_usage >&2
    return 1
  esac
done
shift $((OPTIND - 1))
if [ "$list_only" -eq 1 ] && [ "$#" -gt 0 ]; then
  identify_room_usage >&2
  return 1
fi
root_path=/
tmp_path=$(strip-trailing-slashes "$(abs-path "${TMPDIR:-/tmp}")")
default_tmp_path=$(strip-trailing-slashes "$(abs-path /tmp)")
var_tmp_path=''
if [ -d /var/tmp ]; then
  var_tmp_path=$(strip-trailing-slashes "$(abs-path /var/tmp)")
have_home=0
normalized_home=''
home_parent=''
home_name=''
# Inline home_path logic - only used once
if [ -n "${IDENTIFY_ROOM_HOME-}" ]; then
  resolved_home=$IDENTIFY_ROOM_HOME
  have_home=1
elif [ -n "${LOOK_HOME_PATH-}" ]; then
  resolved_home=$LOOK_HOME_PATH
elif [ -n "${HOME-}" ]; then
  resolved_home=$HOME
if [ "$have_home" -eq 1 ]; then
  normalized_home=$(strip-trailing-slashes "$(abs-path "$resolved_home")")
  home_parent=$(dirname -- "$normalized_home")
  home_name=$(basename -- "$normalized_home")
# Use detect-distro spell (exists and is available)
if command -v detect-distro >/dev/null 2>&1; then
  distro=$(detect-distro 2>/dev/null || true)
else
  kernel=$(uname -s 2>/dev/null || printf '')
  case $kernel in
  Darwin) distro='mac' ;;
  Linux) distro='linux' ;;
  *) distro='' ;;
recognize_room() {
  room=$1
  if [ "$room" = "$root_path" ]; then
    printf '%s\n' "Root"
    printf '%s\n' "The root of the filesystem."
  fi
  if [ "$room" = "$tmp_path" ] || { [ "$room" = "$default_tmp_path" ] && [ "$default_tmp_path" != "$tmp_path" ]; } || { [ -n "$var_tmp_path" ] && [ "$room" = "$var_tmp_path" ]; }; then
    printf '%s\n' "Temporary Directory"
    printf '%s\n' "A temporary workspace where creations are fleeting."
  if [ "$have_home" -eq 1 ]; then
    if [ "$room" = "$normalized_home" ]; then
      printf '%s\n' "Home"
      printf '%s\n' "Your home folder."
      return 0
    fi
    if [ "$home_parent" != "$normalized_home" ] && [ "$home_parent" != '/' ]; then
      case "$room" in
      "$home_parent"/*)
        other_user=${room#"$home_parent"/}
        case "$other_user" in
        ""|*/*) ;;
        "$home_name") ;;
        *)
          # Inline possessive_name logic - only used once in this spell
          if command -v possessive >/dev/null 2>&1; then
            owner=$(possessive "$other_user")
          else
            case $other_user in
            *[sS]) owner="${other_user}'" ;;
            *) owner="${other_user}'s" ;;
            esac
          fi
          printf '%s\n' "$owner Home"
          printf '%s\n' "$owner home folder."
          return 0
          ;;
        esac
        ;;
      esac
  case "$room" in
  /etc|/private/etc)
    printf '%s\n' "Configuration Library"
    printf '%s\n' "System configuration archives line the shelves."
  /var|/private/var)
    printf '%s\n' "Variable Data"
    printf '%s\n' "Changing state, caches, and queues gather here."
  /var/log|/private/var/log)
    printf '%s\n' "Log Archive"
    printf '%s\n' "A hall of chronicles where logs accumulate."
  /usr)
    printf '%s\n' "System Domain"
    printf '%s\n' "Shared system utilities and libraries reside here."
  /usr/local)
    printf '%s\n' "Local Workshop"
    printf '%s\n' "Locally installed tools gather in this workshop."
  /bin)
    printf '%s\n' "Essential Binaries"
    printf '%s\n' "Core user commands live here."
  /sbin)
    printf '%s\n' "System Binaries"
    printf '%s\n' "Administration tools and daemons gather here."
  /opt)
    printf '%s\n' "Optional Packages"
    printf '%s\n' "Third-party or optional software installs dwell here."
  /srv)
    printf '%s\n' "Service Data"
    printf '%s\n' "Data served by system services is kept here."
  /run)
    printf '%s\n' "Runtime State"
    printf '%s\n' "Volatile runtime data for processes."
  /dev)
    printf '%s\n' "Device Files"
    printf '%s\n' "Entries that represent devices and pseudo-devices."
  /proc)
    printf '%s\n' "Process Registry"
    printf '%s\n' "A virtual view into the kernel and running processes."
  /boot)
    printf '%s\n' "Boot Artifacts"
    printf '%s\n' "Kernel images and bootloader data are stored here."
  /home)
    printf '%s\n' "Home Dwellings"
    printf '%s\n' "User home directories gather in this district."
  if [ "$distro" = "mac" ]; then
    case "$room" in
    /Users)
      printf '%s\n' "User Homes"
      printf '%s\n' "Personal home folders reside in this province."
      ;;
    /Applications)
      printf '%s\n' "Applications"
      printf '%s\n' "Graphical applications installed for all users."
    /System)
      printf '%s\n' "System Domain"
      printf '%s\n' "Core system components curated by the OS."
    /Library)
      printf '%s\n' "System Library"
      printf '%s\n' "System-wide support files and frameworks."
    esac
if [ "$list_only" -eq 1 ]; then
  # Inline list_recognized and list_rooms - both only used once
  previous=''
  for dir in \
    "$root_path" \
    "$tmp_path" \
    "$default_tmp_path" \
    "$var_tmp_path" \
    "$normalized_home" \
    "$home_parent" \
    /etc /var /var/log /usr /usr/local /bin /sbin /opt /srv /run /dev /proc /boot /home /Users /Applications /System /Library
  do
    [ -n "$dir" ] || continue
    if [ "$dir" = "$previous" ]; then
      continue
    previous=$dir
    [ -d "$dir" ] || continue
    # Inline list_rooms logic
    if room_output=$(recognize_room "$dir" 2>/dev/null); then
      room_title=$(printf '%s' "$room_output" | sed -n '1p')
      printf '%s - %s\n' "$dir" "$room_title"
  done
target_path=${1:-$PWD}
normalized_target=$(strip-trailing-slashes "$(abs-path "$target_path")")
if recognize_room "$normalized_target"; then
printf '%s\n' 'This room has no special meaning within the UNIX system.'
return 1
# Self-execute when run directly (not sourced)
case "$0" in
  */identify-room) identify_room "$@" ;; esac
