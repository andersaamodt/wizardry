#!/bin/sh
# Verify that shell scripts declare POSIX-friendly shebangs and parse with /bin/sh.
#
# Usage: verify-posix [FILE...]
# With no arguments, every spell under the spells/ directory is checked. When
# files are provided, each FILE is treated as relative to the repository root
# unless an absolute path is given.

set -eu

usage() {
  cat <<'USAGE'
Usage: verify-posix [FILE...]

Check shell scripts for basic POSIX compliance:
- Require a /bin/sh (or env sh) shebang.
- Ensure the file parses under /bin/sh -n.
- Flag bashisms via checkbashisms.
USAGE
}

SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
ROOT_DIR=$(CDPATH= cd -- "$SCRIPT_DIR/.." && pwd -P)

if [ -n "${CHECKBASHISMS-}" ]; then
  checkbashisms_cmd=$CHECKBASHISMS
elif checkbashisms_path=$(command -v checkbashisms 2>/dev/null); then
  checkbashisms_cmd=$checkbashisms_path
else
  checkbashisms_cmd=""
fi

if ! command -v "$checkbashisms_cmd" >/dev/null 2>&1; then
  printf '%s\n' "verify-posix: checkbashisms not found; run menu/install/install-checkbashisms" >&2
  exit 1
fi

set -- "$@"
if [ "$#" -eq 0 ]; then
  while IFS= read -r path; do
    set -- "$@" "${path#"$ROOT_DIR/"}"
  done <<EOF
$(cd "$ROOT_DIR" && find spells -type f)
EOF
fi

status=0
noncompliant=0
for target in "$@"; do
  file_has_issue=0
  case "$target" in
    /*)
      abs="$target"
      rel="$target"
      ;;
    *)
      abs="$ROOT_DIR/$target"
      rel="$target"
      ;;
  esac

  if [ ! -f "$abs" ]; then
    printf 'verify-posix: missing file: %s\n' "$rel" >&2
    status=1
    noncompliant=$((noncompliant + 1))
    continue
  fi

  if ! IFS= read -r first_line <"$abs"; then
    first_line=""
  fi

  if [ "${first_line#\#!}" = "$first_line" ]; then
    printf 'verify-posix: %s lacks a shebang; expected #!/bin/sh\n' "$rel" >&2
    status=1
    file_has_issue=1
    noncompliant=$((noncompliant + 1))
    continue
  fi

  shebang=${first_line#\#!}
  shebang=${shebang# }
  if [ -z "$shebang" ]; then
    printf 'verify-posix: %s has an empty shebang; expected #!/bin/sh\n' "$rel" >&2
    status=1
    file_has_issue=1
    noncompliant=$((noncompliant + 1))
    continue
  fi
  set -- $shebang
  interpreter=${1-}
  arg=${2-}

  shell_name=""
  case "$interpreter" in
    /usr/bin/env)
      shell_name=$arg
      ;;
    *)
      shell_name=$(basename "$interpreter")
      ;;
  esac

  if [ "$shell_name" != "sh" ]; then
    printf 'verify-posix: %s uses %s; please use /bin/sh\n' "$rel" "$first_line" >&2
    status=1
    file_has_issue=1
  fi

  if ! sh -n "$abs" >/dev/null 2>&1; then
    printf 'verify-posix: %s fails to parse with /bin/sh -n\n' "$rel" >&2
    status=1
    file_has_issue=1
  fi

  if ! "$checkbashisms_cmd" -f -p "$abs" >/dev/null 2>&1; then
    printf 'verify-posix: %s contains bashisms (checkbashisms)\n' "$rel" >&2
    status=1
    file_has_issue=1
  fi

  if [ "$file_has_issue" -eq 1 ]; then
    noncompliant=$((noncompliant + 1))
  fi

done

if [ "$noncompliant" -gt 0 ]; then
  printf 'Non-compliant spells: %d\n' "$noncompliant" >&2
fi

exit $status
