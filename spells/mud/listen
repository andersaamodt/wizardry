#!/bin/sh
# Listen for magical happenings in the current room

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: listen [room_path]
       . listen [room_path]

Start background monitoring of the .log file in the current (or specified)
directory and display new entries in real-time.

This enables live MUD multiplayer notifications - when other players speak,
cast spells, or perform actions, you see them immediately in your terminal.

The listener runs as a background process. Multiple listeners can run
simultaneously.

Messages appear above your current prompt line, preserving both your prompt
and any partially-typed command text. Multi-line messages automatically
insert the correct number of blank lines.

Examples:
  listen                    # Monitor current directory
  . listen                  # Monitor current directory (sourced)
  listen /mnt/server/dungeon   # Monitor specific directory
  . listen --stop           # Stop all listeners

See also: say, think
USAGE
  return 0 2>/dev/null || exit 0
  ;;
--stop)
  # Stop listening mode
  _listen_stop_only=1
  ;;
*)
  _listen_stop_only=0
  ;;
esac

# Uncastable pattern - detect if sourced (recommended) or executed
_listen_sourced=0
if eval '[ -n "${ZSH_VERSION:-}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _listen_sourced=1 ;;
  esac
else
  _listen_base=$(basename "$0" 2>/dev/null || printf '%s\n' "$0")
  case "$_listen_base" in
    sh|dash|bash|zsh|ksh|mksh) _listen_sourced=1 ;;
    listen) _listen_sourced=0 ;;
    *) _listen_sourced=1 ;;
  esac
fi

# Store for later use
_listen_is_sourced=$_listen_sourced
unset _listen_sourced _listen_base

# Enforce uncastable pattern - listen MUST be sourced
if [ "$_listen_is_sourced" -eq 0 ]; then
  printf '%s\n' "listen: This spell must be sourced, not executed directly" >&2
  printf '%s\n' "Usage: . listen" >&2
  printf '%s\n' "       source listen" >&2
  exit 1
fi

# Save readline editing mode to prevent breakage (when tools are available)
if command -v grep >/dev/null 2>&1 && command -v awk >/dev/null 2>&1; then
  _listen_set_output=$(set -o 2>/dev/null || true)
  if [ -n "$_listen_set_output" ]; then
    # Extract emacs mode
    _listen_emacs_mode=$(printf '%s\n' "$_listen_set_output" | \
      grep '^emacs' 2>/dev/null | awk '{print $2}' 2>/dev/null || printf '')
    # Extract vi mode
    _listen_vi_mode=$(printf '%s\n' "$_listen_set_output" | \
      grep '^vi' 2>/dev/null | awk '{print $2}' 2>/dev/null || printf '')
  else
    _listen_emacs_mode=""
    _listen_vi_mode=""
  fi
  unset _listen_set_output
else
  # grep/awk not available (restricted PATH) - skip readline preservation
  _listen_emacs_mode=""
  _listen_vi_mode=""
fi

# Use permissive mode for our own logic
set +e
set +u
# Try to clear environment if env-clear is available, but don't fail if it's not
# This makes listen more robust when sourced from cd hook
if command -v env-clear >/dev/null 2>&1; then
  . env-clear 2>/dev/null || true
fi

# Get room path
# CRITICAL: When sourced from cd hook with no args, use $PWD (not cd's inherited $1)
# But when sourced explicitly with an argument, allow that argument
if [ "$_listen_is_sourced" -eq 1 ]; then
  # When sourced, $1 might be inherited from parent function (cd)
  # Only use $1 if it looks like an absolute path, otherwise use $PWD
  case "${1-}" in
    /*) _listen_room_path="$1" ;;  # Absolute path - use it
    *)  _listen_room_path="$PWD" ;;  # Relative or empty - use $PWD
  esac
else
  # When executed directly (shouldn't happen due to uncastable, but just in case)
  _listen_room_path=${1:-$PWD}
fi

# If --stop was specified, stop all listeners
if [ "$_listen_stop_only" = "1" ]; then
  # Stop listening mode - kill all listener processes
  if command -v pgrep >/dev/null 2>&1; then
    # Find all tail processes following .log files
    pgrep -f 'tail -f.*\.log' 2>/dev/null | while read -r _listen_pid; do
      kill "$_listen_pid" 2>/dev/null || true
    done
  fi
  
  # Always show message when stopping (user explicitly requested it)
  printf '%s\n' "âœ“ Stopped listening to room activity"
  
  # When sourced (e.g., by cd hook), guarantee permissive mode instead of restoring
  # Restoring saved opts can re-enable strict modes that break readline
  set +e
  set +u
  # Restore readline mode
  [ "${_listen_emacs_mode:-}" = "on" ] && set -o emacs 2>/dev/null || true
  [ "${_listen_vi_mode:-}" = "on" ] && set -o vi 2>/dev/null || true
  unset _listen_stop_only _listen_is_sourced _listen_room_path
  unset _listen_emacs_mode _listen_vi_mode
  return 0 2>/dev/null || exit 0
fi

# Check if directory exists
if [ ! -d "$_listen_room_path" ]; then
  printf '%s\n' "listen: directory does not exist: $_listen_room_path" >&2
  # When sourced (e.g., by cd hook), guarantee permissive mode instead of restoring
  set +e
  set +u
  # Restore readline mode
  [ "${_listen_emacs_mode:-}" = "on" ] && set -o emacs 2>/dev/null || true
  [ "${_listen_vi_mode:-}" = "on" ] && set -o vi 2>/dev/null || true
  unset _listen_stop_only _listen_room_path _listen_is_sourced
  unset _listen_emacs_mode _listen_vi_mode
  return 1 2>/dev/null || exit 1
fi

_listen_room_log="$_listen_room_path/.log"

# Create log file if it doesn't exist
if [ ! -f "$_listen_room_log" ]; then
  touch "$_listen_room_log" 2>/dev/null || {
    printf '%s\n' "listen: cannot create log file (directory may be read-only)" >&2
    # When sourced (e.g., by cd hook), guarantee permissive mode instead of restoring
    set +e
    set +u
    # Restore readline mode
    [ "${_listen_emacs_mode:-}" = "on" ] && set -o emacs 2>/dev/null || true
    [ "${_listen_vi_mode:-}" = "on" ] && set -o vi 2>/dev/null || true
    unset _listen_stop_only _listen_room_path _listen_room_log _listen_is_sourced
    unset _listen_emacs_mode _listen_vi_mode
    return 1 2>/dev/null || exit 1
  }
fi

# Get terminal width for calculating multi-line messages
# Use tput cols if available, otherwise default to 80
if command -v tput >/dev/null 2>&1; then
  _listen_term_width=$(tput cols 2>/dev/null || printf '80')
else
  _listen_term_width=80
fi

export LISTEN_TERM_WIDTH="$_listen_term_width"

# Auto-stop ALL previous listeners to prevent duplicates
# Simple and reliable - kill everything, start fresh
# Note: Use pkill instead of pgrep|while to avoid subshell issues
if command -v pkill >/dev/null 2>&1; then
  pkill -f 'tail -f.*\.log' 2>/dev/null || true
elif command -v pgrep >/dev/null 2>&1; then
  # Fallback: collect PIDs first, then kill them
  _old_pids=$(pgrep -f 'tail -f.*\.log' 2>/dev/null || true)
  for _pid in $_old_pids; do
    kill "$_pid" 2>/dev/null || true
  done
  unset _old_pids _pid
fi

# Start monitoring in background
# Use tail -f -n 0 to follow the log file from current position (no history)
# Disable job control monitoring to suppress "[N] PID" messages
set +m
{
  tail -f -n 0 "$_listen_room_log" 2>/dev/null | while IFS= read -r line; do
    # Skip empty lines
    [ -z "$line" ] && continue
    
    # Parse the log entry to extract player name and colorize it
    # Expected format: [HH:MM] PlayerName: message
    case "$line" in
      \[*\]\ *:\ *)
        # Extract timestamp, player name, and message
        rest=$(printf '%s' "$line" | sed 's/^\[[^]]*\] //')
        player=$(printf '%s' "$rest" | sed 's/:.*//')
        message=$(printf '%s' "$rest" | sed 's/^[^:]*: //')
        
        # Special case: "log" username should not be displayed
        if [ "$player" = "log" ]; then
          # Just show the message without username prefix
          formatted_msg=$(printf '%s' "$message")
          msg_text=$(printf '%s' "$message")
        else
          # Get color for player name
          color=$(colorize-player-name "$player")
          
          # Format the message line
          formatted_msg=$(printf '\033[1;%dm%s:\033[0m %s' "$color" "$player" "$message")
          
          # Calculate how many terminal lines this message will occupy
          # Strip ANSI codes for length calculation
          msg_text=$(printf '%s: %s' "$player" "$message")
        fi
        msg_len=${#msg_text}
        
        # Calculate number of lines needed (round up)
        lines_needed=$(( (msg_len + LISTEN_TERM_WIDTH - 1) / LISTEN_TERM_WIDTH ))
        [ "$lines_needed" -lt 1 ] && lines_needed=1
        
        # Strategy: Scroll display up, move cursor up to compensate, insert lines, print message
        # This ensures message appears ABOVE the prompt in all scenarios
        
        # Save cursor position
        printf '\0337'
        
        # Move to beginning of line (required for Insert Line to work correctly)
        printf '\r'
        
        # Scroll the display up to make room at bottom (critical for terminal bottom case)
        i=0
        while [ "$i" -lt "$lines_needed" ]; do
          printf '\033[S'  # Scroll up one line
          i=$((i + 1))
        done
        
        # After scrolling, content moved up but cursor stayed at same row
        # Move cursor up by lines_needed to get to where prompt scrolled to
        printf '\033[%dA' "$lines_needed"
        
        # Insert blank lines - pushes prompt down from this position
        i=0
        while [ "$i" -lt "$lines_needed" ]; do
          printf '\033[1L'  # Insert one line
          i=$((i + 1))
        done
        
        # Print the message in the inserted space
        printf '\r%s' "$formatted_msg"
        
        # Restore cursor position - back to original prompt position
        # Insert Line operations pushed the prompt down to the right place
        printf '\0338'
        ;;
      *)
        # Fallback for lines that don't match expected format
        # Calculate length and lines needed
        msg_len=$(printf '%s' "$line" | wc -c)
        lines_needed=$(( (msg_len + 3 + LISTEN_TERM_WIDTH - 1) / LISTEN_TERM_WIDTH ))  # +3 for "ðŸ”® "
        [ "$lines_needed" -lt 1 ] && lines_needed=1
        
        # Save cursor position
        printf '\0337'
        
        # Move to beginning of line (required for Insert Line to work correctly)
        printf '\r'
        
        # Scroll the display up to make room at bottom
        i=0
        while [ "$i" -lt "$lines_needed" ]; do
          printf '\033[S'  # Scroll up one line
          i=$((i + 1))
        done
        
        # Move cursor up to compensate for scroll
        printf '\033[%dA' "$lines_needed"
        
        # Insert blank lines (pushes prompt down)
        i=0
        while [ "$i" -lt "$lines_needed" ]; do
          printf '\033[1L'
          i=$((i + 1))
        done
        
        # Print the message
        printf '\rðŸ”® %s' "$line"
        
        # Restore cursor position - cursor is now at the right place
        printf '\0338'
        ;;
    esac
  done
} &
_listen_monitor_pid=$!
# Re-enable job control
set -m

# Clean up variables and guarantee permissive mode
unset _listen_stop_only _listen_room_path _listen_room_log _listen_is_sourced \
  _listen_monitor_pid _listen_term_width

# When sourced (e.g., by cd hook), guarantee permissive mode instead of restoring
# Restoring saved opts can re-enable strict modes that break readline
set +e
set +u
# Restore readline mode
[ "${_listen_emacs_mode:-}" = "on" ] && set -o emacs 2>/dev/null || true
[ "${_listen_vi_mode:-}" = "on" ] && set -o vi 2>/dev/null || true
unset _listen_emacs_mode _listen_vi_mode
