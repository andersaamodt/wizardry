#!/bin/sh

# Start monitoring room activity in the background for real-time notifications.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: listen [room_path]
       . listen [room_path]

Start (or restart) background monitoring of the .log file in the current
(or specified) directory and display new entries in real-time.

This enables live MUD multiplayer notifications - when other players speak,
cast spells, or perform actions, you see them immediately in your terminal.

The listener runs as a background process. Running listen again will automatically
stop any existing listener and start a new one.

Messages overwrite your current prompt line, then restore your cursor position,
preserving any partially typed command. The cursor moves down one line with
your text intact, allowing you to continue typing seamlessly.

Examples:
  listen                    # Monitor current directory
  . listen                  # Monitor current directory (sourced)
  listen /mnt/server/dungeon   # Monitor specific directory
  . listen --stop           # Stop listening (no new listener started)

See also: say, think
USAGE
  return 0 2>/dev/null || exit 0
  ;;
--stop)
  # Stop listening mode
  _listen_stop_only=1
  ;;
*)
  _listen_stop_only=0
  ;;
esac

# Uncastable pattern - detect if sourced (recommended) or executed
_listen_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _listen_sourced=1 ;;
  esac
else
  _listen_base=${0##*/}
  case "$_listen_base" in
    sh|dash|bash|zsh|ksh|mksh) _listen_sourced=1 ;;
    listen) _listen_sourced=0 ;;
    *) _listen_sourced=1 ;;
  esac
fi

# Store for later use
_listen_is_sourced=$_listen_sourced
unset _listen_sourced _listen_base

set -eu
. env-clear

# Stop any existing listener first
_listen_pid_file="$HOME/.wizardry-listening.pid"
if [ -f "$_listen_pid_file" ]; then
  _listen_old_pid=$(cat "$_listen_pid_file" 2>/dev/null || printf '')
  if [ -n "$_listen_old_pid" ] && kill -0 "$_listen_old_pid" 2>/dev/null; then
    # Kill the monitor process
    kill "$_listen_old_pid" 2>/dev/null || true
    
    # Also try to kill any child processes (tail)
    if command -v ps >/dev/null 2>&1; then
      # Find and kill child processes  
      ps -o pid= --ppid "$_listen_old_pid" 2>/dev/null | while read -r _listen_child_pid; do
        kill "$_listen_child_pid" 2>/dev/null || true
      done
    fi
    
    # Wait a moment for cleanup
    sleep 0.5
  fi
  rm -f "$_listen_pid_file"
fi

# If --stop was specified, we're done
if [ "$_listen_stop_only" = "1" ]; then
  printf '%s\n' "âœ“ Stopped listening to room activity"
  unset _listen_stop_only _listen_pid_file _listen_old_pid _listen_is_sourced
  return 0 2>/dev/null || exit 0
fi

# Get room path (default to current directory)
_listen_room_path=${1:-$PWD}

# Check if directory exists
if [ ! -d "$_listen_room_path" ]; then
  printf '%s\n' "listen: directory does not exist: $_listen_room_path" >&2
  unset _listen_stop_only _listen_pid_file _listen_room_path _listen_is_sourced
  return 1 2>/dev/null || exit 1
fi

_listen_room_log="$_listen_room_path/.log"

# Create log file if it doesn't exist
if [ ! -f "$_listen_room_log" ]; then
  touch "$_listen_room_log" 2>/dev/null || {
    printf '%s\n' "listen: cannot create log file (directory may be read-only)" >&2
    unset _listen_stop_only _listen_pid_file _listen_room_path _listen_room_log _listen_is_sourced
    return 1 2>/dev/null || exit 1
  }
fi

# Save the current prompt for the background process to use
# Try to get a simple representation of PS1
if [ -n "${PS1-}" ]; then
  # For now, export a simple version
  # In the future, this could be enhanced to strip ANSI codes from PS1
  export LISTEN_SAVED_PROMPT="$ "
else
  export LISTEN_SAVED_PROMPT="$ "
fi

# Start monitoring in background
# Use tail -f -n 0 to follow the log file from current position (no history)
{
  tail -f -n 0 "$_listen_room_log" 2>/dev/null | while IFS= read -r line; do
    # Skip empty lines
    [ -z "$line" ] && continue
    
    # Parse the log entry to extract player name and colorize it
    # Expected format: [HH:MM] PlayerName: message
    case "$line" in
      \[*\]\ *:\ *)
        # Extract timestamp, player name, and message
        rest=$(printf '%s' "$line" | sed 's/^\[[^]]*\] //')
        player=$(printf '%s' "$rest" | sed 's/:.*//')
        message=$(printf '%s' "$rest" | sed 's/^[^:]*: //')
        
        # Get color for player name
        color=$(colorize-player-name "$player")
        
        # Approach for preserving typed text:
        # 1. Save cursor position (saves row, col, and attributes)
        # 2. Move to start of line and clear it (removes prompt/typed text)
        # 3. Print message with newline (pushes everything down)
        # 4. Reprint the prompt on the new line
        # 5. Restore cursor column position (move down 1 line from saved position)
        printf '\0337'  # Save cursor position (ESC 7)
        printf '\r\033[2K'  # Move to start of line and clear entire line
        printf '\033[1;%dm%s:\033[0m %s\n' "$color" "$player" "$message"
        printf '%s' "$LISTEN_SAVED_PROMPT"  # Reprint prompt on new line
        printf '\0338'  # Restore cursor position (still at old row)
        printf '\033[1B'  # Move down 1 line (now at new prompt line with saved column)
        ;;
      *)
        # Fallback for lines that don't match expected format
        printf '\0337'  # Save cursor
        printf '\r\033[2K'  # Clear line
        printf 'ðŸ”® %s\n' "$line"
        printf '%s' "$LISTEN_SAVED_PROMPT"  # Reprint prompt
        printf '\0338'  # Restore cursor
        printf '\033[1B'  # Move down 1 line
        ;;
    esac
  done
} &

_listen_monitor_pid=$!

# Save PID for later stopping
printf '%s\n' "$_listen_monitor_pid" > "$_listen_pid_file"

# Clean up variables
unset _listen_stop_only _listen_pid_file _listen_room_path _listen_room_log _listen_is_sourced _listen_use_zle _listen_monitor_pid _listen_old_pid
