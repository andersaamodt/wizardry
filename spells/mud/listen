#!/bin/sh

# Start monitoring room activity in the background for real-time notifications.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: listen [room_path]
       . listen [room_path]

Start background monitoring of the .log file in the current (or specified)
directory and display new entries in real-time.

This enables live MUD multiplayer notifications - when other players speak,
cast spells, or perform actions, you see them immediately in your terminal.

The listener runs as a background process. Multiple listeners can run
simultaneously.

Messages overwrite your current prompt line, then a simple "$ " prompt appears
on the following line. Typed text preservation is limited - the cursor position
is preserved but not the actual command text or prompt.

Examples:
  listen                    # Monitor current directory
  . listen                  # Monitor current directory (sourced)
  listen /mnt/server/dungeon   # Monitor specific directory
  . listen --stop           # Stop all listeners

See also: say, think
USAGE
  return 0 2>/dev/null || exit 0
  ;;
--stop)
  # Stop listening mode
  _listen_stop_only=1
  ;;
*)
  _listen_stop_only=0
  ;;
esac

# Uncastable pattern - detect if sourced (recommended) or executed
_listen_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _listen_sourced=1 ;;
  esac
else
  _listen_base=${0##*/}
  case "$_listen_base" in
    sh|dash|bash|zsh|ksh|mksh) _listen_sourced=1 ;;
    listen) _listen_sourced=0 ;;
    *) _listen_sourced=1 ;;
  esac
fi

# Store for later use
_listen_is_sourced=$_listen_sourced
unset _listen_sourced _listen_base

set -eu
. env-clear

# Get room path
_listen_room_path=${1:-$PWD}

# If --stop was specified, stop all listeners
if [ "$_listen_stop_only" = "1" ]; then
  # Stop listening mode - kill all listener processes
  if command -v pgrep >/dev/null 2>&1; then
    # Find all tail processes following .log files
    pgrep -f 'tail -f.*\.log' 2>/dev/null | while read -r _listen_pid; do
      kill "$_listen_pid" 2>/dev/null || true
    done
  fi
  
  printf '%s\n' "âœ“ Stopped listening to room activity"
  
  unset _listen_stop_only _listen_pid _listen_is_sourced _listen_room_path
  return 0 2>/dev/null || exit 0
fi

# Check if directory exists
if [ ! -d "$_listen_room_path" ]; then
  printf '%s\n' "listen: directory does not exist: $_listen_room_path" >&2
  unset _listen_stop_only _listen_room_path _listen_is_sourced
  return 1 2>/dev/null || exit 1
fi

_listen_room_log="$_listen_room_path/.log"

# Create log file if it doesn't exist
if [ ! -f "$_listen_room_log" ]; then
  touch "$_listen_room_log" 2>/dev/null || {
    printf '%s\n' "listen: cannot create log file (directory may be read-only)" >&2
    unset _listen_stop_only _listen_room_path _listen_room_log _listen_is_sourced
    return 1 2>/dev/null || exit 1
  }
fi

# Try to capture actual prompt when sourced
if [ "$_listen_is_sourced" = "1" ]; then
  printf '[DEBUG listen] Sourced mode detected\n' >&2
  printf '[DEBUG listen] Shell: %s\n' "${SHELL-unknown}" >&2
  
  # Check if ZSH_VERSION is set
  if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
    printf '[DEBUG listen] Zsh detected (version: %s)\n' "$ZSH_VERSION" >&2
    printf '[DEBUG listen] Original PS1: "%s"\n' "${PS1-NOT_SET}" >&2
    
    # Try to expand PS1 using zsh's print -P
    if command -v print >/dev/null 2>&1; then
      _listen_expanded=$(print -P "${PS1-}" 2>&1)
      _listen_expand_status=$?
      printf '[DEBUG listen] print -P exit status: %d\n' "$_listen_expand_status" >&2
      printf '[DEBUG listen] print -P output: "%s"\n' "$_listen_expanded" >&2
      
      if [ "$_listen_expand_status" = "0" ] && [ -n "$_listen_expanded" ]; then
        export LISTEN_SAVED_PROMPT="$_listen_expanded"
        printf '[DEBUG listen] SUCCESS: Using expanded zsh prompt\n' >&2
      else
        export LISTEN_SAVED_PROMPT="$ "
        printf '[DEBUG listen] FALLBACK: print -P failed, using default\n' >&2
      fi
    else
      export LISTEN_SAVED_PROMPT="$ "
      printf '[DEBUG listen] FALLBACK: print command not found\n' >&2
    fi
  else
    # Bash/sh
    printf '[DEBUG listen] Bash/sh detected\n' >&2
    printf '[DEBUG listen] Original PS1: "%s"\n' "${PS1-NOT_SET}" >&2
    
    # Try basic expansion for bash
    if [ -n "${PS1-}" ]; then
      # Use parameter expansion to get current values
      _listen_user="${USER-}"
      _listen_host="${HOSTNAME-$(hostname 2>/dev/null || printf 'localhost')}"
      _listen_pwd="${PWD-}"
      _listen_pwd_base=$(basename "$_listen_pwd" 2>/dev/null || printf '~')
      
      printf '[DEBUG listen] user=%s host=%s pwd=%s pwd_base=%s\n' "$_listen_user" "$_listen_host" "$_listen_pwd" "$_listen_pwd_base" >&2
      
      # Simple sed-based expansion
      _listen_expanded="$PS1"
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed "s/\\\\u/$_listen_user/g")
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed "s/\\\\h/${_listen_host%%.*}/g")
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed "s/\\\\H/$_listen_host/g")
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed "s|\\\\w|$_listen_pwd|g")
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed "s|\\\\W|$_listen_pwd_base|g")
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\\\\\$/$/g')
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\\\#/!/g')
      
      # Remove ANSI codes and \[ \] markers
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\033\[[0-9;]*m//g')
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\e\[[0-9;]*m//g')
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\\\\\[//g')
      _listen_expanded=$(printf '%s' "$_listen_expanded" | sed 's/\\\\\\]//g')
      
      printf '[DEBUG listen] After expansion: "%s"\n' "$_listen_expanded" >&2
      
      if [ -n "$_listen_expanded" ]; then
        export LISTEN_SAVED_PROMPT="$_listen_expanded"
        printf '[DEBUG listen] SUCCESS: Using expanded bash prompt\n' >&2
      else
        export LISTEN_SAVED_PROMPT="$ "
        printf '[DEBUG listen] FALLBACK: Expansion resulted in empty string\n' >&2
      fi
    else
      export LISTEN_SAVED_PROMPT="$ "
      printf '[DEBUG listen] FALLBACK: PS1 not set\n' >&2
    fi
  fi
else
  printf '[DEBUG listen] NOT sourced - using default prompt\n' >&2
  export LISTEN_SAVED_PROMPT="$ "
fi

printf '[DEBUG listen] Final LISTEN_SAVED_PROMPT: "%s" (length: %d)\n' "$LISTEN_SAVED_PROMPT" "${#LISTEN_SAVED_PROMPT}" >&2

# Start monitoring in background
# Use tail -f -n 0 to follow the log file from current position (no history)
{
  printf '[DEBUG background] Starting with LISTEN_SAVED_PROMPT: "%s" (length: %d)\n' "$LISTEN_SAVED_PROMPT" "${#LISTEN_SAVED_PROMPT}" >&2
  
  tail -f -n 0 "$_listen_room_log" 2>/dev/null | while IFS= read -r line; do
    # Skip empty lines
    [ -z "$line" ] && continue
    
    # Parse the log entry to extract player name and colorize it
    # Expected format: [HH:MM] PlayerName: message
    case "$line" in
      \[*\]\ *:\ *)
        # Extract timestamp, player name, and message
        rest=$(printf '%s' "$line" | sed 's/^\[[^]]*\] //')
        player=$(printf '%s' "$rest" | sed 's/:.*//')
        message=$(printf '%s' "$rest" | sed 's/^[^:]*: //')
        
        # Get color for player name
        color=$(colorize-player-name "$player")
        
        # Approach for preserving typed text:
        # 1. Save cursor position (row, column within typed text)
        # 2. Move to start of line and clear it (removes display)
        # 3. Print message with newline (pushes content down)
        # 4. Reprint the prompt on the new line
        # 5. Restore cursor to saved column position, then move down 1 row
        #    (positions cursor at same relative position in the new line)
        printf '\0337'  # Save cursor position (ESC 7)
        printf '\r\033[2K'  # Move to start of line and clear entire line
        printf '\033[1;%dm%s:\033[0m %s\n' "$color" "$player" "$message"
        printf '%s' "$LISTEN_SAVED_PROMPT"  # Reprint prompt on new line
        printf '\0338'  # Restore cursor to saved position (old row, saved column)
        printf '\033[1B'  # Move down 1 line (now at new prompt row, saved column)
        ;;
      *)
        # Fallback for lines that don't match expected format
        printf '\0337'  # Save cursor
        printf '\r\033[2K'  # Clear line
        printf 'ðŸ”® %s\n' "$line"
        printf '%s' "$LISTEN_SAVED_PROMPT"  # Reprint prompt
        printf '\0338'  # Restore cursor
        printf '\033[1B'  # Move down 1 line
        ;;
    esac
  done
} &

_listen_monitor_pid=$!

# Clean up variables
unset _listen_stop_only _listen_room_path _listen_room_log _listen_is_sourced _listen_use_zle _listen_monitor_pid
