#!/bin/sh

# Start monitoring room activity in the background for real-time notifications.
# This spell must be sourced for proper prompt handling in zsh.

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: listen [room_path]
       . listen [room_path]  (recommended for zsh)

Start (or restart) background monitoring of the .log file in the current
(or specified) directory and display new entries in real-time.

This enables live MUD multiplayer notifications - when other players speak,
cast spells, or perform actions, you see them immediately in your terminal.

The listener runs as a background process. Running listen again will automatically
stop any existing listener and start a new one.

For best prompt restoration in zsh, source this spell with '. listen'.
It can be executed directly but prompt handling will be degraded.

Examples:
  listen                    # Monitor current directory
  . listen                  # Monitor current directory (sourced, better for zsh)
  listen /mnt/server/dungeon   # Monitor specific directory
  . listen --stop           # Stop listening (no new listener started)

See also: say, think
USAGE
  return 0 2>/dev/null || exit 0
  ;;
--stop)
  # Stop listening mode
  _listen_stop_only=1
  ;;
*)
  _listen_stop_only=0
  ;;
esac

# Uncastable pattern - detect if sourced (recommended) or executed
_listen_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _listen_sourced=1 ;;
  esac
else
  _listen_base=${0##*/}
  case "$_listen_base" in
    sh|dash|bash|zsh|ksh|mksh) _listen_sourced=1 ;;
    listen) _listen_sourced=0 ;;
    *) _listen_sourced=1 ;;
  esac
fi

# Store for later use
_listen_is_sourced=$_listen_sourced
unset _listen_sourced _listen_base

set -eu
. env-clear

# Stop any existing listener first
_listen_pid_file="$HOME/.wizardry-listening.pid"
if [ -f "$_listen_pid_file" ]; then
  _listen_old_pid=$(cat "$_listen_pid_file" 2>/dev/null || printf '')
  if [ -n "$_listen_old_pid" ] && kill -0 "$_listen_old_pid" 2>/dev/null; then
    # Kill the monitor process
    kill "$_listen_old_pid" 2>/dev/null || true
    
    # Also try to kill any child processes (tail)
    if command -v ps >/dev/null 2>&1; then
      # Find and kill child processes  
      ps -o pid= --ppid "$_listen_old_pid" 2>/dev/null | while read -r _listen_child_pid; do
        kill "$_listen_child_pid" 2>/dev/null || true
      done
    fi
    
    # Wait a moment for cleanup
    sleep 0.5
  fi
  rm -f "$_listen_pid_file"
fi

# If --stop was specified, we're done
if [ "$_listen_stop_only" = "1" ]; then
  printf '%s\n' "âœ“ Stopped listening to room activity"
  unset _listen_stop_only _listen_pid_file _listen_old_pid _listen_is_sourced
  return 0 2>/dev/null || exit 0
fi

# Get room path (default to current directory)
_listen_room_path=${1:-$PWD}

# Check if directory exists
if [ ! -d "$_listen_room_path" ]; then
  printf '%s\n' "listen: directory does not exist: $_listen_room_path" >&2
  unset _listen_stop_only _listen_pid_file _listen_room_path _listen_is_sourced
  return 1 2>/dev/null || exit 1
fi

_listen_room_log="$_listen_room_path/.log"

# Create log file if it doesn't exist
if [ ! -f "$_listen_room_log" ]; then
  touch "$_listen_room_log" 2>/dev/null || {
    printf '%s\n' "listen: cannot create log file (directory may be read-only)" >&2
    unset _listen_stop_only _listen_pid_file _listen_room_path _listen_room_log _listen_is_sourced
    return 1 2>/dev/null || exit 1
  }
fi

# Detect if we're in zsh and sourced
_listen_use_zle=0
if [ -n "${ZSH_VERSION-}" ] && [ "$_listen_is_sourced" -eq 1 ]; then
  # Check if zle is available (we're in an interactive zsh shell)
  if command -v zle >/dev/null 2>&1; then
    _listen_use_zle=1
  fi
fi

# Start monitoring in background
# Use tail -f -n 0 to follow the log file from current position (no history)
if [ "$_listen_use_zle" -eq 1 ]; then
  # ZSH with zle - use signal-based prompt refresh
  {
    tail -f -n 0 "$_listen_room_log" 2>/dev/null | while IFS= read -r line; do
      # Skip empty lines
      [ -z "$line" ] && continue
      
      # Parse the log entry to extract player name and colorize it
      # Expected format: [HH:MM] PlayerName: message
      case "$line" in
        \[*\]\ *:\ *)
          # Extract timestamp, player name, and message
          rest=$(printf '%s' "$line" | sed 's/^\[[^]]*\] //')
          player=$(printf '%s' "$rest" | sed 's/:.*//')
          message=$(printf '%s' "$rest" | sed 's/^[^:]*: //')
          
          # Get color for player name
          color=$(colorize-player-name "$player")
          
          # Print message (zle will handle prompt redraw via trap)
          printf '\r\033[K\033[1;%dm%s:\033[0m %s\n' \
            "$color" "$player" "$message"
          
          # Signal parent zsh to reset prompt
          kill -USR1 $$ 2>/dev/null || true
          ;;
        *)
          # Fallback for lines that don't match expected format
          printf '\r\033[KðŸ”® %s\n' "$line"
          kill -USR1 $$ 2>/dev/null || true
          ;;
      esac
    done
  } &
else
  # Non-zsh or not sourced: use simple approach
  {
    tail -f -n 0 "$_listen_room_log" 2>/dev/null | while IFS= read -r line; do
      # Skip empty lines
      [ -z "$line" ] && continue
      
      # Parse the log entry to extract player name and colorize it
      # Expected format: [HH:MM] PlayerName: message
      case "$line" in
        \[*\]\ *:\ *)
          # Extract timestamp, player name, and message
          rest=$(printf '%s' "$line" | sed 's/^\[[^]]*\] //')
          player=$(printf '%s' "$rest" | sed 's/:.*//')
          message=$(printf '%s' "$rest" | sed 's/^[^:]*: //')
          
          # Get color for player name
          color=$(colorize-player-name "$player")
          
          # Simple output
          printf '\r\033[K\033[1;%dm%s:\033[0m %s\n' \
            "$color" "$player" "$message"
          ;;
        *)
          # Fallback for lines that don't match expected format
          printf '\r\033[KðŸ”® %s\n' "$line"
          ;;
      esac
    done
  } &
fi

_listen_monitor_pid=$!

# Save PID for later stopping
printf '%s\n' "$_listen_monitor_pid" > "$_listen_pid_file"

# Set up zsh hook if we're sourced in zsh
if [ "$_listen_use_zle" -eq 1 ]; then
  # Define a trap handler for USR1 that resets the prompt
  # This runs in the parent shell context since we're sourced
  trap 'zle && zle reset-prompt' USR1
fi

# Clean up variables
unset _listen_stop_only _listen_pid_file _listen_room_path _listen_room_log _listen_is_sourced _listen_use_zle _listen_monitor_pid _listen_old_pid
