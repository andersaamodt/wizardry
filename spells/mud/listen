#!/bin/sh
# Listen for magical happenings in the current room

show_usage() {
  cat <<'USAGE'
Usage: listen [--stop] [--dir <directory>]

Start listening for magical events in the current room.
Creates a background process that monitors for changes and plays sounds.

Options:
  --stop          Stop the listener for the current directory
  --dir <dir>     Listen to a specific directory instead of current
  --help, -h      Show this help message

When sourced into the shell (e.g., by the cd hook), starts/stops listening
based on the current directory.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  return 0 2>/dev/null || exit 0
  ;;
esac

# Uncastable pattern - detect if sourced (recommended) or executed
_listen_sourced=0
if eval '[ -n "${ZSH_VERSION+x}" ]' 2>/dev/null; then
  case "${ZSH_EVAL_CONTEXT-}" in
    *:file) _listen_sourced=1 ;;
  esac
else
  _listen_base=${0##*/}
  case "$_listen_base" in
    sh|dash|bash|zsh|ksh|mksh) _listen_sourced=1 ;;
    listen) _listen_sourced=0 ;;
    *) _listen_sourced=1 ;;
  esac
fi

# Store for later use
_listen_is_sourced=$_listen_sourced
unset _listen_sourced _listen_base

# STEP 3: Add shell option save/restore
_listen_saved_opts=$(set +o)

# Save readline editing mode
_listen_set_output=$(set -o)
_listen_emacs_mode=$(printf '%s\n' "$_listen_set_output" | grep '^emacs' | awk '{print $2}')
_listen_vi_mode=$(printf '%s\n' "$_listen_set_output" | grep '^vi' | awk '{print $2}')
unset _listen_set_output

# STEP 3: Now restore everything and return
# This is what we suspect breaks readline
eval "$_listen_saved_opts"
[ "$_listen_emacs_mode" = "on" ] && set -o emacs 2>/dev/null || true
[ "$_listen_vi_mode" = "on" ] && set -o vi 2>/dev/null || true
unset _listen_saved_opts _listen_emacs_mode _listen_vi_mode _listen_is_sourced

if [ "$_listen_is_sourced" = "1" ]; then
    return 0
else
    exit 0
fi
