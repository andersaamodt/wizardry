#!/bin/sh

# Load required imps for direct execution
if ! command -v require_wizardry >/dev/null 2>&1; then
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _i="$WIZARDRY_DIR/spells/.imps/sys"
  elif [ -n "${ROOT_DIR-}" ]; then
    _i="$ROOT_DIR/spells/.imps/sys"
  else
    _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
  fi
  [ -f "$_i/require-wizardry" ] && . "$_i/require-wizardry"
fi

if ! command -v env_clear >/dev/null 2>&1; then
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _i="$WIZARDRY_DIR/spells/.imps/sys"
  elif [ -n "${ROOT_DIR-}" ]; then
    _i="$ROOT_DIR/spells/.imps/sys"
  else
    _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
  fi
  [ -f "$_i/env-clear" ] && . "$_i/env-clear"
fi


# This spell decorates a location with a description, making it visible to 'look'.
# It's a convenient wrapper around 'enchant' for setting room descriptions.

require_wizardry || return 1

decorate_usage() {
cat <<'USAGE'
Usage: decorate [path] [description]

Decorate a location (folder or file) with a description shown when using the look spell. Defaults to the current directory and accepts either order when both a path and description are provided.
USAGE
}



decorate() {
case "${1-}" in
--help|--usage|-h)
  decorate_usage
  return 0
  ;;
esac

set -eu
env_clear

if lacks enchant; then
        warn "decorate: enchant spell is missing."
        return 1
fi

# Parse arguments - detect which is path and which is description
path=""
description=""

if [ $# -eq 0 ]; then
        # No arguments: use current directory and prompt for description
        path=$PWD
elif [ $# -eq 1 ]; then
        # One argument: could be path or description
        if [ -e "$1" ]; then
                # It's a path - prompt for description
                path=$1
        else
                # It's a description - use current directory
                path=$PWD
                description=$1
        fi
elif [ $# -eq 2 ]; then
        # Two arguments: detect which is the path
        # Note: empty strings are not valid descriptions
        if [ -e "$1" ] && [ -n "$2" ] && [ ! -e "$2" ]; then
                # First is path, second is description
                path=$1
                description=$2
        elif [ -e "$2" ] && [ -n "$1" ] && [ ! -e "$1" ]; then
                # Second is path, first is description
                path=$2
                description=$1
        elif [ -e "$1" ] && [ -e "$2" ]; then
                # Both exist as paths - this is ambiguous
                warn "decorate: both arguments appear to be valid paths."
                return 1
        elif [ -z "$1" ] || [ -z "$2" ]; then
                # One of the arguments is empty
                warn "decorate: description cannot be empty."
                return 1
        else
                # Neither exists as a path
                warn "decorate: no valid path found among arguments."
                return 1
        fi
else
        warn "decorate: too many arguments provided."
        return 1
fi

# Resolve path to absolute
if [ -d "$path" ]; then
        path=$(cd "$path" && pwd)
elif [ -f "$path" ]; then
        path=$(cd "$(dirname "$path")" && pwd)/$(basename "$path")
fi

# Get description if not already set
if [ -z "$description" ]; then
        if has ask-text; then
                description=$(ask_text "Enter description for this location:")
        else
                printf '%s' "Enter description: "
                read -r description
        fi
fi

if [ -z "$description" ]; then
        warn "decorate: description cannot be empty."
        return 1
fi

# Apply the description using enchant
if enchant "$path" description "$description"; then
        printf '%s\n' "The location has been decorated with the description."
else
        warn "decorate: failed to apply description."
        return 1
fi
}


# Load castable imp for direct execution (AFTER all functions defined)
# When executed directly: always source to ensure castable sees correct $0
# When sourced (testing): use from PATH if available to avoid forks
case "$0" in
  sh|dash|bash|zsh|ksh|mksh|*/sh|*/dash|*/bash|*/zsh|*/ksh|*/mksh)
    # Being sourced - use from PATH if available
    if ! command -v castable >/dev/null 2>&1; then
      # Use WIZARDRY_DIR or ROOT_DIR if available (avoids dirname/basename)
      if [ -n "${WIZARDRY_DIR-}" ]; then
        _i="$WIZARDRY_DIR/spells/.imps/sys"
      elif [ -n "${ROOT_DIR-}" ]; then
        _i="$ROOT_DIR/spells/.imps/sys"
      else
        _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
      fi
      [ -f "$_i/castable" ] && . "$_i/castable"
    fi
    ;;
  *)
    # Being executed - always source to ensure correct $0 detection
    if [ -n "${WIZARDRY_DIR-}" ]; then
      _i="$WIZARDRY_DIR/spells/.imps/sys"
    elif [ -n "${ROOT_DIR-}" ]; then
      _i="$ROOT_DIR/spells/.imps/sys"
    else
      _i="${WIZARDRY_DIR:-${ROOT_DIR:-${0%/*/*/*}}}/spells/.imps/sys"
    fi
    [ -f "$_i/castable" ] && . "$_i/castable"
    ;;
esac

castable "$@"
