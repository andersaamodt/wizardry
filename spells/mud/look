#!/bin/sh

# This spell reads a location's extended attributes and presents its description.
# It can prompt to memorize itself so the `look` incantation stays available.

require-wizardry || exit 1

show_usage() {
cat <<'USAGE'
Usage: look [path]

Display a location's title and description attributes with read-magic, offering to memorize the spell into your shell rc for easy reuse. Defaults to the current directory when no path is supplied.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        resolved=$(command -v "$SCRIPT_SOURCE" 2>/dev/null || printf '%s' "$SCRIPT_SOURCE")
        SCRIPT_DIR=${resolved%/*}
        SCRIPT_SOURCE=$resolved
        ;;
esac
if [ -z "$SCRIPT_DIR" ] || [ "$SCRIPT_DIR" = "$SCRIPT_SOURCE" ]; then
        SCRIPT_DIR=.
fi
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
LOOK_SCRIPT_PATH="$SCRIPT_DIR/$(basename "$SCRIPT_SOURCE")"

look_warn() {
        printf '%s\n' "look: $1" >&2
}

# Load colors if available
if [ -n "${LOOK_COLORS_PATH-}" ] && [ -f "$LOOK_COLORS_PATH" ]; then
        # shellcheck disable=SC1090
        . "$LOOK_COLORS_PATH"
elif command -v colors >/dev/null 2>&1; then
        # shellcheck disable=SC1090
        . "$(command -v colors)"
elif [ -x "$SCRIPT_DIR/cantrips/colors" ]; then
        # shellcheck disable=SC1090
        . "$SCRIPT_DIR/cantrips/colors"
else
        BLUE=""
        BOLD=""
        RESET=""
        MUD_LOCATION=""
        MUD_TITLE=""
        MUD_DESCRIPTION=""
fi

# Let tests or callers override the helper path; otherwise look beside this
# script first, then in PATH so the spell still works when installed globally.
# This keeps installation optional while preserving predictability.
READ_MAGIC=${LOOK_READ_MAGIC-}
if [ -z "$READ_MAGIC" ]; then
        if [ -x "$SCRIPT_DIR/read-magic" ]; then
                READ_MAGIC="$SCRIPT_DIR/read-magic"
        elif command -v read-magic >/dev/null 2>&1; then
                READ_MAGIC=$(command -v read-magic)
        else
                printf '%s\n' "look: read-magic spell is missing." >&2
                exit 1
        fi
fi

path_input=${1:-$PWD}
path=$(strip-trailing-slashes "$(abs-path "$path_input")")

# Install/memorize the look spell if needed
rc_file=""
if [ -n "${LOOK_RC_FILE-}" ]; then
        rc_file="$LOOK_RC_FILE"
elif [ -n "${HOME-}" ]; then
        rc_file="$HOME/.bashrc"
fi

if [ -n "$rc_file" ]; then
        look_block_present=0
        if [ -f "$rc_file" ]; then
                if grep -Fq '# >>> wizardry look spell >>>' "$rc_file" || \
                   grep -Fq 'WIZARDRY_LOOK_SPELL' "$rc_file" || \
                   grep -Fq "alias look='$LOOK_SCRIPT_PATH'" "$rc_file"; then
                        look_block_present=1
                fi
        fi
        
        if [ "$look_block_present" -eq 0 ]; then
                ask_yn_cmd=""
                if has ask-yn; then
                        ask_yn_cmd=$(where ask-yn)
                elif [ -x "$SCRIPT_DIR/cantrips/ask-yn" ]; then
                        ask_yn_cmd="$SCRIPT_DIR/cantrips/ask-yn"
                fi
                
                if [ -n "$ask_yn_cmd" ]; then
                        printf '%s\n' "'Look' is a reserved keyword, so you must memorize this spell to change the meaning of the word 'look'."
                        if "$ask_yn_cmd" "Memorize the 'look' spell so it is always available?" yes >/dev/null; then
                                # Ensure parent dir exists
                                rc_dir=${rc_file%/*}
                                if [ "$rc_dir" != "$rc_file" ] && [ ! -d "$rc_dir" ]; then
                                        if ! mkdir -p "$rc_dir"; then
                                                look_warn "unable to create directory '$rc_dir'."
                                        fi
                                fi
                                
                                # Write look block
                                if [ -d "$rc_dir" ] || [ "$rc_dir" = "$rc_file" ]; then
                                        tmp_file=$(temp-file wizardry-look) || tmp_file=""
                                        if [ -n "$tmp_file" ]; then
                                                trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
                                                if [ -f "$rc_file" ]; then
                                                        sed '/^# >>> wizardry look spell >>>$/,/^# <<< wizardry look spell <<</d' "$rc_file" >"$tmp_file"
                                                else
                                                        : >"$tmp_file"
                                                fi
                                                cat <<BLOCK >>"$tmp_file"
# >>> wizardry look spell >>>
alias look='$LOOK_SCRIPT_PATH'
# <<< wizardry look spell <<<
BLOCK
                                                if mv "$tmp_file" "$rc_file" 2>/dev/null; then
                                                        printf '%s\n' "Spell memorized in $(basename "$rc_file"), so you will always be able to use it."
                                                else
                                                        rm -f "$tmp_file" 2>/dev/null || true
                                                        look_warn "unable to update '$rc_file'."
                                                fi
                                                trap - EXIT HUP INT TERM
                                        fi
                                fi
                        else
                                printf '%s\n' "The mud will only run in this shell window."
                        fi
                else
                        look_warn "ask-yn spell is missing; cannot prompt for installation."
                fi
        fi
fi

# Message returned by read-magic when attribute doesn't exist
MISSING_ATTR_MSG='read-magic: attribute does not exist.'

# Get identify-room data if available
IDENTIFY_TITLE=''
IDENTIFY_DESCRIPTION=''
if command -v identify-room >/dev/null 2>&1; then
        if identify_room_output=$(identify-room "$path" 2>/dev/null); then
                IDENTIFY_TITLE=$(printf '%s' "$identify_room_output" | sed -n '1p')
                IDENTIFY_DESCRIPTION=$(printf '%s' "$identify_room_output" | sed -n '2p')
        fi
else
        look_warn "identify-room spell is unavailable; continuing without system lore."
fi

# Get title from attribute or fall back to folder name or identify data
attr_title=$("$READ_MAGIC" "$path" title 2>/dev/null || true)
if [ "$attr_title" != "$MISSING_ATTR_MSG" ] && [ -n "$attr_title" ]; then
        room_title=$attr_title
elif [ -n "$IDENTIFY_TITLE" ]; then
        room_title=$IDENTIFY_TITLE
else
        room_title=$(basename "$path")
fi

# Get description from attribute or fall back to identify data or default
attr_desc=$("$READ_MAGIC" "$path" description 2>/dev/null || true)
if [ "$attr_desc" != "$MISSING_ATTR_MSG" ] && [ -n "$attr_desc" ]; then
        room_description=$attr_desc
elif [ -n "$IDENTIFY_DESCRIPTION" ]; then
        room_description=$IDENTIFY_DESCRIPTION
else
        # Use a checksum of the path to pick a consistent random description
        path_hash=$(printf '%s' "$path" | cksum | cut -d' ' -f1)
        case $((path_hash % 5)) in
                0) room_description="An ordinary room." ;;
                1) room_description="A plain chamber." ;;
                2) room_description="A nondescript space." ;;
                3) room_description="An unremarkable area." ;;
                4) room_description="A simple room." ;;
        esac
fi

# Display MUD-formatted room description
printf '%s%s%s\n' "$MUD_TITLE" "$room_title" "$RESET"
printf '%s%s%s\n' "$MUD_DESCRIPTION" "$room_description" "$RESET"
