#!/bin/sh

# This spell reads a location's extended attributes and presents its description.
# It can prompt to memorize itself so the `look` incantation stays available.

require-wizardry || exit 1

show_usage() {
cat <<'USAGE'
Usage: look [path]

Display a location's title and description attributes with read-magic, offering to memorize the spell into your shell rc for easy reuse. Defaults to the current directory when no path is supplied.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

script_source=$0
case $script_source in
*/*)
        script_dir=${script_source%/*}
        ;;
*)
        resolved=$(command -v "$script_source" 2>/dev/null || printf '%s' "$script_source")
        script_dir=${resolved%/*}
        script_source=$resolved
        ;;
esac
if [ -z "$script_dir" ] || [ "$script_dir" = "$script_source" ]; then
        script_dir=.
fi
script_dir=$(cd "$script_dir" && pwd -P)
look_script_path="$script_dir/$(basename "$script_source")"

look_warn() {
        printf '%s\n' "look: $1" >&2
}

resolve_rc_file() {
        if [ -z "${HOME-}" ]; then
                look_warn "HOME is not set; cannot memorize the spell."
                return 1
        fi
        
        # Try to use detect-rc-file to find the appropriate RC file
        if command -v detect-rc-file >/dev/null 2>&1; then
                detect-rc-file 2>/dev/null || printf '%s/.bashrc\n' "$HOME"
        else
                # Fallback to .bashrc if detect-rc-file not available
                printf '%s/.bashrc\n' "$HOME"
        fi
}

look_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        if grep -Fq '# >>> wizardry look spell >>>' "$rc_file"; then
                return 0
        fi
        if grep -Fq 'WIZARDRY_LOOK_SPELL' "$rc_file"; then
                return 0
        fi
        if grep -Fq "alias look='$look_script_path'" "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        dir=${target%/*}
        if [ "$dir" = "$target" ]; then
                return 0
        fi
        if [ -d "$dir" ]; then
                return 0
        fi
        if ! mkdir -p "$dir"; then
                look_warn "unable to create directory '$dir'."
                return 1
        fi
        return 0
}

write_look_block() {
        rc_file=$1
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(temp-file wizardry-look) || return 1
        trap 'cleanup-file "$tmp_file"' EXIT HUP INT TERM
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry look spell >>>$/,/^# <<< wizardry look spell <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        cat <<BLOCK >>"$tmp_file"
# >>> wizardry look spell >>>
alias look='$look_script_path'
# <<< wizardry look spell <<<
BLOCK
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                look_warn "unable to update '$rc_file'."
                return 1
        fi
        trap - EXIT HUP INT TERM
        return 0
}

locate_ask_yn() {
        if has ask-yn; then
                where ask-yn
                return 0
        fi
        if [ -x "$script_dir/cantrips/ask-yn" ]; then
                printf '%s\n' "$script_dir/cantrips/ask-yn"
                return 0
        fi
        return 1
}

install_look() {
        rc_file=$(resolve_rc_file) || return 0
        if look_block_present "$rc_file"; then
                return 0
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                look_warn "ask-yn spell is missing; cannot prompt for installation."
                return 0
        fi
        printf '%s\n' "'Look' is a reserved keyword, so you must memorize this spell to change the meaning of the word 'look'."
        if "$ask_yn_cmd" "Memorize the 'look' spell so it is always available?" yes >/dev/null; then
                if write_look_block "$rc_file"; then
                        printf '%s\n' "Spell memorized in $(basename "$rc_file"), so you will always be able to use it."
                fi
        else
                printf '%s\n' "The mud will only run in this shell window."
        fi
}

load_colors() {
        if [ -n "${LOOK_COLORS_PATH-}" ] && [ -f "$LOOK_COLORS_PATH" ]; then
                # shellcheck disable=SC1090
                . "$LOOK_COLORS_PATH"
                return 0
        fi
        if command -v colors >/dev/null 2>&1; then
                # shellcheck disable=SC1090
                . "$(command -v colors)"
                return 0
        fi
        if [ -x "$script_dir/cantrips/colors" ]; then
                # shellcheck disable=SC1090
                . "$script_dir/cantrips/colors"
                return 0
        fi
        return 1
}

if ! load_colors; then
        BLUE=""
        BOLD=""
        RESET=""
        mud_location=""
        mud_title=""
        mud_description=""
fi

# Let tests or callers override the helper path; otherwise look beside this
# script first, then in PATH so the spell still works when installed globally.
# This keeps installation optional while preserving predictability.
read_magic=${look_read_magic-}
if [ -z "$read_magic" ]; then
        if [ -x "$script_dir/read-magic" ]; then
                read_magic="$script_dir/read-magic"
        elif command -v read-magic >/dev/null 2>&1; then
                read_magic=$(command -v read-magic)
        else
                printf '%s\n' "look: read-magic spell is missing." >&2
                exit 1
        fi
fi

identify_available=0
if command -v identify-room >/dev/null 2>&1; then
        identify_available=1
fi

path_input=${1:-$PWD}
path=$(strip-trailing-slashes "$(abs-path "$path_input")")

install_look || true

# Message returned by read-magic when attribute doesn't exist
missing_attr_msg='read-magic: attribute does not exist.'

# Default descriptions for rooms without enchanted description attributes
get_default_description() {
        # Use a checksum of the path to pick a consistent random description
        path_hash=$(printf '%s' "$1" | cksum | cut -d' ' -f1)
        case $((path_hash % 5)) in
                0) printf '%s' "An ordinary room." ;;
                1) printf '%s' "A plain chamber." ;;
                2) printf '%s' "A nondescript space." ;;
                3) printf '%s' "An unremarkable area." ;;
                4) printf '%s' "A simple room." ;;
        esac
}

identify_title=''
identify_description=''

if [ "$identify_available" -eq 1 ]; then
        if identify_room_output=$(identify-room "$path" 2>/dev/null); then
                identify_title=$(printf '%s' "$identify_room_output" | sed -n '1p')
                identify_description=$(printf '%s' "$identify_room_output" | sed -n '2p')
        fi
else
        look_warn "identify-room spell is unavailable; continuing without system lore."
fi
# Get title from attribute or fall back to folder name
get_room_title() {
        room_path=$1
        attr_title=$("$read_magic" "$room_path" title 2>/dev/null || true)
        if [ "$attr_title" != "$missing_attr_msg" ] && [ -n "$attr_title" ]; then
                printf '%s' "$attr_title"
        elif [ -n "$identify_title" ]; then
                printf '%s' "$identify_title"
        else
                # Use the folder/file name as the title
                basename "$room_path"
        fi
}

# Get description from attribute or fall back to default
get_room_description() {
        room_path=$1
        attr_desc=$("$read_magic" "$room_path" description 2>/dev/null || true)
        if [ "$attr_desc" != "$missing_attr_msg" ] && [ -n "$attr_desc" ]; then
                printf '%s' "$attr_desc"
                return 0
        fi
        if [ -n "$identify_description" ]; then
                printf '%s' "$identify_description"
                return 0
        fi
        get_default_description "$room_path"
}

# Display MUD-formatted room description
room_title=$(get_room_title "$path")
room_description=$(get_room_description "$path")

printf '%s%s%s\n' "$mud_title" "$room_title" "$RESET"
printf '%s%s%s\n' "$mud_description" "$room_description" "$RESET"
