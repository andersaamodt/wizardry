name: Test Doppelganger Compiled Wizardry

on:
  push:
    branches: [main]
  pull_request:

permissions:
  contents: read

jobs:
  compile-and-test-doppelganger:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install wizardry
        run: |
          # Add wizardry to PATH for compilation
          echo "${{ github.workspace }}/spells" >> $GITHUB_PATH
          echo "${{ github.workspace }}/spells/cantrips" >> $GITHUB_PATH
          echo "${{ github.workspace }}/spells/spellcraft" >> $GITHUB_PATH
          
          # Source invoke-wizardry to set up environment
          export WIZARDRY_DIR="${{ github.workspace }}"
          . "${{ github.workspace }}/spells/.imps/sys/invoke-wizardry"
      
      - name: Create doppelganger
        run: |
          export WIZARDRY_DIR="${{ github.workspace }}"
          . "${{ github.workspace }}/spells/.imps/sys/invoke-wizardry"
          
          # Create doppelganger in /tmp
          doppelganger /tmp/wizardry-doppelganger
          
          echo "=== Doppelganger created ==="
          ls -la /tmp/wizardry-doppelganger/
          echo ""
          echo "=== Spells directory ==="
          ls -la /tmp/wizardry-doppelganger/spells/ | head -20
      
      - name: Test doppelganger spells
        run: |
          echo "=== Testing doppelganger spells ==="
          
          # Exclusions (wizardry infrastructure)
          excluded="invoke-wizardry require-wizardry declare-globals learn-spellbook learn mud decorate select-player"
          
          # Track failures
          fail_file=/tmp/doppelganger-failures.txt
          rm -f "$fail_file"
          touch "$fail_file"
          
          # Test all compiled spells
          find /tmp/wizardry-doppelganger/spells -type f -executable | while IFS= read -r compiled; do
            [ -f "$compiled" ] || continue
            spell_name=$(basename "$compiled")
            
            # Skip excluded
            skip=0
            for ex in $excluded; do
              if [ "$spell_name" = "$ex" ]; then
                skip=1
                break
              fi
            done
            [ "$skip" = "1" ] && continue
            
            # Determine if imp or spell
            is_imp=0
            case "$compiled" in
              */.imps/*) is_imp=1 ;;
            esac
            
            # Test appropriately
            if [ "$is_imp" = "1" ]; then
              # Imps: test with empty stdin
              if echo "" | timeout 1 env -i PATH="/usr/bin:/bin" "$compiled" >/dev/null 2>&1; then
                echo "  ✓ $spell_name"
              else
                ec=$?
                if [ "$ec" != "124" ]; then
                  echo "  ✓ $spell_name (exit $ec OK)"
                else
                  echo "  ✗ $spell_name (timeout)"
                  echo "$spell_name" >> "$fail_file"
                fi
              fi
            else
              # Spells: test --help
              if timeout 2 env -i PATH="/usr/bin:/bin" "$compiled" --help >/dev/null 2>&1; then
                echo "  ✓ $spell_name"
              else
                echo "  ✗ $spell_name"
                echo "$spell_name" >> "$fail_file"
              fi
            fi
          done
          
          # Check for failures
          if [ -s "$fail_file" ]; then
            echo ""
            echo "=== FAILURES ==="
            cat "$fail_file"
            exit 1
          fi
          
          echo ""
          echo "=== All doppelganger spells passed ==="
      
      - name: Run doppelganger behavioral tests
        run: |
          # Run behavioral tests against compiled spells
          if [ ! -d "/tmp/wizardry-doppelganger/.tests" ]; then
            echo "No tests found in doppelganger"
            exit 0
          fi
          
          echo "=== Testing Behavioral Tests ==="
          cd /tmp/wizardry-doppelganger
          
          # Set up environment for compiled spells
          export ROOT_DIR="/tmp/wizardry-doppelganger"
          export WIZARDRY_DIR="/tmp/wizardry-doppelganger"
          export WIZARDRY_TEST_COMPILED=1  # Flag to indicate testing compiled spells
          
          # Add doppelganger to PATH
          export PATH="/tmp/wizardry-doppelganger/spells:$PATH"
          for dir in /tmp/wizardry-doppelganger/spells/*; do
            [ -d "$dir" ] && export PATH="$PATH:$dir"
          done
          
          # Marker for unsupported tests (default is to run all tests)
          UNSUPPORTED_MARKER="^# COMPILED_UNSUPPORTED"
          
          # Use temp files to track across subshell boundary
          pass_file=/tmp/test-pass-count.txt
          fail_file=/tmp/test-fail-count.txt
          skip_file=/tmp/test-skip-count.txt
          subtest_total_file=/tmp/test-subtest-total.txt
          subtest_pass_file=/tmp/test-subtest-pass.txt
          failed_list_file=/tmp/test-failed-list.txt
          
          echo "0" > "$pass_file"
          echo "0" > "$fail_file"
          echo "0" > "$skip_file"
          echo "0" > "$subtest_total_file"
          echo "0" > "$subtest_pass_file"
          echo "" > "$failed_list_file"
          
          # Use file to track test number across loop iterations
          test_num_file=/tmp/test-num.txt
          echo "0" > "$test_num_file"
          
          # Run all tests EXCEPT those marked as unsupported
          find .tests -name "test_*.sh" -o -name "test-*.sh" | sort | while IFS= read -r test_file; do
            # Increment test number
            test_number=$(cat "$test_num_file")
            test_number=$((test_number + 1))
            echo "$test_number" > "$test_num_file"
            
            test_name=$(basename "$test_file" .sh | sed 's/^test[-_]//')
            
            # Skip if test is marked as unsupported
            if grep -q "$UNSUPPORTED_MARKER" "$test_file" 2>/dev/null; then
              skip_count=$(cat "$skip_file")
              echo "$((skip_count + 1))" > "$skip_file"
              continue
            fi
            
            echo "Running: $test_file"
            
            # Capture output with test results
            if output=$(timeout 60 sh "$test_file" 2>&1); then
              # Count passed/failed subtests from output
              subtest_passed=$(echo "$output" | grep -c "^PASS" || true)
              subtest_failed=$(echo "$output" | grep -c "^FAIL" || true)
              : ${subtest_passed:=0}
              : ${subtest_failed:=0}
              subtest_total=$((subtest_passed + subtest_failed))
              
              # Update counters
              prev_total=$(cat "$subtest_total_file")
              prev_pass=$(cat "$subtest_pass_file")
              echo "$((prev_total + subtest_total))" > "$subtest_total_file"
              echo "$((prev_pass + subtest_passed))" > "$subtest_pass_file"
              
              if [ "$subtest_failed" -eq 0 ]; then
                printf "%d. ✓ %s (%d/%d subtests)\n" "$test_number" "$test_name" "$subtest_passed" "$subtest_total"
                pass_count=$(cat "$pass_file")
                echo "$((pass_count + 1))" > "$pass_file"
              else
                printf "%d. ✗ %s (%d/%d subtests)\n" "$test_number" "$test_name" "$subtest_passed" "$subtest_total"
                fail_count=$(cat "$fail_file")
                echo "$((fail_count + 1))" > "$fail_file"
                echo "$test_file" >> "$failed_list_file"
              fi
            else
              printf "%d. ✗ %s (script error)\n" "$test_number" "$test_name"
              fail_count=$(cat "$fail_file")
              echo "$((fail_count + 1))" > "$fail_file"
              echo "$test_file" >> "$failed_list_file"
            fi
          done
          
          # Read final counts
          pass_count=$(cat "$pass_file")
          fail_count=$(cat "$fail_file")
          skip_count=$(cat "$skip_file")
          total_subtests=$(cat "$subtest_total_file")
          passed_subtests=$(cat "$subtest_pass_file")
          
          echo ""
          echo "Summary: $pass_count passed, $fail_count failed, 0 uncovered, 0 incomplete, subtests $passed_subtests/$total_subtests."
          
          # Show failures if any
          if [ "$fail_count" -gt 0 ]; then
            echo ""
            echo "Failed tests:"
            cat "$failed_list_file"
            
            # If ≤10 failures, rerun ONLY those tests with --very-verbose for debugging
            if [ "$fail_count" -le 10 ]; then
              echo ""
              echo "Detected ≤10 failing tests; rerunning them with --very-verbose for focused debug..."
              echo ""
              
              test_rerun_num=0
              while IFS= read -r failed_test; do
                [ -z "$failed_test" ] && continue
                test_rerun_num=$((test_rerun_num + 1))
                test_name=$(basename "$failed_test" .sh | sed 's/^test[-_]//')
                echo "[$test_rerun_num/$fail_count] $failed_test"
                sh "$failed_test" --very-verbose 2>&1 || true
                echo ""
              done < "$failed_list_file"
            fi
            
            exit 1
          fi
      
      - name: Create doppelganger zip
        if: success()
        run: |
          cd /tmp
          zip -r wizardry-doppelganger-${{ github.sha }}.zip wizardry-doppelganger \
            -x "wizardry-doppelganger/.git/*" \
            -x "wizardry-doppelganger/.github/*"
          
          echo "=== Zip created ==="
          ls -lh wizardry-doppelganger-*.zip
      
      - name: Upload doppelganger artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: wizardry-doppelganger-${{ github.sha }}
          path: /tmp/wizardry-doppelganger-${{ github.sha }}.zip
          retention-days: 720
      
      - name: Clean up old artifacts
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            // Get all artifacts for this repo
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            // Filter for doppelganger artifacts, sort by creation date
            const doppelgangerArtifacts = artifacts.data.artifacts
              .filter(artifact => artifact.name.startsWith('wizardry-doppelganger-'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            console.log(`Found ${doppelgangerArtifacts.length} doppelganger artifacts`);
            
            // Keep only the last 3, delete the rest
            const toDelete = doppelgangerArtifacts.slice(3);
            
            for (const artifact of toDelete) {
              console.log(`Deleting old artifact: ${artifact.name} (created ${artifact.created_at})`);
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
              } catch (error) {
                console.log(`Failed to delete ${artifact.name}: ${error.message}`);
              }
            }
            
            console.log(`Kept ${Math.min(3, doppelgangerArtifacts.length)} most recent artifacts`);
