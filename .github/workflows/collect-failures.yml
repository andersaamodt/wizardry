name: Collect test failures

# Collects failure outputs and makes them visible to Copilot via:
# 1. Job summaries (visible in workflow run UI - Copilot can read)
# 2. Workflow logs (sequential output for easy review)
# 3. PR description (updated automatically - Copilot can read this immediately)
#
# For AI agents: When a user asks you to fix test failures, check the PR description
# for the "## üîç Latest Test Failures" section. It contains extracted error text that
# is updated immediately after workflow completion and is directly readable by AI agents.

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  actions: read
  pull-requests: write
  checks: write

jobs:
  collect-failures:
    name: Collect workflow failures
    runs-on: ubuntu-latest
    timeout-minutes: 60  # Maximum 1 hour monitoring

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Monitor workflows and collect failures
        id: collect
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          echo "========================================================================"
          echo " WORKFLOW FAILURE COLLECTION"
          echo "========================================================================"
          echo "PR Number: $PR_NUMBER"
          echo "Commit SHA: $COMMIT_SHA"
          echo ""

          # Track which workflows we've already reported (using file-based storage)
          mkdir -p /tmp/reported_runs
          
          # Initialize failure summary file for PR comment
          failure_summary_file="/tmp/failure_summary.txt"
          : > "$failure_summary_file"

          # Workflows to monitor
          workflows=(
            "Unit tests"
            "POSIX, linting, and style checks"
            "Test standalone compiled spells"
            "Test doppelganger compiled wizardry"
            "Dual-pattern validation"
            "Demonstrate wizardry"
            "Compile wizardry"
          )

          # Function to extract test summary from logs
          extract_test_summary() {
            local logfile=$1
            # First remove everything from "Error: Process exited" onward
            local cleaned_log="/tmp/cleaned_$$.txt"
            sed '/Error.*Process exited/,$d' "$logfile" > "$cleaned_log"
            
            # Extract from "=== Test Summary ===" to the end or next section
            if grep -q "=== Test Summary ===" "$cleaned_log"; then
              sed -n '/=== Test Summary ===/,/^===/p' "$cleaned_log" | head -n -1
            fi
            
            rm -f "$cleaned_log"
          }

          # Function to extract failed step from logs
          extract_failed_step() {
            local logfile=$1
            local job_name=$2

            # For unit tests, extract test summary
            if echo "$job_name" | grep -qi "unit test"; then
              extract_test_summary "$logfile"
              return
            fi

            # First remove everything from "Error: Process exited" onward from the entire log
            local cleaned_log="/tmp/cleaned_$$.txt"
            sed '/Error.*Process exited/,$d' "$logfile" > "$cleaned_log"

            # For other workflows, find the failing step in cleaned log
            if grep -q "##\[error\]" "$cleaned_log"; then
              # Extract error lines and surrounding context
              grep -B 5 -A 10 "##\[error\]" "$cleaned_log" | head -100
            elif grep -qi "FAIL\|ERROR" "$cleaned_log"; then
              # Extract failure lines
              grep -i -B 3 -A 3 "FAIL\|ERROR" "$cleaned_log" | head -100
            else
              # Last resort: show last part of cleaned log
              tail -50 "$cleaned_log"
            fi
            
            rm -f "$cleaned_log"
          }

          # Function to process a completed workflow run
          process_workflow_run() {
            local run_id=$1
            local workflow_name=$2
            local conclusion=$3

            # Skip if already reported
            if [ -f "/tmp/reported_runs/$run_id" ]; then
              return
            fi

            touch "/tmp/reported_runs/$run_id"

            echo "----------------------------------------"
            echo "Workflow: $workflow_name"
            echo "Run ID: $run_id"
            echo "Status: $conclusion"
            echo ""

            if [ "$conclusion" = "success" ]; then
              echo "‚úÖ Passed"
              echo ""
              return
            fi

            if [ "$conclusion" != "failure" ]; then
              echo "Status: $conclusion (skipped)"
              echo ""
              return
            fi

            echo "‚ùå FAILED - extracting error details..."
            echo ""

            # Get failed jobs
            gh api "/repos/${{ github.repository }}/actions/runs/${run_id}/jobs" \
              > /tmp/jobs_${run_id}.json

            local failed_count=$(jq '[.jobs[] | select(.conclusion == "failure")] | length' \
              /tmp/jobs_${run_id}.json)
            echo "Failed jobs: $failed_count"
            echo ""
            
            # Add to failure summary for PR comment
            {
              echo ""
              echo "### ‚ùå $workflow_name"
              echo ""
              echo "**Failed jobs:** $failed_count"
              echo ""
            } >> "$failure_summary_file"

            # Process each failed job
            jq -r '.jobs[] | select(.conclusion == "failure") | "\(.id)|\(.name)"' \
              /tmp/jobs_${run_id}.json | \
            while IFS='|' read -r job_id job_name; do
              echo "--- Failed Job: $job_name ---"

              # Get job logs
              if gh api "/repos/${{ github.repository }}/actions/jobs/${job_id}/logs" \
                > /tmp/log_${job_id}.txt 2>&1; then
                # Extract relevant failure text
                failure_text=$(extract_failed_step "/tmp/log_${job_id}.txt" "$job_name")
                echo "$failure_text"
                echo ""
                
                # Add to PR comment summary
                {
                  echo "**Job: $job_name**"
                  echo '```'
                  echo "$failure_text"
                  echo '```'
                  echo ""
                } >> "$failure_summary_file"
              else
                echo "‚ö†Ô∏è Could not download logs"
                echo ""
              fi

              rm -f /tmp/log_${job_id}.txt
            done

            rm -f /tmp/jobs_${run_id}.json
            echo ""
          }

          # Poll for workflow completions
          poll_count=0
          max_polls=720  # 720 * 5s = 1 hour max
          completed_count=0

          while [ $poll_count -lt $max_polls ]; do
            poll_count=$((poll_count + 1))

            # Get workflow runs for this commit
            runs_json=$(gh api \
              "/repos/${{ github.repository }}/actions/runs?head_sha=${COMMIT_SHA}&per_page=100")

            # Process each monitored workflow
            for workflow_name in "${workflows[@]}"; do
              # Find the latest run for this workflow
              run_info=$(echo "$runs_json" | jq -r --arg name "$workflow_name" \
                '.workflow_runs[] | select(.name == $name) | "\(.id)|\(.conclusion)|\(.status)"' \
                | head -1)

              if [ -z "$run_info" ]; then
                continue
              fi

              IFS='|' read -r run_id conclusion status <<< "$run_info"

              # Only process completed runs
              if [ "$status" = "completed" ]; then
                process_workflow_run "$run_id" "$workflow_name" "$conclusion"
              fi
            done

            # Count how many are completed
            completed_count=$(ls -1 /tmp/reported_runs 2>/dev/null | wc -l)

            # Check if all workflows are completed
            if [ "$completed_count" -ge "${#workflows[@]}" ]; then
              echo "All workflows completed. Monitoring finished."
              break
            fi

            # Log progress every minute (12 polls)
            if [ $((poll_count % 12)) -eq 0 ]; then
              echo "[$(date -u +%H:%M:%S)] Monitoring... ($completed_count/${#workflows[@]} workflows completed)"
            fi

            # Sleep before next poll
            sleep 5
          done

          if [ $poll_count -ge $max_polls ]; then
            echo "‚ö†Ô∏è Monitoring timeout reached (1 hour)"
          fi

          echo ""
          echo "========================================================================"
          echo " WORKFLOW FAILURE COLLECTION - Complete"
          echo "========================================================================"
          
          # Set output for PR comment step
          if [ -s "$failure_summary_file" ]; then
            echo "has_failures=true" >> "$GITHUB_OUTPUT"
            # Encode failure summary for output (escape newlines and quotes)
            {
              echo "failure_summary<<EOF"
              cat "$failure_summary_file"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "has_failures=false" >> "$GITHUB_OUTPUT"
            echo "failure_summary=" >> "$GITHUB_OUTPUT"
          fi

      - name: Create summary
        if: always()
        run: |
          {
            echo "# üîç Test Failure Collection"
            echo ""
            echo "**PR:** #${{ github.event.pull_request.number }}"
            echo "**Commit:** ${{ github.event.pull_request.head.sha }}"
            echo ""
            echo "This workflow monitors all test workflows for this PR and reports failures."
            echo ""
            echo "See the workflow logs above for detailed failure information."
          } >> "$GITHUB_STEP_SUMMARY"
      
      - name: Update PR description
        if: steps.collect.outputs.has_failures == 'true'
        uses: actions/github-script@v7
        env:
          FAILURE_SUMMARY: ${{ steps.collect.outputs.failure_summary }}
        with:
          script: |
            const pr = '${{ github.event.pull_request.number }}';
            const failureSummary = process.env.FAILURE_SUMMARY;
            const runId = '${{ github.run_id }}';
            const date = new Date().toISOString().split('T')[0];
            const time = new Date().toISOString().split('T')[1].slice(0,8);
            
            // Get current PR
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr
            });
            
            let currentBody = pullRequest.body || '';
            
            // Create failure section
            const failureSection = [
              '',
              '---',
              '',
              '## üîç Latest Test Failures',
              '',
              '**Updated:** ' + date + ' ' + time + ' UTC',
              '',
              failureSummary,
              '',
              'üí° **View detailed logs:** Check the [workflow run logs](../../actions/runs/' + runId + ')',
              '',
              '<!-- test-failures-end -->'
            ].join('\n');
            
            // Remove existing failure section if present
            const failureStart = currentBody.indexOf('## üîç Latest Test Failures');
            if (failureStart !== -1) {
              const failureEnd = currentBody.indexOf('<!-- test-failures-end -->');
              if (failureEnd !== -1) {
                // Remove from start of section to end marker
                const beforeSection = currentBody.substring(0, failureStart - 5); // -5 for the --- and newlines
                const afterSection = currentBody.substring(failureEnd + 28); // +28 for <!-- test-failures-end -->
                currentBody = beforeSection + afterSection;
              }
            }
            
            // Append new failure section
            const newBody = currentBody.trim() + failureSection;
            
            // Update PR body
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr,
              body: newBody
            });
