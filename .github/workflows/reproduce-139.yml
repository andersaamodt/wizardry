name: Reproduce exit 139

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  reproduce-segfault-ubuntu-absolute-minimal:
    name: Ubuntu - Banish Absolute Minimal (no functions)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish ABSOLUTE MINIMAL (just shebang + exit)
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Absolute minimal: just shebang and exit, no functions at all
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with absolute-minimal banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish ABSOLUTE MINIMAL, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is calling ANY script after invoke"

  reproduce-segfault-ubuntu-empty-function:
    name: Ubuntu - Banish Empty Function (def but no call)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with EMPTY FUNCTION (define but don't call)
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Define an empty function but don't call it
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          empty_func() {
            :
          }
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with empty-function banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish EMPTY FUNCTION, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is DEFINING a function after invoke"

  reproduce-segfault-ubuntu-call-empty:
    name: Ubuntu - Banish Call Empty (call empty function)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish that CALLS empty function
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Define and call an empty function
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          empty_func() {
            :
          }
          empty_func
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with call-empty banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish CALL EMPTY, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is CALLING a function after invoke"

  reproduce-segfault-ubuntu-framework-half2:
    name: Ubuntu - Banish Framework Half 2 (validation only)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with FRAMEWORK HALF 2 (level validation only)
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Second half of banish framework: level range validation
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          printf '[TRACE] banish half2: start\n' >&2
          target_level=${1:-0}
          printf '[TRACE] banish half2: got arg=%s\n' "$target_level" >&2
          
          # Framework HALF 2: level range check
          printf '[TRACE] banish half2: checking level range\n' >&2
          if [ "$target_level" -lt 0 ] || [ "$target_level" -gt 9 ]; then
            printf 'banish: level out of range (0-9)\n' >&2
            exit 1
          fi
          printf '[TRACE] banish half2: level in valid range\n' >&2
          
          printf 'Banish framework half2: level %s validated successfully\n' "$target_level"
          printf '[TRACE] banish half2: exiting successfully\n' >&2
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with framework-half2 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish FRAMEWORK HALF 2, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in banish's level validation"

  reproduce-segfault-ubuntu-standalone-check:
    name: Ubuntu - Standalone POSIX Check (no banish)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Invoke wizardry, run standalone POSIX check, then test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          echo "About to invoke wizardry, run STANDALONE POSIX check, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry
          
          # Standalone POSIX commands check (not through banish)
          echo "Running standalone POSIX check..."
          posix_failed=0
          posix_cmds="sh test printf command dirname basename pwd cat"
          posix_cmds="$posix_cmds grep find sort cut head tail tr wc awk sed xargs mktemp uname"
          for cmd in $posix_cmds; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              posix_failed=1
              break
            fi
          done
          
          if [ "$posix_failed" -eq 0 ]; then
            printf 'Standalone POSIX check passed\n'
          else
            printf 'Standalone POSIX check failed\n' >&2
            exit 1
          fi
          
          # Now run test-magic
          ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in the POSIX check itself"

  reproduce-segfault-arch-absolute-minimal:
    name: Arch - Banish Absolute Minimal (no functions)
    runs-on: ubuntu-latest
    container: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish ABSOLUTE MINIMAL (just shebang + exit)
        run: |
          export WIZARDRY_DIR="${PWD}"
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with absolute-minimal banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish ABSOLUTE MINIMAL, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is calling ANY script after invoke"

  reproduce-segfault-arch-empty-function:
    name: Arch - Banish Empty Function (def but no call)
    runs-on: ubuntu-latest
    container: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with EMPTY FUNCTION (define but don't call)
        run: |
          export WIZARDRY_DIR="${PWD}"
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          empty_func() {
            :
          }
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with empty-function banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish EMPTY FUNCTION, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is DEFINING a function after invoke"

  reproduce-segfault-arch-call-empty:
    name: Arch - Banish Call Empty (call empty function)
    runs-on: ubuntu-latest
    container: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish that CALLS empty function
        run: |
          export WIZARDRY_DIR="${PWD}"
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          empty_func() {
            :
          }
          empty_func
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with call-empty banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish CALL EMPTY, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is CALLING a function after invoke"

  reproduce-segfault-arch-framework-half2:
    name: Arch - Banish Framework Half 2 (validation only)
    runs-on: ubuntu-latest
    container: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with FRAMEWORK HALF 2 (level validation only)
        run: |
          export WIZARDRY_DIR="${PWD}"
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          printf '[TRACE] banish half2: start\n' >&2
          target_level=${1:-0}
          printf '[TRACE] banish half2: got arg=%s\n' "$target_level" >&2
          
          printf '[TRACE] banish half2: checking level range\n' >&2
          if [ "$target_level" -lt 0 ] || [ "$target_level" -gt 9 ]; then
            printf 'banish: level out of range (0-9)\n' >&2
            exit 1
          fi
          printf '[TRACE] banish half2: level in valid range\n' >&2
          
          printf 'Banish framework half2: level %s validated successfully\n' "$target_level"
          printf '[TRACE] banish half2: exiting successfully\n' >&2
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with framework-half2 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish FRAMEWORK HALF 2, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic--verbose
          echo "Completed - if fails with 139, bug is in banish's level validation"

  reproduce-segfault-arch-standalone-check:
    name: Arch - Standalone POSIX Check (no banish)
    runs-on: ubuntu-latest
    container: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Invoke wizardry, run standalone POSIX check, then test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          echo "About to invoke wizardry, run STANDALONE POSIX check, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry
          
          echo "Running standalone POSIX check..."
          posix_failed=0
          posix_cmds="sh test printf command dirname basename pwd cat"
          posix_cmds="$posix_cmds grep find sort cut head tail tr wc awk sed xargs mktemp uname"
          for cmd in $posix_cmds; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              posix_failed=1
              break
            fi
          done
          
          if [ "$posix_failed" -eq 0 ]; then
            printf 'Standalone POSIX check passed\n'
          else
            printf 'Standalone POSIX check failed\n' >&2
            exit 1
          fi
          
          ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in the POSIX check itself"

  reproduce-segfault-ubuntu-quarter1:
    name: Ubuntu - Quarter 1 (POSIX commands only)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with FIRST QUARTER POSIX checks
        run: |
          export WIZARDRY_DIR="${PWD}"
          # First quarter: POSIX commands check ONLY
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          target_level=${1:-0}
          
          # Banish with FIRST QUARTER: POSIX commands only
          WIZARDRY_DIR=${WIZARDRY_DIR:-${PWD}}
          
          # Check POSIX commands
          posix_failed=0
          posix_cmds="sh test printf command dirname basename pwd cat"
          posix_cmds="$posix_cmds grep find sort cut head tail tr wc awk sed xargs mktemp uname"
          for cmd in $posix_cmds; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              posix_failed=1
              break
            fi
          done
          
          if [ "$posix_failed" -eq 0 ]; then
            printf 'POSIX commands check passed\n'
          else
            printf 'POSIX commands check failed\n' >&2
            exit 1
          fi
          
          printf 'Banish quarter 1: level %s validated\n' "$target_level"
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with quarter-1 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish with QUARTER 1 POSIX checks, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in POSIX commands check"

  reproduce-segfault-ubuntu-quarter2:
    name: Ubuntu - Quarter 2 (download tools + tar)
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with SECOND QUARTER POSIX checks
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Second quarter: download tools + tar checks
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          target_level=${1:-0}
          
          # Banish with SECOND QUARTER: download tools + tar
          WIZARDRY_DIR=${WIZARDRY_DIR:-${PWD}}
          
          # Check download tools
          if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
            printf 'Download tools check: no curl/wget\n' >&2
          else
            printf 'Download tools check passed\n'
          fi
          
          # Check tar
          if ! command -v tar >/dev/null 2>&1; then
            printf 'tar check: not found\n' >&2
          else
            printf 'tar check passed\n'
          fi
          
          printf 'Banish quarter 2: level %s validated\n' "$target_level"
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with quarter-2 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish with QUARTER 2 POSIX checks, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in download/tar checks"

  reproduce-segfault-arch-quarter1:
    name: Arch - Quarter 1 (POSIX commands only)
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch
    steps:
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm git

      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with FIRST QUARTER POSIX checks
        run: |
          export WIZARDRY_DIR="${PWD}"
          # First quarter: POSIX commands check ONLY
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          target_level=${1:-0}
          
          # Banish with FIRST QUARTER: POSIX commands only
          WIZARDRY_DIR=${WIZARDRY_DIR:-${PWD}}
          
          # Check POSIX commands
          posix_failed=0
          posix_cmds="sh test printf command dirname basename pwd cat"
          posix_cmds="$posix_cmds grep find sort cut head tail tr wc awk sed xargs mktemp uname"
          for cmd in $posix_cmds; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              posix_failed=1
              break
            fi
          done
          
          if [ "$posix_failed" -eq 0 ]; then
            printf 'POSIX commands check passed\n'
          else
            printf 'POSIX commands check failed\n' >&2
            exit 1
          fi
          
          printf 'Banish quarter 1: level %s validated\n' "$target_level"
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with quarter-1 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish with QUARTER 1 POSIX checks, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in POSIX commands check"

  reproduce-segfault-arch-quarter2:
    name: Arch - Quarter 2 (download tools + tar)
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    env:
      WIZARDRY_OS_LABEL: arch
    steps:
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm git

      - uses: actions/checkout@v4

      - name: Generate glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh

      - name: Create banish with SECOND QUARTER POSIX checks
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Second quarter: download tools + tar checks
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          target_level=${1:-0}
          
          # Banish with SECOND QUARTER: download tools + tar
          WIZARDRY_DIR=${WIZARDRY_DIR:-${PWD}}
          
          # Check download tools
          if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
            printf 'Download tools check: no curl/wget\n' >&2
          else
            printf 'Download tools check passed\n'
          fi
          
          # Check tar
          if ! command -v tar >/dev/null 2>&1; then
            printf 'tar check: not found\n' >&2
          else
            printf 'tar check passed\n'
          fi
          
          printf 'Banish quarter 2: level %s validated\n' "$target_level"
          exit 0
          EOF
          chmod +x /tmp/banish
          cat /tmp/banish

      - name: Invoke wizardry with quarter-2 banish and run test-magic
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry, call banish with QUARTER 2 POSIX checks, and run test-magic..."
          . spells/.imps/sys/invoke-wizardry && banish 0 && ./spells/.wizardry/test-magic --verbose
          echo "Completed - if fails with 139, bug is in download/tar checks"

  reproduce-segfault-nix-3rd-quarter:
    name: Nix - 3rd quarter (for comparison)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate glosses and keep only 3RD quarter
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          total_lines=$(wc -l < /tmp/glosses_full.sh)
          quarter_lines=$((total_lines / 4))
          start_line=$((quarter_lines * 2 + 1))
          end_line=$((quarter_lines * 3))
          echo "Full glosses: $total_lines lines"
          echo "Taking 3RD quarter: lines $start_line to $end_line"
          # Extract by COMPLETE FUNCTIONS to avoid syntax errors
          # Use awk to extract whole function definitions that START in our range
          awk -v start="$start_line" -v end="$end_line" '
            /^[a-zA-Z_][a-zA-Z0-9_]*\(\)/ { in_func=1; func_start=NR; func_text="" }
            in_func { func_text = func_text $0 "\n" }
            in_func && /^}$/ { 
              in_func=0
              if (func_start >= start && func_start <= end) {
                printf "%s", func_text
              }
            }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh
          echo "First 10 lines:"
          head -10 /tmp/glosses.sh

      - name: Try sourcing 3RD quarter in nix-shell
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            echo 'About to source 3RD QUARTER of glosses in nix-shell...'
            . /tmp/glosses.sh
            echo 'Successfully sourced 3rd quarter'
            echo 'Trying declare -F...'
            declare -F | head -20
            echo 'Completed - comparing to see if 3rd quarter still fails'
          "

  reproduce-segfault-nix-37th-sixtyfourth:
    name: Nix - 37th Sixty-Fourth (first half of 19th)
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate full glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          wc -l /tmp/glosses_full.sh
          ls -lh /tmp/glosses_full.sh

      - name: Extract 37TH SIXTY-FOURTH of functions (first half of 19th)
        run: |
          export WIZARDRY_DIR="${PWD}"
          total_lines=$(wc -l < /tmp/glosses_full.sh)
          start_line=$((total_lines / 64 * 36 + 1))
          end_line=$((total_lines / 64 * 37))
          echo "Total lines: $total_lines"
          echo "Extracting 37th sixty-fourth: lines $start_line to $end_line"
          
          # Extract complete functions in this range using awk
          awk -v start="$start_line" -v end="$end_line" '
            /^[a-zA-Z_][a-zA-Z0-9_-]* *\(\)/ {
              in_func = 1
              func_start = NR
              func_lines = $0 "\n"
              next
            }
            in_func {
              func_lines = func_lines $0 "\n"
              if (/^}$/) {
                if (func_start >= start && func_start <= end) {
                  printf "%s", func_lines
                }
                in_func = 0
              }
            }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh
          echo "First 10 lines:"
          head -10 /tmp/glosses.sh

      - name: Try sourcing 37TH SIXTY-FOURTH in nix-shell
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            echo 'About to source 37TH SIXTY-FOURTH of glosses in nix-shell...'
            . /tmp/glosses.sh
            echo 'Successfully sourced 37th sixty-fourth'
            echo 'Trying declare -F...'
            declare -F | head -20
            echo 'Completed - 0.78% of functions (first half of failing 19th)'
          "

  reproduce-segfault-nix-38th-sixtyfourth:
    name: Nix - 38th Sixty-Fourth (second half of 19th)
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate full glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          wc -l /tmp/glosses_full.sh
          ls -lh /tmp/glosses_full.sh

      - name: Extract 38TH SIXTY-FOURTH of functions (second half of 19th)
        run: |
          export WIZARDRY_DIR="${PWD}"
          total_lines=$(wc -l < /tmp/glosses_full.sh)
          start_line=$((total_lines / 64 * 37 + 1))
          end_line=$((total_lines / 64 * 38))
          echo "Total lines: $total_lines"
          echo "Extracting 38th sixty-fourth: lines $start_line to $end_line"
          
          # Extract complete functions in this range using awk
          awk -v start="$start_line" -v end="$end_line" '
            /^[a-zA-Z_][a-zA-Z0-9_-]* *\(\)/ {
              in_func = 1
              func_start = NR
              func_lines = $0 "\n"
              next
            }
            in_func {
              func_lines = func_lines $0 "\n"
              if (/^}$/) {
                if (func_start >= start && func_start <= end) {
                  printf "%s", func_lines
                }
                in_func = 0
              }
            }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh
          echo "First 10 lines:"
          head -10 /tmp/glosses.sh

      - name: Try sourcing 38TH SIXTY-FOURTH in nix-shell
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            echo 'About to source 38TH SIXTY-FOURTH of glosses in nix-shell...'
            . /tmp/glosses.sh
            echo 'Successfully sourced 38th sixty-fourth'
            echo 'Trying declare -F...'
            declare -F | head -20
            echo 'Completed - 0.78% of functions (second half of failing 19th)'
          "

  reproduce-segfault-nix-19th-thirtysecond:
    name: Nix - 20th Thirty-Second (second half of 10th sixteenth)
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate full glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          wc -l /tmp/glosses_full.sh
          ls -lh /tmp/glosses_full.sh

      - name: Extract 20TH THIRTY-SECOND of functions (second half of 10th sixteenth)
        run: |
          export WIZARDRY_DIR="${PWD}"
          total_lines=$(wc -l < /tmp/glosses_full.sh)
          start_line=$((total_lines / 32 * 19 + 1))
          end_line=$((total_lines / 32 * 20))
          echo "Total lines: $total_lines"
          echo "Extracting 20th thirty-second: lines $start_line to $end_line"
          
          # Extract complete functions in this range using awk
          awk -v start="$start_line" -v end="$end_line" '
            /^[a-zA-Z_][a-zA-Z0-9_-]* *\(\)/ {
              in_func = 1
              func_start = NR
              func_lines = $0 "\n"
              next
            }
            in_func {
              func_lines = func_lines $0 "\n"
              if (/^}$/) {
                if (func_start >= start && func_start <= end) {
                  printf "%s", func_lines
                }
                in_func = 0
              }
            }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          ls -lh /tmp/glosses.sh
          echo "First 10 lines:"
          head -10 /tmp/glosses.sh

      - name: Try sourcing 20TH thirty-second in nix-shell
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            echo 'About to source 20TH THIRTY-SECOND of glosses in nix-shell...'
            . /tmp/glosses.sh
            echo 'Successfully sourced 20th thirty-second'
            echo 'Trying declare -F...'
            declare -F | head -20
            echo 'Completed - if this fails, bug is in 20th thirty-second (second half of failing 10th sixteenth)'
          "

  # PROOF TEST 1: Reproduce bug by explicitly redefining declare()
  reproduce-declare-ubuntu:
    name: PROOF - Ubuntu explicitly redefine declare() builtin
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses WITHOUT declare
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          # Filter OUT the declare function to get clean glosses
          awk '
            /^declare *\(\)/ { in_declare=1; next }
            in_declare { if (/^}$/) { in_declare=0 }; next }
            !in_declare { print }
          ' /tmp/glosses_full.sh > /tmp/glosses_clean.sh
          echo "Clean glosses (without declare):"
          wc -l /tmp/glosses_clean.sh
          grep -c "^[a-zA-Z_][a-zA-Z0-9_-]* *()" /tmp/glosses_clean.sh || true

      - name: Source clean glosses and then REDEFINE declare()
        run: |
          export WIZARDRY_DIR="${PWD}"
          # Source clean glosses
          . /tmp/glosses_clean.sh
          echo "Sourced clean glosses successfully"
          
          # Now explicitly redefine the declare() builtin
          declare() {
            echo "Custom declare function"
          }
          
          echo "Redefined declare() - this should cause segfault"
          # Try to use declare
          declare -F | head -5 || echo "FAILED with exit code $?"

  # PROOF TEST 2: Same test on Nix
  reproduce-declare-nix:
    name: PROOF - Nix explicitly redefine declare() builtin
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate glosses WITHOUT declare
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          # Filter OUT the declare function
          awk '
            /^declare *\(\)/ { in_declare=1; next }
            in_declare { if (/^}$/) { in_declare=0 }; next }
            !in_declare { print }
          ' /tmp/glosses_full.sh > /tmp/glosses_clean.sh
          wc -l /tmp/glosses_clean.sh

      - name: Source clean glosses and REDEFINE declare() in nix-shell
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            # Source clean glosses
            . /tmp/glosses_clean.sh
            echo 'Sourced clean glosses'
            
            # Redefine declare() builtin
            declare() {
              echo 'Custom declare in nix'
            }
            
            echo 'Redefined declare() - should cause exit 139'
            declare -F | head -5 || echo 'FAILED with exit code \$?'
          "

  # PROOF TEST 3: Fix the failing 38th sixty-fourth by excluding declare
  reproduce-segfault-nix-38th-without-declare:
    name: PROOF - Nix 38th sixty-fourth EXCLUDING declare() 
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v24
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Generate full glosses to file
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          wc -l /tmp/glosses_full.sh

      - name: Extract 38TH SIXTY-FOURTH but EXCLUDE declare()
        run: |
          export WIZARDRY_DIR="${PWD}"
          total_lines=$(wc -l < /tmp/glosses_full.sh)
          start_line=$((total_lines / 64 * 37 + 1))
          end_line=$((total_lines / 64 * 38))
          echo "Total lines: $total_lines"
          echo "Extracting 38th sixty-fourth: lines $start_line to $end_line (EXCLUDING declare)"
          
          # Extract complete functions in this range, EXCLUDING declare
          awk -v start="$start_line" -v end="$end_line" '
            /^declare *\(\)/ { in_declare=1; next }
            in_declare { if (/^}$/) { in_declare=0 }; next }
            /^[a-zA-Z_][a-zA-Z0-9_-]* *\(\)/ {
              in_func = 1
              func_start = NR
              func_name = $0
              func_lines = $0 "\n"
              next
            }
            in_func {
              func_lines = func_lines $0 "\n"
              if (/^}$/) {
                if (func_start >= start && func_start <= end) {
                  printf "%s", func_lines
                }
                in_func = 0
              }
            }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          echo "Functions extracted:"
          grep "^[a-zA-Z_][a-zA-Z0-9_-]* *()" /tmp/glosses.sh || true
          echo "First 20 lines:"
          head -20 /tmp/glosses.sh

      - name: Try sourcing 38TH SIXTY-FOURTH without declare
        run: |
          WIZARDRY_DIR="${PWD}"
          nix-shell -p bash --run "
            export WIZARDRY_DIR='${WIZARDRY_DIR}'
            echo 'About to source 38TH SIXTY-FOURTH (without declare) in nix-shell...'
            . /tmp/glosses.sh
            echo 'SUCCESS! Sourced 38th sixty-fourth WITHOUT declare'
            echo 'Trying declare -F...'
            declare -F | head -20
            echo 'Completed - should SUCCEED (previously failed with 139)'
          "

  # PROOF TEST 4: Fix framework test by excluding declare
  reproduce-segfault-ubuntu-framework-without-declare:
    name: PROOF - Ubuntu framework EXCLUDING declare()
    runs-on: ubuntu-latest
    env:
      WIZARDRY_OS_LABEL: ubuntu

    steps:
      - uses: actions/checkout@v4

      - name: Generate glosses WITHOUT declare
        run: |
          export WIZARDRY_DIR="${PWD}"
          cd spells/.wizardry
          ./generate-glosses > /tmp/glosses_full.sh
          # Filter OUT the declare function
          awk '
            /^declare *\(\)/ { in_declare=1; next }
            in_declare { if (/^}$/) { in_declare=0 }; next }
            !in_declare { print }
          ' /tmp/glosses_full.sh > /tmp/glosses.sh
          wc -l /tmp/glosses.sh
          echo "Glosses generated WITHOUT declare function"

      - name: Create banish framework half 2
        run: |
          export WIZARDRY_DIR="${PWD}"
          cat > /tmp/banish <<'EOF'
          #!/bin/sh
          set -eu
          
          level=${1:-0}
          
          # Framework Half 2: Level range validation (if statement)
          echo "[TRACE] Checking level range..."
          if [ "$level" -lt 0 ] || [ "$level" -gt 8 ]; then
            echo "banish: level must be 0-8" >&2
            exit 1
          fi
          
          echo "[TRACE] Level $level validated"
          exit 0
          EOF
          chmod +x /tmp/banish

      - name: Invoke wizardry WITHOUT declare and run framework test
        run: |
          export WIZARDRY_DIR="${PWD}"
          export PATH="/tmp:${PATH}"
          echo "About to invoke wizardry (WITHOUT declare), call banish framework, and run test-magic..."
          . /tmp/glosses.sh
          echo "Sourced glosses successfully"
          banish 0
          echo "Banish succeeded"
          ./spells/.wizardry/test-magic --verbose
          echo "SUCCESS! Framework test completed (previously failed with 139)"
