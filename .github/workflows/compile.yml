name: Compile wizardry

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  actions: write  # Required for artifact cleanup

jobs:
  compile:
    name: Compile and package wizardry
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up wizardry environment
        run: |
          export WIZARDRY_DIR="${{ github.workspace }}"
          . "${{ github.workspace }}/spells/.imps/sys/invoke-wizardry"
          echo "WIZARDRY_DIR=$WIZARDRY_DIR" >> "$GITHUB_ENV"
          echo "${{ github.workspace }}/spells" >> "$GITHUB_PATH"
          echo "${{ github.workspace }}/spells/cantrips" >> "$GITHUB_PATH"
          echo "${{ github.workspace }}/spells/spellcraft" >> "$GITHUB_PATH"

      - name: Create compiled doppelganger
        run: |
          export WIZARDRY_DIR="${{ github.workspace }}"
          . "${{ github.workspace }}/spells/.imps/sys/invoke-wizardry"

          # Create doppelganger in /tmp
          doppelganger /tmp/wizardry-compiled

          echo "=== Doppelganger created ==="
          ls -la /tmp/wizardry-compiled/

          # Verify spells directory exists
          if [ ! -d "/tmp/wizardry-compiled/spells" ]; then
            echo "ERROR: spells directory not created"
            exit 1
          fi

          echo ""
          echo "=== Spells directory structure ==="
          find /tmp/wizardry-compiled/spells -type d | head -20

      - name: Create ZIP artifact with root files only
        run: |
          cd /tmp/wizardry-compiled

          # Create ZIP with root files, excluding .tests and any .git* files
          # The doppelganger already excludes .git and .github directories,
          # but we exclude them again as a safeguard
          # We need to explicitly exclude .tests/ for the clean compiled version

          zip -r /tmp/wizardry-compiled-${{ github.sha }}.zip . \
            -x ".tests/*" \
            -x "*.git*"

          echo "=== ZIP created ==="
          ls -lh /tmp/wizardry-compiled-*.zip

          echo ""
          echo "=== ZIP contents (first 50 entries) ==="
          unzip -l /tmp/wizardry-compiled-*.zip | head -50

      - name: Upload compiled wizardry artifact
        uses: actions/upload-artifact@v4
        with:
          name: wizardry-compiled-${{ github.sha }}
          path: /tmp/wizardry-compiled-${{ github.sha }}.zip
          retention-days: 730
          if-no-files-found: error

      - name: Clean up old artifacts
        if: success() && github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const keepCount = 3;  // Number of recent artifacts to keep

            const msg = `Cleaning up artifacts, keeping ${keepCount}...`;
            console.log(msg);

            // Fetch all artifacts with pagination
            let allArtifacts = [];
            let page = 1;
            const perPage = 100;

            while (true) {
              const response = await github.rest.actions.listArtifactsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: perPage,
                page: page
              });

              if (response.data.artifacts.length === 0) {
                break;
              }

              allArtifacts = allArtifacts.concat(response.data.artifacts);

              // Check if there are more pages
              if (response.data.artifacts.length < perPage) {
                break;
              }

              page++;
            }

            console.log(`Total artifacts found: ${allArtifacts.length}`);

            // Filter for compiled wizardry artifacts
            const prefix = 'wizardry-compiled-';
            const compiledArtifacts = allArtifacts
              .filter(artifact => artifact.name.startsWith(prefix))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            const foundMsg = `Found ${compiledArtifacts.length} artifacts`;
            console.log(foundMsg);

            // Keep only the most recent N, delete the rest
            const toDelete = compiledArtifacts.slice(keepCount);

            if (toDelete.length === 0) {
              console.log('No old artifacts to delete');
              return;
            }

            console.log(`Deleting ${toDelete.length} old artifacts...`);

            for (const artifact of toDelete) {
              const delMsg = `Deleting: ${artifact.name}`;
              console.log(delMsg);
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
                console.log(`  ✓ Deleted ${artifact.name}`);
              } catch (error) {
                const errMsg = `  ✗ Failed: ${error.message}`;
                console.log(errMsg);
              }
            }

            const kept = Math.min(keepCount, compiledArtifacts.length);
            const doneMsg = `Cleanup complete. Kept ${kept} artifacts`;
            console.log(doneMsg);
