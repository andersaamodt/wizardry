name: PR Test Monitor

# Monitors test workflows and reports failures to PR
# Runs once per PR, stays alive, and polls for workflow completions
# This avoids the workflow_run approval requirement

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  actions: read
  pull-requests: write
  checks: write

jobs:
  monitor:
    name: Monitor PR workflows
    runs-on: ubuntu-latest
    timeout-minutes: 60  # Maximum 1 hour monitoring
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Monitor workflows and collect failures
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          #!/bin/bash
          set -euo pipefail
          
          echo "========================================================================"
          echo " PR TEST MONITOR - Starting"
          echo "========================================================================"
          echo "PR Number: $PR_NUMBER"
          echo "Commit SHA: $COMMIT_SHA"
          echo ""
          
          # Track which workflows we've already reported
          declare -A reported_runs
          
          # Workflows to monitor
          workflows=(
            "Unit tests"
            "POSIX, linting, and style checks"
            "Test standalone compiled spells"
            "Test doppelganger compiled wizardry"
            "Dual-pattern validation"
            "Demonstrate wizardry"
            "Compile wizardry"
          )
          
          # Function to extract test summary from logs
          extract_test_summary() {
            local logfile=$1
            # Extract from "=== Test Summary ===" to the end or next section
            if grep -q "=== Test Summary ===" "$logfile"; then
              sed -n '/=== Test Summary ===/,/^===/p' "$logfile" | head -n -1
            fi
          }
          
          # Function to extract failed step from logs
          extract_failed_step() {
            local logfile=$1
            local job_name=$2
            
            # For unit tests, extract test summary
            if echo "$job_name" | grep -qi "unit test"; then
              extract_test_summary "$logfile"
              return
            fi
            
            # For other workflows, find the failing step
            # GitHub logs have timestamps, we want the section with errors
            if grep -q "##\[error\]" "$logfile"; then
              # Extract error lines and surrounding context
              grep -B 5 -A 10 "##\[error\]" "$logfile" | head -100
            elif grep -qi "FAIL\|ERROR" "$logfile"; then
              # Extract failure lines
              grep -i -B 3 -A 3 "FAIL\|ERROR" "$logfile" | head -100
            else
              # Last resort: show last part of log
              tail -50 "$logfile"
            fi
          }
          
          # Function to process a completed workflow run
          process_workflow_run() {
            local run_id=$1
            local workflow_name=$2
            local conclusion=$3
            
            # Skip if already reported
            if [ -n "${reported_runs[$run_id]:-}" ]; then
              return
            fi
            
            reported_runs[$run_id]=1
            
            echo "----------------------------------------"
            echo "Workflow: $workflow_name"
            echo "Run ID: $run_id"
            echo "Status: $conclusion"
            echo ""
            
            if [ "$conclusion" = "success" ]; then
              echo "‚úÖ Passed"
              echo ""
              return
            fi
            
            if [ "$conclusion" != "failure" ]; then
              echo "Status: $conclusion (skipped)"
              echo ""
              return
            fi
            
            echo "‚ùå FAILED - extracting error details..."
            echo ""
            
            # Get failed jobs
            gh api "/repos/${{ github.repository }}/actions/runs/${run_id}/jobs" > /tmp/jobs_${run_id}.json
            
            local failed_count=$(jq '[.jobs[] | select(.conclusion == "failure")] | length' /tmp/jobs_${run_id}.json)
            echo "Failed jobs: $failed_count"
            echo ""
            
            # Process each failed job
            jq -r '.jobs[] | select(.conclusion == "failure") | "\(.id)|\(.name)"' /tmp/jobs_${run_id}.json | \
            while IFS='|' read -r job_id job_name; do
              echo "--- Failed Job: $job_name ---"
              
              # Get job logs
              if gh api "/repos/${{ github.repository }}/actions/jobs/${job_id}/logs" > /tmp/log_${job_id}.txt 2>&1; then
                # Extract relevant failure text
                extract_failed_step "/tmp/log_${job_id}.txt" "$job_name"
                echo ""
              else
                echo "‚ö†Ô∏è Could not download logs"
                echo ""
              fi
              
              rm -f /tmp/log_${job_id}.txt
            done
            
            rm -f /tmp/jobs_${run_id}.json
            echo ""
          }
          
          # Poll for workflow completions
          poll_count=0
          max_polls=720  # 720 * 5s = 1 hour max
          completed_workflows=0
          
          while [ $poll_count -lt $max_polls ]; do
            poll_count=$((poll_count + 1))
            
            # Get workflow runs for this commit
            runs_json=$(gh api "/repos/${{ github.repository }}/actions/runs?head_sha=${COMMIT_SHA}&per_page=100")
            
            # Process each monitored workflow
            for workflow_name in "${workflows[@]}"; do
              # Find the latest run for this workflow
              run_info=$(echo "$runs_json" | jq -r --arg name "$workflow_name" \
                '.workflow_runs[] | select(.name == $name) | "\(.id)|\(.conclusion)|\(.status)"' | head -1)
              
              if [ -z "$run_info" ]; then
                continue
              fi
              
              IFS='|' read -r run_id conclusion status <<< "$run_info"
              
              # Only process completed runs
              if [ "$status" = "completed" ]; then
                process_workflow_run "$run_id" "$workflow_name" "$conclusion"
                completed_workflows=$((completed_workflows + 1))
              fi
            done
            
            # Check if all workflows are completed
            if [ $completed_workflows -eq ${#workflows[@]} ]; then
              echo "All workflows completed. Monitoring finished."
              break
            fi
            
            # Log progress every minute (12 polls)
            if [ $((poll_count % 12)) -eq 0 ]; then
              echo "[$(date -u +%H:%M:%S)] Monitoring... ($completed_workflows/${#workflows[@]} workflows completed)"
            fi
            
            # Sleep before next poll
            sleep 5
          done
          
          if [ $poll_count -ge $max_polls ]; then
            echo "‚ö†Ô∏è Monitoring timeout reached (1 hour)"
          fi
          
          echo ""
          echo "========================================================================"
          echo " PR TEST MONITOR - Complete"
          echo "========================================================================"
      
      - name: Create summary
        if: always()
        run: |
          {
            echo "# üîç PR Test Monitor"
            echo ""
            echo "**PR:** #${{ github.event.pull_request.number }}"
            echo "**Commit:** ${{ github.event.pull_request.head.sha }}"
            echo ""
            echo "This workflow monitors all test workflows for this PR and reports failures."
            echo ""
            echo "See the workflow logs above for detailed failure information."
          } >> "$GITHUB_STEP_SUMMARY"
