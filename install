#!/bin/sh

# Handle --uninstall argument to run the uninstall script
if [ "$#" -eq 1 ] && [ "$1" = "--uninstall" ]; then
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="."
        uninstall_script="$script_dir/uninstall_wizardry"
        if [ -x "$uninstall_script" ]; then
                exec "$uninstall_script"
        else
                printf '%s\n' "Error: uninstall script not found at '$uninstall_script'." >&2
                printf '%s\n' "Run the install script first to create it." >&2
                exit 1
        fi
fi

# Abort if unexpected arguments are supplied so we do not accidentally discard
# them when repurposing the positional parameters to track missing directories.
if [ "$#" -ne 0 ]; then
        printf '%s\n' "Usage: install [--uninstall]" >&2
        exit 1
fi

# Disable CDPATH so that "cd" behaves predictably even if the user has a
# custom search path configured in their environment.  This keeps the script
# portable across login shells that set CDPATH to multiple directories.
unset CDPATH

REQUIRED_REL_DIRS="spells"

# Determine the default target directory shown in the install prompt. The
# installer accepts three environment variables to steer non-interactive
# installs:
#   * WIZARDRY_INSTALL_DIR – fully overrides the prompt and is used directly.
#   * WIZARDRY_ROOT        – legacy alias used as an override if set.
#   * WIZARDRY_REMOTE_DIR  – retained for backwards compatibility; becomes the
#                            prompt default when present.
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_ROOT
elif [ -n "${WIZARDRY_REMOTE_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_REMOTE_DIR
elif [ -n "${HOME-}" ]; then
        PROMPT_DEFAULT=$HOME/.wizardry
else
        PROMPT_DEFAULT=.wizardry
fi

# Validate and normalize PROMPT_DEFAULT to prevent path construction issues.
# Environment variables should provide absolute paths, but we handle relative
# paths defensively. If a relative path looks like it's missing a leading slash
# (e.g., starts with "home/"), we treat it as absolute.
# Note: Using character classes for case-insensitive matching (e.g., [Hh]ome)
# is POSIX-compliant and handles common variations without external tools.
case $PROMPT_DEFAULT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        [Hh]ome/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Tt]mp/*|[Mm]nt/*|[Rr]oot/*)
                # Looks like an absolute path missing the leading slash
                # This handles cases where environment variables are set incorrectly
                # Using case-insensitive patterns to catch common variations
                PROMPT_DEFAULT="/$PROMPT_DEFAULT"
                ;;
        *)
                # Other relative paths: resolve relative to HOME if possible
                if [ -n "${HOME-}" ]; then
                        # Convert relative to absolute by prepending HOME
                        PROMPT_DEFAULT=$HOME/$PROMPT_DEFAULT
                else
                        # No HOME set and relative path given - use current directory
                        cwd=$(pwd -P)
                        PROMPT_DEFAULT=$cwd/$PROMPT_DEFAULT
                fi
                ;;
esac

if [ -n "${WIZARDRY_INSTALL_PLATFORM-}" ]; then
        PATH_WIZARD_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        DETECT_RC_FILE_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        export PATH_WIZARD_PLATFORM DETECT_RC_FILE_PLATFORM
fi

# Track whether we are running out of an existing checkout so local installs
# can simply copy the files instead of downloading a fresh archive.  Piped
# installs (wget|sh) expose the script through /bin/sh so we only find a
# checkout when this file is run directly from disk.
LOCAL_SOURCE=""
case $0 in
        */*)
                script_dir=${0%/*}
                if [ -z "$script_dir" ]; then
                        script_dir=.
                fi
                if script_dir_abs=$(cd "$script_dir" 2>/dev/null && pwd -P); then
                        if [ -d "$script_dir_abs/spells" ]; then
                                LOCAL_SOURCE=$script_dir_abs
                        fi
                fi
                ;;
        *)
                if [ -n "${PWD-}" ] && [ -f "$PWD/$0" ]; then
                        if script_dir_abs=$(cd "$PWD" 2>/dev/null && pwd -P); then
                                if [ -d "$script_dir_abs/spells" ]; then
                                        LOCAL_SOURCE=$script_dir_abs
                                fi
                        fi
                fi
                ;;
esac

cleanup_bootstrap() {
        # Clean up any temporary directory created during the download process.
        if [ -n "${BOOTSTRAP_TMP_DIR-}" ] && [ -d "$BOOTSTRAP_TMP_DIR" ]; then
                rm -rf "$BOOTSTRAP_TMP_DIR"
        fi
}

# Remote installs create a throwaway working directory; trap its cleanup so
# shells on every platform remove the temporary files even if the install
# process exits early.
trap 'cleanup_bootstrap' EXIT HUP INT TERM

download_file() {
        # Fetch a remote archive using curl or wget, whichever is available on the
        # host platform.  Some of our supported OS images only ship one of the two
        # tools by default, so we try both before giving up.
        dest=$1
        url=$2
        if command -v curl >/dev/null 2>&1; then
                if curl -fsSL "$url" -o "$dest"; then
                        return 0
                fi
        fi
        if command -v wget >/dev/null 2>&1; then
                if wget -qO "$dest" "$url"; then
                        return 0
                fi
        fi
        printf '%s\n' "Error: Neither curl nor wget is available to download wizardry." >&2
        return 1
}

INSTALL_INPUT=""
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        INSTALL_INPUT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        INSTALL_INPUT=$WIZARDRY_ROOT
else
        message="Where should wizardry be installed? [$PROMPT_DEFAULT] "
        if [ -t 0 ]; then
                # Print the prompt to stderr so the question is visible even if stdout is
                # captured inside a subshell.
                printf '%s' "$message" >&2
                IFS= read -r INSTALL_INPUT
        else
                printf '%s\n' "Info: No interactive input detected; using '$PROMPT_DEFAULT'." >&2
        fi
fi

if [ -z "$INSTALL_INPUT" ]; then
        INSTALL_INPUT=$PROMPT_DEFAULT
fi

case $INSTALL_INPUT in
        ~)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME
                ;;
        ~/*)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME/${INSTALL_INPUT#\~/}
                ;;
esac

case $INSTALL_INPUT in
        /*)
                INSTALL_DIR=$INSTALL_INPUT
                ;;
        *)
                cwd=$(pwd -P)
                INSTALL_DIR=$cwd/$INSTALL_INPUT
                ;;
esac

if [ -d "$INSTALL_DIR/spells" ]; then
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
else
        if [ -e "$INSTALL_DIR" ]; then
                printf '%s\n' "Error: '$INSTALL_DIR' already exists but does not look like wizardry." >&2
                exit 1
        fi
        parent=${INSTALL_DIR%/*}
        if [ "$parent" = "$INSTALL_DIR" ]; then
                parent=.
        fi
        if ! mkdir -p "$parent"; then
                printf '%s\n' "Error: Unable to create directory '$parent'." >&2
                exit 1
        fi
        if [ -n "$LOCAL_SOURCE" ]; then
                printf '%s\n' "Copying wizardry from '$LOCAL_SOURCE' to '$INSTALL_DIR'..."
                if ! cp -R "$LOCAL_SOURCE" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to copy wizardry from '$LOCAL_SOURCE'." >&2
                        exit 1
                fi
        else
                # We need to bootstrap wizardry by downloading a tarball.  Each supported
                # platform provides tar, but some only ship curl or wget, so the
                # download_file helper above checks both before failing.
                archive_url=${WIZARDRY_REMOTE_ARCHIVE-https://github.com/andersaamodt/wizardry/archive/refs/heads/main.tar.gz}
                if ! command -v tar >/dev/null 2>&1; then
                        printf '%s\n' "Error: tar is required to unpack wizardry when installing remotely." >&2
                        exit 1
                fi
                BOOTSTRAP_TMP_DIR=$(mktemp -d "${TMPDIR:-/tmp}/wizardry-install.XXXXXX") || exit 1
                archive="$BOOTSTRAP_TMP_DIR/wizardry.tar.gz"
                printf '%s\n' "Downloading wizardry to '$INSTALL_DIR'..."
                if ! download_file "$archive" "$archive_url"; then
                        exit 1
                fi
                if ! tar -xzf "$archive" -C "$BOOTSTRAP_TMP_DIR"; then
                        printf '%s\n' "Error: Failed to unpack wizardry archive." >&2
                        exit 1
                fi
                extracted=""
                for candidate in "$BOOTSTRAP_TMP_DIR"/*; do
                        if [ -d "$candidate/spells" ]; then
                                extracted=$candidate
                                break
                        fi
                done
                if [ -z "$extracted" ]; then
                        printf '%s\n' "Error: Downloaded archive did not contain wizardry spells." >&2
                        exit 1
                fi
                if ! mv "$extracted" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to move wizardry into '$INSTALL_DIR'." >&2
                        exit 1
                fi
                printf '%s\n' "Wizardry downloaded to '$INSTALL_DIR'."
        fi
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
fi

# Now that the wizardry tree is available, point at the helper spells we rely
# on to update PATH entries and ask for confirmation.
PATH_WIZARD="$ABS_DIR/spells/translocation/path-wizard"
DETECT_RC_FILE="$ABS_DIR/spells/divination/detect-rc-file"
MEMORIZE="$ABS_DIR/spells/spellcraft/memorize"
CORE_INSTALLER=${WIZARDRY_CORE_INSTALLER:-$ABS_DIR/spells/install/core/install-core}
ASK_YN="$ABS_DIR/spells/cantrips/ask_yn"
COLORS_SPELL="$ABS_DIR/spells/cantrips/colors"
PATH_WIZARD_FLAGS=${PATH_WIZARD_FLAGS:---recursive}

# Export environment variables for all helper spells so that they use the new
# versions being installed, not any old versions that may be in PATH.
# This prevents issues where a user has an old wizardry installation in PATH.
SCRIBE_SPELL="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_SCRIBE="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_COMMAND_HELPER="$ABS_DIR/spells/cantrips/memorize-command"
export DETECT_RC_FILE SCRIBE_SPELL MEMORIZE_SCRIBE MEMORIZE_COMMAND_HELPER

# Load colors for better formatted output
load_colors() {
        if [ -r "$COLORS_SPELL" ]; then
                # shellcheck source=/dev/null
                . "$COLORS_SPELL"
                # Disable colors if stdout is not a terminal
                if [ ! -t 1 ]; then
                        RESET=''
                        GREEN=''
                        CYAN=''
                        YELLOW=''
                        BLUE=''
                        BOLD=''
                        GREY=''
                        RED=''
                fi
        else
                # Fallback to no colors
                RESET=''
                GREEN=''
                CYAN=''
                YELLOW=''
                BLUE=''
                BOLD=''
                GREY=''
                RED=''
        fi
}

load_colors

# Helper functions for formatted messages
info_msg() {
        printf '%s==>%s %s\n' "$BOLD$CYAN" "$RESET" "$*"
}

success_msg() {
        printf '%s✓%s %s\n' "$BOLD$GREEN" "$RESET" "$*"
}

section_msg() {
        printf '\n%s===== %s =====%s\n' "$BOLD$BLUE" "$*" "$RESET"
}

substep_msg() {
        printf '%s  ->%s %s\n' "$CYAN" "$RESET" "$*"
}

if [ ! -x "$PATH_WIZARD" ]; then
        printf '%s\n' "Error: Expected helper '$PATH_WIZARD' is missing or not executable." >&2
        exit 1
fi

if [ ! -x "$DETECT_RC_FILE" ]; then
        printf '%s\n' "Error: Required helper '$DETECT_RC_FILE' is missing." >&2
        exit 1
fi

if [ ! -x "$ASK_YN" ]; then
        printf '%s\n' "Error: Required cantrip '$ASK_YN' is missing." >&2
        exit 1
fi

if [ -x "$CORE_INSTALLER" ]; then
        section_msg "Installing Core Prerequisites"
        # Run core installer - it returns success even if some optional deps fail
        ASSUME_YES=1 "$CORE_INSTALLER" >/dev/null 2>&1 || true
        success_msg "Core prerequisites checked"
fi

# Perform comprehensive installation detection across all RC files
# This checks multiple RC files to see if wizardry is installed anywhere
detect_installation_status() {
        # Check common RC files for wizardry paths
        rc_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $HOME/.zshrc $HOME/.zprofile $HOME/.config/nixpkgs/configuration.nix /etc/nixos/configuration.nix"

        found_in_any_rc=0
        for rc_file in $rc_files; do
                if [ -f "$rc_file" ]; then
                        if grep -q "$ABS_DIR" "$rc_file" 2>/dev/null; then
                                found_in_any_rc=1
                                break
                        fi
                fi
        done

        # Check if spells directory exists
        spells_exist=0
        if [ -d "$ABS_DIR/spells" ]; then
                spells_exist=1
        fi

        # Return status: 0=not installed, 1=partially installed, 2=fully installed
        if [ "$found_in_any_rc" -eq 0 ] && [ "$spells_exist" -eq 0 ]; then
                return 0  # Not installed
        elif [ "$found_in_any_rc" -eq 1 ] && [ "$spells_exist" -eq 1 ]; then
                return 2  # Fully installed
        else
                return 1  # Partially installed (needs repair)
        fi
}

# Detect installation status for better user messaging
detect_installation_status
install_status=$?

case $install_status in
        0)
                install_mode="fresh"
                ;;
        1)
                install_mode="repair"
                ;;
        2)
                install_mode="detected"
                ;;
        *)
                install_mode="fresh"
                ;;
esac

# Collect the directories whose PATH exports are absent from the chosen start-up
# file so we can repair them in one pass.
set --
for rel in $REQUIRED_REL_DIRS
do
        dir="$ABS_DIR/$rel"

        if [ ! -d "$dir" ]; then
                printf '%s\n' "Warning: Expected directory '$dir' is missing; skipping." >&2
                continue
        fi

        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS status "$dir"; then
                continue
        fi
        set -- "$@" "$dir"
done

if [ "$#" -eq 0 ]; then
        printf '%s\n' "Wizardry is already installed. Run it with 'menu' or 'mud'."
        exit 0
fi

# Inform user about installation mode
if [ "$install_mode" = "repair" ]; then
        info_msg "Adding missing PATH configuration for existing wizardry installation"
fi

# Detect the rc file and format before prompting so we can give specific guidance
detect_rc_file_value=""
detect_format_value=""
if detect_output="$($DETECT_RC_FILE 2>/dev/null)"; then
        while IFS='=' read -r key value; do
                case $key in
                rc_file)
                        detect_rc_file_value=$value
                        ;;
                format)
                        detect_format_value=$value
                        ;;
                esac
        done <<EOF
$detect_output
EOF
fi

section_msg "Installation Plan"

# Count how many directories will be added (for recursion display)
total_path_additions=0
if [ "$PATH_WIZARD_FLAGS" = "--recursive" ]; then
        for dir
        do
                if [ -d "$dir" ]; then
                        subdir_count=$(find "$dir" -type d 2>/dev/null | wc -l)
                        total_path_additions=$((total_path_additions + subdir_count))
                fi
        done
else
        total_path_additions=$#
fi

info_msg "Will add $total_path_additions directories to your PATH"
for dir
do
        substep_msg "$dir"
        if [ "$PATH_WIZARD_FLAGS" = "--recursive" ]; then
                substep_msg "  (and all subdirectories)"
        fi
done

# Provide format-specific information about what file will be modified
printf '\n'
if [ "$detect_format_value" = "nix" ]; then
        info_msg "NixOS Configuration"
        substep_msg "Configuration file to be modified:"
        if [ -n "$detect_rc_file_value" ]; then
                printf '      %s\n' "$detect_rc_file_value"
        else
                printf '      (could not determine configuration file)\n'
        fi
        substep_msg "Backup: A timestamped backup will be created automatically"
        substep_msg "After install: The installer will run 'sudo nixos-rebuild switch' or 'home-manager switch'"
elif [ -n "$detect_rc_file_value" ]; then
        info_msg "Shell configuration to be modified: $detect_rc_file_value"
fi

# Confirm with the user (or their automation) before editing their configuration.
# When stdin is not interactive we fall back to the non-blocking ASK_CANTRIP_INPUT=none
# pathway so wget|sh installs do not hang.
proceed=0
printf '\n'
if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
        proceed=1
else
        if [ ! -t 0 ] && [ -z "${ASK_CANTRIP_INPUT-}" ]; then
                if ASK_CANTRIP_INPUT=none "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        else
                if "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        fi
fi

if [ "$proceed" -ne 1 ]; then
        printf '%s\n' "Installation cancelled."
        exit 1
fi

section_msg "Updating PATH"

path_updates_made=0
for dir
do
        path_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-path.XXXXXX") || exit 1
        info_msg "Adding $dir to PATH..."
        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS add "$dir" >"$path_log" 2>&1; then
                path_updates_made=1
                success_msg "Added to PATH"
        else
                cat "$path_log" >&2
                rm -f "$path_log"
                exit 1
        fi
        rm -f "$path_log"
done

if [ "$path_updates_made" -eq 1 ]; then
        if [ -n "$detect_rc_file_value" ]; then
                rc_destination=$(printf "'%s'" "$detect_rc_file_value")
        else
                rc_destination="your shell configuration file"
        fi

        success_msg "PATH configuration updated in $rc_destination"

        if [ "$detect_format_value" = "nix" ]; then
                # On NixOS, attempt to run nixos-rebuild or home-manager switch
                info_msg "Attempting to rebuild NixOS configuration..."

                rebuild_success=0
                # Try to detect if we should use sudo or doas
                priv_cmd=""
                if command -v doas >/dev/null 2>&1; then
                        priv_cmd="doas"
                elif command -v sudo >/dev/null 2>&1; then
                        priv_cmd="sudo"
                fi

                # Try home-manager first (doesn't need privileges)
                if command -v home-manager >/dev/null 2>&1; then
                        info_msg "Running 'home-manager switch'..."
                        if home-manager switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                        fi
                fi

                # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
                if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
                        info_msg "Running '$priv_cmd nixos-rebuild switch'..."
                        if $priv_cmd nixos-rebuild switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                        fi
                fi

                if [ "$rebuild_success" -eq 0 ]; then
                        printf '%sNote:%s Could not automatically rebuild NixOS configuration.\n' "$YELLOW" "$RESET"
                        printf 'Please run one of these commands manually:\n'
                        printf '  home-manager switch  (for home-manager users)\n'
                        printf '  sudo nixos-rebuild switch  (for system-level configuration)\n'
                fi
        else
                printf 'Wizardry directories recorded in %s. Open a new shell or source the file to activate them.\n' "$rc_destination"
        fi
fi

# Memorizing spells pre-compiles wizardry's menus so interactive commands are
# ready before the user opens their first shell inside the new install.
mem_status=0
if [ -x "$MEMORIZE" ]; then
        section_msg "Memorizing Spells"
        mem_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-memorize.XXXXXX") || exit 1
        if "$MEMORIZE" --recursive "$ABS_DIR/spells" >"$mem_log" 2>&1; then
                # Parse output to extract counts without the "skipped" message
                memorized_count=$(grep -o 'Memorized [0-9]* spell' "$mem_log" | grep -o '[0-9]*' | head -1)
                if [ -n "$memorized_count" ] && [ "$memorized_count" -gt 0 ]; then
                        success_msg "Memorized $memorized_count spell(s)"
                fi
        else
                mem_status=$?
                cat "$mem_log" >&2 || true
        fi
        rm -f "$mem_log"
else
        printf '%sWarning:%s memorize spell is missing; skipping automatic memorization.\n' "$YELLOW" "$RESET" >&2
fi

# Create uninstall script
create_uninstall_script() {
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="$ABS_DIR"
        uninstall_script="$script_dir/uninstall_wizardry"

        cat >"$uninstall_script" <<'UNINSTALL_EOF'
#!/bin/sh

# Wizardry Uninstall Script
# This script was automatically generated during installation.
# It will reverse all changes made by the install script.

set -eu

UNINSTALL_EOF

        # Add variables for the installation
        cat >>"$uninstall_script" <<UNINSTALL_VARS
INSTALL_DIR="$ABS_DIR"
INSTALL_WAS_LOCAL="$LOCAL_SOURCE"
RC_FILE="$detect_rc_file_value"
RC_FORMAT="$detect_format_value"

UNINSTALL_VARS

        cat >>"$uninstall_script" <<'UNINSTALL_MAIN'
# Load colors if available
if [ -r "$INSTALL_DIR/spells/cantrips/colors" ]; then
        # shellcheck source=/dev/null
        . "$INSTALL_DIR/spells/cantrips/colors"
else
        RESET=''
        RED=''
        YELLOW=''
        GREEN=''
        BOLD=''
        CYAN=''
fi

printf '\n%s===== Wizardry Uninstall =====%s\n\n' "$BOLD$CYAN" "$RESET"
printf '%sThis will remove wizardry from your system:%s\n' "$YELLOW" "$RESET"
printf '  - Remove PATH entries from %s\n' "$RC_FILE"
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '  - Delete wizardry directory: %s\n' "$INSTALL_DIR"
else
        printf '  - Keep wizardry directory (local source installation)\n'
fi
printf '\n'

# Ask for confirmation
printf '%sDo you want to proceed?%s [y/N] ' "$BOLD" "$RESET"
read -r answer
case $answer in
        y|Y|yes|YES)
                : # Continue
                ;;
        *)
                printf 'Uninstall cancelled.\n'
                exit 0
                ;;
esac

printf '\n%s==> Removing PATH entries...%s\n' "$CYAN" "$RESET"

# Use path-wizard to remove PATH entries
PATH_WIZARD="$INSTALL_DIR/spells/translocation/path-wizard"
if [ -x "$PATH_WIZARD" ]; then
        for dir in "$INSTALL_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                if "$PATH_WIZARD" --recursive remove "$dir" 2>/dev/null; then
                        printf '  %s✓%s Removed %s\n' "$GREEN" "$RESET" "$dir"
                fi
        done
        # Also try removing the main spells directory
        if "$PATH_WIZARD" remove "$INSTALL_DIR/spells" 2>/dev/null; then
                printf '  %s✓%s Removed %s\n' "$GREEN" "$RESET" "$INSTALL_DIR/spells"
        fi
else
        printf '  %sWarning:%s Could not find path-wizard; manual PATH cleanup may be needed\n' "$YELLOW" "$RESET"
fi

# Remove wizardry directory if it was downloaded (not local source)
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '\n%s==> Removing wizardry directory...%s\n' "$CYAN" "$RESET"
        if [ -d "$INSTALL_DIR" ]; then
                if rm -rf "$INSTALL_DIR"; then
                        printf '  %s✓%s Deleted %s\n' "$GREEN" "$RESET" "$INSTALL_DIR"
                else
                        printf '  %sError:%s Could not delete %s\n' "$RED" "$RESET" "$INSTALL_DIR"
                        exit 1
                fi
        fi
fi

printf '\n%s✓ Wizardry uninstalled successfully%s\n' "$BOLD$GREEN" "$RESET"
printf 'You may need to restart your shell or source your configuration file.\n\n'

# Self-destruct - safely remove the uninstall script itself
SELF_DIR="$(cd "$(dirname "$0")" 2>/dev/null && pwd)" || SELF_DIR="."
SELF_NAME="$(basename "$0")"
if [ -n "$SELF_DIR" ] && [ -n "$SELF_NAME" ]; then
        rm -f "$SELF_DIR/$SELF_NAME"
fi
UNINSTALL_MAIN

        chmod +x "$uninstall_script"
        return 0
}

if create_uninstall_script; then
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="."
        success_msg "Uninstall script created at: $script_dir/uninstall_wizardry"
fi

printf '\n'
section_msg "Installation Complete!"
success_msg "Wizardry has been successfully installed"
printf '\n%sNext steps:%s\n' "$BOLD" "$RESET"
if [ "$detect_format_value" = "nix" ]; then
        printf '  1. Your NixOS configuration has been updated\n'
        printf '  2. Run %smenu%s or %smud%s to start using wizardry\n' "$CYAN" "$RESET" "$CYAN" "$RESET"
else
        printf '  1. Open a fresh terminal or run: %ssource %s%s\n' "$CYAN" "$detect_rc_file_value" "$RESET"
        printf '  2. Run %smenu%s or %smud%s to start using wizardry\n' "$CYAN" "$RESET" "$CYAN" "$RESET"
fi
printf '  3. To uninstall, run: %s./install --uninstall%s\n' "$CYAN" "$RESET"
printf '\n'

exit "$mem_status"
