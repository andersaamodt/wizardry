#!/bin/sh

# Bootstrap spell: main wizardry installer.
# Abort if unexpected arguments are supplied so we do not accidentally discard
# them when repurposing the positional parameters to track missing directories.
if [ "$#" -ne 0 ]; then
        printf '%s\n' "Usage: install" >&2
        exit 1
fi

# Disable CDPATH so that "cd" behaves predictably even if the user has a
# custom search path configured in their environment.  This keeps the script
# portable across login shells that set CDPATH to multiple directories.
unset CDPATH

# NOTE: With the new word-of-binding paradigm (PR #410), directories no longer
# need to be added to PATH manually. Instead, invoke-wizardry is sourced from
# the rc file and dynamically sets up PATH at shell startup.

# Determine the default target directory shown in the install prompt. The
# installer accepts three environment variables to steer non-interactive
# installs:
#   * WIZARDRY_INSTALL_DIR – fully overrides the prompt and is used directly.
#   * WIZARDRY_ROOT        – legacy alias used as an override if set.
#   * WIZARDRY_REMOTE_DIR  – retained for backwards compatibility; becomes the
#                            prompt default when present.
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_ROOT
elif [ -n "${WIZARDRY_REMOTE_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_REMOTE_DIR
elif [ -n "${HOME-}" ]; then
        PROMPT_DEFAULT=$HOME/.wizardry
else
        PROMPT_DEFAULT=.wizardry
fi

# Validate and normalize PROMPT_DEFAULT to prevent path construction issues.
# Environment variables should provide absolute paths, but we handle relative
# paths defensively. If a relative path looks like it's missing a leading slash
# (e.g., starts with "home/"), we treat it as absolute.
# Note: Using character classes for case-insensitive matching (e.g., [Hh]ome)
# is POSIX-compliant and handles common variations without external tools.
case $PROMPT_DEFAULT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        [Hh]ome/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Tt]mp/*|[Mm]nt/*|[Rr]oot/*)
                # Looks like an absolute path missing the leading slash
                # This handles cases where environment variables are set incorrectly
                # Using case-insensitive patterns to catch common variations
                PROMPT_DEFAULT="/$PROMPT_DEFAULT"
                ;;
        *)
                # Other relative paths: resolve relative to HOME if possible
                if [ -n "${HOME-}" ]; then
                        # Convert relative to absolute by prepending HOME
                        PROMPT_DEFAULT=$HOME/$PROMPT_DEFAULT
                else
                        # No HOME set and relative path given - use current directory
                        cwd=$(pwd -P)
                        PROMPT_DEFAULT=$cwd/$PROMPT_DEFAULT
                fi
                ;;
esac

if [ -n "${WIZARDRY_INSTALL_PLATFORM-}" ]; then
        LEARN_SPELLBOOK_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        DETECT_RC_FILE_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        export LEARN_SPELLBOOK_PLATFORM DETECT_RC_FILE_PLATFORM
fi

# Track whether we are running out of an existing checkout so local installs
# can simply copy the files instead of downloading a fresh archive.  Piped
# installs (wget|sh) expose the script through /bin/sh so we only find a
# checkout when this file is run directly from disk.
LOCAL_SOURCE=""
case $0 in
        */*)
                script_dir=${0%/*}
                if [ -z "$script_dir" ]; then
                        script_dir=.
                fi
                if script_dir_abs=$(cd "$script_dir" 2>/dev/null && pwd -P); then
                        if [ -d "$script_dir_abs/spells" ]; then
                                LOCAL_SOURCE=$script_dir_abs
                        fi
                fi
                ;;
        *)
                if [ -n "${PWD-}" ] && [ -f "$PWD/$0" ]; then
                        if script_dir_abs=$(cd "$PWD" 2>/dev/null && pwd -P); then
                                if [ -d "$script_dir_abs/spells" ]; then
                                        LOCAL_SOURCE=$script_dir_abs
                                fi
                        fi
                fi
                ;;
esac

cleanup_bootstrap() {
        # Clean up any temporary directory created during the download process.
        if [ -n "${BOOTSTRAP_TMP_DIR-}" ] && [ -d "$BOOTSTRAP_TMP_DIR" ]; then
                rm -rf "$BOOTSTRAP_TMP_DIR"
        fi
}

# Handle interrupt signals (Ctrl-C, HUP, TERM) by cleaning up and exiting.
# This ensures the script terminates immediately when the user presses Ctrl-C.
handle_interrupt() {
        cleanup_bootstrap
        printf '\n%s\n' "Installation interrupted." >&2
        exit 130
}

# Remote installs create a throwaway working directory; trap its cleanup so
# shells on every platform remove the temporary files even if the install
# process exits early.
trap 'cleanup_bootstrap' EXIT
trap 'handle_interrupt' HUP INT TERM

download_file() {
        # Fetch a remote archive using curl or wget, whichever is available on the
        # host platform.  Some of our supported OS images only ship one of the two
        # tools by default, so we try both before giving up.
        dest=$1
        url=$2
        if command -v curl >/dev/null 2>&1; then
                if curl -fsSL "$url" -o "$dest"; then
                        return 0
                fi
        fi
        if command -v wget >/dev/null 2>&1; then
                if wget -qO "$dest" "$url"; then
                        return 0
                fi
        fi
        printf '%s\n' "Error: Neither curl nor wget is available to download wizardry." >&2
        return 1
}

INSTALL_INPUT=""
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        INSTALL_INPUT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        INSTALL_INPUT=$WIZARDRY_ROOT
else
        message="Wizardry install directory? [$PROMPT_DEFAULT] "
        if [ -t 0 ]; then
                # Print the prompt to stderr so the question is visible even if stdout is
                # captured inside a subshell.
                printf '%s' "$message" >&2
                IFS= read -r INSTALL_INPUT
        else
                printf '%s\n' "Info: No interactive input detected; using '$PROMPT_DEFAULT'." >&2
        fi
fi

if [ -z "$INSTALL_INPUT" ]; then
        INSTALL_INPUT=$PROMPT_DEFAULT
fi

case $INSTALL_INPUT in
        "~")
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME
                ;;
        "~/"*)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME/${INSTALL_INPUT#\~/}
                ;;
esac

# Normalize INSTALL_INPUT to handle paths that look like absolute paths but are
# missing the leading slash (e.g., "home/username/.wizardry" -> "/home/username/.wizardry").
# This prevents accidental path doubling like "/home/username/home/username/.wizardry".
case $INSTALL_INPUT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        [Hh]ome/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Tt]mp/*|[Mm]nt/*|[Rr]oot/*)
                # Looks like an absolute path missing the leading slash
                INSTALL_INPUT="/$INSTALL_INPUT"
                ;;
esac

case $INSTALL_INPUT in
        /*)
                INSTALL_DIR=$INSTALL_INPUT
                ;;
        *)
                cwd=$(pwd -P)
                INSTALL_DIR=$cwd/$INSTALL_INPUT
                ;;
esac

if [ -d "$INSTALL_DIR/spells" ]; then
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
else
        if [ -e "$INSTALL_DIR" ]; then
                printf '%s\n' "Error: '$INSTALL_DIR' already exists but does not look like wizardry." >&2
                exit 1
        fi
        parent=${INSTALL_DIR%/*}
        if [ "$parent" = "$INSTALL_DIR" ]; then
                parent=.
        fi
        if ! mkdir -p "$parent"; then
                printf '%s\n' "Error: Unable to create directory '$parent'." >&2
                exit 1
        fi
        if [ -n "$LOCAL_SOURCE" ]; then
                printf '%s\n' "Copying wizardry from '$LOCAL_SOURCE' to '$INSTALL_DIR'..."
                if ! cp -R "$LOCAL_SOURCE" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to copy wizardry from '$LOCAL_SOURCE'." >&2
                        exit 1
                fi
        else
                # We need to bootstrap wizardry by downloading a tarball.  Each supported
                # platform provides tar, but some only ship curl or wget, so the
                # download_file helper above checks both before failing.
                archive_url=${WIZARDRY_REMOTE_ARCHIVE-https://github.com/andersaamodt/wizardry/archive/refs/heads/main.tar.gz}
                if ! command -v tar >/dev/null 2>&1; then
                        printf '%s\n' "Error: tar is required to unpack wizardry when installing remotely." >&2
                        exit 1
                fi
                BOOTSTRAP_TMP_DIR=$(mktemp -d "${TMPDIR:-/tmp}/wizardry-install.XXXXXX") || exit 1
                archive="$BOOTSTRAP_TMP_DIR/wizardry.tar.gz"
                printf '%s\n' "Downloading wizardry to '$INSTALL_DIR'..."
                if ! download_file "$archive" "$archive_url"; then
                        exit 1
                fi
                if ! tar -xzf "$archive" -C "$BOOTSTRAP_TMP_DIR"; then
                        printf '%s\n' "Error: Failed to unpack wizardry archive." >&2
                        exit 1
                fi
                extracted=""
                for candidate in "$BOOTSTRAP_TMP_DIR"/*; do
                        if [ -d "$candidate/spells" ]; then
                                extracted=$candidate
                                break
                        fi
                done
                if [ -z "$extracted" ]; then
                        printf '%s\n' "Error: Downloaded archive did not contain wizardry spells." >&2
                        exit 1
                fi
                if ! mv "$extracted" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to move wizardry into '$INSTALL_DIR'." >&2
                        exit 1
                fi
                printf '%s\n' "Wizardry downloaded to '$INSTALL_DIR'."
        fi
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
fi

# Now that the wizardry tree is available, point at the helper spells we rely
# on to set up shell integration and ask for confirmation.
INVOKE_WIZARDRY="$ABS_DIR/spells/.imps/sys/invoke-wizardry"
DETECT_RC_FILE="$ABS_DIR/spells/divination/detect-rc-file"
NIX_SHELL_ADD="$ABS_DIR/spells/.imps/sys/nix-shell-add"
NIX_SHELL_REMOVE="$ABS_DIR/spells/.imps/sys/nix-shell-remove"
CORE_INSTALLER=${WIZARDRY_CORE_INSTALLER:-$ABS_DIR/spells/.arcana/core/install-core}
ASK_YN="$ABS_DIR/spells/cantrips/ask-yn"

# MUD-related helpers (these are used in the optional MUD installation section)
MUD_CD_SPELL="$ABS_DIR/spells/.arcana/mud/cd"
MUD_CONFIG="$ABS_DIR/spells/.arcana/mud/mud-config"

# NOTE: With the word-of-binding paradigm, spells no longer need to be pre-installed.
# word-of-binding auto-sources spells on first use when called via handle-command-not-found.
# Users can still use install() functions in spells for explicit customizations like aliases.

# Export environment variables for all helper spells so that they use the new
# versions being installed, not any old versions that may be in PATH.
# This prevents issues where a user has an old wizardry installation in PATH.
LEARN_SPELL="$ABS_DIR/spells/spellcraft/learn"
MEMORIZE_LEARN="$ABS_DIR/spells/spellcraft/learn"
MEMORIZE_SPELL_HELPER="$ABS_DIR/spells/cantrips/memorize"
export DETECT_RC_FILE LEARN_SPELL MEMORIZE_LEARN MEMORIZE_SPELL_HELPER NIX_SHELL_INIT

# Bootstrap color definitions (inline - cannot rely on wizardry spells during install)
# Create the escape character in a POSIX-compliant way.
ESC=$(printf '\033')

disable_colors() {
        RESET=''
        GREEN=''
        CYAN=''
        YELLOW=''
        BLUE=''
        BOLD=''
        GREY=''
        RED=''
}

# Set up colors inline since install script cannot assume spells are available
RESET="${ESC}[0m"
GREEN="${ESC}[32m"
CYAN="${ESC}[36m"
YELLOW="${ESC}[33m"
BLUE="${ESC}[34m"
BOLD="${ESC}[1m"
GREY="${ESC}[2m"
RED="${ESC}[31m"

# Disable colors if stdout is not a terminal or NO_COLOR is set
if [ ! -t 1 ]; then
        disable_colors
elif [ -n "${NO_COLOR-}" ]; then
        disable_colors
fi

# Helper functions for formatted messages
info_msg() {
        printf '%s==>%s %s\n' "$BOLD$CYAN" "$RESET" "$*"
}

success_msg() {
        printf '%s✓%s %s\n' "$BOLD$GREEN" "$RESET" "$*"
}

section_msg() {
        printf '\n%s===== %s =====%s\n' "$BOLD$BLUE" "$*" "$RESET"
}

substep_msg() {
        printf '%s  ->%s %s\n' "$CYAN" "$RESET" "$*"
}

if [ ! -x "$INVOKE_WIZARDRY" ]; then
        printf '%s\n' "Error: Expected helper '$INVOKE_WIZARDRY' is missing or not executable." >&2
        exit 1
fi

if [ ! -x "$DETECT_RC_FILE" ]; then
        printf '%s\n' "Error: Required helper '$DETECT_RC_FILE' is missing." >&2
        exit 1
fi

if [ ! -x "$ASK_YN" ]; then
        printf '%s\n' "Error: Required cantrip '$ASK_YN' is missing." >&2
        exit 1
fi

# Note: Core prerequisite installation is deferred until after the install plan is shown
# This avoids prompting for sudo before the user understands what will happen

# Perform comprehensive installation detection across all RC files
# This checks multiple RC files to see if wizardry is installed anywhere
detect_installation_status() {
        # Check common RC files for wizardry invoke-wizardry source or wizardry markers
        rc_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $HOME/.zshrc $HOME/.zprofile $HOME/.config/home-manager/home.nix $HOME/.config/nixpkgs/home.nix /etc/nixos/configuration.nix"

        found_in_any_rc=0
        for rc_file in $rc_files; do
                if [ -f "$rc_file" ]; then
                        # Look for invoke-wizardry source line or wizardry markers
                        if grep -qE "(invoke-wizardry|wizardry: invoke-wizardry|wizardry: wizardry-init)" "$rc_file" 2>/dev/null; then
                                found_in_any_rc=1
                                break
                        fi
                        # Also check for legacy PATH entries with wizardry dir
                        if grep -q "$ABS_DIR" "$rc_file" 2>/dev/null; then
                                found_in_any_rc=1
                                break
                        fi
                fi
        done

        # Check if spells directory exists
        spells_exist=0
        if [ -d "$ABS_DIR/spells" ]; then
                spells_exist=1
        fi

        # Return status: 0=not installed, 1=partially installed, 2=fully installed
        if [ "$found_in_any_rc" -eq 0 ] && [ "$spells_exist" -eq 0 ]; then
                return 0  # Not installed
        elif [ "$found_in_any_rc" -eq 1 ] && [ "$spells_exist" -eq 1 ]; then
                return 2  # Fully installed
        else
                return 1  # Partially installed (needs repair)
        fi
}

# Detect installation status for better user messaging
detect_installation_status
install_status=$?

case $install_status in
        0)
                install_mode="fresh"
                ;;
        1)
                install_mode="repair"
                ;;
        2)
                install_mode="detected"
                ;;
        *)
                install_mode="fresh"
                ;;
esac

# Check if invoke-wizardry source line is already in the RC file.
# This replaces the old PATH-based detection approach.
invoke_wizardry_installed=0
check_invoke_wizardry_status() {
        if [ -z "${detect_rc_file_value-}" ]; then
                return 1
        fi
        if [ ! -f "$detect_rc_file_value" ]; then
                return 1
        fi
        # For nix format, check for wizardry shell init marker
        case $detect_format_value in
        nix)
                if grep -qE "wizardry: (invoke-wizardry|wizardry-init)" "$detect_rc_file_value" 2>/dev/null; then
                        return 0
                fi
                ;;
        *)
                # For shell format, check for invoke-wizardry source line or marker
                if grep -qE "(invoke-wizardry|wizardry: invoke-wizardry|wizardry: wizardry-init)" "$detect_rc_file_value" 2>/dev/null; then
                        return 0
                fi
                ;;
        esac
        return 1
}

# Detect the rc file and format early - needed for installation status check
detect_rc_file_value=""
detect_format_value=""
detect_platform_value=""
if detect_output="$($DETECT_RC_FILE 2>/dev/null)"; then
        while IFS='=' read -r key value; do
                case $key in
                rc_file)
                        detect_rc_file_value=$value
                        ;;
                format)
                        detect_format_value=$value
                        ;;
                platform)
                        detect_platform_value=$value
                        ;;
                esac
        done <<EOF
$detect_output
EOF
fi

# On NixOS, if no nix config was found (format is shell), prompt for the config path
# since NixOS systems always have a configuration.nix somewhere
if [ "$detect_platform_value" = "nixos" ] && [ "$detect_format_value" = "shell" ]; then
        info_msg "NixOS detected but no configuration file found at standard paths"
        substep_msg "Checked: /etc/nixos/configuration.nix"
        substep_msg "Checked: ~/.config/home-manager/home.nix"
        substep_msg "Checked: ~/.config/nixpkgs/home.nix"
        printf '\n'
        
        # Check if we have input available (either terminal or piped/redirected)
        # Respect ASK_CANTRIP_INPUT=none to disable interactive prompts
        if [ "${ASK_CANTRIP_INPUT-}" = "none" ]; then
                printf '%s\n' "Error: No NixOS configuration file found and no interactive input available." >&2
                printf '%s\n' "Set NIXOS_CONFIG environment variable to specify the configuration file path." >&2
                exit 1
        fi
        
        printf '%s' "Enter the path to your configuration.nix: " >&2
        IFS= read -r user_nix_config
        
        if [ -n "$user_nix_config" ]; then
                # Expand ~/ patterns. Note: ~user/ patterns are not supported;
                # users should provide absolute paths or use ~/ for their home.
                case $user_nix_config in
                        ~/*)
                                user_nix_config=$HOME/${user_nix_config#\~/}
                                ;;
                esac
                
                # Normalize paths that look like absolute paths but are missing
                # the leading slash (e.g., "etc/nixos/configuration.nix").
                case $user_nix_config in
                        /*)
                                # Already absolute path
                                :
                                ;;
                        [Hh]ome/*|[Ee]tc/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Nn]ix/*)
                                # Looks like an absolute path missing the leading slash
                                user_nix_config="/$user_nix_config"
                                ;;
                esac
                
                if [ -f "$user_nix_config" ]; then
                        detect_rc_file_value=$user_nix_config
                        detect_format_value=nix
                        # Export for any helper that needs it
                        NIXOS_CONFIG=$user_nix_config
                        export NIXOS_CONFIG
                        success_msg "Using configuration file: $user_nix_config"
                else
                        printf '%s\n' "Error: File not found: $user_nix_config" >&2
                        exit 1
                fi
        else
                printf '%s\n' "Error: NixOS requires a configuration file path." >&2
                exit 1
        fi
fi

# Now that we have detect_rc_file_value, we can check if invoke-wizardry is installed
if check_invoke_wizardry_status; then
        invoke_wizardry_installed=1
else
        invoke_wizardry_installed=0
fi

# Determine if installation is needed
needs_installation=0
if [ "$install_status" -eq 0 ]; then
        # Not installed at all - needs full installation
        needs_installation=1
elif [ "$install_status" -eq 1 ]; then
        # Partially installed - needs repair
        needs_installation=1
elif [ "$invoke_wizardry_installed" -eq 0 ]; then
        # Fully installed files but no invoke-wizardry in rc (legacy or needs upgrade)
        needs_installation=1
fi

# If wizardry is fully installed (including invoke-wizardry), show the options menu
if [ "$needs_installation" -eq 0 ]; then
        # Wizardry is already installed - offer options via simple text menu
        printf '\n'
        info_msg "Wizardry is already installed at: $ABS_DIR"
        printf '\n'
        printf '%sWhat would you like to do?%s\n' "$BOLD" "$RESET"
        printf '  1) %sRepair%s - Fix shell configuration if needed\n' "$CYAN" "$RESET"
        printf '  2) %sReinstall%s - Reinstall wizardry (keeps current location)\n' "$CYAN" "$RESET"
        printf '  3) %sUninstall%s - Remove wizardry from your system\n' "$CYAN" "$RESET"
        printf '  4) %sExit%s - Do nothing and exit\n' "$CYAN" "$RESET"
        printf '\n'
        
        # Read user choice
        # Check if we can read input (tty or pipe)
        if [ -t 0 ] || [ -p /dev/stdin ]; then
                printf '%sEnter your choice (1-4): %s' "$BOLD" "$RESET" >&2
                IFS= read -r choice
        else
                # Non-interactive mode - default to exit
                if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
                        # In automated mode with ASSUME_YES, default to repair
                        choice="1"
                        printf '%s\n' "Non-interactive mode: defaulting to repair (option 1)"
                else
                        printf '%s\n' "Wizardry is already installed. Run 'menu' or 'mud' to use it."
                        exit 0
                fi
        fi
        
        case $choice in
                1)
                        # Repair - continue with normal flow
                        info_msg "Repairing wizardry installation..."
                        needs_installation=1
                        ;;
                2)
                        # Reinstall - continue with normal installation flow
                        info_msg "Reinstalling wizardry..."
                        needs_installation=1
                        ;;
                3)
                        # Uninstall - use the uninstall script from the existing installation
                        uninstall_script="$ABS_DIR/.uninstall"
                        if [ -x "$uninstall_script" ]; then
                                exec "$uninstall_script"
                        else
                                printf '%s\n' "Error: uninstall script not found at '$uninstall_script'." >&2
                                printf '%s\n' "The uninstall script is created during installation." >&2
                                printf '%s\n' "You may need to manually remove '$ABS_DIR' and the invoke-wizardry source line from your shell rc file." >&2
                                exit 1
                        fi
                        ;;
                4|"")
                        # Exit (empty input also exits)
                        printf '%s\n' "No changes made. Run 'menu' or 'mud' to use wizardry."
                        exit 0
                        ;;
                *)
                        # Invalid choice - treat as exit
                        printf '%s\n' "Invalid choice. No changes made."
                        exit 0
                        ;;
        esac
fi

section_msg "Installation Plan"

# Show what will be installed
info_msg "Will add invoke-wizardry to your shell configuration"
substep_msg "Location: $INVOKE_WIZARDRY"
substep_msg "This script sets up wizardry environment and PATH at shell startup"

# Provide format-specific information about what file will be modified
printf '\n'
if [ -n "$detect_rc_file_value" ]; then
        info_msg "Configuration file to be modified: $detect_rc_file_value"
fi

# Confirm with the user (or their automation) before editing their configuration.
# When stdin is not interactive we fall back to the non-blocking ASK_CANTRIP_INPUT=none
# pathway so wget|sh installs do not hang.
proceed=0
printf '\n'
if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
        proceed=1
else
        if [ ! -t 0 ] && [ -z "${ASK_CANTRIP_INPUT-}" ]; then
                if ASK_CANTRIP_INPUT=none "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        else
                if "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        fi
fi

if [ "$proceed" -ne 1 ]; then
        printf '%s\n' "Installation cancelled."
        exit 1
fi

# Install core prerequisites now that user has confirmed and seen the plan
# This is where we might ask for sudo on some platforms, so it comes after showing the plan
if [ -x "$CORE_INSTALLER" ]; then
        section_msg "Checking Core Prerequisites"
        
        # Show what we're checking with a sublist
        info_msg "Verifying required tools:"
        
        # Check and display status of each core dependency
        # List common prerequisites
        prereq_git_ok=0
        prereq_tar_ok=0
        prereq_curl_wget_ok=0
        
        if command -v git >/dev/null 2>&1; then
                prereq_git_ok=1
                substep_msg "git: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "git: ${YELLOW}not found (will attempt install)${RESET}"
        fi
        
        if command -v tar >/dev/null 2>&1; then
                prereq_tar_ok=1
                substep_msg "tar: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "tar: ${RED}✗ missing (required)${RESET}"
        fi
        
        if command -v curl >/dev/null 2>&1; then
                prereq_curl_wget_ok=1
                substep_msg "curl: ${GREEN}✓ installed${RESET}"
        elif command -v wget >/dev/null 2>&1; then
                prereq_curl_wget_ok=1
                substep_msg "wget: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "curl/wget: ${YELLOW}neither found (needed for remote downloads)${RESET}"
        fi
        
        # Platform-specific checks
        case $(uname -s 2>/dev/null) in
                Darwin)
                        # macOS specific
                        if command -v stty >/dev/null 2>&1; then
                                substep_msg "stty: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "stty: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        if command -v tput >/dev/null 2>&1; then
                                substep_msg "tput: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "tput: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        ;;
                *)
                        # Linux
                        if command -v bwrap >/dev/null 2>&1; then
                                substep_msg "bubblewrap: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "bubblewrap: ${YELLOW}not found (optional, for test sandboxing)${RESET}"
                        fi
                        if command -v stty >/dev/null 2>&1; then
                                substep_msg "stty: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "stty: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        if command -v tput >/dev/null 2>&1; then
                                substep_msg "tput: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "tput: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        ;;
        esac
        
        # Run core installer - it returns success even if some optional deps fail
        ASSUME_YES=1 "$CORE_INSTALLER" >/dev/null 2>&1 || true
        success_msg "Core prerequisites verified"
fi

section_msg "Setting up Shell Integration"

shell_setup_made=0
rebuild_success=0
sourcing_succeeded=0

# Determine the destination description for messages
if [ -n "$detect_rc_file_value" ]; then
        rc_destination=$(printf "'%s'" "$detect_rc_file_value")
else
        rc_destination="your shell configuration file"
fi

# Add invoke-wizardry source line to the shell configuration file.
# This replaces the old approach of adding directories to PATH manually.
# invoke-wizardry dynamically sets up PATH at shell startup.
info_msg "Updating $rc_destination..."

# Generate the source line for invoke-wizardry
invoke_wizardry_source_line=". \"$INVOKE_WIZARDRY\""

case $detect_format_value in
nix)
        # For NixOS, use nix-shell-add to add shell initialization code
        if [ -x "$NIX_SHELL_ADD" ]; then
                if printf '%s\n' "$invoke_wizardry_source_line" | "$NIX_SHELL_ADD" wizardry-init "$detect_rc_file_value" bash 2>/dev/null; then
                        shell_setup_made=1
                else
                        printf '%s\n' "Error: Failed to add wizardry initialization to '$detect_rc_file_value'." >&2
                        exit 1
                fi
        else
                printf '%s\n' "Error: nix-shell-add helper not found at '$NIX_SHELL_ADD'." >&2
                exit 1
        fi
        ;;
*)
        # For standard shell rc files, add the source line directly with a wizardry marker
        # Check if the source line already exists
        if grep -qE "(invoke-wizardry|wizardry: wizardry-init)" "$detect_rc_file_value" 2>/dev/null; then
                shell_setup_made=0
        else
                # Create rc file if it doesn't exist
                if [ ! -f "$detect_rc_file_value" ]; then
                        touch "$detect_rc_file_value"
                fi
                # Add the source line with inline marker
                printf '%s\n' "$invoke_wizardry_source_line # wizardry: wizardry-init" >> "$detect_rc_file_value"
                shell_setup_made=1
        fi
        ;;
esac

if [ "$shell_setup_made" -eq 1 ]; then
        success_msg "Shell configuration updated in $rc_destination"
fi

# Create ~/.spellbook directory for custom spells
# Note: invoke-wizardry automatically adds this to PATH, so no manual PATH addition needed
if [ -n "${HOME-}" ]; then
        spell_home_dir="$HOME/.spellbook"
        if [ ! -d "$spell_home_dir" ]; then
                mkdir -p "$spell_home_dir"
                substep_msg "Created custom spellbook at $spell_home_dir"
        fi
fi

# NOTE: With the word-of-binding paradigm (PR #410), spells are auto-sourced on
# first use via handle-command-not-found. Pre-installing spells is no longer needed.
# Users can still manually run spell install() functions for customizations.

# MUD Installation (optional)
# After setting up shell integration, ask if user wants to install the MUD features
install_mud=0
if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
        # In non-interactive mode, skip MUD installation by default
        # unless explicitly requested via environment variable
        if [ "${WIZARDRY_INSTALL_MUD-}" = "1" ]; then
                install_mud=1
        fi
else
        if [ ! -t 0 ] && [ -z "${ASK_CANTRIP_INPUT-}" ]; then
                # Non-interactive mode - use ASK_CANTRIP_INPUT=none to allow the default
                if ASK_CANTRIP_INPUT=none "$ASK_YN" "Install the MUD (multi-user dungeon) features?" yes >/dev/null; then
                        install_mud=1
                fi
        else
                if "$ASK_YN" "Install the MUD (multi-user dungeon) features?" yes >/dev/null; then
                        install_mud=1
                fi
        fi
fi

if [ "$install_mud" -eq 1 ]; then
        section_msg "Installing MUD"

        # Install the CD hook (runs 'look' on directory change)
        if [ -x "$MUD_CD_SPELL" ]; then
                info_msg "Installing CD hook..."
                if "$MUD_CD_SPELL" install >/dev/null 2>&1; then
                        substep_msg "CD hook (runs 'look' on directory change)"
                else
                        printf '%sNote:%s CD hook installation skipped.\n' "$YELLOW" "$RESET" >&2
                fi
        fi

        # Enable MUD config features (including command-not-found which is planned)
        if [ -x "$MUD_CONFIG" ]; then
                info_msg "Enabling MUD features..."
                # Enable all MUD config features
                for feature in command-not-found touch-hook fantasy-theme inventory combat mud-enabled; do
                        "$MUD_CONFIG" set "$feature" 1 >/dev/null 2>&1 || true
                done
                substep_msg "Command not found hook (planned feature)"
                substep_msg "Touch hook (planned feature)"
                substep_msg "Fantasy theme (planned feature)"
                substep_msg "Inventory feature (planned feature)"
                substep_msg "HP/MP and combat (planned feature)"
        fi

        success_msg "MUD features installed"
fi

# Handle platform-specific post-installation steps
if [ "$shell_setup_made" -eq 1 ]; then
        if [ "$detect_format_value" = "nix" ]; then
                # On NixOS, attempt to run nixos-rebuild or home-manager switch
                section_msg "Rebuilding NixOS Configuration"
                info_msg "Attempting to rebuild NixOS configuration..."

                # Try to detect if we should use sudo or doas
                priv_cmd=""
                if command -v sudo >/dev/null 2>&1; then
                        priv_cmd="sudo"
                elif command -v doas >/dev/null 2>&1; then
                        priv_cmd="doas"
                fi

                # Try home-manager first (doesn't need privileges)
                if command -v home-manager >/dev/null 2>&1; then
                        info_msg "Running 'home-manager switch'..."
                        if home-manager switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                                # Source the session variables to make PATH available immediately
                                # home-manager stores session vars in hm-session-vars.sh
                                hm_session_vars="$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh"
                                if [ -f "$hm_session_vars" ]; then
                                        # shellcheck disable=SC1090
                                        if . "$hm_session_vars" 2>/dev/null; then
                                                sourcing_succeeded=1
                                        fi
                                fi
                        fi
                fi

                # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
                if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
                        info_msg "Running '$priv_cmd nixos-rebuild switch'..."
                        if "$priv_cmd" nixos-rebuild switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                                # Source /etc/profile to get the new PATH immediately
                                # This runs the system-wide profile scripts that include our PATH changes
                                # shellcheck disable=SC1091
                                if . /etc/profile 2>/dev/null; then
                                        sourcing_succeeded=1
                                fi
                        fi
                fi

                if [ "$rebuild_success" -eq 0 ]; then
                        printf '%sNote:%s NixOS configuration could not be automatically rebuilt.\n' "$YELLOW" "$RESET"
                        printf 'To activate changes, use one of these commands:\n'
                        printf '  home-manager switch  (for home-manager users)\n'
                        printf '  sudo nixos-rebuild switch  (for system-level configuration)\n'
                fi
        else
                # Source the rc file immediately to make wizardry available in the current shell
                # Note: This sources the user's own shell config (e.g., .bashrc), which they already
                # trust since it runs on every shell startup. We redirect stderr and ignore failures
                # since rc files may contain interactive-only code that errors in non-interactive mode.
                # shellcheck disable=SC1090
                sourcing_succeeded=0
                if . "$detect_rc_file_value" 2>/dev/null; then
                        sourcing_succeeded=1
                fi
        fi
fi

# Create uninstall script
create_uninstall_script() {
        uninstall_script="$ABS_DIR/.uninstall"

        cat >"$uninstall_script" <<'UNINSTALL_EOF'
#!/bin/sh

# Wizardry Uninstall Script
# This script was automatically generated during installation.
# It will reverse all changes made by the install script.

set -eu

UNINSTALL_EOF

        # Add variables for the installation
        cat >>"$uninstall_script" <<UNINSTALL_VARS
INSTALL_DIR="$ABS_DIR"
INSTALL_WAS_LOCAL="$LOCAL_SOURCE"
RC_FILE="$detect_rc_file_value"
RC_FORMAT="$detect_format_value"

UNINSTALL_VARS

        cat >>"$uninstall_script" <<'UNINSTALL_MAIN'
# Inline color definitions (consistent with install script)
ESC=$(printf '\033')
RESET="${ESC}[0m"
RED="${ESC}[31m"
YELLOW="${ESC}[33m"
GREEN="${ESC}[32m"
BOLD="${ESC}[1m"
CYAN="${ESC}[36m"

# Disable colors if stdout is not a terminal or NO_COLOR is set
if [ ! -t 1 ]; then
        RESET='' RED='' YELLOW='' GREEN='' BOLD='' CYAN=''
elif [ -n "${NO_COLOR-}" ]; then
        RESET='' RED='' YELLOW='' GREEN='' BOLD='' CYAN=''
fi

printf '\n%s===== Wizardry Uninstall =====%s\n\n' "$BOLD$CYAN" "$RESET"
printf '%sThis will remove wizardry from your system:%s\n' "$YELLOW" "$RESET"
printf '  - Remove invoke-wizardry source line from %s\n' "$RC_FILE"
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '  - Delete wizardry directory: %s\n' "$INSTALL_DIR"
else
        printf '  - Keep wizardry directory (local source installation)\n'
fi
printf '\n'

# Ask for confirmation
printf '%sDo you want to proceed?%s [y/N] ' "$BOLD" "$RESET"
read -r answer
case $answer in
        y|Y|yes|YES)
                : # Continue
                ;;
        *)
                printf 'Uninstall cancelled.\n'
                exit 0
                ;;
esac

printf '\n%s==> Removing shell configuration...%s\n' "$CYAN" "$RESET"

# Remove the invoke-wizardry source line from the rc file
if [ -f "$RC_FILE" ]; then
        if [ "$RC_FORMAT" = "nix" ]; then
                # For NixOS, use nix-shell-remove to remove the wizardry-init block
                NIX_SHELL_REMOVE="$INSTALL_DIR/spells/.imps/sys/nix-shell-remove"
                if [ -x "$NIX_SHELL_REMOVE" ]; then
                        if "$NIX_SHELL_REMOVE" wizardry-init "$RC_FILE" 2>/dev/null; then
                                printf '  %s✓%s Removed wizardry initialization from %s\n' "$GREEN" "$RESET" "$RC_FILE"
                        else
                                printf '  %sNote:%s No wizardry initialization found in %s\n' "$YELLOW" "$RESET" "$RC_FILE"
                        fi
                else
                        # Fallback: try to remove lines containing wizardry-init marker
                        tmp_file="${RC_FILE}.wizardry.$$"
                        if grep -v 'wizardry: wizardry-init' "$RC_FILE" > "$tmp_file" 2>/dev/null; then
                                mv "$tmp_file" "$RC_FILE"
                                printf '  %s✓%s Removed wizardry initialization from %s\n' "$GREEN" "$RESET" "$RC_FILE"
                        else
                                rm -f "$tmp_file"
                                printf '  %sNote:%s Could not remove wizardry initialization\n' "$YELLOW" "$RESET"
                        fi
                fi
        else
                # For shell rc files, remove lines containing the wizardry-init marker
                tmp_file="${RC_FILE}.wizardry.$$"
                if grep -v 'wizardry: wizardry-init' "$RC_FILE" > "$tmp_file" 2>/dev/null; then
                        mv "$tmp_file" "$RC_FILE"
                        printf '  %s✓%s Removed wizardry initialization from %s\n' "$GREEN" "$RESET" "$RC_FILE"
                else
                        rm -f "$tmp_file"
                        printf '  %sNote:%s No wizardry initialization found to remove\n' "$YELLOW" "$RESET"
                fi
        fi
else
        printf '  %sNote:%s RC file %s not found\n' "$YELLOW" "$RESET" "$RC_FILE"
fi

# On NixOS, run nixos-rebuild to apply the configuration changes
if [ "$RC_FORMAT" = "nix" ]; then
        printf '\n%s==> Rebuilding NixOS configuration...%s\n' "$CYAN" "$RESET"

        rebuild_success=0
        
        # Try to detect if we should use sudo or doas
        priv_cmd=""
        if command -v sudo >/dev/null 2>&1; then
                priv_cmd="sudo"
        elif command -v doas >/dev/null 2>&1; then
                priv_cmd="doas"
        fi

        # Try home-manager first (doesn't need privileges)
        if command -v home-manager >/dev/null 2>&1; then
                printf '  Running home-manager switch...\n'
                if home-manager switch; then
                        printf '  %s✓%s NixOS environment rebuilt successfully\n' "$GREEN" "$RESET"
                        rebuild_success=1
                fi
        fi

        # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
        if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
                printf '  Running %s nixos-rebuild switch...\n' "$priv_cmd"
                if "$priv_cmd" nixos-rebuild switch; then
                        printf '  %s✓%s NixOS environment rebuilt successfully\n' "$GREEN" "$RESET"
                        rebuild_success=1
                fi
        fi

        if [ "$rebuild_success" -eq 0 ]; then
                printf '  %sNote:%s NixOS configuration could not be automatically rebuilt.\n' "$YELLOW" "$RESET"
                printf '  To activate changes, use one of these commands:\n'
                printf '    home-manager switch  (for home-manager users)\n'
                printf '    sudo nixos-rebuild switch  (for system-level configuration)\n'
        fi
fi

# Remove wizardry directory if it was downloaded (not local source)
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '\n%s==> Removing wizardry directory...%s\n' "$CYAN" "$RESET"
        if [ -d "$INSTALL_DIR" ]; then
                if rm -rf "$INSTALL_DIR"; then
                        printf '  %s✓%s Deleted %s\n' "$GREEN" "$RESET" "$INSTALL_DIR"
                else
                        printf '  %sError:%s Could not delete %s\n' "$RED" "$RESET" "$INSTALL_DIR"
                        exit 1
                fi
        fi
fi

printf '\n%s✓ Wizardry uninstalled successfully%s\n' "$BOLD$GREEN" "$RESET"

# Show platform-specific guidance for when changes take effect
if [ "$RC_FORMAT" = "nix" ]; then
        printf '\nWizardry shell integration has been removed. Open a new terminal window to complete the process.\n\n'
else
        printf '\nWizardry shell integration has been removed. New terminal windows will not have wizardry commands available.\n\n'
fi

# Self-destruct - safely remove the uninstall script itself
SELF_DIR="$(cd "$(dirname "$0")" 2>/dev/null && pwd)" || SELF_DIR="."
SELF_NAME="$(basename "$0")"
if [ -n "$SELF_DIR" ] && [ -n "$SELF_NAME" ]; then
        rm -f "$SELF_DIR/$SELF_NAME"
fi
UNINSTALL_MAIN

        chmod +x "$uninstall_script"
        return 0
}

# Create uninstall script silently - only notify on failure
if ! create_uninstall_script; then
        printf '%sWarning:%s Could not create uninstall script at %s/.uninstall\n' "$YELLOW" "$RESET" "$ABS_DIR" >&2
fi

section_msg "Installation Complete!"
# Only claim success if NixOS rebuild succeeded (or it's not a NixOS install)
if [ "$detect_format_value" != "nix" ] || [ "$rebuild_success" -eq 1 ]; then
        success_msg "Wizardry has been successfully installed"
else
        printf '%sNote:%s Wizardry files are installed, but NixOS configuration needs to be rebuilt manually.\n' "$YELLOW" "$RESET"
fi

# Show platform-specific guidance for when changes take effect
printf '\n'
if [ "$detect_format_value" = "nix" ]; then
        if [ "$sourcing_succeeded" -eq 1 ]; then
                printf 'Wizardry is now ready to use in this terminal.\n'
                printf '(New terminal windows will also have wizardry available.)\n'
        elif [ "$rebuild_success" -eq 1 ]; then
                # Rebuild succeeded but sourcing failed - need to open new terminal
                printf 'Wizardry will be available when you open a new terminal window.\n'
                printf '(The NixOS rebuild completed, but session variables could not be reloaded.)\n'
        else
                # Rebuild failed - need manual intervention
                printf '%sNote:%s After rebuilding your NixOS configuration, open a new terminal to use wizardry.\n' "$YELLOW" "$RESET"
        fi
elif [ -n "$detect_rc_file_value" ]; then
        if [ "$sourcing_succeeded" -eq 1 ]; then
                printf 'Wizardry is now ready to use in this terminal.\n'
        else
                printf 'Wizardry will be available when you open a new terminal window.\n'
        fi
        printf '(New terminal windows will also have wizardry available.)\n'
fi
printf '\n'
printf 'Run %smenu%s or %smud%s to start using wizardry.\n' "$CYAN" "$RESET" "$CYAN" "$RESET"
printf '\n'

exit 0
