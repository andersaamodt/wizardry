#!/bin/sh

# Handle --uninstall argument to run the uninstall script
if [ "$#" -eq 1 ] && [ "$1" = "--uninstall" ]; then
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="."
        uninstall_script="$script_dir/uninstall_wizardry"
        if [ -x "$uninstall_script" ]; then
                exec "$uninstall_script"
        else
                printf '%s\n' "Error: uninstall script not found at '$uninstall_script'." >&2
                printf '%s\n' "Run the install script first to create it." >&2
                exit 1
        fi
fi

# Abort if unexpected arguments are supplied so we do not accidentally discard
# them when repurposing the positional parameters to track missing directories.
if [ "$#" -ne 0 ]; then
        printf '%s\n' "Usage: install [--uninstall]" >&2
        exit 1
fi

# Disable CDPATH so that "cd" behaves predictably even if the user has a
# custom search path configured in their environment.  This keeps the script
# portable across login shells that set CDPATH to multiple directories.
unset CDPATH

REQUIRED_REL_DIRS="spells"

# Determine the default target directory shown in the install prompt. The
# installer accepts three environment variables to steer non-interactive
# installs:
#   * WIZARDRY_INSTALL_DIR – fully overrides the prompt and is used directly.
#   * WIZARDRY_ROOT        – legacy alias used as an override if set.
#   * WIZARDRY_REMOTE_DIR  – retained for backwards compatibility; becomes the
#                            prompt default when present.
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_ROOT
elif [ -n "${WIZARDRY_REMOTE_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_REMOTE_DIR
elif [ -n "${HOME-}" ]; then
        PROMPT_DEFAULT=$HOME/.wizardry
else
        PROMPT_DEFAULT=.wizardry
fi

# Validate and normalize PROMPT_DEFAULT to prevent path construction issues.
# Environment variables should provide absolute paths, but we handle relative
# paths defensively. If a relative path looks like it's missing a leading slash
# (e.g., starts with "home/"), we treat it as absolute.
# Note: Using character classes for case-insensitive matching (e.g., [Hh]ome)
# is POSIX-compliant and handles common variations without external tools.
case $PROMPT_DEFAULT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        [Hh]ome/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Tt]mp/*|[Mm]nt/*|[Rr]oot/*)
                # Looks like an absolute path missing the leading slash
                # This handles cases where environment variables are set incorrectly
                # Using case-insensitive patterns to catch common variations
                PROMPT_DEFAULT="/$PROMPT_DEFAULT"
                ;;
        *)
                # Other relative paths: resolve relative to HOME if possible
                if [ -n "${HOME-}" ]; then
                        # Convert relative to absolute by prepending HOME
                        PROMPT_DEFAULT=$HOME/$PROMPT_DEFAULT
                else
                        # No HOME set and relative path given - use current directory
                        cwd=$(pwd -P)
                        PROMPT_DEFAULT=$cwd/$PROMPT_DEFAULT
                fi
                ;;
esac

if [ -n "${WIZARDRY_INSTALL_PLATFORM-}" ]; then
        PATH_WIZARD_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        DETECT_RC_FILE_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        export PATH_WIZARD_PLATFORM DETECT_RC_FILE_PLATFORM
fi

# Track whether we are running out of an existing checkout so local installs
# can simply copy the files instead of downloading a fresh archive.  Piped
# installs (wget|sh) expose the script through /bin/sh so we only find a
# checkout when this file is run directly from disk.
LOCAL_SOURCE=""
case $0 in
        */*)
                script_dir=${0%/*}
                if [ -z "$script_dir" ]; then
                        script_dir=.
                fi
                if script_dir_abs=$(cd "$script_dir" 2>/dev/null && pwd -P); then
                        if [ -d "$script_dir_abs/spells" ]; then
                                LOCAL_SOURCE=$script_dir_abs
                        fi
                fi
                ;;
        *)
                if [ -n "${PWD-}" ] && [ -f "$PWD/$0" ]; then
                        if script_dir_abs=$(cd "$PWD" 2>/dev/null && pwd -P); then
                                if [ -d "$script_dir_abs/spells" ]; then
                                        LOCAL_SOURCE=$script_dir_abs
                                fi
                        fi
                fi
                ;;
esac

cleanup_bootstrap() {
        # Clean up any temporary directory created during the download process.
        if [ -n "${BOOTSTRAP_TMP_DIR-}" ] && [ -d "$BOOTSTRAP_TMP_DIR" ]; then
                rm -rf "$BOOTSTRAP_TMP_DIR"
        fi
}

# Handle interrupt signals (Ctrl-C, HUP, TERM) by cleaning up and exiting.
# This ensures the script terminates immediately when the user presses Ctrl-C.
handle_interrupt() {
        cleanup_bootstrap
        printf '\n%s\n' "Installation interrupted." >&2
        exit 130
}

# Remote installs create a throwaway working directory; trap its cleanup so
# shells on every platform remove the temporary files even if the install
# process exits early.
trap 'cleanup_bootstrap' EXIT
trap 'handle_interrupt' HUP INT TERM

download_file() {
        # Fetch a remote archive using curl or wget, whichever is available on the
        # host platform.  Some of our supported OS images only ship one of the two
        # tools by default, so we try both before giving up.
        dest=$1
        url=$2
        if command -v curl >/dev/null 2>&1; then
                if curl -fsSL "$url" -o "$dest"; then
                        return 0
                fi
        fi
        if command -v wget >/dev/null 2>&1; then
                if wget -qO "$dest" "$url"; then
                        return 0
                fi
        fi
        printf '%s\n' "Error: Neither curl nor wget is available to download wizardry." >&2
        return 1
}

INSTALL_INPUT=""
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        INSTALL_INPUT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        INSTALL_INPUT=$WIZARDRY_ROOT
else
        message="Where should wizardry be installed? [$PROMPT_DEFAULT] "
        if [ -t 0 ]; then
                # Print the prompt to stderr so the question is visible even if stdout is
                # captured inside a subshell.
                printf '%s' "$message" >&2
                IFS= read -r INSTALL_INPUT
        else
                printf '%s\n' "Info: No interactive input detected; using '$PROMPT_DEFAULT'." >&2
        fi
fi

if [ -z "$INSTALL_INPUT" ]; then
        INSTALL_INPUT=$PROMPT_DEFAULT
fi

case $INSTALL_INPUT in
        "~")
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME
                ;;
        "~/"*)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME/${INSTALL_INPUT#\~/}
                ;;
esac

# Normalize INSTALL_INPUT to handle paths that look like absolute paths but are
# missing the leading slash (e.g., "home/username/.wizardry" -> "/home/username/.wizardry").
# This prevents accidental path doubling like "/home/username/home/username/.wizardry".
case $INSTALL_INPUT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        [Hh]ome/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Tt]mp/*|[Mm]nt/*|[Rr]oot/*)
                # Looks like an absolute path missing the leading slash
                INSTALL_INPUT="/$INSTALL_INPUT"
                ;;
esac

case $INSTALL_INPUT in
        /*)
                INSTALL_DIR=$INSTALL_INPUT
                ;;
        *)
                cwd=$(pwd -P)
                INSTALL_DIR=$cwd/$INSTALL_INPUT
                ;;
esac

if [ -d "$INSTALL_DIR/spells" ]; then
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
else
        if [ -e "$INSTALL_DIR" ]; then
                printf '%s\n' "Error: '$INSTALL_DIR' already exists but does not look like wizardry." >&2
                exit 1
        fi
        parent=${INSTALL_DIR%/*}
        if [ "$parent" = "$INSTALL_DIR" ]; then
                parent=.
        fi
        if ! mkdir -p "$parent"; then
                printf '%s\n' "Error: Unable to create directory '$parent'." >&2
                exit 1
        fi
        if [ -n "$LOCAL_SOURCE" ]; then
                printf '%s\n' "Copying wizardry from '$LOCAL_SOURCE' to '$INSTALL_DIR'..."
                if ! cp -R "$LOCAL_SOURCE" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to copy wizardry from '$LOCAL_SOURCE'." >&2
                        exit 1
                fi
        else
                # We need to bootstrap wizardry by downloading a tarball.  Each supported
                # platform provides tar, but some only ship curl or wget, so the
                # download_file helper above checks both before failing.
                archive_url=${WIZARDRY_REMOTE_ARCHIVE-https://github.com/andersaamodt/wizardry/archive/refs/heads/main.tar.gz}
                if ! command -v tar >/dev/null 2>&1; then
                        printf '%s\n' "Error: tar is required to unpack wizardry when installing remotely." >&2
                        exit 1
                fi
                BOOTSTRAP_TMP_DIR=$(mktemp -d "${TMPDIR:-/tmp}/wizardry-install.XXXXXX") || exit 1
                archive="$BOOTSTRAP_TMP_DIR/wizardry.tar.gz"
                printf '%s\n' "Downloading wizardry to '$INSTALL_DIR'..."
                if ! download_file "$archive" "$archive_url"; then
                        exit 1
                fi
                if ! tar -xzf "$archive" -C "$BOOTSTRAP_TMP_DIR"; then
                        printf '%s\n' "Error: Failed to unpack wizardry archive." >&2
                        exit 1
                fi
                extracted=""
                for candidate in "$BOOTSTRAP_TMP_DIR"/*; do
                        if [ -d "$candidate/spells" ]; then
                                extracted=$candidate
                                break
                        fi
                done
                if [ -z "$extracted" ]; then
                        printf '%s\n' "Error: Downloaded archive did not contain wizardry spells." >&2
                        exit 1
                fi
                if ! mv "$extracted" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to move wizardry into '$INSTALL_DIR'." >&2
                        exit 1
                fi
                printf '%s\n' "Wizardry downloaded to '$INSTALL_DIR'."
        fi
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
fi

# Now that the wizardry tree is available, point at the helper spells we rely
# on to update PATH entries and ask for confirmation.
PATH_WIZARD="$ABS_DIR/spells/system/path-wizard"
DETECT_RC_FILE="$ABS_DIR/spells/divination/detect-rc-file"
MEMORIZE="$ABS_DIR/spells/spellcraft/memorize"
CORE_INSTALLER=${WIZARDRY_CORE_INSTALLER:-$ABS_DIR/spells/install/core/install-core}
ASK_YN="$ABS_DIR/spells/cantrips/ask_yn"
PATH_WIZARD_FLAGS=${PATH_WIZARD_FLAGS:---recursive}

# Export environment variables for all helper spells so that they use the new
# versions being installed, not any old versions that may be in PATH.
# This prevents issues where a user has an old wizardry installation in PATH.
SCRIBE_SPELL="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_SCRIBE="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_COMMAND_HELPER="$ABS_DIR/spells/cantrips/memorize-command"
export DETECT_RC_FILE SCRIBE_SPELL MEMORIZE_SCRIBE MEMORIZE_COMMAND_HELPER

# Bootstrap color definitions (inline - cannot rely on wizardry spells during install)
# Create the escape character in a POSIX-compliant way.
ESC=$(printf '\033')

disable_colors() {
        RESET=''
        GREEN=''
        CYAN=''
        YELLOW=''
        BLUE=''
        BOLD=''
        GREY=''
        RED=''
}

# Set up colors inline since install script cannot assume spells are available
RESET="${ESC}[0m"
GREEN="${ESC}[32m"
CYAN="${ESC}[36m"
YELLOW="${ESC}[33m"
BLUE="${ESC}[34m"
BOLD="${ESC}[1m"
GREY="${ESC}[2m"
RED="${ESC}[31m"

# Disable colors if stdout is not a terminal or NO_COLOR is set
if [ ! -t 1 ]; then
        disable_colors
elif [ -n "${NO_COLOR-}" ]; then
        disable_colors
fi

# Helper functions for formatted messages
info_msg() {
        printf '%s==>%s %s\n' "$BOLD$CYAN" "$RESET" "$*"
}

success_msg() {
        printf '%s✓%s %s\n' "$BOLD$GREEN" "$RESET" "$*"
}

section_msg() {
        printf '\n%s===== %s =====%s\n' "$BOLD$BLUE" "$*" "$RESET"
}

substep_msg() {
        printf '%s  ->%s %s\n' "$CYAN" "$RESET" "$*"
}

if [ ! -x "$PATH_WIZARD" ]; then
        printf '%s\n' "Error: Expected helper '$PATH_WIZARD' is missing or not executable." >&2
        exit 1
fi

if [ ! -x "$DETECT_RC_FILE" ]; then
        printf '%s\n' "Error: Required helper '$DETECT_RC_FILE' is missing." >&2
        exit 1
fi

if [ ! -x "$ASK_YN" ]; then
        printf '%s\n' "Error: Required cantrip '$ASK_YN' is missing." >&2
        exit 1
fi

# Note: Core prerequisite installation is deferred until after the install plan is shown
# This avoids prompting for sudo before the user understands what will happen

# Perform comprehensive installation detection across all RC files
# This checks multiple RC files to see if wizardry is installed anywhere
detect_installation_status() {
        # Check common RC files for wizardry paths
        rc_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $HOME/.zshrc $HOME/.zprofile $HOME/.config/home-manager/home.nix $HOME/.config/nixpkgs/home.nix /etc/nixos/configuration.nix"

        found_in_any_rc=0
        for rc_file in $rc_files; do
                if [ -f "$rc_file" ]; then
                        if grep -q "$ABS_DIR" "$rc_file" 2>/dev/null; then
                                found_in_any_rc=1
                                break
                        fi
                fi
        done

        # Check if spells directory exists
        spells_exist=0
        if [ -d "$ABS_DIR/spells" ]; then
                spells_exist=1
        fi

        # Return status: 0=not installed, 1=partially installed, 2=fully installed
        if [ "$found_in_any_rc" -eq 0 ] && [ "$spells_exist" -eq 0 ]; then
                return 0  # Not installed
        elif [ "$found_in_any_rc" -eq 1 ] && [ "$spells_exist" -eq 1 ]; then
                return 2  # Fully installed
        else
                return 1  # Partially installed (needs repair)
        fi
}

# Generate a flake.nix file in the wizardry directory for NixOS users
# This allows declarative installation via home-manager or NixOS modules
generate_flake_nix() {
        flake_path="$ABS_DIR/flake.nix"
        if [ -f "$flake_path" ]; then
                return 0  # Already exists
        fi
        
        cat > "$flake_path" << 'FLAKE_EOF'
{
  description = "Wizardry - the terminal's missing link";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        
        wizardry = pkgs.stdenvNoCC.mkDerivation {
          pname = "wizardry";
          version = "0.1.0";
          
          src = ./.;
          
          dontBuild = true;
          
          installPhase = ''
            runHook preInstall
            
            mkdir -p $out/share/wizardry
            mkdir -p $out/bin
            
            cp -r spells $out/share/wizardry/
            cp -r .tests $out/share/wizardry/
            cp -r tutorials $out/share/wizardry/ 2>/dev/null || true
            cp install $out/share/wizardry/
            cp README.md $out/share/wizardry/
            
            cat > $out/bin/menu <<EOF
#!/bin/sh
exec "$out/share/wizardry/spells/menu/menu" "\$@"
EOF
            chmod +x $out/bin/menu
            
            cat > $out/bin/mud <<EOF
#!/bin/sh
exec "$out/share/wizardry/spells/mud/mud" "\$@"
EOF
            chmod +x $out/bin/mud
            
            cat > $out/share/wizardry/setup.sh <<EOF
WIZARDRY_ROOT="$out/share/wizardry"
export WIZARDRY_ROOT
EOF
            
            find $out/share/wizardry/spells -type d | while read -r dir; do
              echo "export PATH=\"\$PATH:$dir\"" >> $out/share/wizardry/setup.sh
            done
            
            runHook postInstall
          '';
          
          meta = {
            description = "Wizardry - shell scripts for terminal users";
            homepage = "https://github.com/andersaamodt/wizardry";
            platforms = pkgs.lib.platforms.unix;
          };
        };
      in
      {
        packages = {
          default = wizardry;
          wizardry = wizardry;
        };
        
        devShells.default = pkgs.mkShell {
          packages = [ wizardry ];
          shellHook = ''
            export WIZARDRY_ROOT="${wizardry}/share/wizardry"
            source "${wizardry}/share/wizardry/setup.sh"
            echo "Wizardry is ready! Type 'menu' or 'mud' to start."
          '';
        };
      }
    ) // {
      homeManagerModules.default = { config, lib, pkgs, ... }:
        let
          cfg = config.programs.wizardry;
        in
        {
          options.programs.wizardry = {
            enable = lib.mkEnableOption "wizardry shell scripts";
            
            package = lib.mkOption {
              type = lib.types.package;
              default = self.packages.${pkgs.system}.wizardry;
              description = "The wizardry package to use.";
            };
          };
          
          config = lib.mkIf cfg.enable {
            home.packages = [ cfg.package ];
            
            home.sessionVariables = {
              WIZARDRY_ROOT = "${cfg.package}/share/wizardry";
            };
            
            programs.bash.initExtra = lib.mkIf config.programs.bash.enable ''
              source "${cfg.package}/share/wizardry/setup.sh"
            '';
            
            programs.zsh.initExtra = lib.mkIf config.programs.zsh.enable ''
              source "${cfg.package}/share/wizardry/setup.sh"
            '';
          };
        };
      
      nixosModules.default = { config, lib, pkgs, ... }:
        let
          cfg = config.programs.wizardry;
        in
        {
          options.programs.wizardry = {
            enable = lib.mkEnableOption "wizardry shell scripts";
            
            package = lib.mkOption {
              type = lib.types.package;
              default = self.packages.${pkgs.system}.wizardry;
              description = "The wizardry package to use.";
            };
          };
          
          config = lib.mkIf cfg.enable {
            environment.systemPackages = [ cfg.package ];
            
            environment.sessionVariables = {
              WIZARDRY_ROOT = "${cfg.package}/share/wizardry";
            };
            
            environment.shellInit = ''
              source "${cfg.package}/share/wizardry/setup.sh"
            '';
          };
        };
    };
}
FLAKE_EOF

        if [ -f "$flake_path" ]; then
                success_msg "Generated flake.nix in $ABS_DIR for declarative NixOS installation"
                substep_msg "Use 'nix develop $ABS_DIR' to try wizardry"
                substep_msg "Or add to your flake inputs for permanent installation"
        fi
}

# Detect installation status for better user messaging
detect_installation_status
install_status=$?

case $install_status in
        0)
                install_mode="fresh"
                ;;
        1)
                install_mode="repair"
                ;;
        2)
                install_mode="detected"
                ;;
        *)
                install_mode="fresh"
                ;;
esac

# Collect the directories whose PATH exports are absent from the chosen start-up
# file so we can repair them in one pass.
set --
for rel in $REQUIRED_REL_DIRS
do
        dir="$ABS_DIR/$rel"

        if [ ! -d "$dir" ]; then
                printf '%s\n' "Warning: Expected directory '$dir' is missing; skipping." >&2
                continue
        fi

        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS status "$dir"; then
                continue
        fi
        set -- "$@" "$dir"
done

if [ "$#" -eq 0 ]; then
        # Wizardry is already installed - offer options via simple text menu
        printf '\n'
        info_msg "Wizardry is already installed at: $ABS_DIR"
        printf '\n'
        printf '%sWhat would you like to do?%s\n' "$BOLD" "$RESET"
        printf '  1) %sRepair%s - Fix PATH configuration if needed\n' "$CYAN" "$RESET"
        printf '  2) %sReinstall%s - Reinstall wizardry (keeps current location)\n' "$CYAN" "$RESET"
        printf '  3) %sUninstall%s - Remove wizardry from your system\n' "$CYAN" "$RESET"
        printf '  4) %sExit%s - Do nothing and exit\n' "$CYAN" "$RESET"
        printf '\n'
        
        # Read user choice
        # Check if we can read input (tty or pipe)
        if [ -t 0 ] || [ -p /dev/stdin ]; then
                printf '%sEnter your choice (1-4): %s' "$BOLD" "$RESET" >&2
                IFS= read -r choice
        else
                # Non-interactive mode - default to exit
                if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
                        # In automated mode with ASSUME_YES, default to repair
                        choice="1"
                        printf '%s\n' "Non-interactive mode: defaulting to repair (option 1)"
                else
                        printf '%s\n' "Wizardry is already installed. Run 'menu' or 'mud' to use it."
                        exit 0
                fi
        fi
        
        case $choice in
                1)
                        # Repair - continue with normal flow to check/fix PATH
                        info_msg "Repairing wizardry installation..."
                        # Force re-add all paths even if they appear present
                        set -- "$ABS_DIR/spells"
                        ;;
                2)
                        # Reinstall - continue with normal installation flow
                        info_msg "Reinstalling wizardry..."
                        set -- "$ABS_DIR/spells"
                        ;;
                3)
                        # Uninstall - use the uninstall script from the existing installation
                        uninstall_script="$ABS_DIR/uninstall_wizardry"
                        if [ -x "$uninstall_script" ]; then
                                exec "$uninstall_script"
                        else
                                printf '%s\n' "Error: uninstall script not found at '$uninstall_script'." >&2
                                printf '%s\n' "The uninstall script is created during installation." >&2
                                printf '%s\n' "You may need to manually remove '$ABS_DIR' and PATH entries from your shell configuration." >&2
                                exit 1
                        fi
                        ;;
                4|"")
                        # Exit (empty input also exits)
                        printf '%s\n' "No changes made. Run 'menu' or 'mud' to use wizardry."
                        exit 0
                        ;;
                *)
                        # Invalid choice - treat as exit
                        printf '%s\n' "Invalid choice. No changes made."
                        exit 0
                        ;;
        esac
fi

# Inform user about installation mode
if [ "$install_mode" = "repair" ]; then
        info_msg "Adding missing PATH configuration for existing wizardry installation"
fi

# Detect the rc file and format before prompting so we can give specific guidance
detect_rc_file_value=""
detect_format_value=""
detect_platform_value=""
if detect_output="$($DETECT_RC_FILE 2>/dev/null)"; then
        while IFS='=' read -r key value; do
                case $key in
                rc_file)
                        detect_rc_file_value=$value
                        ;;
                format)
                        detect_format_value=$value
                        ;;
                platform)
                        detect_platform_value=$value
                        ;;
                esac
        done <<EOF
$detect_output
EOF
fi

# On NixOS, if no nix config was found (format is shell), prompt for the config path
# since NixOS systems always have a configuration.nix somewhere
if [ "$detect_platform_value" = "nixos" ] && [ "$detect_format_value" = "shell" ]; then
        info_msg "NixOS detected but no configuration file found at standard paths"
        substep_msg "Checked: /etc/nixos/configuration.nix"
        substep_msg "Checked: ~/.config/home-manager/home.nix"
        substep_msg "Checked: ~/.config/nixpkgs/home.nix"
        printf '\n'
        
        # Check if we have input available (either terminal or piped/redirected)
        # Respect ASK_CANTRIP_INPUT=none to disable interactive prompts
        if [ "${ASK_CANTRIP_INPUT-}" = "none" ]; then
                printf '%s\n' "Error: No NixOS configuration file found and no interactive input available." >&2
                printf '%s\n' "Set NIXOS_CONFIG environment variable to specify the configuration file path." >&2
                exit 1
        fi
        
        printf '%s' "Enter the path to your configuration.nix: " >&2
        IFS= read -r user_nix_config
        
        if [ -n "$user_nix_config" ]; then
                # Expand ~/ patterns. Note: ~user/ patterns are not supported;
                # users should provide absolute paths or use ~/ for their home.
                case $user_nix_config in
                        ~/*)
                                user_nix_config=$HOME/${user_nix_config#\~/}
                                ;;
                esac
                
                # Normalize paths that look like absolute paths but are missing
                # the leading slash (e.g., "etc/nixos/configuration.nix").
                case $user_nix_config in
                        /*)
                                # Already absolute path
                                :
                                ;;
                        [Hh]ome/*|[Ee]tc/*|[Uu]sers/*|[Uu]sr/*|[Oo]pt/*|[Vv]ar/*|[Nn]ix/*)
                                # Looks like an absolute path missing the leading slash
                                user_nix_config="/$user_nix_config"
                                ;;
                esac
                
                if [ -f "$user_nix_config" ]; then
                        detect_rc_file_value=$user_nix_config
                        detect_format_value=nix
                        # Export for path-wizard to use
                        NIXOS_CONFIG=$user_nix_config
                        export NIXOS_CONFIG
                        success_msg "Using configuration file: $user_nix_config"
                else
                        printf '%s\n' "Error: File not found: $user_nix_config" >&2
                        exit 1
                fi
        else
                printf '%s\n' "Error: NixOS requires a configuration file path." >&2
                exit 1
        fi
fi

section_msg "Installation Plan"

# Count how many directories will be added (for recursion display)
total_path_additions=0
if [ "$PATH_WIZARD_FLAGS" = "--recursive" ]; then
        for dir
        do
                if [ -d "$dir" ]; then
                        subdir_count=$(find "$dir" -type d 2>/dev/null | wc -l)
                        total_path_additions=$((total_path_additions + subdir_count))
                fi
        done
else
        total_path_additions=$#
fi

info_msg "Will add $total_path_additions directories to your PATH"
for dir
do
        substep_msg "$dir"
        if [ "$PATH_WIZARD_FLAGS" = "--recursive" ]; then
                substep_msg "  (and all subdirectories)"
        fi
done

# Provide format-specific information about what file will be modified
printf '\n'
nix_flakes_consent=0
if [ "$detect_format_value" = "nix" ]; then
        info_msg "NixOS Configuration"
        substep_msg "Configuration file to be modified:"
        if [ -n "$detect_rc_file_value" ]; then
                printf '      %s\n' "$detect_rc_file_value"
        else
                printf '      (could not determine configuration file)\n'
        fi
        substep_msg "Backup: A timestamped backup will be created automatically"
        substep_msg "After install: The installer will run 'sudo nixos-rebuild switch' or 'home-manager switch'"
        
        # Check if flakes are already enabled
        flakes_already_enabled=0
        if [ -n "$detect_rc_file_value" ] && [ -f "$detect_rc_file_value" ]; then
                if grep -q 'experimental-features' "$detect_rc_file_value" 2>/dev/null; then
                        if grep -qE '("|'\''| )flakes("|'\''| |])' "$detect_rc_file_value" 2>/dev/null; then
                                flakes_already_enabled=1
                        fi
                fi
        fi
        
        # If flakes not enabled, ask user if we should enable them (separate prompt)
        if [ "$flakes_already_enabled" -eq 0 ]; then
                printf '\n'
                info_msg "Flakes are not currently enabled in your NixOS configuration"
                substep_msg "Wizardry works best with Nix flakes enabled"
                substep_msg "This will add: nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];"
                printf '\n'
                
                if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
                        nix_flakes_consent=1
                elif [ -t 0 ] || [ -p /dev/stdin ]; then
                        # Can read from tty or piped input
                        printf '%sMay we enable flakes in your configuration.nix? [Y/n] %s' "$BOLD" "$RESET" >&2
                        IFS= read -r flakes_answer
                        case $flakes_answer in
                                n|N|no|NO)
                                        nix_flakes_consent=0
                                        substep_msg "Skipping flakes enablement (you can enable manually later)"
                                        ;;
                                *)
                                        nix_flakes_consent=1
                                        substep_msg "Will enable flakes during installation"
                                        ;;
                        esac
                else
                        # Non-interactive with no input: default to enabling flakes
                        nix_flakes_consent=1
                fi
        else
                substep_msg "Flakes are already enabled in your configuration"
        fi
elif [ -n "$detect_rc_file_value" ]; then
        info_msg "Shell configuration to be modified: $detect_rc_file_value"
fi

# Confirm with the user (or their automation) before editing their configuration.
# When stdin is not interactive we fall back to the non-blocking ASK_CANTRIP_INPUT=none
# pathway so wget|sh installs do not hang.
proceed=0
printf '\n'
if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
        proceed=1
else
        if [ ! -t 0 ] && [ -z "${ASK_CANTRIP_INPUT-}" ]; then
                if ASK_CANTRIP_INPUT=none "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        else
                if "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        fi
fi

if [ "$proceed" -ne 1 ]; then
        printf '%s\n' "Installation cancelled."
        exit 1
fi

# Install core prerequisites now that user has confirmed and seen the plan
# This is where we might ask for sudo on some platforms, so it comes after showing the plan
if [ -x "$CORE_INSTALLER" ]; then
        section_msg "Checking Core Prerequisites"
        
        # Show what we're checking with a sublist
        info_msg "Verifying required tools:"
        
        # Check and display status of each core dependency
        # List common prerequisites
        prereq_git_ok=0
        prereq_tar_ok=0
        prereq_curl_wget_ok=0
        
        if command -v git >/dev/null 2>&1; then
                prereq_git_ok=1
                substep_msg "git: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "git: ${YELLOW}not found (will attempt install)${RESET}"
        fi
        
        if command -v tar >/dev/null 2>&1; then
                prereq_tar_ok=1
                substep_msg "tar: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "tar: ${RED}✗ missing (required)${RESET}"
        fi
        
        if command -v curl >/dev/null 2>&1; then
                prereq_curl_wget_ok=1
                substep_msg "curl: ${GREEN}✓ installed${RESET}"
        elif command -v wget >/dev/null 2>&1; then
                prereq_curl_wget_ok=1
                substep_msg "wget: ${GREEN}✓ installed${RESET}"
        else
                substep_msg "curl/wget: ${YELLOW}neither found (needed for remote downloads)${RESET}"
        fi
        
        # Platform-specific checks
        case $(uname -s 2>/dev/null) in
                Darwin)
                        # macOS specific
                        if command -v stty >/dev/null 2>&1; then
                                substep_msg "stty: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "stty: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        if command -v tput >/dev/null 2>&1; then
                                substep_msg "tput: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "tput: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        ;;
                *)
                        # Linux
                        if command -v bwrap >/dev/null 2>&1; then
                                substep_msg "bubblewrap: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "bubblewrap: ${YELLOW}not found (optional, for test sandboxing)${RESET}"
                        fi
                        if command -v stty >/dev/null 2>&1; then
                                substep_msg "stty: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "stty: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        if command -v tput >/dev/null 2>&1; then
                                substep_msg "tput: ${GREEN}✓ installed${RESET}"
                        else
                                substep_msg "tput: ${YELLOW}not found (will attempt install)${RESET}"
                        fi
                        ;;
        esac
        
        printf '\n'
        # Run core installer - it returns success even if some optional deps fail
        ASSUME_YES=1 "$CORE_INSTALLER" >/dev/null 2>&1 || true
        success_msg "Core prerequisites verified"
fi

section_msg "Updating PATH"

# Export flakes consent for NixOS path-wizard
if [ "$nix_flakes_consent" -eq 1 ]; then
        WIZARDRY_NIX_FLAKES_CONSENT=1
else
        WIZARDRY_NIX_FLAKES_CONSENT=0
fi
export WIZARDRY_NIX_FLAKES_CONSENT

path_updates_made=0
for dir
do
        path_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-path.XXXXXX") || exit 1
        info_msg "Adding $dir to PATH..."
        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS add "$dir" >"$path_log" 2>&1; then
                path_updates_made=1
                success_msg "Added to PATH"
        else
                cat "$path_log" >&2
                rm -f "$path_log"
                exit 1
        fi
        rm -f "$path_log"
done

if [ "$path_updates_made" -eq 1 ]; then
        if [ -n "$detect_rc_file_value" ]; then
                rc_destination=$(printf "'%s'" "$detect_rc_file_value")
        else
                rc_destination="your shell configuration file"
        fi

        success_msg "PATH configuration updated in $rc_destination"

        if [ "$detect_format_value" = "nix" ]; then
                # On NixOS, attempt to run nixos-rebuild or home-manager switch
                info_msg "Attempting to rebuild NixOS configuration..."

                rebuild_success=0
                # Try to detect if we should use sudo or doas
                priv_cmd=""
                if command -v sudo >/dev/null 2>&1; then
                        priv_cmd="sudo"
                elif command -v doas >/dev/null 2>&1; then
                        priv_cmd="doas"
                fi

                # Try home-manager first (doesn't need privileges)
                if command -v home-manager >/dev/null 2>&1; then
                        info_msg "Running 'home-manager switch'..."
                        if home-manager switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                        fi
                fi

                # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
                if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
                        info_msg "Running '$priv_cmd nixos-rebuild switch'..."
                        if $priv_cmd nixos-rebuild switch; then
                                success_msg "NixOS environment rebuilt successfully"
                                rebuild_success=1
                        fi
                fi

                if [ "$rebuild_success" -eq 0 ]; then
                        printf '%sNote:%s Could not automatically rebuild NixOS configuration.\n' "$YELLOW" "$RESET"
                        printf 'Please run one of these commands manually:\n'
                        printf '  home-manager switch  (for home-manager users)\n'
                        printf '  sudo nixos-rebuild switch  (for system-level configuration)\n'
                fi

                # Generate flake.nix in the wizardry directory for declarative NixOS usage
                generate_flake_nix
        else
                printf 'Wizardry directories recorded in %s. Open a new shell or source the file to activate them.\n' "$rc_destination"
        fi
fi

# Memorizing spells pre-compiles wizardry's menus so interactive commands are
# ready before the user opens their first shell inside the new install.
mem_status=0
if [ -x "$MEMORIZE" ]; then
        section_msg "Memorizing Spells"
        mem_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-memorize.XXXXXX") || exit 1
        if "$MEMORIZE" --recursive "$ABS_DIR/spells" >"$mem_log" 2>&1; then
                # Parse output to extract counts without the "skipped" message
                memorized_count=$(grep -o 'Memorized [0-9]* spell' "$mem_log" | grep -o '[0-9]*' | head -1)
                if [ -n "$memorized_count" ] && [ "$memorized_count" -gt 0 ]; then
                        success_msg "Memorized $memorized_count spell(s)"
                fi
        else
                mem_status=$?
                cat "$mem_log" >&2 || true
        fi
        rm -f "$mem_log"
else
        printf '%sWarning:%s memorize spell is missing; skipping automatic memorization.\n' "$YELLOW" "$RESET" >&2
fi

# Create uninstall script
create_uninstall_script() {
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="$ABS_DIR"
        uninstall_script="$script_dir/uninstall_wizardry"

        cat >"$uninstall_script" <<'UNINSTALL_EOF'
#!/bin/sh

# Wizardry Uninstall Script
# This script was automatically generated during installation.
# It will reverse all changes made by the install script.

set -eu

UNINSTALL_EOF

        # Add variables for the installation
        cat >>"$uninstall_script" <<UNINSTALL_VARS
INSTALL_DIR="$ABS_DIR"
INSTALL_WAS_LOCAL="$LOCAL_SOURCE"
RC_FILE="$detect_rc_file_value"
RC_FORMAT="$detect_format_value"

UNINSTALL_VARS

        cat >>"$uninstall_script" <<'UNINSTALL_MAIN'
# Inline color definitions (consistent with install script)
ESC=$(printf '\033')
RESET="${ESC}[0m"
RED="${ESC}[31m"
YELLOW="${ESC}[33m"
GREEN="${ESC}[32m"
BOLD="${ESC}[1m"
CYAN="${ESC}[36m"

# Disable colors if stdout is not a terminal or NO_COLOR is set
if [ ! -t 1 ]; then
        RESET='' RED='' YELLOW='' GREEN='' BOLD='' CYAN=''
elif [ -n "${NO_COLOR-}" ]; then
        RESET='' RED='' YELLOW='' GREEN='' BOLD='' CYAN=''
fi

printf '\n%s===== Wizardry Uninstall =====%s\n\n' "$BOLD$CYAN" "$RESET"
printf '%sThis will remove wizardry from your system:%s\n' "$YELLOW" "$RESET"
printf '  - Remove PATH entries from %s\n' "$RC_FILE"
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '  - Delete wizardry directory: %s\n' "$INSTALL_DIR"
else
        printf '  - Keep wizardry directory (local source installation)\n'
fi
printf '\n'

# Ask for confirmation
printf '%sDo you want to proceed?%s [y/N] ' "$BOLD" "$RESET"
read -r answer
case $answer in
        y|Y|yes|YES)
                : # Continue
                ;;
        *)
                printf 'Uninstall cancelled.\n'
                exit 0
                ;;
esac

printf '\n%s==> Removing PATH entries...%s\n' "$CYAN" "$RESET"

# Use path-wizard to remove PATH entries
PATH_WIZARD="$INSTALL_DIR/spells/system/path-wizard"
if [ -x "$PATH_WIZARD" ]; then
        for dir in "$INSTALL_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                if "$PATH_WIZARD" --recursive remove "$dir" 2>/dev/null; then
                        printf '  %s✓%s Removed %s\n' "$GREEN" "$RESET" "$dir"
                fi
        done
        # Also try removing the main spells directory
        if "$PATH_WIZARD" remove "$INSTALL_DIR/spells" 2>/dev/null; then
                printf '  %s✓%s Removed %s\n' "$GREEN" "$RESET" "$INSTALL_DIR/spells"
        fi
else
        printf '  %sWarning:%s Could not find path-wizard; manual PATH cleanup may be needed\n' "$YELLOW" "$RESET"
fi

# Remove wizardry directory if it was downloaded (not local source)
if [ -z "$INSTALL_WAS_LOCAL" ]; then
        printf '\n%s==> Removing wizardry directory...%s\n' "$CYAN" "$RESET"
        if [ -d "$INSTALL_DIR" ]; then
                if rm -rf "$INSTALL_DIR"; then
                        printf '  %s✓%s Deleted %s\n' "$GREEN" "$RESET" "$INSTALL_DIR"
                else
                        printf '  %sError:%s Could not delete %s\n' "$RED" "$RESET" "$INSTALL_DIR"
                        exit 1
                fi
        fi
fi

printf '\n%s✓ Wizardry uninstalled successfully%s\n' "$BOLD$GREEN" "$RESET"
printf 'You may need to restart your shell or source your configuration file.\n\n'

# Self-destruct - safely remove the uninstall script itself
SELF_DIR="$(cd "$(dirname "$0")" 2>/dev/null && pwd)" || SELF_DIR="."
SELF_NAME="$(basename "$0")"
if [ -n "$SELF_DIR" ] && [ -n "$SELF_NAME" ]; then
        rm -f "$SELF_DIR/$SELF_NAME"
fi
UNINSTALL_MAIN

        chmod +x "$uninstall_script"
        return 0
}

if create_uninstall_script; then
        script_dir=$(CDPATH='' cd -- "$(dirname "$0")" 2>/dev/null && pwd -P) || script_dir="."
        success_msg "Uninstall script created at: $script_dir/uninstall_wizardry"
fi

printf '\n'
section_msg "Installation Complete!"
success_msg "Wizardry has been successfully installed"
printf '\n%sNext steps:%s\n' "$BOLD" "$RESET"
if [ "$detect_format_value" = "nix" ]; then
        printf '  1. Your NixOS configuration has been updated (using flakes)\n'
        printf '  2. A flake.nix file has been generated in the wizardry directory\n'
        printf '  3. Run %smenu%s or %smud%s to start using wizardry\n' "$CYAN" "$RESET" "$CYAN" "$RESET"
else
        printf '  1. Open a fresh terminal or run: %ssource %s%s\n' "$CYAN" "$detect_rc_file_value" "$RESET"
        printf '  2. Run %smenu%s or %smud%s to start using wizardry\n' "$CYAN" "$RESET" "$CYAN" "$RESET"
fi
printf '  4. To uninstall, run: %s./install --uninstall%s\n' "$CYAN" "$RESET"
printf '\n'

exit "$mem_status"
