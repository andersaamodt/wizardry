#!/bin/sh

# Abort if unexpected arguments are supplied so we do not accidentally discard
# them when repurposing the positional parameters to track missing directories.
if [ "$#" -ne 0 ]; then
        printf '%s\n' "Usage: install" >&2
        exit 1
fi

# Disable CDPATH so that "cd" behaves predictably even if the user has a
# custom search path configured in their environment.  This keeps the script
# portable across login shells that set CDPATH to multiple directories.
unset CDPATH

REQUIRED_REL_DIRS="spells"

# Determine the default target directory shown in the install prompt. The
# installer accepts three environment variables to steer non-interactive
# installs:
#   * WIZARDRY_INSTALL_DIR – fully overrides the prompt and is used directly.
#   * WIZARDRY_ROOT        – legacy alias used as an override if set.
#   * WIZARDRY_REMOTE_DIR  – retained for backwards compatibility; becomes the
#                            prompt default when present.
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_ROOT
elif [ -n "${WIZARDRY_REMOTE_DIR-}" ]; then
        PROMPT_DEFAULT=$WIZARDRY_REMOTE_DIR
elif [ -n "${HOME-}" ]; then
        PROMPT_DEFAULT=$HOME/.wizardry
else
        PROMPT_DEFAULT=.wizardry
fi

# Validate and normalize PROMPT_DEFAULT to prevent path construction issues.
# Environment variables should provide absolute paths, but we handle relative
# paths defensively. If a relative path looks like it's missing a leading slash
# (e.g., starts with "home/"), we treat it as absolute.
case $PROMPT_DEFAULT in
        /*)
                # Already absolute path, no normalization needed
                :
                ;;
        home/*|Users/*|usr/*|opt/*|var/*|tmp/*)
                # Looks like an absolute path missing the leading slash
                # This handles cases where environment variables are set incorrectly
                PROMPT_DEFAULT="/$PROMPT_DEFAULT"
                ;;
        *)
                # Other relative paths: resolve relative to HOME if possible
                if [ -n "${HOME-}" ]; then
                        # Convert relative to absolute by prepending HOME
                        PROMPT_DEFAULT=$HOME/$PROMPT_DEFAULT
                else
                        # No HOME set and relative path given - use current directory
                        cwd=$(pwd -P)
                        PROMPT_DEFAULT=$cwd/$PROMPT_DEFAULT
                fi
                ;;
esac

if [ -n "${WIZARDRY_INSTALL_PLATFORM-}" ]; then
        PATH_WIZARD_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        DETECT_RC_FILE_PLATFORM=$WIZARDRY_INSTALL_PLATFORM
        export PATH_WIZARD_PLATFORM DETECT_RC_FILE_PLATFORM
fi

# Track whether we are running out of an existing checkout so local installs
# can simply copy the files instead of downloading a fresh archive.  Piped
# installs (wget|sh) expose the script through /bin/sh so we only find a
# checkout when this file is run directly from disk.
LOCAL_SOURCE=""
case $0 in
        */*)
                script_dir=${0%/*}
                if [ -z "$script_dir" ]; then
                        script_dir=.
                fi
                if script_dir_abs=$(cd "$script_dir" 2>/dev/null && pwd -P); then
                        if [ -d "$script_dir_abs/spells" ]; then
                                LOCAL_SOURCE=$script_dir_abs
                        fi
                fi
                ;;
        *)
                if [ -n "${PWD-}" ] && [ -f "$PWD/$0" ]; then
                        if script_dir_abs=$(cd "$PWD" 2>/dev/null && pwd -P); then
                                if [ -d "$script_dir_abs/spells" ]; then
                                        LOCAL_SOURCE=$script_dir_abs
                                fi
                        fi
                fi
                ;;
esac

cleanup_bootstrap() {
        # Clean up any temporary directory created during the download process.
        if [ -n "${BOOTSTRAP_TMP_DIR-}" ] && [ -d "$BOOTSTRAP_TMP_DIR" ]; then
                rm -rf "$BOOTSTRAP_TMP_DIR"
        fi
}

# Remote installs create a throwaway working directory; trap its cleanup so
# shells on every platform remove the temporary files even if the install
# process exits early.
trap 'cleanup_bootstrap' EXIT HUP INT TERM

download_file() {
        # Fetch a remote archive using curl or wget, whichever is available on the
        # host platform.  Some of our supported OS images only ship one of the two
        # tools by default, so we try both before giving up.
        dest=$1
        url=$2
        if command -v curl >/dev/null 2>&1; then
                if curl -fsSL "$url" -o "$dest"; then
                        return 0
                fi
        fi
        if command -v wget >/dev/null 2>&1; then
                if wget -qO "$dest" "$url"; then
                        return 0
                fi
        fi
        printf '%s\n' "Error: Neither curl nor wget is available to download wizardry." >&2
        return 1
}

INSTALL_INPUT=""
if [ -n "${WIZARDRY_INSTALL_DIR-}" ]; then
        INSTALL_INPUT=$WIZARDRY_INSTALL_DIR
elif [ -n "${WIZARDRY_ROOT-}" ]; then
        INSTALL_INPUT=$WIZARDRY_ROOT
else
        message="Where should wizardry be installed? [$PROMPT_DEFAULT] "
        if [ -t 0 ]; then
                # Print the prompt to stderr so the question is visible even if stdout is
                # captured inside a subshell.
                printf '%s' "$message" >&2
                IFS= read -r INSTALL_INPUT
        else
                printf '%s\n' "Info: No interactive input detected; using '$PROMPT_DEFAULT'." >&2
        fi
fi

if [ -z "$INSTALL_INPUT" ]; then
        INSTALL_INPUT=$PROMPT_DEFAULT
fi

case $INSTALL_INPUT in
        ~)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME
                ;;
        ~/*)
                if [ -z "${HOME-}" ]; then
                        printf '%s\n' "Error: HOME is not set; cannot expand '~'." >&2
                        exit 1
                fi
                INSTALL_INPUT=$HOME/${INSTALL_INPUT#\~/}
                ;;
esac

case $INSTALL_INPUT in
        /*)
                INSTALL_DIR=$INSTALL_INPUT
                ;;
        *)
                cwd=$(pwd -P)
                INSTALL_DIR=$cwd/$INSTALL_INPUT
                ;;
esac

if [ -d "$INSTALL_DIR/spells" ]; then
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
else
        if [ -e "$INSTALL_DIR" ]; then
                printf '%s\n' "Error: '$INSTALL_DIR' already exists but does not look like wizardry." >&2
                exit 1
        fi
        parent=${INSTALL_DIR%/*}
        if [ "$parent" = "$INSTALL_DIR" ]; then
                parent=.
        fi
        if ! mkdir -p "$parent"; then
                printf '%s\n' "Error: Unable to create directory '$parent'." >&2
                exit 1
        fi
        if [ -n "$LOCAL_SOURCE" ]; then
                printf '%s\n' "Copying wizardry from '$LOCAL_SOURCE' to '$INSTALL_DIR'..."
                if ! cp -R "$LOCAL_SOURCE" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to copy wizardry from '$LOCAL_SOURCE'." >&2
                        exit 1
                fi
        else
                # We need to bootstrap wizardry by downloading a tarball.  Each supported
                # platform provides tar, but some only ship curl or wget, so the
                # download_file helper above checks both before failing.
                archive_url=${WIZARDRY_REMOTE_ARCHIVE-https://github.com/andersaamodt/wizardry/archive/refs/heads/main.tar.gz}
                if ! command -v tar >/dev/null 2>&1; then
                        printf '%s\n' "Error: tar is required to unpack wizardry when installing remotely." >&2
                        exit 1
                fi
                BOOTSTRAP_TMP_DIR=$(mktemp -d "${TMPDIR:-/tmp}/wizardry-install.XXXXXX") || exit 1
                archive="$BOOTSTRAP_TMP_DIR/wizardry.tar.gz"
                printf '%s\n' "Downloading wizardry to '$INSTALL_DIR'..."
                if ! download_file "$archive" "$archive_url"; then
                        exit 1
                fi
                if ! tar -xzf "$archive" -C "$BOOTSTRAP_TMP_DIR"; then
                        printf '%s\n' "Error: Failed to unpack wizardry archive." >&2
                        exit 1
                fi
                extracted=""
                for candidate in "$BOOTSTRAP_TMP_DIR"/*; do
                        if [ -d "$candidate/spells" ]; then
                                extracted=$candidate
                                break
                        fi
                done
                if [ -z "$extracted" ]; then
                        printf '%s\n' "Error: Downloaded archive did not contain wizardry spells." >&2
                        exit 1
                fi
                if ! mv "$extracted" "$INSTALL_DIR"; then
                        printf '%s\n' "Error: Unable to move wizardry into '$INSTALL_DIR'." >&2
                        exit 1
                fi
                printf '%s\n' "Wizardry downloaded to '$INSTALL_DIR'."
        fi
        ABS_DIR=$(cd "$INSTALL_DIR" && pwd -P)
fi

# Now that the wizardry tree is available, point at the helper spells we rely
# on to update PATH entries and ask for confirmation.
PATH_WIZARD="$ABS_DIR/spells/translocation/path-wizard"
DETECT_RC_FILE="$ABS_DIR/spells/divination/detect-rc-file"
MEMORIZE="$ABS_DIR/spells/spellcraft/memorize"
CORE_INSTALLER=${WIZARDRY_CORE_INSTALLER:-$ABS_DIR/spells/install/core/install-core}
ASK_YN="$ABS_DIR/spells/cantrips/ask_yn"
PATH_WIZARD_FLAGS=${PATH_WIZARD_FLAGS:---recursive}

# Export environment variables for all helper spells so that they use the new
# versions being installed, not any old versions that may be in PATH.
# This prevents issues where a user has an old wizardry installation in PATH.
SCRIBE_SPELL="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_SCRIBE="$ABS_DIR/spells/spellcraft/scribe-spell"
MEMORIZE_COMMAND_HELPER="$ABS_DIR/spells/cantrips/memorize-command"
export DETECT_RC_FILE SCRIBE_SPELL MEMORIZE_SCRIBE MEMORIZE_COMMAND_HELPER

if [ ! -x "$PATH_WIZARD" ]; then
        printf '%s\n' "Error: Expected helper '$PATH_WIZARD' is missing or not executable." >&2
        exit 1
fi

if [ ! -x "$DETECT_RC_FILE" ]; then
        printf '%s\n' "Error: Required helper '$DETECT_RC_FILE' is missing." >&2
        exit 1
fi

if [ ! -x "$ASK_YN" ]; then
        printf '%s\n' "Error: Required cantrip '$ASK_YN' is missing." >&2
        exit 1
fi

if [ -x "$CORE_INSTALLER" ]; then
        printf '%s\n' "Ensuring core prerequisites are installed..."
        if ! ASSUME_YES=1 "$CORE_INSTALLER"; then
                printf '%s\n' "Warning: Unable to install all core prerequisites automatically. Please install them manually." >&2
        fi
else
        printf '%s\n' "Warning: Core installer not found at '$CORE_INSTALLER'; skipping core prerequisite setup." >&2
fi

# Perform comprehensive installation detection across all RC files
# This checks multiple RC files to see if wizardry is installed anywhere
detect_installation_status() {
        # Check common RC files for wizardry paths
        rc_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $HOME/.zshrc $HOME/.zprofile $HOME/.config/nixpkgs/configuration.nix"
        
        found_in_any_rc=0
        for rc_file in $rc_files; do
                if [ -f "$rc_file" ]; then
                        if grep -q "$ABS_DIR" "$rc_file" 2>/dev/null; then
                                found_in_any_rc=1
                                break
                        fi
                fi
        done
        
        # Check if spells directory exists
        spells_exist=0
        if [ -d "$ABS_DIR/spells" ]; then
                spells_exist=1
        fi
        
        # Return status: 0=not installed, 1=partially installed, 2=fully installed
        if [ "$found_in_any_rc" -eq 0 ] && [ "$spells_exist" -eq 0 ]; then
                return 0  # Not installed
        elif [ "$found_in_any_rc" -eq 1 ] && [ "$spells_exist" -eq 1 ]; then
                return 2  # Fully installed
        else
                return 1  # Partially installed (needs repair)
        fi
}

# Detect installation status for better user messaging
detect_installation_status
install_status=$?

case $install_status in
        0)
                install_mode="fresh"
                ;;
        1)
                install_mode="repair"
                ;;
        2)
                install_mode="detected"
                ;;
        *)
                install_mode="fresh"
                ;;
esac

# Collect the directories whose PATH exports are absent from the chosen start-up
# file so we can repair them in one pass.
set --
for rel in $REQUIRED_REL_DIRS
do
        dir="$ABS_DIR/$rel"

        if [ ! -d "$dir" ]; then
                printf '%s\n' "Warning: Expected directory '$dir' is missing; skipping." >&2
                continue
        fi

        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS status "$dir"; then
                continue
        fi
        set -- "$@" "$dir"
done

if [ "$#" -eq 0 ]; then
        printf '%s\n' "Wizardry is already installed. Run it with 'menu' or 'mud'."
        exit 0
fi

# Inform user about installation mode
if [ "$install_mode" = "repair" ]; then
        printf '%s\n' "Detected incomplete wizardry installation. Repairing..."
fi

# Detect the rc file and format before prompting so we can give specific guidance
detect_rc_file_value=""
detect_format_value=""
if detect_output="$($DETECT_RC_FILE 2>/dev/null)"; then
        while IFS='=' read -r key value; do
                case $key in
                rc_file)
                        detect_rc_file_value=$value
                        ;;
                format)
                        detect_format_value=$value
                        ;;
                esac
        done <<EOF
$detect_output
EOF
fi

printf '%s\n' "Wizardry will ensure the following directories appear in your PATH:"
for dir
do
        printf '  %s\n' "$dir"
done

# Provide format-specific information about what file will be modified
if [ "$detect_format_value" = "nix" ]; then
        printf '\n'
        printf '%s\n' "On NixOS, wizardry will modify your configuration file:"
        if [ -n "$detect_rc_file_value" ]; then
                printf '  %s\n' "$detect_rc_file_value"
        else
                printf '  %s\n' "~/.config/nixpkgs/configuration.nix"
        fi
        printf '%s\n' ""
        printf '%s\n' "A backup will be created automatically before any changes are made."
        printf '%s\n' "After installation, run 'nixos-rebuild switch' or 'home-manager switch' to activate."
elif [ -n "$detect_rc_file_value" ]; then
        printf '%s\n' "This will be added to: $detect_rc_file_value"
fi

# Confirm with the user (or their automation) before editing their configuration.
# When stdin is not interactive we fall back to the non-blocking ASK_CANTRIP_INPUT=none
# pathway so wget|sh installs do not hang.
proceed=0
if [ "${WIZARDRY_INSTALL_ASSUME_YES-}" = "1" ]; then
        proceed=1
else
        if [ ! -t 0 ] && [ -z "${ASK_CANTRIP_INPUT-}" ]; then
                if ASK_CANTRIP_INPUT=none "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        else
                if "$ASK_YN" "Proceed with installation?" yes >/dev/null; then
                        proceed=1
                fi
        fi
fi

if [ "$proceed" -ne 1 ]; then
        printf '%s\n' "Ok, well wizardry won't work until you install it by adding the spells directory to your PATH."
        exit 1
fi

path_updates_made=0
for dir
do
        path_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-path.XXXXXX") || exit 1
        if "$PATH_WIZARD" $PATH_WIZARD_FLAGS add "$dir" >"$path_log" 2>&1; then
                path_updates_made=1
        else
                cat "$path_log" >&2
                rm -f "$path_log"
                exit 1
        fi
        rm -f "$path_log"
done

if [ "$path_updates_made" -eq 1 ]; then
        if [ -n "$detect_rc_file_value" ]; then
                rc_destination=$(printf "'%s'" "$detect_rc_file_value")
        else
                rc_destination="your shell configuration file"
        fi
        if [ "$detect_format_value" = "nix" ]; then
                printf 'Wizardry directories recorded in %s. Rebuild your Nix environment or restart your shell session to activate them.\n' "$rc_destination"
        else
                printf 'Wizardry directories recorded in %s. Open a new shell or source the file to activate them.\n' "$rc_destination"
        fi
fi

# Memorizing spells pre-compiles wizardry's menus so interactive commands are
# ready before the user opens their first shell inside the new install.
mem_status=0
if [ -x "$MEMORIZE" ]; then
        mem_log=$(mktemp "${TMPDIR:-/tmp}/wizardry-memorize.XXXXXX") || exit 1
        if "$MEMORIZE" --recursive "$ABS_DIR/spells" >"$mem_log" 2>&1; then
                cat "$mem_log"
                printf '%s\n' "Spells memorized successfully."
        else
                mem_status=$?
                cat "$mem_log" >&2 || true
        fi
        rm -f "$mem_log"
else
        printf '%s\n' "Warning: memorize spell is missing; skipping automatic memorization." >&2
fi

printf '%s\n' "Your spellbook has been activated. Open a fresh terminal or source your shell configuration to cast spells everywhere."

exit "$mem_status"
