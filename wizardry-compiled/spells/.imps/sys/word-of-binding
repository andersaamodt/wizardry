#!/bin/sh
#
# ---------------------------- word-of-binding -----------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: word-of-binding
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: word-of-binding
_word_of_binding() {
  if [ $# -eq 0 ]; then
    printf '%s\n' "word-of-binding: command name required" >&2
    return 1
  fi

  _wob_name=$1
  shift

  if [ -z "${WIZARDRY_DIR-}" ]; then
    _wob_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    WIZARDRY_DIR=$(CDPATH= cd -- "$_wob_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi

  # Convert hyphenated name to true-name: clip-copy -> _clip_copy
  _wob_true_name=$(printf '_%s\n' "$_wob_name" | sed 's/-/_/g')

  # Find module file
  _wob_module=""
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _wob_imps_dir="$WIZARDRY_DIR/spells/.imps"
    if [ -d "$_wob_imps_dir" ]; then
      if [ -f "$_wob_imps_dir/$_wob_name" ]; then
        _wob_module="$_wob_imps_dir/$_wob_name"
      else
        for _wob_family_dir in "$_wob_imps_dir"/*; do
          [ -d "$_wob_family_dir" ] || continue
          if [ -f "$_wob_family_dir/$_wob_name" ]; then
            _wob_module="$_wob_family_dir/$_wob_name"
            break
          fi
        done
      fi
    fi
    
    if [ -z "$_wob_module" ]; then
      for _wob_spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_wob_spell_dir" ] || continue
        case "$_wob_spell_dir" in */.imps) continue ;; esac
        if [ -f "$_wob_spell_dir/$_wob_name" ]; then
          _wob_module="$_wob_spell_dir/$_wob_name"
          break
        fi
      done
    fi
  fi
  
  if [ -z "$_wob_module" ]; then
    if [ -n "${SPELLBOOK_DIR-}" ] && [ -d "$SPELLBOOK_DIR" ]; then
      if [ -f "$SPELLBOOK_DIR/$_wob_name" ]; then
        _wob_module="$SPELLBOOK_DIR/$_wob_name"
      fi
    elif [ -n "${HOME-}" ] && [ -d "$HOME/.spellbook" ]; then
      if [ -f "$HOME/.spellbook/$_wob_name" ]; then
        _wob_module="$HOME/.spellbook/$_wob_name"
      fi
    fi
  fi

  if [ -z "$_wob_module" ]; then
    printf '%s\n' "word-of-binding: unknown command '$_wob_name'" >&2
    return 127
  fi

  # Check if module has true-name function (for binding/sourcing)
  if grep -qE "^[[:space:]]*${_wob_true_name}[[:space:]]*\\(\\)" "$_wob_module" 2>/dev/null; then
    # Bind (source) the module to load its function
    # shellcheck disable=SC1090
    . "$_wob_module"
    
    # Create alias for future calls
    alias "$_wob_name=$_wob_true_name" 2>/dev/null || true
    
    if command -v "$_wob_true_name" >/dev/null 2>&1; then
      "$_wob_true_name" "$@"
    else
      printf '%s\n' "word-of-binding: failed to bind '$_wob_name' - function not defined" >&2
      return 1
    fi
  else
    # Evoke (execute) the script directly in a subshell
    "$_wob_module" "$@"
  fi
}

# _word_of_binding NAME [ARGS...] - resolve and invoke a wizardry command by name
# Dispatcher for autoloading missing commands via handle-command-not-found.
# Sources the module and calls its true-name function.

_word_of_binding() {
  if [ $# -eq 0 ]; then
    printf '%s\n' "_word_of_binding: command name required" >&2
    return 1
  fi

  _wob_name=$1
  shift

  if [ -z "${WIZARDRY_DIR-}" ]; then
    _wob_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    WIZARDRY_DIR=$(CDPATH= cd -- "$_wob_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi

  # Convert hyphenated name to true-name: clip-copy -> _clip_copy
  _wob_true_name=$(printf '_%s\n' "$_wob_name" | sed 's/-/_/g')

  # Find module file
  _wob_module=""
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _wob_imps_dir="$WIZARDRY_DIR/spells/.imps"
    if [ -d "$_wob_imps_dir" ]; then
      if [ -f "$_wob_imps_dir/$_wob_name" ]; then
        _wob_module="$_wob_imps_dir/$_wob_name"
      else
        for _wob_family_dir in "$_wob_imps_dir"/*; do
          [ -d "$_wob_family_dir" ] || continue
          if [ -f "$_wob_family_dir/$_wob_name" ]; then
            _wob_module="$_wob_family_dir/$_wob_name"
            break
          fi
        done
      fi
    fi
    
    if [ -z "$_wob_module" ]; then
      for _wob_spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_wob_spell_dir" ] || continue
        case "$_wob_spell_dir" in */.imps) continue ;; esac
        if [ -f "$_wob_spell_dir/$_wob_name" ]; then
          _wob_module="$_wob_spell_dir/$_wob_name"
          break
        fi
      done
    fi
  fi
  
  if [ -z "$_wob_module" ]; then
    if [ -n "${SPELLBOOK_DIR-}" ] && [ -d "$SPELLBOOK_DIR" ]; then
      if [ -f "$SPELLBOOK_DIR/$_wob_name" ]; then
        _wob_module="$SPELLBOOK_DIR/$_wob_name"
      fi
    elif [ -n "${HOME-}" ] && [ -d "$HOME/.spellbook" ]; then
      if [ -f "$HOME/.spellbook/$_wob_name" ]; then
        _wob_module="$HOME/.spellbook/$_wob_name"
      fi
    fi
  fi

  if [ -z "$_wob_module" ]; then
    printf '%s\n' "_word_of_binding: unknown command '$_wob_name'" >&2
    return 127
  fi

  # Check if module has true-name function (for binding/sourcing)
  if grep -qE "^[[:space:]]*${_wob_true_name}[[:space:]]*\\(\\)" "$_wob_module" 2>/dev/null; then
    # Bind (source) the module to load its function
    # shellcheck disable=SC1090
    . "$_wob_module"
    
    # Create alias for future calls
    alias "$_wob_name=$_wob_true_name" 2>/dev/null || true
    
    if command -v "$_wob_true_name" >/dev/null 2>&1; then
      "$_wob_true_name" "$@"
    else
      printf '%s\n' "_word_of_binding: failed to bind '$_wob_name' - function not defined" >&2
      return 1
    fi
  else
    # Evoke (execute) the script directly in a subshell
    "$_wob_module" "$@"
  fi
}

# Self-execute when run directly (not sourced)
case "$0" in
  */_word_of_binding) _word_of_binding "$@" ;; esac
