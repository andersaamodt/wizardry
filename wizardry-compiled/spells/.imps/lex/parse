#!/bin/sh
#
# --------------------------------- parse ----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: parse
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------

# parse CMD... - recursively parse and execute written imperatives
# Scans for linking words (imps in lex/) and delegates to them.
# Longer linking words take precedence (and-then before and or then).

_parse() {
  if [ $# -eq 0 ]; then
    return 0
  fi

  _parse_lex_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)

  if [ $# -ge 2 ]; then
    _parse_two_word="$1-$2"
    if [ -x "$_parse_lex_dir/$_parse_two_word" ] && [ "$_parse_two_word" != "parse" ]; then
      shift 2
      "$_parse_lex_dir/$_parse_two_word" "" "" "$@"
      return $?
    fi
  fi

  _parse_first=$1
  if [ -x "$_parse_lex_dir/$_parse_first" ] && [ "$_parse_first" != "parse" ]; then
    shift
    "$_parse_lex_dir/$_parse_first" "" "" "$@"
    return $?
  fi

  _parse_cmd=$_parse_first
  shift

  if [ $# -eq 0 ]; then
    "$_parse_cmd"
    return $?
  fi

  _parse_total=$#
  _parse_i=1
  for _parse_arg in "$@"; do
    eval "_parse_arg_$_parse_i=\"\$_parse_arg\""
    _parse_i=$((_parse_i + 1))
  done

  _parse_link_pos=0
  _parse_link_len=0
  _parse_link_word=''
  _parse_i=1
  while [ "$_parse_i" -le "$_parse_total" ]; do
    if [ "$_parse_i" -lt "$_parse_total" ]; then
      _parse_j=$((_parse_i + 1))
      eval "_parse_w1=\"\$_parse_arg_$_parse_i\""
      eval "_parse_w2=\"\$_parse_arg_$_parse_j\""
      _parse_two_word="$_parse_w1-$_parse_w2"
      if [ -x "$_parse_lex_dir/$_parse_two_word" ] && [ "$_parse_two_word" != "parse" ]; then
        _parse_link_pos=$_parse_i
        _parse_link_len=2
        _parse_link_word=$_parse_two_word
        break
      fi
    fi
    
    eval "_parse_w=\"\$_parse_arg_$_parse_i\""
    if [ -x "$_parse_lex_dir/$_parse_w" ] && [ "$_parse_w" != "parse" ]; then
      _parse_link_pos=$_parse_i
      _parse_link_len=1
      _parse_link_word=$_parse_w
      break
    fi
    
    _parse_i=$((_parse_i + 1))
  done

  if [ "$_parse_link_pos" -eq 0 ]; then
    set --
    _parse_i=1
    while [ "$_parse_i" -le "$_parse_total" ]; do
      eval "set -- \"\$@\" \"\$_parse_arg_$_parse_i\""
      _parse_i=$((_parse_i + 1))
    done
    "$_parse_cmd" "$@"
    return $?
  fi

  _parse_cmd_args_end=$((_parse_link_pos - 1))
  _parse_cmd_args=''
  _parse_i=1
  while [ "$_parse_i" -le "$_parse_cmd_args_end" ]; do
    eval "_parse_a=\"\$_parse_arg_$_parse_i\""
    if [ -z "$_parse_cmd_args" ]; then
      _parse_cmd_args=$_parse_a
    else
      _parse_cmd_args="$_parse_cmd_args $_parse_a"
    fi
    _parse_i=$((_parse_i + 1))
  done

  _parse_remain_start=$((_parse_link_pos + _parse_link_len))

  set --
  _parse_i=$_parse_remain_start
  while [ "$_parse_i" -le "$_parse_total" ]; do
    eval "set -- \"\$@\" \"\$_parse_arg_$_parse_i\""
    _parse_i=$((_parse_i + 1))
  done

  "$_parse_lex_dir/$_parse_link_word" "$_parse_cmd" "$_parse_cmd_args" "$@"
}

# Self-execute when run directly (not sourced)
case "$0" in
  */parse) _parse "$@" ;; esac
