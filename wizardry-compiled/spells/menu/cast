#!/bin/sh
#
# ---------------------------------- cast ----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: cast
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined imp: has
_has() {
  command -v "$1" >/dev/null 2>&1
}

# Inlined spell: memorize
_memorize() {

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory


spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
	cast_dir=$1
	if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
		file=$(expand_tilde "$WIZARDRY_CAST_FILE")
	elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
		file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
	else
		file=$cast_dir/.memorized
	fi
	printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
	if [ ! -d "$cast_dir" ]; then
		mkdir -p "$cast_dir"
	fi
	dir=${command_file%/*}
	if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_name() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "$spell_name: names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

nonempty() {
	[ -n "$1" ]
}

add_spell() {
	name=$1
	validate_name "$name"
	ensure_parent_directory
	# Memorize just lists existing spells by name - no wrapper scripts needed
	# The spell must already exist in PATH or spellbook
	cmd=$name
	tmp=$(temp-file memorize) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	if [ -f "$command_file" ]; then
		while IFS= read -r line || nonempty "$line"; do
			entry_name=$line
			case $line in
			*"$tab_char"*)
				entry_name=${line%%"$tab_char"*}
				;;
			esac
			if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
				continue
			fi
			printf '%s\n' "$line" >>"$tmp"
		done <"$command_file"
	fi
	printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
	if [ -f "$tmp" ]; then
		cat "$tmp" >>"$command_file"
	fi
	trap - EXIT HUP INT TERM
	rm -f "$tmp"
}

list_entries() {
	if [ -f "$command_file" ]; then
		cat "$command_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1

case $action in
list)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$command_file"
	;;
dir)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$cast_dir"
	;;
--help|--usage|-h)
	show_usage
	;;
-*)
	printf '%s\n' "$spell_name: unknown option '$action'" >&2
	show_usage
	exit 1
	;;
*)
	# Default action: memorize the spell
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "$spell_name: expects exactly one spell name." >&2
		show_usage
		exit 1
	fi
	add_spell "$action"
	;;
esac
}

# This spell casts previously memorized commands from the spellbook.

# Self-healing: Create spellbook directory if missing
create_spellbook_if_missing() {
        spellbook_dir="${XDG_DATA_HOME:-$HOME/.local/share}/wizardry/spellbook"
        if ! [ -d "$spellbook_dir" ]; then
                mkdir -p "$spellbook_dir" 2>/dev/null || {
                        spellbook_dir="${TMPDIR:-/tmp}/wizardry-spellbook-$$"
                        mkdir -p "$spellbook_dir"
                }
        fi
        printf '%s' "$spellbook_dir"
}

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Direct call to _memorize spell (no variable indirection)
if ! _has _memorize; then
        # Fallback: use directory directly
        cast_dir=$(create_spellbook_if_missing)
else
        cast_dir=$(_memorize dir 2>/dev/null) || cast_dir=$(create_spellbook_if_missing)
fi

cast_list() {
        if _has _memorize; then
                _memorize list
        else
                # Fallback: list files directly
                for f in "$cast_dir"/*; do
                        [ -f "$f" ] || continue
                        name=$(basename "$f")
                        cmd=$(cat "$f" 2>/dev/null || printf '')
                        [ -n "$cmd" ] && printf '%s\t%s\n' "$name" "$cmd"
                done
        fi
}

print_empty_message() {
        printf '%s\n' "No spells are available to cast."
        printf '%s\n' "Add spells from the Spellbook menu."
}

spell_menu_loop() {
        first_run=1
        while :
        do
                if [ "$first_run" -eq 0 ]; then
                        printf '\n'
                else
                        first_run=0
                fi

                entries=$(cast_list)
                if [ -z "$entries" ]; then
                        print_empty_message
                        break
                fi
                set --
                while IFS=$(printf '\t') read -r alias command
                do
                        [ -z "$alias" ] && continue
                        # Memorized spells are called directly by name
                        entry_cmd=$command
                        # Label is just the alias; menu shows and executes entry_cmd on the right
                        set -- "$@" "$(printf '%s%%%s' "$alias" "$entry_cmd")"
                done <<SPELLS
$entries
SPELLS
                exit_label=$(_exit_label)
                set -- "$@" "${exit_label}%kill -TERM \$PPID"
                menu "Cast a Spell:" "$@" || true
        done
}

show_usage() {
        cat <<'USAGE'
Usage: cast [--list|--dir]

  --list   Show the stored spells in NAME<TAB>COMMAND format.
  --dir    Print the directory containing cast menu spells.
  --help   Show this help text.

Run without arguments to open the interactive casting menu.
USAGE
}

case ${1-} in
        --list)
                entries=$(cast_list)
                if [ -n "$entries" ]; then
                        printf '%s\n' "$entries"
                fi
                exit 0
                ;;
        --dir)
                printf '%s\n' "$cast_dir"
                exit 0
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                ;;
        "")
                :
                ;;
        *)
                show_usage >&2
                exit 1
                ;;
esac
set -eu

if ! require menu "The casting menu needs the 'menu' command."; then
        exit 1
fi

spell_menu_loop
