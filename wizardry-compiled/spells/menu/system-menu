#!/bin/sh
#
# ------------------------------ system-menu -------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: system-menu
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: detect-distro
_detect_distro() {

# Bootstrap spell: prints a short identifier for the current OS.
# Use -v to narrate detection while exporting DISTRO for callers.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Parse flags for verbose output or help text.
verbose=0
while getopts hv opt
do
        case $opt in
        v)
                verbose=1
                ;;
        h)
                show_usage
                exit 0
                ;;
        *)
                show_usage >&2
                exit 1
                ;;
        esac
done
shift $((OPTIND - 1))

if [ "$#" -ne 0 ]; then
        show_usage >&2
        exit 1
fi

root_prefix=${DETECT_DISTRO_ROOT:-}
os_release_path=${DETECT_DISTRO_OS_RELEASE:-"${root_prefix}/etc/os-release"}
root_prefix=${root_prefix%/}
case $root_prefix in
        /*|'') : ;;
        *) root_prefix=/$root_prefix ;;
esac

os_release_id() {
        if [ ! -f "$os_release_path" ]; then
                return 1
        fi

        awk -F= 'tolower($1) == "id" { gsub(/"/, "", $2); print tolower($2) }' "$os_release_path"
}

detect_uname() {
        if [ -n "${DETECT_DISTRO_UNAME-}" ]; then
                printf '%s' "$DETECT_DISTRO_UNAME"
                return 0
        fi

        if uname >/dev/null 2>&1; then
                uname
        fi
}

file_exists() {
        [ -f "${root_prefix}$1" ]
}

# Detect from specific markers toward the generic uname fallback.
os_id=$(os_release_id || true)

if file_exists "/etc/NIXOS" || [ "${os_id-}" = "nixos" ]; then
        distro='nixos'
elif file_exists "/etc/debian_version"; then
        distro='debian'
elif file_exists "/etc/arch-release"; then
        distro='arch'
elif file_exists "/etc/fedora-release"; then
        distro='fedora'
elif [ "${os_id-}" = "debian" ] || [ "${os_id-}" = "ubuntu" ] || [ "${os_id-}" = "raspbian" ]; then
        distro='debian'
elif [ "${os_id-}" = "arch" ]; then
        distro='arch'
elif [ "${os_id-}" = "fedora" ]; then
        distro='fedora'
else
        kernel_name=$(detect_uname || true)
        if [ "${kernel_name-}" = "Darwin" ]; then
                distro='mac'
        fi
fi

# Export the detection so callers can key off the result.
if [ -n "${distro-}" ]; then
        DISTRO=$distro
        export DISTRO
else
        printf '%s\n' 'unknown'
        exit 1
fi

if [ "$verbose" -eq 1 ]; then
        case $DISTRO in
        debian)
                printf '%s\n' 'Debian, Ubuntu, or Raspbian OS detected.'
                ;;
        arch)
                printf '%s\n' 'Arch or Manjaro-based OS detected.'
                ;;
        fedora)
                printf '%s\n' 'Fedora detected as the operating system.'
                ;;
        mac)
                printf '%s\n' 'MacOS detected.'
                ;;
        nixos)
                printf '%s\n' 'NixOS detected.'
                ;;
        esac
else
        printf '%s\n' "$DISTRO"
fi
}

# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined spell: services-menu
_services_menu() {

# services-menu collects all service-management spells in one place so users
# never need to remember flags. Each menu item launches a single-purpose spell.



case "${1-}" in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
esac

set -u

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The services menu needs the 'menu' command to present options."; then
  exit 1
fi

for spell in start-service stop-service restart-service enable-service disable-service \
  service-status is-service-installed remove-service install-service-template; do
  if ! require "$spell" "The services menu expects the '$spell' spell."; then
    exit 1
  fi
done

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

display_menu() {
  start_item="Start a service%start-service"
  stop_item="Stop a service%stop-service"
  restart_item="Restart a service%restart-service"
  enable_item="Enable a service at boot%enable-service"
  disable_item="Disable a service at boot%disable-service"
  status_item="Check service status%service-status"
  installed_item="Check if a service is installed%is-service-installed"
  remove_item="Remove a service%remove-service"
  install_item="Install service from template%install-service-template"
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$start_item" "$stop_item" "$restart_item" \
    "$enable_item" "$disable_item" "$status_item" \
    "$installed_item" "$remove_item" "$install_item" "$exit_item"

  menu "Services Menu:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
}

# Inlined spell: shutdown-menu
_shutdown_menu() {

# This spell displays shutdown, restart, logout, and power management options.
# Commands are invoked directly via the menu without external spell dependencies.



case "${1-}" in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
esac


# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The shutdown menu needs the 'menu' command to present options."; then
  exit 1
fi

# Detect whether sleep is available (systemd or pmset on macOS)
sleep_available=""
if command -v systemctl >/dev/null 2>&1; then
  # Try can-suspend first; fall back to kernel power state if unavailable
  # (NixOS and older systemd versions may not support can-suspend)
  can_suspend_result=$(systemctl can-suspend 2>&1) || true
  case "$can_suspend_result" in
    yes)
      sleep_available="Sleep%sudo systemctl suspend"
      ;;
    *)
      # Check kernel power states as fallback (mem = suspend/sleep)
      if [ -r /sys/power/state ] && grep -qw mem /sys/power/state 2>/dev/null; then
        sleep_available="Sleep%sudo systemctl suspend"
      fi
      ;;
  esac
elif command -v pmset >/dev/null 2>&1; then
  sleep_available="Sleep%sudo pmset sleepnow"
fi

# Detect whether hibernate is available (systemd only)
hibernate_available=""
if command -v systemctl >/dev/null 2>&1; then
  # Try can-hibernate first; fall back to kernel power state if unavailable
  # (NixOS and older systemd versions may not support can-hibernate)
  can_hibernate_result=$(systemctl can-hibernate 2>&1) || true
  case "$can_hibernate_result" in
    yes)
      hibernate_available="Hibernate%sudo systemctl hibernate"
      ;;
    *)
      # Check kernel power states as fallback (disk = hibernate)
      if [ -r /sys/power/state ] && grep -qw disk /sys/power/state 2>/dev/null; then
        hibernate_available="Hibernate%sudo systemctl hibernate"
      fi
      ;;
  esac
fi

# Detect whether loginctl is available for graceful logout (systemd only)
logout_cmd=""
if command -v loginctl >/dev/null 2>&1; then
  logout_cmd="loginctl terminate-user \"\$USER\""
else
  logout_cmd="pkill -TERM -u \"\$USER\""
fi

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

display_menu() {
  # Graceful restart/shutdown give processes time to clean up
  restart_item="Restart%sudo shutdown -r +0"
  shutdown_item="Shutdown%sudo shutdown -h +0"
  logout_item="Logout%$logout_cmd"
  # Force operations bypass graceful shutdown procedures
  force_restart_item="Force restart%sudo reboot -f"
  force_shutdown_item="Force shutdown%sudo poweroff -f"
  force_logout_item="Force logout%pkill -KILL -u \"\$USER\""
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$restart_item" "$shutdown_item" "$logout_item"
  if [ -n "$sleep_available" ]; then
    set -- "$@" "$sleep_available"
  fi
  if [ -n "$hibernate_available" ]; then
    set -- "$@" "$hibernate_available"
  fi
  set -- "$@" "$force_restart_item" "$force_shutdown_item" "$force_logout_item" "$exit_item"

  menu "Restart / Shutdown:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
}

# Inlined spell: test-magic
_test_magic() {
# Entrypoint for running the project test suite from the system menu, CLI, or CI.
#
# Responsibilities:
# - Provide the full test runner logic in a single spell.
# - Discover tests, filter them, and report coverage in the expected format.

# CRITICAL: Seed a baseline PATH BEFORE set -eu and before any commands
# On macOS GitHub Actions, PATH may be completely empty, causing immediate failure
# when we try to use basename, dirname, cd, pwd, find, sort, awk, etc.
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*)
    # Already has at least one standard directory
    ;;
  *)
    # PATH is empty or missing standard directories, prepend baseline
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac


cmd_name=$(basename "$0")
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH so we can use them directly
# This allows running test-magic directly without wizardry being installed
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac


export PATH

only_patterns=""
list_only=0
verbose=0
very_verbose=0
rerun_args=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "$cmd_name: --only requires a pattern" >&2
        show_usage
        exit 1
      fi
      rerun_args="$rerun_args --only $2"
      if [ -n "$only_patterns" ]; then
        only_patterns="$only_patterns\n$2"
      else
        only_patterns="$2"
      fi
      shift 2
      ;;
    --list)
      list_only=1
      rerun_args="$rerun_args --list"
      shift
      ;;
    --verbose)
      verbose=1
      rerun_args="$rerun_args --verbose"
      shift
      ;;
    --very-verbose)
      very_verbose=1
      rerun_args="$rerun_args --very-verbose"
      shift
      ;;
    --help|--usage|-h)
      show_usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "$cmd_name: unknown option '$1'" >&2
      show_usage
      exit 1
      ;;
  esac
done

find_tests() {
  find "$test_dir" -type f -name 'test-*.sh' | sort
}

pattern_has_match() {
  pattern=$1
  found=1
  while IFS= read -r path; do
    [ -n "$path" ] || continue
    rel=${path#"$test_dir/"}
    case $rel in
      $pattern)
        found=0
        break
        ;;
    esac
  done <<EOF_TESTS
$(find_tests)
EOF_TESTS
  return $found
}

matches_patterns() {
  rel=$1
  if [ -z "$only_patterns" ]; then
    return 0
  fi
  match=1
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    case $rel in
      $pat)
        match=0
        break
        ;;
    esac
  done <<EOF_PATS
$only_patterns
EOF_PATS
  return $match
}

test_files=""

if [ -n "$only_patterns" ]; then
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    if ! pattern_has_match "$pat"; then
      echo "$cmd_name: pattern '$pat' matched no tests" >&2
      exit 1
    fi
  done <<EOF_PATS
$only_patterns
EOF_PATS
fi

while IFS= read -r path; do
  short=${path#"$test_dir/"}
  if matches_patterns "$short"; then
    if [ -n "$test_files" ]; then
      test_files=$(printf '%s\n%s' "$test_files" "$short")
    else
      test_files="$short"
    fi
  fi
done <<EOF_TESTS
$(find_tests)
EOF_TESTS

if [ -z "$test_files" ]; then
  echo "$cmd_name: no tests discovered." >&2
  exit 1
fi

if [ "$list_only" -eq 1 ]; then
  printf '%s\n' "$test_files"
  exit 0
fi

spell_path_for_test() {
  test_path=$1
  rel=${test_path#"$test_dir/"}
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$root_dir" "spells/$dir" "$base"
}

record_subtests() {
  counts=$(printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      passed += parts[1]
      total += parts[2]
      next
    }
    /^FAIL_DETAIL:/ { next }
    END { print (passed+0) " " (total+0) }
  ')

  set -- $counts
  if [ "$#" -eq 2 ]; then
    subtests_passed=$((subtests_passed + $1))
    subtests_total=$((subtests_total + $2))
  fi
}

status=0
pass=0
fail=0
subtests_passed=0
subtests_total=0
failed_scripts=""
incomplete_tests=""
incomplete_count=0
test_number=0
test_total=$(printf '%s\n' "$test_files" | grep -c .)
# Imps have no --help flag, so they need 2 subtests minimum.
# Spells have a --help flag which needs testing, plus 2 additional subtests.
MIN_SUBTESTS_IMP=2
MIN_SUBTESTS_SPELL=3
failure_output_file=$(temp-file test-magic) || exit 1
trap 'cleanup-file "$failure_output_file"' EXIT HUP INT TERM

spell_name_for_test() {
  test_path=$1
  
  # Special case: test-suite.sh should display as "common tests"
  case "$test_path" in
    */test-suite.sh|test-suite.sh)
      printf '%s\n' "common tests"
      return
      ;;
  esac
  
  spell_path=$(spell_path_for_test "$test_path" 2>/dev/null || true)

  if [ -n "$spell_path" ]; then
    printf '%s\n' "$(basename "$spell_path")"
    return
  fi

  base=${test_path##*/}
  base=${base#test_}
  base=${base%.sh}
  printf '%s\n' "$base"
}

print_failure_debug() {
  test_path=$1
  output=$2

  printf 'Debug (failures only) for %s:\n' "$test_path"
  printf '%s\n' "$output" | awk '
    /^PASS / { next }
    /^[0-9]+\/[0-9]+ tests passed/ { next }
    /^FAIL_DETAIL:/ { next }
    /^$/ { next }
    { printf "  %s\n", $0 }
  '
}

record_failed_script() {
  script=$1
  numbers=$2

  name=$(spell_name_for_test "$script")

  if [ -n "$numbers" ]; then
    entry="$name ($numbers)"
  else
    entry="$name"
  fi

  if [ -n "$failed_scripts" ]; then
    failed_scripts="$failed_scripts, $entry"
  else
    failed_scripts="$entry"
  fi
}

# Extract the total subtest count from test output.
# $1 - test output containing "X/Y tests passed" summary line
# Returns the total (Y) from the summary, or 0 if no summary found.
get_subtest_total() {
  printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      print parts[2]
      exit
    }
    END { if (!NR) print 0 }
  '
}

# Check if test output contains a --help test case.
# Looks for test case lines (PASS/FAIL) that mention help or usage.
# $1 - test output
# Returns 0 if help test found, 1 otherwise.
has_help_test() {
  printf '%s\n' "$1" | grep -qiE "(PASS|FAIL).*(--help|-h|help|usage)"
}

# Record a test that has fewer than required subtests or is missing help test.
# $1 - test path
# $2 - reason (e.g., "2 subtests" or "missing --help test")
record_incomplete_test() {
  test_path=$1
  reason=$2
  name=$(spell_name_for_test "$test_path")
  entry="$name ($reason)"
  if [ -n "$incomplete_tests" ]; then
    incomplete_tests="$incomplete_tests, $entry"
  else
    incomplete_tests="$entry"
  fi
}

while IFS= read -r test_path; do
  [ -n "$test_path" ] || continue
  abs="$test_dir/$test_path"
  test_number=$((test_number + 1))
  printf '[%d/%d] %s\n' "$test_number" "$test_total" "$test_path"

  if output=$(sh "$abs" 2>&1); then
    pass=$((pass + 1))
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    [ "$verbose" -eq 1 ] && printf '%s\n' "$cleaned_output" | sed 's/^/  /'
  else
    status=1
    fail=$((fail + 1))
    numbers=$(printf '%s\n' "$output" | awk -F ':' '
      /^FAIL_DETAIL:/ {
        if (NF >= 2) {
          n = split($2, parts, ",")
          for (i = 1; i <= n; i++) {
            idx = parts[i]
            gsub(/^ +| +$/, "", idx)
            if (idx ~ /^[0-9]+$/) {
              order[++count] = idx
            }
          }
        }
        next
      }
      END {
        for (i = 1; i <= count; i++) {
          if (i > 1) {
            printf(", ")
          }
          printf("%s", order[i])
        }
        printf("\n")
      }
    ' | sed 's/[[:space:]]*$//')
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    record_failed_script "$test_path" "$numbers"
    if [ "$very_verbose" -eq 1 ]; then
      print_failure_debug "$test_path" "$cleaned_output"
    fi
    {
      printf '=== %s ===\n' "$test_path"
      printf '%s\n\n' "$cleaned_output"
    } >>"$failure_output_file"
  fi

  # Check minimum subtest requirements based on test type.
  # Imps (in .imps/): Need MIN_SUBTESTS_IMP subtests (no --help).
  # Spells: Need a --help test PLUS MIN_SUBTESTS_IMP additional behavioral subtests.
  # Global tests (test-install.sh, test-suite.sh): Exempt from --help requirement.
  test_subtest_count=$(get_subtest_total "$cleaned_output")
  test_incomplete_reasons=""
  case "$test_path" in
    .imps/*|*/.imps/*)
      # Imps have no --help, just need MIN_SUBTESTS_IMP subtests
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    test-install.sh|test-suite.sh)
      # Global/special tests don't need --help test
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    *)
      # Spells need a --help test plus additional behavioral subtests.
      # Total must be at least MIN_SUBTESTS_SPELL (1 help + 2 behavioral = 3).
      if ! has_help_test "$cleaned_output"; then
        record_incomplete_test "$test_path" "missing --help test"
        test_incomplete_reasons="missing --help test"
      fi
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_SPELL" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        if [ -n "$test_incomplete_reasons" ]; then
          test_incomplete_reasons="$test_incomplete_reasons; $test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        else
          test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        fi
      fi
      ;;
  esac

  # Print inline incomplete warning using LACK (not PASS/FAIL)
  if [ -n "$test_incomplete_reasons" ]; then
    incomplete_count=$((incomplete_count + 1))
    printf 'LACK %s (%s)\n' "$(spell_name_for_test "$test_path")" "$test_incomplete_reasons"
  fi

  printf '\n'
done <<EOF_TESTS
$(printf '%s\n' "$test_files")
EOF_TESTS

find_matching_test_for_spell() {
  spell=$1
  rel=${spell#"$root_dir/"}
  rel=${rel#spells/}
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  candidate_sh="$test_dir/$dir/test-${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi
  return 1
}

scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=""

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$root_dir/"}
    case $rel in
      spells/system/test-magic|spells/system/verify-posix)
        continue
        ;;
      *.service|*.gitkeep|*.gitignore)
        # Skip non-script files
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null 2>&1; then
      coverage_covered=$((coverage_covered + 1))
    else
      if [ -n "$uncovered_spells" ]; then
        uncovered_spells=$(printf '%s\n%s' "$uncovered_spells" "$rel")
      else
        uncovered_spells="$rel"
      fi
    fi
  done <<EOF_SPELLS
$(cd "$root_dir" && find spells -type f | sort)
EOF_SPELLS
}

scan_extraneous() {
  extraneous_files=""
  
  while IFS= read -r test_file; do
    [ -n "$test_file" ] || continue
    
    # Skip test-suite.sh
    case $test_file in
      */test-suite.sh) continue ;;
    esac
    
    # Extract spell path from test path
    rel=${test_file#"$test_dir/"}
    dir=$(dirname "$rel")
    base=$(basename "$rel")
    # Remove test- prefix and .sh suffix
    base=${base#test-}
    base=${base%.sh}
    
    # Handle special cases for install tests (test the root install script)
    # The install script is in the repo root (not spells/) so its test can be:
    # 1. .tests/test-install.sh (dir="." base="install") 
    # 2. .tests/install/test-install.sh (dir="install" base="install")
    case "$base" in
      install|install-with-old-version)
        if [ "$dir" = "install" ] || [ "$dir" = "." ]; then
          if [ -f "$root_dir/install" ]; then
            continue
          fi
        fi
        ;;
    esac
    
    spell_path="$root_dir/spells/$dir/$base"
    
    if [ ! -f "$spell_path" ]; then
      if [ -n "$extraneous_files" ]; then
        extraneous_files=$(printf '%s\n%s' "$extraneous_files" ".tests/$rel")
      else
        extraneous_files=".tests/$rel"
      fi
    fi
  done <<EOF_TESTS
$(find "$test_dir" -type f -name 'test-*.sh' | sort)
EOF_TESTS
}

scan_coverage
scan_extraneous
coverage_uncovered=$((coverage_total - coverage_covered))

total_scripts=$((pass + fail))
printf 'Summary: %d passed, %d failed, %d uncovered, %d incomplete, subtests %d/%d.\n' \
  "$pass" "$fail" "$coverage_uncovered" "$incomplete_count" "$subtests_passed" "$subtests_total"

if [ "$coverage_uncovered" -gt 0 ]; then
  printf 'Uncovered spells:\n'
  printf '  %s\n' "$uncovered_spells"
  status=1
fi

if [ -n "$extraneous_files" ]; then
  printf 'Extraneous test files (no corresponding spell):\n'
  printf '  %s\n' "$extraneous_files"
  status=1
fi

if [ -n "$incomplete_tests" ]; then
  printf 'Incomplete tests (imps need %d+ subtests, spells need %d+ including --help):\n' "$MIN_SUBTESTS_IMP" "$MIN_SUBTESTS_SPELL"
  printf '  %s\n' "$incomplete_tests"
  status=1
fi

if [ "$very_verbose" -eq 1 ] && [ "$fail" -gt 10 ]; then
  printf 'Too many failures (%d) for --very-verbose; skipping detailed output.\n' "$fail"
  very_verbose=0
fi

if [ "$status" -ne 0 ] && [ -n "$failed_scripts" ]; then
  show_failure_output=0
  if [ "$very_verbose" -eq 1 ] && [ "$fail" -le 10 ]; then
    show_failure_output=1
  fi

  if [ "$show_failure_output" -eq 1 ] && [ -s "$failure_output_file" ]; then
    printf 'Failure details (showing %d):\n' "$fail"
    while IFS= read -r line; do
      case $line in
        "=== "*) printf '%s\n' "$line" ;;
        *) printf '  %s\n' "$line" ;;
      esac
    done <"$failure_output_file"
  fi

  detect_os_label() {
    if [ -n "${WIZARDRY_OS_LABEL-}" ]; then
      printf '%s\n' "$WIZARDRY_OS_LABEL"
      return 0
    fi

    if [ -x "$root_dir/spells/divination/detect-distro" ]; then
      if label=$("$root_dir/spells/divination/detect-distro" 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v detect-distro >/dev/null 2>&1; then
      if label=$(detect-distro 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v uname >/dev/null 2>&1; then
      label=$(uname -s 2>/dev/null || true)
      label=$(printf '%s' "$label" | tr ' A-Z' '_a-z')
      if [ -n "$label" ]; then
        printf '%s\n' "$label"
        return 0
      fi
    fi

    printf 'unknown\n'
  }

  os_label=$(detect_os_label)
  printf 'Failed tests (%s): %s\n' "$os_label" "$failed_scripts"
fi

if [ "$status" -ne 0 ] && [ "$fail" -le 10 ] && [ "${GITHUB_ACTIONS-}" != "" ] \
  && [ "${TEST_MAGIC_DEBUG_RERUN-}" != "1" ] && [ "$very_verbose" -eq 0 ]; then
  trap - EXIT HUP INT TERM
  cleanup-file "$failure_output_file"
  printf '\nGitHub Actions detected <=10 failing tests; rerunning with --very-verbose for focused debug...\n'
  set -- $rerun_args
  TEST_MAGIC_DEBUG_RERUN=1 exec "$0" --very-verbose "$@"
fi

trap - EXIT HUP INT TERM
cleanup-file "$failure_output_file"

exit $status
}

# Inlined spell: update-all
_update_all() {

# This spell refreshes the wizardry repository alongside other managed sources.
# Pass --verbose to narrate each update step.


VERBOSE=0

while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    --help|--usage|-h)
      show_usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf 'Unknown option: %s\n' "$1" >&2
      show_usage >&2
      exit 1
      ;;
    *)
      break
      ;;
  esac

done

if [ "$#" -ne 0 ]; then
  printf 'Unexpected argument: %s\n' "$1" >&2
  show_usage >&2
  exit 1
fi

script_dir=$(cd "$(dirname "$0")" && pwd)
repo_dir=$(cd "$script_dir/../.." && pwd)

# Add imps to PATH so we can use temp-file and cleanup-file directly
if [ -d "$repo_dir/spells/.imps" ]; then
  PATH="$repo_dir/spells/.imps:$PATH"
  for impdir in "$repo_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

if has colors; then
  # shellcheck source=/dev/null
  . "$(command -v colors)"
else
  GREY=''
  RESET=''
fi

require_command() {
  cmd=$1
  has "$cmd" || fail "Required command not found: $cmd"
}

print_step() {
  printf '%s\n' "$1"
}

format_command() {
  if [ "$#" -eq 0 ]; then
    return 0
  fi

  printf '%s' "$1"
  shift
  for arg do
    printf ' %s' "$arg"
  done
}

print_command() {
  printf '%b  $ %s%b\n' "${GREY:-}" "$(format_command "$@")" "${RESET:-}"
}

run_quiet() {
  if [ "$#" -eq 0 ]; then
    return 0
  fi
  print_command "$@"
  if [ "$VERBOSE" -eq 1 ]; then
    "$@"
  else
    "$@" >/dev/null 2>&1
  fi
}

progress_filter() {
  last_progress=''
  while IFS= read -r line || nonempty "$line"; do
    case $line in
      Progress:*)
        last_progress=$line
        printf '\r%s' "$line"
        ;;
      *)
        if [ -n "$last_progress" ]; then
          printf '\r%s\n' "$last_progress"
          last_progress=''
        fi
        if [ -n "$line" ]; then
          printf '%s\n' "$line"
        fi
        ;;
    esac
  done

  if [ -n "$last_progress" ]; then
    printf '\r%s\n' "$last_progress"
  fi
}

run_with_progress() {
  if [ "$#" -eq 0 ]; then
    return 0
  fi

  print_command "$@"

  if [ "$VERBOSE" -eq 1 ]; then
    "$@"
    return $?
  fi

  progress_tmp=$(temp-file update-all) || return 1
  trap 'cleanup-file "$progress_tmp"' EXIT HUP INT TERM
  (
    set +e
    "$@" 2>&1
    cmd_status=$?
    set -e
    printf '%s\n' "$cmd_status" >"$progress_tmp"
    exit 0
  ) | tr '\r' '\n' | progress_filter

  status=$(cat "$progress_tmp" 2>/dev/null || printf '1\n')
  trap - EXIT HUP INT TERM
  rm -f "$progress_tmp"

  case ${status:-} in
    '' ) status=1 ;;
  esac

  return "$status"
}

assume_yes() {
  case ${WIZARDRY_UPDATE_ALL_ASSUME_YES:-} in
    1|[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee])
      return 0
      ;;
  esac
  return 1
}

confirm_updates() {
  if assume_yes; then
    return 0
  fi
  lacks ask-yn && fail 'ask-yn spell is missing; cannot confirm updates.'
  printf '%s\n' 'Proceed with system updates?'
  if printf '\n' | ASK_CANTRIP_INPUT=stdin ask-yn 'Proceed with system updates?' yes >/dev/null; then
    return 0
  fi
  return 1
}

resolve_distro() {
  if is set "${WIZARDRY_UPDATE_ALL_DISTRO:-}"; then
    printf '%s\n' "$WIZARDRY_UPDATE_ALL_DISTRO"
    return 0
  fi

  if has detect-distro; then
    if distro=$(detect-distro 2>/dev/null); then
      printf '%s\n' "$distro"
      return 0
    fi
  fi

  return 1
}

distro=$(resolve_distro)
if [ -z "$distro" ]; then
  printf '%s\n' 'Unable to detect operating system.' >&2
  exit 1
fi

printf 'Detected platform: %s\n' "$distro"

if ! confirm_updates; then
  printf '%s\n' 'cancelled by user' >&2
  exit 1
fi

case $distro in
  debian)
    require_command sudo
    require_command apt-get
    print_step '• Refreshing apt package lists'
    run_quiet sudo apt-get update
    print_step '• Installing upgrades'
    run_with_progress sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y full-upgrade
    print_step '• Removing unused packages'
    run_with_progress sudo apt-get -o Dpkg::Progress-Fancy=1 -o Dpkg::Use-Pty=0 -y autoremove
    ;;
  arch)
    require_command sudo
    require_command pacman
    require_command pamac
    print_step '• Synchronising pacman packages'
    run_quiet sudo pacman -Syu --noconfirm
    print_step '• Refreshing Pamac-managed packages'
    run_quiet pamac update --no-confirm
    print_step '• Rebuilding Pamac AUR packages'
    run_quiet pamac build --no-confirm
    ;;
  nixos)
    require_command sudo
    require_command nix-channel
    require_command nixos-rebuild
    require_command nix-env
    print_step '• Refreshing system channels'
    run_quiet sudo nix-channel --update
    print_step '• Rebuilding system configuration'
    run_quiet sudo nixos-rebuild switch --upgrade
    print_step '• Refreshing user channels'
    run_quiet nix-channel --update
    print_step '• Upgrading user packages'
    run_quiet nix-env -u --always
    ;;
  *)
    printf 'Unsupported platform: %s\n' "$distro" >&2
    exit 2
    ;;
esac

print_step 'All updates complete.'
}

# Inlined spell: update-wizardry
_update_wizardry() {

# This spell fast-forwards the wizardry repository in place.
# It locates the checkout directory or accepts WIZARDRY_DIR to target another path.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

require_cmd=${REQUIRE_COMMAND-require-command}

require() {
  "$require_cmd" "$@"
}

if ! require git "Update wizardry needs 'git' to pull the latest changes."; then
  exit 1
fi

if [ -n "${WIZARDRY_DIR-}" ]; then
  wizardry_dir=$WIZARDRY_DIR
  if [ ! -d "$wizardry_dir" ]; then
    printf '%s\n' "WIZARDRY_DIR does not exist or is not a directory: $wizardry_dir" >&2
    exit 1
  fi
  if ! git -C "$wizardry_dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf '%s\n' "WIZARDRY_DIR is not a git repository: $wizardry_dir" >&2
    exit 1
  fi
else
  # Attempt to locate the wizardry repository based on this spell's location.
  candidate=$(dirname "$script_dir")
  if git -C "$candidate" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    wizardry_dir=$(git -C "$candidate" rev-parse --show-toplevel)
  else
    candidate=$(dirname "$candidate")
    if git -C "$candidate" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      wizardry_dir=$(git -C "$candidate" rev-parse --show-toplevel)
    else
      printf '%s\n' 'Unable to determine the wizardry repository. Set WIZARDRY_DIR to the checkout location.' >&2
      exit 1
    fi
  fi
fi

printf 'Updating wizardry repository at %s\n' "$wizardry_dir"
exec git -C "$wizardry_dir" pull --ff-only
}

# Inlined spell: verify-posix
_verify_posix() {

# Verify that wizardry spells use POSIX-compliant shell practices.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

# Add imps to PATH so we can use temp-file and cleanup-file directly
if [ -d "$repo_dir/spells/.imps" ]; then
  PATH="$repo_dir/spells/.imps:$PATH"
  for impdir in "$repo_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

checkbashisms_cmd=${CHECKBASHISMS-}
if [ -z "$checkbashisms_cmd" ] && command -v checkbashisms >/dev/null 2>&1; then
  checkbashisms_cmd=$(command -v checkbashisms)
fi

if [ -z "$checkbashisms_cmd" ]; then
  printf '%s\n' "verify-posix: checkbashisms is required but not found in PATH." >&2
  exit 1
fi

gather_default_targets() {
  find "$repo_dir/spells" -type f \( -perm -u+x -o -perm -g+x -o -perm -o+x \) \
    -print | sort | while IFS= read -r file; do
      first_line=$(sed -n '1p' "$file")
      case $first_line in
        '#!/bin/sh'|'#! /bin/sh'|'#!/usr/bin/env sh'|'#! /usr/bin/env sh')
          printf '%s\n' "${file#"$repo_dir/"}"
          ;;
      esac
    done
}

collect_targets() {
  if [ "$#" -gt 0 ]; then
    printf '%s\n' "$@"
  else
    gather_default_targets
  fi
}

failures=0
total=0
failed_targets=""

targets_file=$(temp-file verify-posix-targets) || exit 1
trap 'cleanup-file "$targets_file"' EXIT HUP INT TERM
collect_targets "$@" >"$targets_file"

while IFS= read -r target; do
  [ -n "$target" ] || continue
  total=$((total + 1))

  case $target in
    /*)
      path="$target"
      ;;
    *)
      path="$repo_dir/$target"
      ;;
  esac

  if [ ! -e "$path" ]; then
    printf 'FAIL %s: missing file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi

  if [ ! -f "$path" ]; then
    printf 'FAIL %s: not a regular file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi

  shebang=$(sed -n '1p' "$path")

  case $shebang in
    '')
      printf 'FAIL %s: lacks a shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    '#!')
      printf 'FAIL %s: has an empty shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    '#!'*)
      interpreter=${shebang#\#!}
      while [ "${interpreter# }" != "$interpreter" ]; do
        interpreter=${interpreter# }
      done
      ;;
    *)
      printf 'FAIL %s: lacks a shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
  esac

  case $interpreter in
    '/bin/sh'|'/usr/bin/env sh')
      :
      ;;
    '/usr/bin/env bash'*|'/bin/bash'*)
      printf 'FAIL %s: uses %s (should use /bin/sh)\n' "$target" "$shebang"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    *)
      printf 'FAIL %s: uses %s (should use /bin/sh)\n' "$target" "$shebang"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
  esac

  tmp_log=$(temp-file verify-posix-log) || exit 1
  if "$checkbashisms_cmd" "$path" >"$tmp_log" 2>&1; then
    printf 'PASS %s\n' "$target"
  else
    printf 'FAIL %s\n' "$target"
    while IFS= read -r line; do
      printf '  %s\n' "$line"
    done <"$tmp_log"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
  fi
  cleanup-file "$tmp_log"
done <"$targets_file"
trap - EXIT HUP INT TERM
rm -f "$targets_file"

if [ "$failures" -eq 0 ]; then
  printf 'All %d scripts are POSIX-compliant.\n' "$total"
else
  printf '%d of %d scripts failed POSIX compliance.\n' "$failures" "$total"
  printf 'Failing spells: %s\n' "$failed_targets"
  exit 1
fi
}


# This spell displays system maintenance tasks.


show_usage() {
  cat <<'USAGE'
Usage: system-menu

Displays the system maintenance menu.
USAGE
}

case "${1-}" in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
esac

set -eu
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
spells_dir=$(dirname "$script_dir")
repo_dir=$(dirname "$spells_dir")

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The system menu needs the 'menu' command to present options."; then
  exit 1
fi

# Detect whether we are running on NixOS to offer system-specific actions.
nixos_rebuild=""
if command -v _detect_distro >/dev/null 2>&1 && [ "$(_detect_distro 2>/dev/null)" = "nixos" ]; then
  nixos_rebuild="Rebuild NixOS%sudo nixos-rebuild switch"
fi

display_menu() {
  restart_menu="Restart...%_shutdown_menu"
  services="Manage services%_services_menu"
  verify_posix="Verify POSIX spells%_verify_posix"
  update_wizardry="Update wizardry%_update_wizardry"
  test_suite="Test all wizardry spells%_test_magic"
  update_all="Update all software%_update_all -v"
  uninstall_wizardry="Uninstall wizardry%$repo_dir/.uninstall"
  exit_label=$(_exit_label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$restart_menu" "$update_all" "$update_wizardry" "$services"
  if [ -n "$nixos_rebuild" ]; then
    set -- "$@" "$nixos_rebuild"
  fi
  set -- "$@" "$verify_posix" "$test_suite" "$uninstall_wizardry" "$exit_item"

  menu "System Menu:" "$@"
}

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
