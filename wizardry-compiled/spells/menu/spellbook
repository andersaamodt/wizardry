#!/bin/sh
#
# ------------------------------- spellbook --------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: spellbook
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: category-title
_category_title() {
  case $1 in
    arcane)       printf 'Arcane' ;;
    cantrips)     printf 'Cantrips' ;;
    psi)          printf 'Psi' ;;
    divination)   printf 'Divination' ;;
    enchant)      printf 'Enchantment' ;;
    install)      printf 'Install' ;;
    crypto)       printf 'Crypto' ;;
    mud)          printf 'MUD' ;;
    priorities)   printf 'Priorities' ;;
    spellcraft)   printf 'Spellcraft' ;;
    system)       printf 'System' ;;
    translocation) printf 'Translocation' ;;
    wards)        printf 'Wards' ;;
    *)
      _ct_first=$(printf '%s' "$1" | cut -c1 | tr '[:lower:]' '[:upper:]')
      _ct_rest=$(printf '%s' "$1" | cut -c2-)
      printf '%s%s' "$_ct_first" "$_ct_rest"
      ;;
  esac
}

# Inlined imp: empty
_empty() {
  [ -z "$1" ]
}

# Inlined imp: env-or
_env_or() {
  _eo_var=$1
  # Validate variable name contains only alphanumerics and underscores
  case "$_eo_var" in
    *[!A-Za-z0-9_]*|"")
      printf '%s\n' "$2"
      return
      ;;
  esac
  eval "_eo_val=\${$_eo_var-}"
  if [ -n "$_eo_val" ]; then
    printf '%s\n' "$_eo_val"
  else
    printf '%s\n' "$2"
  fi
}

# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined spell: memorize
_memorize() {

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory


spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
	cast_dir=$1
	if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
		file=$(expand_tilde "$WIZARDRY_CAST_FILE")
	elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
		file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
	else
		file=$cast_dir/.memorized
	fi
	printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
	if [ ! -d "$cast_dir" ]; then
		mkdir -p "$cast_dir"
	fi
	dir=${command_file%/*}
	if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_name() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "$spell_name: names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

nonempty() {
	[ -n "$1" ]
}

add_spell() {
	name=$1
	validate_name "$name"
	ensure_parent_directory
	# Memorize just lists existing spells by name - no wrapper scripts needed
	# The spell must already exist in PATH or spellbook
	cmd=$name
	tmp=$(temp-file memorize) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	if [ -f "$command_file" ]; then
		while IFS= read -r line || nonempty "$line"; do
			entry_name=$line
			case $line in
			*"$tab_char"*)
				entry_name=${line%%"$tab_char"*}
				;;
			esac
			if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
				continue
			fi
			printf '%s\n' "$line" >>"$tmp"
		done <"$command_file"
	fi
	printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
	if [ -f "$tmp" ]; then
		cat "$tmp" >>"$command_file"
	fi
	trap - EXIT HUP INT TERM
	rm -f "$tmp"
}

list_entries() {
	if [ -f "$command_file" ]; then
		cat "$command_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1

case $action in
list)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$command_file"
	;;
dir)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$cast_dir"
	;;
--help|--usage|-h)
	show_usage
	;;
-*)
	printf '%s\n' "$spell_name: unknown option '$action'" >&2
	show_usage
	exit 1
	;;
*)
	# Default action: memorize the spell
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "$spell_name: expects exactly one spell name." >&2
		show_usage
		exit 1
	fi
	add_spell "$action"
	;;
esac
}

# Inlined spell: scribe-spell
_scribe_spell() {
# This spell scribes (creates) a custom spell in your spellbook.
# It prompts for name, command text, and optionally a category.


SCRIPT_NAME=$(basename "$0")


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")

# Category can be passed via --category argument
current_category=""

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

# Check if a spell name conflicts with an existing command or spell
check_duplicate_name() {
        name=$1
        # Check if name conflicts with an existing command in PATH
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s\n' "$SCRIPT_NAME: '$name' conflicts with an existing command." >&2
                return 1
        fi
        # Check if spell already exists in the spellbook directory
        if [ -e "$spell_home/$name" ]; then
                printf '%s\n' "$SCRIPT_NAME: '$name' already exists in your spellbook." >&2
                return 1
        fi
        # Check subfolders of the spellbook for existing spells
        if [ -d "$spell_home" ]; then
                for subdir in "$spell_home"/*; do
                        [ -d "$subdir" ] || continue
                        if [ -e "$subdir/$name" ]; then
                                printf '%s\n' "$SCRIPT_NAME: '$name' already exists in your spellbook." >&2
                                return 1
                        fi
                done
        fi
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must not be empty." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command may not contain tabs." >&2
                return 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "$SCRIPT_NAME: command must be a single line." >&2
                return 1
        fi
}

# Validate category name (folder name)
validate_category() {
        cat_name=$1
        case $cat_name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "$SCRIPT_NAME: category names may contain only letters, digits, dots, underscores, and dashes." >&2
                return 1
                ;;
        -*)
                printf '%s\n' "$SCRIPT_NAME: category names may not begin with a dash." >&2
                return 1
                ;;
        esac
}

spell_path() {
        if [ -n "$current_category" ]; then
                printf '%s/%s/%s' "$spell_home" "$current_category" "$1"
        else
                printf '%s/%s' "$spell_home" "$1"
        fi
}

write_spell_script() {
        script_name=$1
        cmd_text=$2
        target_path=$(spell_path "$script_name")
        ensure_parent_dir "$target_path"
        if [ -n "$current_category" ]; then
                mkdir -p "$spell_home/$current_category"
        else
                mkdir -p "$spell_home"
        fi
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$target_path" <<EOF_SCRIPT
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$target_path"
}

# Add a new category folder to PATH using learn-spellbook
add_category_to_path() {
        cat_name=$1
        cat_path="$spell_home/$cat_name"
        
        # Find learn-spellbook
        if command -v learn-spellbook >/dev/null 2>&1; then
                learn_spellbook=$(command -v learn-spellbook)
        else
                # Try relative path from this script
                SCRIPT_SOURCE=$0
                case $SCRIPT_SOURCE in
                */*)
                        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
                        ;;
                *)
                        SCRIPT_DIR=.
                        ;;
                esac
                SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
                learn_spellbook="$SCRIPT_DIR/learn-spellbook"
                if [ ! -x "$learn_spellbook" ]; then
                        printf '%s\n' "learn-spellbook not found; category folder created but not added to PATH." >&2
                        return 0
                fi
        fi
        
        "$learn_spellbook" add "$cat_path" 2>/dev/null || true
}

record_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name" || return 1
        check_duplicate_name "$cmd_name" || return 1
        validate_command "$cmd" || return 1
        if [ -n "$current_category" ]; then
                mkdir -p "$spell_home/$current_category"
        else
                mkdir -p "$spell_home"
        fi
        write_spell_script "$cmd_name" "$cmd"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt" >&2
        IFS= read -r value
        printf '%s' "$value"
}

# Override directory (for creating spells in subfolders)
override_dir=""
# Flag for creating a new category only (no spell)
new_category_mode=0

# Parse arguments
while [ "$#" -gt 0 ]; do
        case ${1-} in
                --help|--usage|-h)
                        show_usage
                        exit 0
                        ;;
                --new-category)
                        new_category_mode=1
                        shift
                        ;;
                --category)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "$SCRIPT_NAME: --category requires a value." >&2
                                exit 1
                        fi
                        current_category=$2
                        validate_category "$current_category" || exit 1
                        shift 2
                        ;;
                --category=*)
                        current_category=${1#*=}
                        validate_category "$current_category" || exit 1
                        shift
                        ;;
                --dir)
                        if [ "$#" -lt 2 ]; then
                                printf '%s\n' "$SCRIPT_NAME: --dir requires a value." >&2
                                exit 1
                        fi
                        override_dir=$2
                        shift 2
                        ;;
                --dir=*)
                        override_dir=${1#*=}
                        shift
                        ;;
                --)
                        shift
                        break
                        ;;
                -*)
                        printf '%s\n' "$SCRIPT_NAME: unknown option '$1'" >&2
                        exit 1
                        ;;
                *)
                        break
                        ;;
        esac
done

# If override_dir is set, use it instead of spell_home
if [ -n "$override_dir" ]; then
        spell_home=$override_dir
        # Clear category since we're using a specific dir
        current_category=""
fi

# Handle --new-category mode
if [ "$new_category_mode" -eq 1 ]; then
        if [ "$#" -ge 1 ]; then
                category_name=$1
        else
                category_name=$(prompt_for_input "Category name: ")
        fi
        if [ -z "$category_name" ]; then
                printf '%s\n' "A category name is required." >&2
                exit 1
        fi
        validate_category "$category_name" || exit 1
        if [ -d "$spell_home/$category_name" ]; then
                printf '%s\n' "Category '$category_name' already exists." >&2
                exit 1
        fi
        mkdir -p "$spell_home/$category_name"
        add_category_to_path "$category_name"
        printf "Created category '%s' in %s.\n" "$category_name" "$spell_home"
        exit 0
fi

# Non-interactive mode with arguments
if [ "$#" -ge 2 ]; then
        name=$1
        shift
        record_command "$name" "$@" || exit 1
        if [ -n "$current_category" ]; then
                printf "Scribed '%s' to %s/%s.\n" "$name" "$spell_home" "$current_category"
        else
                printf "Scribed '%s' to %s.\n" "$name" "$spell_home"
        fi
        exit 0
fi

# Check for partial arguments
if [ "$#" -eq 1 ]; then
        show_usage >&2
        exit 1
fi

# Interactive mode - ask for command FIRST, then name
cmd_text=$(prompt_for_input "Command: ")
cmd_name=$(prompt_for_input "Name: ")

if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
        printf '%s\n' "A name and command are required." >&2
        exit 1
fi

# If no category was provided via --category or --dir, ask if user wants to categorize
if [ -z "$current_category" ] && [ -z "$override_dir" ]; then
        printf 'Would you like to categorize this spell? [y/N] ' >&2
        read -r categorize_answer
        case $categorize_answer in
                y|Y|yes|YES)
                        category_name=$(prompt_for_input "Category name: ")
                        if [ -n "$category_name" ]; then
                                validate_category "$category_name" || exit 1
                                current_category=$category_name
                                # Create the category folder and add to PATH if it's new
                                if [ ! -d "$spell_home/$current_category" ]; then
                                        mkdir -p "$spell_home/$current_category"
                                        add_category_to_path "$current_category"
                                fi
                        fi
                        ;;
        esac
fi

record_command "$cmd_name" "$cmd_text" || exit 1
if [ -n "$current_category" ]; then
        printf "Scribed '%s' to %s/%s.\n" "$cmd_name" "$spell_home" "$current_category"
else
        printf "Scribed '%s' to %s.\n" "$cmd_name" "$spell_home"
fi
}

# Inlined spell: spell-menu
_spell_menu() {
# spell-menu - Display action menu for a spell or custom command
# Shows options: Cast now, Memorize/Forget, Help, Test spell, Delete (for custom)

# Self-healing: Create spellbook directory if missing
create_spellbook_if_missing() {
        spellbook_dir="${XDG_DATA_HOME:-$HOME/.local/share}/wizardry/spellbook"
        if ! [ -d "$spellbook_dir" ]; then
                mkdir -p "$spellbook_dir" 2>/dev/null || {
                        spellbook_dir="${TMPDIR:-/tmp}/wizardry-spellbook-$$"
                        mkdir -p "$spellbook_dir"
                }
        fi
        printf '%s' "$spellbook_dir"
}

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# Provide fallback if colors not available
if command -v colors >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$(command -v colors)"
else
        # Minimal fallback - define color functions as no-ops
        reset() { :; }
        bold() { :; }
        dim() { :; }
        red() { :; }
        green() { :; }
        yellow() { :; }
        blue() { :; }
        magenta() { :; }
        cyan() { :; }
fi

# Get spell home directory with fallback
if command -v env-or >/dev/null 2>&1; then
        spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
else
        spell_home="${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}"
fi
[ -d "$spell_home" ] || mkdir -p "$spell_home" 2>/dev/null || spell_home=$(create_spellbook_if_missing)

cast_list() {
        if command -v memorize >/dev/null 2>&1; then
                memorize list
        else
                # Fallback: list files directly from spellbook
                cast_dir=$(create_spellbook_if_missing)
                for f in "$cast_dir"/*; do
                        [ -f "$f" ] || continue
                        name=$(basename "$f")
                        cmd=$(cat "$f" 2>/dev/null || printf '')
                        [ -n "$cmd" ] && printf '%s\t%s\n' "$name" "$cmd"
                done
        fi
}

is_memorized() {
        check_name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$check_name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

do_memorize() {
        mem_name=$1
        shift
        memorize add "$mem_name" "$@"
}

do_forget() {
        mem_name=$1
        memorize remove "$mem_name"
}

# Check if a script is a custom spell (user-created, not a built-in spell)
# Custom spells are user-created commands that exist ONLY in spell_home (not in system PATH)
# Built-in spells that happen to be in PATH are NOT custom spells
is_custom_spell() {
        check_name=$1
        
        # First, check if this is a built-in spell (exists in PATH outside of spell_home)
        # If so, it's NOT a custom spell, even if memorized
        if cmd_path=$(command -v "$check_name" 2>/dev/null); then
                case "$cmd_path" in
                        "$spell_home"/*) 
                                # Found in spell_home - could be custom, check below
                                ;;
                        *)
                                # Found elsewhere in PATH - this is a built-in spell, not custom
                                return 1
                                ;;
                esac
        fi
        
        # Check if custom script exists in spell_home root
        script_path="$spell_home/$check_name"
        if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$check_name"
                if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                        return 0
                fi
        done
        return 1
}

# Check if a spell has an install() function (making it installable)
# Uses the is-installable imp if available, otherwise falls back to inline check
is_installable() {
        spell_cmd=$1
        if command -v is-installable >/dev/null 2>&1; then
                is-installable "$spell_cmd"
                return $?
        fi
        # Fallback: inline check
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        if grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

# Check if a spell has a --help option
has_help_option() {
        spell_cmd=$1
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        # Check if the script contains --help or -h handling
        if grep -Eq '(--help|-h\))' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}


# Handle action flags (called by menu via subprocess)
case ${1-} in
        --cast)
                shift
                eval "$*"
                exit 0
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --install)
                shift
                # The command is already escaped when passed to this handler
                # Run the spell with --install flag to trigger its install() function
                cmd=$1
                # Use eval since command might contain arguments/quotes
                # The caller has already escaped the command properly
                eval "$cmd" --install || true
                exit 0
                ;;
esac


if [ "$#" -lt 1 ]; then
        show_usage >&2
        exit 1
fi

name=$1
# The command is the spell name (which is executable either as scribed command or from PATH)
command=$name

if ! require menu "The spell menu needs the 'menu' command."; then
        exit 1
fi

# Escape single quotes in command for safe passing
escaped_command=$(printf '%s' "$command" | sed "s/'/'\\\\''/g")

first_run=1
start_selection=1
was_memorized=0

while :; do
        if [ "$first_run" -eq 0 ]; then
                printf '\n'
                # Check if memorization state changed (toggle was used)
                if is_memorized "$name"; then
                        now_memorized=1
                else
                        now_memorized=0
                fi
                if [ "$was_memorized" != "$now_memorized" ]; then
                        # Toggle was selected - keep cursor on toggle item (item 2)
                        start_selection=2
                else
                        # Other action - reset to first item
                        start_selection=1
                fi
        else
                first_run=0
        fi

        # Check current memorization state and build toggle label
        if is_memorized "$name"; then
                was_memorized=1
                cast_toggle="[X] Forget%forget '$name'"
        else
                was_memorized=0
                cast_toggle="[ ] Memorize%memorize '$name'"
        fi
        # Build menu items - Cast now runs the command directly (using escaped version for safety)
        exit_label=$(exit-label)
        exit_item="${exit_label}%kill -TERM \$PPID"
        
        # Check if spell has --help option
        help_item=""
        if has_help_option "$command"; then
                help_item="Help%$escaped_command --help"
        fi
        
        if is_custom_spell "$name"; then
                # Custom spells (in ~/.spellbook or subfolders) show Erase spell option
                # Use erase-spell which asks for confirmation then exits the menu
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "Erase spell%erase-spell '$name' && kill -TERM \$PPID" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Erase spell%erase-spell '$name' && kill -TERM \$PPID" "$exit_item"
                fi
        elif is_installable "$command"; then
                # Show Learn option for spells with install() function
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$exit_item"
                fi
        else
                # Built-in spells: no Erase option
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$exit_item"
                fi
        fi
        
        menu --start-selection "$start_selection" "Spell: $name" "$@" || true
done
}

# This spell provides a menu interface for managing the spellbook.


show_usage() {
        cat <<'USAGE'
Usage: spellbook [PATH|--_memorize NAME CMD|--forget NAME|--scribe NAME CMD|--list]

Open the interactive spellbook to browse categories, scribe commands,
and manage the cast menu. Optionally pass a PATH to jump to a category.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

ROOT_DIR=$(CDPATH= cd -- "$(dirname "$0")/../.." && pwd -P)

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

cast_store=${CAST_STORE-_memorize}
if cast_store_path=$(command -v "$cast_store" 2>/dev/null); then
        cast_store=$cast_store_path
else
        printf '%s\n' "spellbook: _memorize helper _is missing." >&2
        exit 1
fi

cast_dir=$($cast_store dir)

spell_home=$(_env_or SPELLBOOK_DIR "${HOME:-.}/.spellbook")

if [ -d "$spell_home" ]; then
        PATH="$spell_home:$PATH"
fi

ensure_parent_dir() {
        file=$1
        dir=${file%/*}
        if [ "$dir" != "$file" ] && [ ! -d "$dir" ]; then
                mkdir -p "$dir"
        fi
}

validate_name() {
        name=$1
        case $name in
        ''|*[!A-Za-z0-9._-]*)
                printf '%s\n' "spellbook: names may contain only letters, digits, dots, underscores, and dashes (no spaces)." >&2
                exit 1
                ;;
        -*)
                printf '%s\n' "spellbook: names may not begin with a dash." >&2
                exit 1
                ;;
        esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook: command must not be _empty." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\t')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command may not contain tabs." >&2
                exit 1
        fi
        if [ "$(printf '%s' "$cmd" | tr -d '\n')" != "$cmd" ]; then
                printf '%s\n' "spellbook: command must be a single line." >&2
                exit 1
        fi
}

scribed_spell_path() {
        printf '%s/%s' "$spell_home" "$1"
}

write_scribed_script() {
        script_name=$1
        cmd_text=$2
        ensure_parent_dir "$(scribed_spell_path "$script_name")"
        mkdir -p "$spell_home"
        escaped_cmd=$(printf '%s' "$cmd_text" | sed "s/'/'\\''/g")
        cat >"$(scribed_spell_path "$script_name")" <<EOF_SCRIPT
#!/bin/sh
exec sh -c '$escaped_cmd' "\$0" "\$@"
EOF_SCRIPT
        chmod +x "$(scribed_spell_path "$script_name")"
}

# Extract the command from a scribed script file
# Returns _empty string if not a valid scribed script format
# For non-scribed scripts, returns the command if there's exactly one line of sh code
# (excluding shebang, comments, and whitespace)
extract_command_from_script() {
        script_path=$1
        if [ ! -f "$script_path" ]; then
                return 1
        fi
        # First try to extract from scribed format
        # Scripts are in format: exec sh -c 'COMMAND' "$0" "$@"
        result=$(sed -n "s/^exec sh -c '\\(.*\\)' \"\\\$0\" \"\\\$@\"$/\\1/p" "$script_path" | sed "s/'\\\\''/'/g")
        if [ -n "$result" ]; then
                printf '%s' "$result"
                return 0
        fi
        
        # For non-scribed scripts, check if there's exactly one line of code
        # Count meaningful lines (excluding shebang, comments, and whitespace)
        code_lines=$(grep -v '^[[:space:]]*$' "$script_path" | grep -v '^[[:space:]]*#' | wc -l | tr -d ' ')
        if [ "$code_lines" -eq 1 ]; then
                # Return the single code line
                result=$(grep -v '^[[:space:]]*$' "$script_path" | grep -v '^[[:space:]]*#' | head -n 1)
                if [ -n "$result" ]; then
                        printf '%s' "$result"
                        return 0
                fi
        fi
        return 1
}

list_spell_directories() {
        set --
        for dir in "$ROOT_DIR"/spells/*; do
                [ -d "$dir" ] || continue
                [ "$(basename "$dir")" = "menu" ] && continue
                set -- "$@" "$(basename "$dir")"
        done
        printf '%s\n' "$@"
}

spell_categories() {
        list_spell_directories | sort
}

# Convert folder name to display name using the _category_title imp
category_display_name() {
        folder=$1
        if command -v _category_title >/dev/null 2>&1; then
                _category_title "$folder"
        else
                # Fallback if imp not available
                case $folder in
                        enchant)
                                printf '%s' "Enchantment"
                                ;;
                        mud)
                                printf '%s' "MUD"
                                ;;
                        *)
                                # Capitalize first letter
                                first=$(printf '%s' "$folder" | cut -c1 | tr '[:lower:]' '[:upper:]')
                                rest=$(printf '%s' "$folder" | cut -c2-)
                                printf '%s%s' "$first" "$rest"
                                ;;
                esac
        fi
}

# Convert filename to display name: hyphens to spaces, titlecase
filename_to_display() {
        name=$1
        # Convert hyphens to spaces and titlecase each word
        printf '%s' "$name" | awk '{gsub(/-/," "); for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1))tolower(substr($i,2))}}1'
}

safe_command_label() {
        filename=$1
        printf '%s' "$(filename_to_display "$filename")"
}

command_for_spell() {
        spell_path=$1
        name=$(basename "$spell_path")
        if command -v "$name" >/dev/null 2>&1; then
                printf '%s' "$name"
        else
                printf '%s' "$spell_path"
        fi
}

# Resolve a category path by searching in multiple locations.
# If the path starts with ./ or /, use it directly.
# Otherwise, search in: spells/, ~/.spellbook, current directory
resolve_category_path() {
        category=$1
        case $category in
                /*|./*)
                        # Absolute or explicit relative path - use directly
                        if [ -d "$category" ]; then
                                printf '%s' "$category"
                                return 0
                        fi
                        return 1
                        ;;
        esac
        # Search in spells/ directory first
        if [ -d "$ROOT_DIR/spells/$category" ]; then
                printf '%s' "$ROOT_DIR/spells/$category"
                return 0
        fi
        # Search in ~/.spellbook (user spell home)
        if [ -d "$spell_home/$category" ]; then
                printf '%s' "$spell_home/$category"
                return 0
        fi
        # Search in current directory
        if [ -d "$category" ]; then
                printf '%s' "$category"
                return 0
        fi
        return 1
}

list_category_spells() {
        cat_name=$1
        # Use resolve_category_path to find the actual directory
        resolved_path=$(resolve_category_path "$cat_name") || resolved_path="$ROOT_DIR/spells/$cat_name"
        find "$resolved_path" -maxdepth 2 -type f -perm -111 2>/dev/null | sort
}

# List all scribed commands (custom commands in spell_home, excluding built-in spells)
# Only shows truly custom user-created commands, not built-in spells that might have
# been memorized (those should only appear in the Cast menu)
list_scribed_commands() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        # Handle _empty directory by checking if glob matches anything
        set +f  # Enable globbing
        for script in "$spell_home"/*; do
                # Skip if glob didn't match (no files exist)
                [ -e "$script" ] || continue
                [ -f "$script" ] || continue
                [ -x "$script" ] || continue
                script_name=$(basename "$script")
                # Skip hidden files and the .memorized file
                case $script_name in
                        .*) continue ;;
                esac
                # Skip if this command exists elsewhere in PATH (it's a built-in spell, not custom)
                if cmd_path=$(command -v "$script_name" 2>/dev/null); then
                        case "$cmd_path" in
                                "$spell_home"/*) 
                                        # Only found in spell_home - this _is a custom command
                                        ;;
                                *)
                                        # Found in system PATH - skip this built-in spell
                                        continue
                                        ;;
                        esac
                fi
                cmd_text=$(extract_command_from_script "$script")
                if [ -n "$cmd_text" ]; then
                        printf '%s\t%s\n' "$script_name" "$cmd_text"
                fi
        done
}

# List user folders in ~/.spellbook (excluding hidden folders and folders matching built-in categories)
list_user_folders() {
        if [ ! -d "$spell_home" ]; then
                return 0
        fi
        builtin_cats=$(spell_categories)
        for folder in "$spell_home"/*; do
                [ -d "$folder" ] || continue
                folder_name=$(basename "$folder")
                # Skip hidden folders
                case $folder_name in
                        .*) continue ;;
                esac
                # Skip folders that match a built-in category
                is_builtin=0
                for cat in $builtin_cats; do
                        if [ "$folder_name" = "$cat" ]; then
                                is_builtin=1
                                break
                        fi
                done
                [ "$is_builtin" -eq 1 ] && continue
                printf '%s\n' "$folder_name"
        done
}

# Check if a category name _is a built-in category
is_builtin_category() {
        check_name=$1
        for cat in $(spell_categories); do
                if [ "$check_name" = "$cat" ]; then
                        return 0
                fi
        done
        return 1
}

# Check if a path _is inside the spell_home directory (custom spellbook)
is_in_spell_home() {
        check_path=$1
        case "$check_path" in
                "$spell_home"*)
                        return 0
                        ;;
        esac
        return 1
}

# Check if a custom category folder _is _empty (no executable files)
is_custom_category_empty() {
        check_path=$1
        # Must be in spell_home to be a custom category
        if ! is_in_spell_home "$check_path"; then
                return 1
        fi
        # Check if directory has any executable files
        if find "$check_path" -maxdepth 1 -type f -perm -111 2>/dev/null | grep -q .; then
                return 1
        fi
        return 0
}

# Delete an _empty custom category folder
delete_custom_category() {
        cat_path=$1
        if [ -d "$cat_path" ] && is_in_spell_home "$cat_path"; then
                # Only delete if _empty of executable files
                if is_custom_category_empty "$cat_path"; then
                        rm -rf "$cat_path"
                        printf '%s\n' "Deleted category: $(basename "$cat_path")"
                        return 0
                fi
        fi
        return 1
}

# Check if a script _is a scribed command (exists as executable in spell_home)
is_scribed_command() {
        check_name=$1
        script_path=$(scribed_spell_path "$check_name")
        [ -f "$script_path" ] && [ -x "$script_path" ]
}

record_scribed_command() {
        cmd_name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_name "$cmd_name"
        validate_command "$cmd"
        mkdir -p "$spell_home"
        write_scribed_script "$cmd_name" "$cmd"
}

remove_scribed_command() {
        cmd_name=$1
        script_path=$(scribed_spell_path "$cmd_name")
        if [ -f "$script_path" ]; then
                rm -f "$script_path"
                return 0
        fi
        return 1
}

cast_list() {
        "$cast_store" list
}

is_memorized() {
        name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

memorize_spell() {
        name=$1
        shift
        "$cast_store" add "$name" "$@"
}

forget_spell() {
        name=$1
        "$cast_store" remove "$name"
}

prompt_for_input() {
        prompt=$1
        printf '%s' "$prompt"
        IFS= read -r value
        printf '%s' "$value"
}

scribe_command_interactive() {
        cmd_name=$(prompt_for_input "Name: ")
        cmd_text=$(prompt_for_input "Command: ")
        if [ -z "$cmd_name" ] || [ -z "$cmd_text" ]; then
                printf '%s\n' "A name and command are required." >&2
                return 1
        fi
        record_scribed_command "$cmd_name" "$cmd_text"
        printf "Scribed '%s' to %s.\n" "$cmd_name" "$spell_home"
}

spellbook_menu() {
        current_path=${1-}
        first_run=1
        while :; do
                if [ "$first_run" -eq 0 ]; then
                        printf '\n'
                else
                        first_run=0
                fi

                set --
                # Determine the resolved path for non-root views
                resolved_path=""
                in_custom_folder=0
                category_name=""
                if [ -n "$current_path" ]; then
                        # Get the category name (last component of path)
                        category_name=$(basename "$current_path")
                        if resolved_path=$(resolve_category_path "$current_path"); then
                                if is_in_spell_home "$resolved_path"; then
                                        in_custom_folder=1
                                fi
                        else
                                printf '%s\n' "spellbook: category '$current_path' not found" >&2
                                return 1
                        fi
                fi
                
                # Only show three sections at root level (no path argument)
                if [ -z "$current_path" ]; then
                        # SECTION 1: Individual scribed commands (showing command content)
                        while IFS=$(printf '\t') read -r cmd_name cmd_text; do
                                [ -z "$cmd_name" ] && continue
                                # Show the command text as the label
                                label=$(printf '%s' "$cmd_text")
                                set -- "$@" "$label%_spell_menu $cmd_name"
                        done <<SCRIBED_COMMANDS
$(list_scribed_commands)
SCRIBED_COMMANDS
                        
                        # SECTION 2: User folders in ~/.spellbook (if any exist, excluding those matching built-in)
                        user_folders=$(list_user_folders)
                        if [ -n "$user_folders" ]; then
                                # Add divider between commands and user folders
                                set -- "$@" "%--divider--"
                                while IFS= read -r folder_name; do
                                        [ -z "$folder_name" ] && continue
                                        # Don't capitalize - just use the folder name
                                        set -- "$@" "${folder_name}%spellbook $spell_home/$folder_name"
                                done <<USER_FOLDERS
$user_folders
USER_FOLDERS
                        fi
                        
                        # SECTION 3: Built-in spell categories
                        # Add divider between user folders and built-in categories
                        set -- "$@" "%--divider--"
                        for category in $(spell_categories); do
                                # Don't capitalize - just use the folder name
                                set -- "$@" "${category}%spellbook $category"
                        done
                else
                        # Non-root view: show spells from both built-in and custom folders combined
                        # First, list built-in spells
                        builtin_dir="$ROOT_DIR/spells/$category_name"
                        custom_dir="$spell_home/$category_name"
                        
                        # List built-in spells
                        if [ -d "$builtin_dir" ]; then
                                for spell in $(find "$builtin_dir" -maxdepth 1 -type f -perm -111 2>/dev/null | sort); do
                                        spell_name=$(basename "$spell")
                                        set -- "$@" "${spell_name}%_spell_menu $spell_name"
                                done
                        fi
                        
                        # List custom spells from ~/.spellbook/<category> with custom theme color
                        if [ -d "$custom_dir" ]; then
                                for spell in $(find "$custom_dir" -maxdepth 1 -type f -perm -111 2>/dev/null | sort); do
                                        spell_name=$(basename "$spell")
                                        # Use THEME_CUSTOM for custom spell names (distinct from highlight)
                                        set -- "$@" "${THEME_CUSTOM}${spell_name}${RESET}%_spell_menu $spell_name"
                                done
                        fi
                        
                        # List subdirectories (only for navigation, shown after spells)
                        if [ -d "$resolved_path" ]; then
                                for subdir in "$resolved_path"/*; do
                                        [ -d "$subdir" ] || continue
                                        subname=$(basename "$subdir")
                                        set -- "$@" "${subname}%spellbook $resolved_path/$subname"
                                done
                        fi
                fi
                
                # Add "Delete category" option for _empty custom category folders
                if [ -n "$current_path" ] && [ -n "$resolved_path" ] && is_custom_category_empty "$resolved_path"; then
                        # Use escaped path in the command
                        escaped_path=$(printf '%s' "$resolved_path" | sed "s/'/'\\\\''/g")
                        set -- "$@" "Delete category%rm -rf '$escaped_path' && kill -TERM \$PPID"
                fi
                
                # Add "New category" at root level (third-to-last item)
                if [ -z "$current_path" ]; then
                        set -- "$@" "New category%_scribe_spell --new-category"
                fi
                
                # Add "Scribe new spell" as penultimate menu item
                if [ -z "$current_path" ]; then
                        # Root level - create in ~/.spellbook
                        set -- "$@" "Scribe new spell%_scribe_spell"
                else
                        # Category level - create in ~/.spellbook/<category>
                        set -- "$@" "Scribe new spell%_scribe_spell --dir $spell_home/$category_name"
                fi
                
                # Use "Back" when in a submenu, "Exit" at root
                if [ -z "$current_path" ]; then
                        exit_label=$(_exit_label)
                else
                        exit_label="Back"
                fi
                set -- "$@" "${exit_label}%kill -TERM \$PPID"
                
                # Build menu title - use original folder name for category
                if [ -z "$current_path" ]; then
                        menu_title="Spellbook:"
                else
                        menu_title="${category_name}:"
                fi
                menu "$menu_title" "$@" || true
        done
}

spellbook_path=""

case ${1-} in
        --_memorize)
                shift
                if [ "$#" -lt 2 ]; then
                        show_usage >&2
                        exit 1
                fi
                name=$1
                shift
                memorize_spell "$name" "$@"
                exit 0
                ;;
        --forget)
                shift
                if [ "$#" -ne 1 ]; then
                        show_usage >&2
                        exit 1
                fi
                forget_spell "$1"
                exit 0
                ;;
        --list)
                cast_list
                exit 0
                ;;
        --scribe)
                shift
                if [ "$#" -lt 2 ]; then
                        show_usage >&2
                        exit 1
                fi
                name=$1
                shift
                record_scribed_command "$name" "$@"
                printf "Scribed '%s' to %s.\n" "$name" "$spell_home"
                exit 0
                ;;
        --interactive-scribe)
                scribe_command_interactive
                exit $?
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                spellbook_path=${1-}
                ;;
        "")
                :
                ;;
        -*)
                show_usage >&2
                exit 1
                ;;
        *)
                # Treat as a path to a category
                spellbook_path=$1
                ;;
        esac

if ! require menu "The spellbook menu needs the 'menu' command."; then
        exit 1
fi

spellbook_menu "$spellbook_path"
