#!/bin/sh
#
# ------------------------------- priorities -------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: priorities
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined spell: priority-menu
_priority_menu() {

# This spell displays a menu of commands for a prioritized file or folder.
# Use 'priorities' to easily select a priority with this menu.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The Priority menu needs the 'menu' command to present options."; then
  exit 1
fi

FILE="${1-}"

if [ -z "$FILE" ]; then
        printf '%s\n' "priority-menu: file path required." >&2
        exit 1
fi

display_menu() {
        checked_state=$(read-magic "${FILE}" checked)
        if [ "${checked_state}" = "read-magic: attribute does not exist." ]; then
          check_item="Check%echo 'Placeholder: Check command'"
        else
          check_item="Uncheck%echo 'Placeholder: Uncheck command'"
        fi

        filename=$(basename "$FILE")
        exit_label=$(exit-label)
        exit_item="${exit_label}%kill -TERM \$PPID"

        set -- "Prioritize (upboat)%prioritize \"$FILE\"; kill -TERM \$PPID" \
               "${check_item}" \
               "Discard from priorities (downboat)%echo 'Placeholder: Discard command'" \
               "Edit Card%echo 'Placeholder: Edit command'" \
               "Browse Within%echo 'Placeholder: Browse files within this file/folder'" \
               "$exit_item"
        menu "${THEME_HEADING}${filename}${RESET}:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
}

# Inlined spell: read-magic
_read_magic() {

# This spell lists extended attributes from a file, optionally narrowing to one key.
# It walks through existence checks and available helpers in a linear, didactic order.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

require_args() {
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    printf '%s\n' "read-magic: one or two parameters expected (file path and optional attribute name)."
    return 1
  fi
}

file_exists() {
  if [ ! -e "$1" ]; then
    printf '%s\n' "read-magic: file does not exist."
    return 1
  fi
}

# Strip the header line from attr -g output.
# The attr command outputs: Attribute "key" had a N byte value for path:
# followed by the actual value on subsequent lines. We simply remove the first line.
parse_attr_output() {
  printf '%s\n' "$1" | sed '1d'
}

helper_usable() {
  helper=$1
  if ! command -v "$helper" >/dev/null 2>&1; then
    return 1
  fi

  if [ "${WIZARDRY_TEST_HELPERS_ONLY-0}" -eq 1 ]; then
    helper_path=$(command -v "$helper")
    case "$helper_path" in
      /usr/*|/bin/*|/sbin/*|/usr/local/*)
        return 1 ;;
    esac
  fi

  return 0
}

read_value() {
  key=$1
  file=$2

  if helper_usable attr; then
    if output=$(attr -g "$key" "$file" 2>/dev/null); then
      parse_attr_output "$output"
      return 0
    fi
  fi

  if helper_usable xattr; then
    if output=$(xattr -p "$key" "$file" 2>/dev/null); then
      printf '%s' "$output"
      return 0
    fi
  fi

  if helper_usable getfattr; then
    if output=$(getfattr -n "$key" --only-values "$file" 2>/dev/null); then
      printf '%s' "$output"
      return 0
    fi
  fi

  return 1
}

list_keys() {
  file=$1

  if helper_usable attr; then
    if keys=$(attr -l "$file" 2>/dev/null); then
      # Parse attr -l output which may be in format:
      # Attribute "key" has a value...
      # or just: key
      parsed=$(printf '%s\n' "$keys" | awk '
        /^Attribute "/ {
          # Extract key from quoted format: Attribute "key" ...
          if (match($0, /"([^"]+)"/)) {
            key = substr($0, RSTART+1, RLENGTH-2)
            print key
          }
          next
        }
        NF { print }
      ')
      if [ -n "$parsed" ]; then
        printf '%s\n' "$parsed"
        return 0
      fi
    fi
  fi

  if helper_usable xattr; then
    if keys=$(xattr "$file" 2>/dev/null); then
      if [ -n "$keys" ]; then
        printf '%s\n' "$keys"
        return 0
      fi
    fi
  fi

  if helper_usable getfattr; then
    if keys=$(getfattr -d "$file" 2>/dev/null); then
      parsed=$(printf '%s' "$keys" | awk -F '=' '/^# / {next} {print $1}')
      if [ -n "$parsed" ]; then
        printf '%s' "$parsed"
        return 0
      fi
    fi
  fi

  return 1
}

print_all_attributes() {
  file=$1

  keys=$(list_keys "$file" || printf '')

  if [ -z "$keys" ]; then
    printf '%s\n' "No enchanted attributes found."
    return
  fi

  printf '%s\n' "$keys" | while IFS= read -r key || [ -n "$key" ]; do
    [ -z "$key" ] && continue
    value=$(read_value "$key" "$file" || printf '')
    printf '%s: %s\n' "$key" "$value"
  done
}

main() {
  if ! require_args "$@"; then
    exit 1
  fi

  file=$1
  attribute=${2-}

  if ! file_exists "$file"; then
    exit 1
  fi

  if [ -z "$attribute" ]; then
    print_all_attributes "$file"
    exit 0
  fi

  if value=$(read_value "$attribute" "$file"); then
    printf '%s\n' "$value"
  else
    printf '%s\n' "read-magic: attribute does not exist."
    exit 1
  fi
}

main "$@"
}


# This spell displays and manages prioritized items in the current directory.
# Use it to view and reorder files by priority.

show_usage() {
cat <<'USAGE'
Usage: priorities [-v]

Display prioritized items in the current directory as an interactive menu, with -v to show priority numbers.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Initialize verbose flag to 0
verbose=0

# Parse options
while getopts "v" opt; do
  case $opt in
    v) verbose=1 ;; # If -v _is passed, set verbose to 1
    \?) printf '%s\n' "Invalid option: -$OPTARG" >&2 ;; # Invalid option
  esac
done
shift $((OPTIND-1)) # Shift off the options and optional --.

# Function to display priorities
display_priorities() {
  # Get directory
  DIR="${PWD}"

  # Get the current priorities of the directory
  dir_priorities=$(_read_magic "${DIR}" priorities)

  # If there are no priorities, print an error message and exit
  if [ -z "${dir_priorities}" ] || [ "$dir_priorities" = "_read_magic: attribute does not exist." ]; then
    echo "No priorities set in the current folder. Try 'prioritize <filename>'."
    exit 1
  fi

  # Initialize variables
  highest_priority=""
  line_added=false
  menu_command="menu Priorities:"

  # Loop through the priorities
  dir_priorities=$(echo "${dir_priorities}" | tr ',' '\n')

  for priority_hash in $dir_priorities; do
    # Get the priority file
    priority_file=$(get-card "${priority_hash}")

    # Check if the file exists
    if [ -n "${priority_file}" ]; then
      # Get priority of the file
      file_priority=$(_read_magic "${priority_file}" priority 2>/dev/null)
      
      # If the file does not have a priority, set it to 0
      if [ -z "${file_priority}" ] || [ "$file_priority" = "_read_magic: attribute does not exist." ]; then
        file_priority=0
      fi

      # If the priority of the file _is a number
      if [ "${file_priority}" -eq "${file_priority}" ] 2>/dev/null; then
        # If the file's priority _is not the highest priority, add a line
        if [ -n "${highest_priority}" ] && [ "${file_priority}" -ne "${highest_priority}" ] && [ "${line_added}" = false ]; then
          menu_command="${menu_command} \"─── %\""
          line_added=true
        fi

        # Add the file to the menu command
        menu_command="${menu_command} \""
        if [ $verbose -eq 1 ]; then
          menu_command="${menu_command}${file_priority} "
        fi
        item_name=$(basename "$priority_file")
        menu_command="${menu_command}$item_name%_priority_menu \\\"${priority_file}\\\"\""

        # Update the highest priority
        highest_priority="${file_priority}"
      fi
    fi
  done

  # Add exit command
  exit_label=$(_exit_label)
  menu_command="${menu_command} \"${exit_label}%kill -TERM \$PPID\""

  # Execute the constructed menu command
  eval "${menu_command}"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_priorities || true
done
