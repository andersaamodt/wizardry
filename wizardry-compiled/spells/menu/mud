#!/bin/sh
#
# ---------------------------------- mud -----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: mud
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: detect-distro
_detect_distro() {

# Bootstrap spell: prints a short identifier for the current OS.
# Use -v to narrate detection while exporting DISTRO for callers.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Parse flags for verbose output or help text.
verbose=0
while getopts hv opt
do
        case $opt in
        v)
                verbose=1
                ;;
        h)
                show_usage
                exit 0
                ;;
        *)
                show_usage >&2
                exit 1
                ;;
        esac
done
shift $((OPTIND - 1))

if [ "$#" -ne 0 ]; then
        show_usage >&2
        exit 1
fi

root_prefix=${DETECT_DISTRO_ROOT:-}
os_release_path=${DETECT_DISTRO_OS_RELEASE:-"${root_prefix}/etc/os-release"}
root_prefix=${root_prefix%/}
case $root_prefix in
        /*|'') : ;;
        *) root_prefix=/$root_prefix ;;
esac

os_release_id() {
        if [ ! -f "$os_release_path" ]; then
                return 1
        fi

        awk -F= 'tolower($1) == "id" { gsub(/"/, "", $2); print tolower($2) }' "$os_release_path"
}

detect_uname() {
        if [ -n "${DETECT_DISTRO_UNAME-}" ]; then
                printf '%s' "$DETECT_DISTRO_UNAME"
                return 0
        fi

        if uname >/dev/null 2>&1; then
                uname
        fi
}

file_exists() {
        [ -f "${root_prefix}$1" ]
}

# Detect from specific markers toward the generic uname fallback.
os_id=$(os_release_id || true)

if file_exists "/etc/NIXOS" || [ "${os_id-}" = "nixos" ]; then
        distro='nixos'
elif file_exists "/etc/debian_version"; then
        distro='debian'
elif file_exists "/etc/arch-release"; then
        distro='arch'
elif file_exists "/etc/fedora-release"; then
        distro='fedora'
elif [ "${os_id-}" = "debian" ] || [ "${os_id-}" = "ubuntu" ] || [ "${os_id-}" = "raspbian" ]; then
        distro='debian'
elif [ "${os_id-}" = "arch" ]; then
        distro='arch'
elif [ "${os_id-}" = "fedora" ]; then
        distro='fedora'
else
        kernel_name=$(detect_uname || true)
        if [ "${kernel_name-}" = "Darwin" ]; then
                distro='mac'
        fi
fi

# Export the detection so callers can key off the result.
if [ -n "${distro-}" ]; then
        DISTRO=$distro
        export DISTRO
else
        printf '%s\n' 'unknown'
        exit 1
fi

if [ "$verbose" -eq 1 ]; then
        case $DISTRO in
        debian)
                printf '%s\n' 'Debian, Ubuntu, or Raspbian OS detected.'
                ;;
        arch)
                printf '%s\n' 'Arch or Manjaro-based OS detected.'
                ;;
        fedora)
                printf '%s\n' 'Fedora detected as the operating system.'
                ;;
        mac)
                printf '%s\n' 'MacOS detected.'
                ;;
        nixos)
                printf '%s\n' 'NixOS detected.'
                ;;
        esac
else
        printf '%s\n' "$DISTRO"
fi
}

# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined spell: jump-to-marker
_jump_to_marker() {

# This spell teleports to markers set with mark-location.
# Source this file or use word-of-binding to invoke it.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
-*)
        warn "jump-to-marker: unknown option '$1'."
        exit 1
        ;;
esac


# Resolve markers directory
_jm_spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
MARKERS_DIR=$(env-or JUMP_TO_MARKERS_DIR "$_jm_spell_home/.markers")

# jump_portal_messages preserves every line of flavor text from the original
# spell and sprinkles in a few new sensations for modern teleportation.
jump_portal_messages() {
	cat <<'PORTAL'
You feel a sudden warmth as you are enveloped in a glowing aura. When it fades, you find yourself at your destination.
A strange sensation comes over you as you close your eyes. When you open them again, you are standing at your destination.
You focus your mind on the marked location and feel yourself being pulled through the fabric of space. You open your eyes to find yourself at your destination.
You feel a jolt as you are momentarily suspended in midair. When you land, you find yourself at your destination.
You close your eyes and take a deep breath. When you open them, you are standing at your destination.
A swirling vortex appears before you. You take a step forward and find yourself at your destination.
You feel a tug on your stomach as you are suddenly pulled through a tunnel of light. When you emerge, you are at your destination.
You hold out your hand and a bright portal appears. You step through and find yourself at your destination.
You feel a rush of wind as you are teleported to your destination.
You hear a faint ringing in your ears as you are transported to your destination.
You close your eyes and visualize your destination. When you open them, you are standing there.
You step into a glowing portal and are immediately transported to your destination.
You feel a tug on your ankle as you are pulled through a wormhole. When you emerge, you are at your destination.
You hear a faint hum as you are enveloped in a field of energy. When it dissipates, you are at your destination.
You feel a sudden pressure on your chest as you are teleported to your destination.
You feel a surge of magical energy as you are transported through the veil of reality.
A glowing portal opens before you, and you step through it to your destination.
A shimmering aura envelops you, and when it fades, you find yourself at the marked location.
You close your eyes and focus, and when you open them again, you are standing at the marked location.
A burst of light and sound surrounds you, and when it subsides, you are at the marked location.
You feel a tug on your soul, and when it releases, you are standing at the marked location.
You focus your magical energy and teleport to the marked location.
A warp in the fabric of reality opens up, and you step through it to the marked location.
You feel a sudden jolt, and when you regain your bearings, you are at the marked location.
You close your eyes and visualize the marked location, and when you open them, you are there.
You call upon the power of the elements to transport you to the marked location.
You channel the energy of the celestial bodies to jump to the marked location.
You recite an ancient incantation, and a magical portal appears, taking you to the marked location.
A shimmering rune circle flares beneath your feet.
You step through a swirling vortex of starlight.
A gust of glittering dust whips past as space folds around you.
Your stomach flips as ley-lines knit a tunnel through reality.
A bell tolls softly as the air warps into a crystalline doorway.
You whisper the coordinates and a ribbon of light drags you forward.
A ripple of color cascades outward before snapping you elsewhere.
The scent of ozone and old tomes surrounds you mid-teleport.
A chalk sigil burns bright, then launches you into the void.
You ride a comet of sparks toward the marked destination.
A murmured incantation bends distance like molten glass.
Reality hiccups; when it steadies, you are already in motion.
PORTAL
}

jump_random_message() {
jump_portal_messages | awk 'BEGIN{srand();}{lines[NR]=$0}END{if (NR==0) exit 0; idx=int(rand()*NR)+1; print lines[idx];}'
}

jump_describe_current_location() {
if has look; then
        look 2>/dev/null || true
fi
}

# Get all available marker names, sorted with numbers first then alphabetical
jump_list_markers() {
        markers_dir=$MARKERS_DIR
        if [ ! -d "$markers_dir" ]; then
                return 1
        fi
        # List numeric markers sorted numerically, then non-numeric sorted alphabetically
        numeric_markers=""
        alpha_markers=""
        for marker in "$markers_dir"/*; do
                [ -f "$marker" ] || continue
                name=$(file-name "$marker")
                # Skip hidden files
                case "$name" in
                        .*) continue ;;
                esac
                # Separate numeric and non-numeric markers
                case "$name" in
                        *[!0-9]*)
                                alpha_markers="$alpha_markers $name"
                                ;;
                        *)
                                numeric_markers="$numeric_markers $name"
                                ;;
                esac
        done
        # Sort and output: numbers first (numerically), then names (alphabetically)
        for n in $(printf '%s\n' $numeric_markers | sort -n); do
                printf '%s\n' "$n"
        done
        for n in $(printf '%s\n' $alpha_markers | sort); do
                printf '%s\n' "$n"
        done
}

# Get the most recently used marker (by mtime)
# Returns empty if all markers have the same mtime (fresh state)
# or if the most recent marker is older than 4 hours (reset timeout)
jump_most_recent_marker() {
        markers_dir=$MARKERS_DIR
        if [ ! -d "$markers_dir" ]; then
                return 1
        fi
        # Find the most recently modified marker file (excluding hidden files)
        # Using ls -t to sort by mtime, newest first
        sorted=$(ls -t "$markers_dir" 2>/dev/null)
        recent=$(printf '%s\n' "$sorted" | head -1)
        oldest=$(printf '%s\n' "$sorted" | tail -1)
        
        # Need at least two different files to have meaningful "most recent"
        if [ -z "$recent" ] || [ ! -f "$markers_dir/$recent" ] || [ "$recent" = "$oldest" ]; then
                return 1
        fi
        
        # Check if mtimes are actually different (ls -t may sort alphabetically when equal)
        # Use stat to get mtime: -c %Y for GNU/Linux, -f %m for BSD/macOS
        recent_mtime=$(stat -c %Y "$markers_dir/$recent" 2>/dev/null) || \
                      recent_mtime=$(stat -f %m "$markers_dir/$recent" 2>/dev/null)
        oldest_mtime=$(stat -c %Y "$markers_dir/$oldest" 2>/dev/null) || \
                      oldest_mtime=$(stat -f %m "$markers_dir/$oldest" 2>/dev/null)
        
        if [ "$recent_mtime" != "$oldest_mtime" ]; then
                # Check if the most recent marker is older than 4 hours
                # If so, reset cycling (return empty to start at "1")
                current_time=$(now)
                four_hours=$((4 * 60 * 60))
                age=$((current_time - recent_mtime))
                if [ "$age" -gt "$four_hours" ]; then
                        return 1
                fi
                printf '%s\n' "$recent"
                return 0
        fi
        return 1
}

# Get next marker in sequence for cycling
jump_next_marker() {
        current=$1
        all_markers=$(jump_list_markers)
        if [ -z "$all_markers" ]; then
                printf '%s\n' "1"
                return
        fi
        found=0
        first=""
        for m in $all_markers; do
                if [ -z "$first" ]; then
                        first=$m
                fi
                if [ "$found" -eq 1 ]; then
                        printf '%s\n' "$m"
                        return
                fi
                if [ "$m" = "$current" ]; then
                        found=1
                fi
        done
        # Wrap around to first marker
        printf '%s\n' "$first"
}

jump_to_marker_impl() {
        markers_dir=$MARKERS_DIR
        marker_name="${1:-}"
        
        # If no marker specified OR marker is "0", cycle through markers
        # (jump 0 is equivalent to jump with no args)
        if [ -z "$marker_name" ] || [ "$marker_name" = "0" ]; then
                # Find the most recently used marker (by mtime) and get the next one
                # This enables cycling: jump touches the marker, making it "most recent",
                # then next jump cycles to the following marker
                # If no recent marker found (all same mtime = fresh state), start at "1"
                last_marker=$(jump_most_recent_marker || true)
                if [ -n "$last_marker" ]; then
                        marker_name=$(jump_next_marker "$last_marker")
                else
                        marker_name="1"
                fi
        fi
        
        marker_file="$markers_dir/$marker_name"
        
        # Check for markers directory
        if [ ! -d "$markers_dir" ]; then
                say "No markers have been set. Use 'mark-location' to mark a location first."
                return 1
        fi
        
        # Check for specific marker file
        if [ ! -f "$marker_file" ]; then
                say "No marker '$marker_name' found. Use 'mark-location $marker_name' to set it."
                # List available markers
                available=$(jump_list_markers || true)
                if [ -n "$available" ]; then
                        printf '%s' "Available markers: "
                        printf '%s\n' "$available" | tr '\n' ' '
                        printf '\n'
                fi
                return 1
        fi
        
        destination=$(cat "$marker_file")
        if [ -z "$destination" ]; then
                say "The rune '$marker_name' is blank; the marked location has faded away."
                return 1
        fi
        if [ ! -d "$destination" ]; then
                say "The ley-line remembers '$destination' for marker '$marker_name', but it no longer exists."
                return 1
        fi
        # Normalize paths to handle macOS double slashes
        current=$(here | norm-path)
        normalized_destination=$(norm-path "$destination")
        if [ "$current" = "$normalized_destination" ]; then
                say "You are already standing at marker '$marker_name'."
                # Touch marker to update mtime for cycling
                touch "$marker_file"
                return 0
        fi
        if ! cd "$destination"; then
                warn "The portal refuses to stabilize; try marking again."
                return 1
        fi
        arrival=$(jump_random_message)
        if [ -n "$arrival" ]; then
                say "$arrival"
        fi
        
        # Touch marker to update mtime for cycling
        touch "$marker_file"
        
jump_describe_current_location
}

# Self-execute when run directly (not sourced)
case "$0" in
  */jump-to-marker|*/jump) jump_to_marker_impl "$@" ;; esac
}

# Inlined spell: mud-admin-menu
_mud_admin_menu() {

# This spell displays the menu for adminning hosting a MUD server.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The MUD Admin menu needs the 'menu' command to present options."; then
  exit 1
fi

display_menu() {
  add="Add authorized player%add-player"
  list_players="List authorized players%new-player"
  list_rooms="List shared rooms%list-rooms"
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$add" "$list_players" "$list_rooms" "$exit_item"
  menu "MUD Admin:" "$@"
}

loop_limit=${MENU_LOOP_LIMIT:-}
first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true

  # Support MENU_LOOP_LIMIT for testing
  if [ -n "$loop_limit" ]; then
    loop_limit=$((loop_limit - 1))
    if [ "$loop_limit" -le 0 ]; then
      break
    fi
  fi
done
}

# Inlined spell: mud-settings
_mud_settings() {

# This spell displays the MUD settings menu.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The MUD Settings menu needs the 'menu' command to present options."; then
  exit 1
fi

# Check if player key exists
has_player_key() {
  if [ -n "${MUD_PLAYER-}" ] && [ -f "$HOME/.ssh/${MUD_PLAYER}.pub" ]; then
    return 0
  fi
  # Check for any player key in ~/.ssh with common naming patterns
  # Use nullglob-safe pattern matching
  for key in "$HOME"/.ssh/*.pub; do
    # Skip if glob didn't match (returns literal *.pub)
    [ -e "$key" ] || continue
    [ -f "$key" ] && return 0
  done
  return 1
}

display_menu() {
  # Show appropriate player key option based on whether key exists
  if has_player_key; then
    player_key_item="Copy player key to clipboard%copy ~/.ssh/\$MUD_PLAYER.pub"
  else
    player_key_item="Create player key%new-player"
  fi
  
  change="Change Player%select-player"
  new="New Player%new-player"
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- "$player_key_item" "$change" "$new" "$exit_item"
  menu "MUD Settings:" "$@"
}

loop_limit=${MENU_LOOP_LIMIT:-}
first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true

  # Support MENU_LOOP_LIMIT for testing
  if [ -n "$loop_limit" ]; then
    loop_limit=$((loop_limit - 1))
    if [ "$loop_limit" -le 0 ]; then
      break
    fi
  fi
done
}

# This spell displays the main MUD (Multi-User Dungeon) menu interface.


show_usage() {
  cat <<'USAGE'
Usage: mud

Displays the MUD (Multi-User Dungeon) menu.
USAGE
}

case "${1-}" in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
esac

set -eu

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The MUD menu needs the 'menu' command to present options."; then
  exit 1
fi

# Get platform-specific portal chamber location
get_portal_location() {
  platform=$(_detect_distro 2>/dev/null || printf 'unknown')
  case "$platform" in
    mac)
      # macOS uses /Volumes for mounted drives
      printf '%s' "/Volumes"
      ;;
    *)
      # Linux and others use /mnt
      printf '%s' "/mnt"
      ;;
  esac
}

display_menu() {
  portal_location=$(get_portal_location)
  
  look="Look Around%look"
  home="Teleport Home%cd"
  jump="Teleport to Marker%_jump_to_marker"
  portal="Teleport to Portal Chamber%cd $portal_location"
  admin="Admin MUD Hosting%_mud_admin_menu"
  settings="MUD Settings%_mud_settings"
  exit_label=$(_exit_label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  set -- \
    "$look" \
    "$home" \
    "$jump" \
    "$portal" \
    "$admin" \
    "$settings" \
    "$exit_item"
  menu "MUD Menu:" "$@"
}

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
