#!/bin/sh
#
# ------------------------------- spell-menu -------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: spell-menu
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: env-or
_env_or() {
  _eo_var=$1
  # Validate variable name contains only alphanumerics and underscores
  case "$_eo_var" in
    *[!A-Za-z0-9_]*|"")
      printf '%s\n' "$2"
      return
      ;;
  esac
  eval "_eo_val=\${$_eo_var-}"
  if [ -n "$_eo_val" ]; then
    printf '%s\n' "$_eo_val"
  else
    printf '%s\n' "$2"
  fi
}

# Inlined spell: erase-spell
_erase_spell() {
# erase-spell - Delete a custom spell from $SPELLBOOK_DIR
# Asks for confirmation before deleting.


spell_home=$(env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook")


find_custom_spell() {
        name=$1
        # Check in spell_home root
        script_path="$spell_home/$name"
        if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                printf '%s' "$script_path"
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$name"
                if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                        printf '%s' "$script_path"
                        return 0
                fi
        done
        return 1
}

force=0
name=""

while [ "$#" -gt 0 ]; do
        case $1 in
                --help|--usage|-h)
                        show_usage
                        exit 0
                        ;;
                --force|-f)
                        force=1
                        shift
                        ;;
                -*)
                        printf 'erase-spell: unknown option: %s\n' "$1" >&2
                        exit 1
                        ;;
                *)
                        if [ -z "$name" ]; then
                                name=$1
                        else
                                printf 'erase-spell: unexpected argument: %s\n' "$1" >&2
                                exit 1
                        fi
                        shift
                        ;;
        esac

done

if [ -z "$name" ]; then
        show_usage >&2
        exit 1
fi

# Find the spell
script_path=$(find_custom_spell "$name") || {
        printf 'erase-spell: spell "%s" not found in %s\n' "$name" "$spell_home" >&2
        exit 1
}

# Check if it's actually in spell_home (not a built-in spell)
case "$script_path" in
        "$spell_home"/*)
                : # OK, it's a custom spell
                ;;
        *)
                printf 'erase-spell: "%s" is not a custom spell and cannot be erased\n' "$name" >&2
                exit 1
                ;;
esac

# Ask for confirmation unless --force
if [ "$force" -eq 0 ]; then
        printf 'Erase spell "%s"? This cannot be undone. (y/N) ' "$name"
        read -r answer
        case $answer in
                [Yy]|[Yy][Ee][Ss])
                        : # proceed
                        ;;
                *)
                        printf 'Aborted.\n'
                        exit 0
                        ;;
        esac
fi

# Delete the spell
rm -f "$script_path"
printf 'Erased spell "%s".\n' "$name"
}

# Inlined imp: exit-label
_exit_label() {
  printf '%s' "Exit"
}

# Inlined imp: is-installable
_is_installable() {
  if [ -z "${1-}" ]; then
    return 1
  fi

  _ii_spell_cmd=$1
  _ii_spell_path=$(command -v "$_ii_spell_cmd" 2>/dev/null) || _ii_spell_path=$_ii_spell_cmd

  if [ ! -r "$_ii_spell_path" ]; then
    return 1
  fi

  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$_ii_spell_path" 2>/dev/null
}

# Inlined spell: memorize
_memorize() {

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory


spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
	cast_dir=$1
	if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
		file=$(expand_tilde "$WIZARDRY_CAST_FILE")
	elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
		file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
	else
		file=$cast_dir/.memorized
	fi
	printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
	if [ ! -d "$cast_dir" ]; then
		mkdir -p "$cast_dir"
	fi
	dir=${command_file%/*}
	if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_name() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "$spell_name: names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

nonempty() {
	[ -n "$1" ]
}

add_spell() {
	name=$1
	validate_name "$name"
	ensure_parent_directory
	# Memorize just lists existing spells by name - no wrapper scripts needed
	# The spell must already exist in PATH or spellbook
	cmd=$name
	tmp=$(temp-file memorize) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	if [ -f "$command_file" ]; then
		while IFS= read -r line || nonempty "$line"; do
			entry_name=$line
			case $line in
			*"$tab_char"*)
				entry_name=${line%%"$tab_char"*}
				;;
			esac
			if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
				continue
			fi
			printf '%s\n' "$line" >>"$tmp"
		done <"$command_file"
	fi
	printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
	if [ -f "$tmp" ]; then
		cat "$tmp" >>"$command_file"
	fi
	trap - EXIT HUP INT TERM
	rm -f "$tmp"
}

list_entries() {
	if [ -f "$command_file" ]; then
		cat "$command_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1

case $action in
list)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$command_file"
	;;
dir)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$cast_dir"
	;;
--help|--usage|-h)
	show_usage
	;;
-*)
	printf '%s\n' "$spell_name: unknown option '$action'" >&2
	show_usage
	exit 1
	;;
*)
	# Default action: memorize the spell
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "$spell_name: expects exactly one spell name." >&2
		show_usage
		exit 1
	fi
	add_spell "$action"
	;;
esac
}

# spell-menu - Display action menu for a spell or custom command
# Shows options: Cast now, Memorize/Forget, Help, Test spell, Delete (for custom)

# Self-healing: Create spellbook directory if missing
create_spellbook_if_missing() {
        spellbook_dir="${XDG_DATA_HOME:-$HOME/.local/share}/wizardry/spellbook"
        if ! [ -d "$spellbook_dir" ]; then
                mkdir -p "$spellbook_dir" 2>/dev/null || {
                        spellbook_dir="${TMPDIR:-/tmp}/wizardry-spellbook-$$"
                        mkdir -p "$spellbook_dir"
                }
        fi
        printf '%s' "$spellbook_dir"
}

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

# Load color palette (colors handles terminal capability detection internally)
# Provide fallback if colors not available
if command -v colors >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$(command -v colors)"
else
        # Minimal fallback - define color functions as no-ops
        reset() { :; }
        bold() { :; }
        dim() { :; }
        red() { :; }
        green() { :; }
        yellow() { :; }
        blue() { :; }
        magenta() { :; }
        cyan() { :; }
fi

# Get spell home directory with fallback
if command -v _env_or >/dev/null 2>&1; then
        spell_home=$(_env_or SPELLBOOK_DIR "${HOME:-.}/.spellbook")
else
        spell_home="${SPELLBOOK_DIR:-${HOME:-.}/.spellbook}"
fi
[ -d "$spell_home" ] || mkdir -p "$spell_home" 2>/dev/null || spell_home=$(create_spellbook_if_missing)

cast_list() {
        if command -v _memorize >/dev/null 2>&1; then
                _memorize list
        else
                # Fallback: list files directly from spellbook
                cast_dir=$(create_spellbook_if_missing)
                for f in "$cast_dir"/*; do
                        [ -f "$f" ] || continue
                        name=$(basename "$f")
                        cmd=$(cat "$f" 2>/dev/null || printf '')
                        [ -n "$cmd" ] && printf '%s\t%s\n' "$name" "$cmd"
                done
        fi
}

is_memorized() {
        check_name=$1
        while IFS=$(printf '\t') read -r alias _; do
                if [ "$alias" = "$check_name" ]; then
                        return 0
                fi
        done <<ENTRIES
$(cast_list)
ENTRIES
        return 1
}

do_memorize() {
        mem_name=$1
        shift
        _memorize add "$mem_name" "$@"
}

do_forget() {
        mem_name=$1
        _memorize remove "$mem_name"
}

# Check if a script is a custom spell (user-created, not a built-in spell)
# Custom spells are user-created commands that exist ONLY in spell_home (not in system PATH)
# Built-in spells that happen to be in PATH are NOT custom spells
is_custom_spell() {
        check_name=$1
        
        # First, check if this is a built-in spell (exists in PATH outside of spell_home)
        # If so, it's NOT a custom spell, even if memorized
        if cmd_path=$(command -v "$check_name" 2>/dev/null); then
                case "$cmd_path" in
                        "$spell_home"/*) 
                                # Found in spell_home - could be custom, check below
                                ;;
                        *)
                                # Found elsewhere in PATH - this is a built-in spell, not custom
                                return 1
                                ;;
                esac
        fi
        
        # Check if custom script exists in spell_home root
        script_path="$spell_home/$check_name"
        if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$check_name"
                if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                        return 0
                fi
        done
        return 1
}

# Check if a spell has an install() function (making it installable)
# Uses the _is_installable imp if available, otherwise falls back to inline check
is_installable() {
        spell_cmd=$1
        if command -v _is_installable >/dev/null 2>&1; then
                _is_installable "$spell_cmd"
                return $?
        fi
        # Fallback: inline check
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        if grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

# Check if a spell has a --help option
has_help_option() {
        spell_cmd=$1
        spell_path=$(command -v "$spell_cmd" 2>/dev/null) || spell_path=$spell_cmd
        if [ ! -r "$spell_path" ]; then
                return 1
        fi
        # Check if the script contains --help or -h handling
        if grep -Eq '(--help|-h\))' "$spell_path" 2>/dev/null; then
                return 0
        fi
        return 1
}

show_usage() {
        cat <<'USAGE'
Usage: spell-menu <spell-name>

Display an action menu for a spell with options to cast, _memorize,
get help, or erase.
USAGE
}

# Handle action flags (called by menu via subprocess)
case ${1-} in
        --cast)
                shift
                eval "$*"
                exit 0
                ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --install)
                shift
                # The command is already escaped when passed to this handler
                # Run the spell with --install flag to trigger its install() function
                cmd=$1
                # Use eval since command might contain arguments/quotes
                # The caller has already escaped the command properly
                eval "$cmd" --install || true
                exit 0
                ;;
esac

set -eu

if [ "$#" -lt 1 ]; then
        show_usage >&2
        exit 1
fi

name=$1
# The command is the spell name (which is executable either as scribed command or from PATH)
command=$name

if ! require menu "The spell menu needs the 'menu' command."; then
        exit 1
fi

# Escape single quotes in command for safe passing
escaped_command=$(printf '%s' "$command" | sed "s/'/'\\\\''/g")

first_run=1
start_selection=1
was_memorized=0

while :; do
        if [ "$first_run" -eq 0 ]; then
                printf '\n'
                # Check if memorization state changed (toggle was used)
                if is_memorized "$name"; then
                        now_memorized=1
                else
                        now_memorized=0
                fi
                if [ "$was_memorized" != "$now_memorized" ]; then
                        # Toggle was selected - keep cursor on toggle item (item 2)
                        start_selection=2
                else
                        # Other action - reset to first item
                        start_selection=1
                fi
        else
                first_run=0
        fi

        # Check current memorization state and build toggle label
        if is_memorized "$name"; then
                was_memorized=1
                cast_toggle="[X] Forget%forget '$name'"
        else
                was_memorized=0
                cast_toggle="[ ] Memorize%_memorize '$name'"
        fi
        # Build menu items - Cast now runs the command directly (using escaped version for safety)
        exit_label=$(_exit_label)
        exit_item="${exit_label}%kill -TERM \$PPID"
        
        # Check if spell has --help option
        help_item=""
        if has_help_option "$command"; then
                help_item="Help%$escaped_command --help"
        fi
        
        if is_custom_spell "$name"; then
                # Custom spells (in ~/.spellbook or subfolders) show Erase spell option
                # Use _erase_spell which asks for confirmation then exits the menu
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "Erase spell%_erase_spell '$name' && kill -TERM \$PPID" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Erase spell%_erase_spell '$name' && kill -TERM \$PPID" "$exit_item"
                fi
        elif is_installable "$command"; then
                # Show Learn option for spells with install() function
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "Learn%spell-menu --install '$escaped_command'" "$exit_item"
                fi
        else
                # Built-in spells: no Erase option
                if [ -n "$help_item" ]; then
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$help_item" "$exit_item"
                else
                        set -- "Cast now%$escaped_command" "$cast_toggle" "$exit_item"
                fi
        fi
        
        menu --start-selection "$start_selection" "Spell: $name" "$@" || true
done
