#!/bin/sh
#
# ------------------------------- test-magic -------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: test-magic
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined spell: detect-distro
_detect_distro() {

# Bootstrap spell: prints a short identifier for the current OS.
# Use -v to narrate detection while exporting DISTRO for callers.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


# Parse flags for verbose output or help text.
verbose=0
while getopts hv opt
do
        case $opt in
        v)
                verbose=1
                ;;
        h)
                show_usage
                exit 0
                ;;
        *)
                show_usage >&2
                exit 1
                ;;
        esac
done
shift $((OPTIND - 1))

if [ "$#" -ne 0 ]; then
        show_usage >&2
        exit 1
fi

root_prefix=${DETECT_DISTRO_ROOT:-}
os_release_path=${DETECT_DISTRO_OS_RELEASE:-"${root_prefix}/etc/os-release"}
root_prefix=${root_prefix%/}
case $root_prefix in
        /*|'') : ;;
        *) root_prefix=/$root_prefix ;;
esac

os_release_id() {
        if [ ! -f "$os_release_path" ]; then
                return 1
        fi

        awk -F= 'tolower($1) == "id" { gsub(/"/, "", $2); print tolower($2) }' "$os_release_path"
}

detect_uname() {
        if [ -n "${DETECT_DISTRO_UNAME-}" ]; then
                printf '%s' "$DETECT_DISTRO_UNAME"
                return 0
        fi

        if uname >/dev/null 2>&1; then
                uname
        fi
}

file_exists() {
        [ -f "${root_prefix}$1" ]
}

# Detect from specific markers toward the generic uname fallback.
os_id=$(os_release_id || true)

if file_exists "/etc/NIXOS" || [ "${os_id-}" = "nixos" ]; then
        distro='nixos'
elif file_exists "/etc/debian_version"; then
        distro='debian'
elif file_exists "/etc/arch-release"; then
        distro='arch'
elif file_exists "/etc/fedora-release"; then
        distro='fedora'
elif [ "${os_id-}" = "debian" ] || [ "${os_id-}" = "ubuntu" ] || [ "${os_id-}" = "raspbian" ]; then
        distro='debian'
elif [ "${os_id-}" = "arch" ]; then
        distro='arch'
elif [ "${os_id-}" = "fedora" ]; then
        distro='fedora'
else
        kernel_name=$(detect_uname || true)
        if [ "${kernel_name-}" = "Darwin" ]; then
                distro='mac'
        fi
fi

# Export the detection so callers can key off the result.
if [ -n "${distro-}" ]; then
        DISTRO=$distro
        export DISTRO
else
        printf '%s\n' 'unknown'
        exit 1
fi

if [ "$verbose" -eq 1 ]; then
        case $DISTRO in
        debian)
                printf '%s\n' 'Debian, Ubuntu, or Raspbian OS detected.'
                ;;
        arch)
                printf '%s\n' 'Arch or Manjaro-based OS detected.'
                ;;
        fedora)
                printf '%s\n' 'Fedora detected as the operating system.'
                ;;
        mac)
                printf '%s\n' 'MacOS detected.'
                ;;
        nixos)
                printf '%s\n' 'NixOS detected.'
                ;;
        esac
else
        printf '%s\n' "$DISTRO"
fi
}

# Inlined imp: fail
_fail() {
  printf '%s\n' "$*" >&2
  return 1
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}

# Inlined spell: verify-posix
_verify_posix() {

# Verify that wizardry spells use POSIX-compliant shell practices.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)

# Add imps to PATH so we can use temp-file and cleanup-file directly
if [ -d "$repo_dir/spells/.imps" ]; then
  PATH="$repo_dir/spells/.imps:$PATH"
  for impdir in "$repo_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
  export PATH
fi

checkbashisms_cmd=${CHECKBASHISMS-}
if [ -z "$checkbashisms_cmd" ] && command -v checkbashisms >/dev/null 2>&1; then
  checkbashisms_cmd=$(command -v checkbashisms)
fi

if [ -z "$checkbashisms_cmd" ]; then
  printf '%s\n' "verify-posix: checkbashisms is required but not found in PATH." >&2
  exit 1
fi

gather_default_targets() {
  find "$repo_dir/spells" -type f \( -perm -u+x -o -perm -g+x -o -perm -o+x \) \
    -print | sort | while IFS= read -r file; do
      first_line=$(sed -n '1p' "$file")
      case $first_line in
        '#!/bin/sh'|'#! /bin/sh'|'#!/usr/bin/env sh'|'#! /usr/bin/env sh')
          printf '%s\n' "${file#"$repo_dir/"}"
          ;;
      esac
    done
}

collect_targets() {
  if [ "$#" -gt 0 ]; then
    printf '%s\n' "$@"
  else
    gather_default_targets
  fi
}

failures=0
total=0
failed_targets=""

targets_file=$(temp-file verify-posix-targets) || exit 1
trap 'cleanup-file "$targets_file"' EXIT HUP INT TERM
collect_targets "$@" >"$targets_file"

while IFS= read -r target; do
  [ -n "$target" ] || continue
  total=$((total + 1))

  case $target in
    /*)
      path="$target"
      ;;
    *)
      path="$repo_dir/$target"
      ;;
  esac

  if [ ! -e "$path" ]; then
    printf 'FAIL %s: missing file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi

  if [ ! -f "$path" ]; then
    printf 'FAIL %s: not a regular file\n' "$target"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
    continue
  fi

  shebang=$(sed -n '1p' "$path")

  case $shebang in
    '')
      printf 'FAIL %s: lacks a shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    '#!')
      printf 'FAIL %s: has an empty shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    '#!'*)
      interpreter=${shebang#\#!}
      while [ "${interpreter# }" != "$interpreter" ]; do
        interpreter=${interpreter# }
      done
      ;;
    *)
      printf 'FAIL %s: lacks a shebang; expected #!/bin/sh\n' "$target"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
  esac

  case $interpreter in
    '/bin/sh'|'/usr/bin/env sh')
      :
      ;;
    '/usr/bin/env bash'*|'/bin/bash'*)
      printf 'FAIL %s: uses %s (should use /bin/sh)\n' "$target" "$shebang"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
    *)
      printf 'FAIL %s: uses %s (should use /bin/sh)\n' "$target" "$shebang"
      failures=$((failures + 1))
      failed_targets=${failed_targets:+$failed_targets,}$target
      continue
      ;;
  esac

  tmp_log=$(temp-file verify-posix-log) || exit 1
  if "$checkbashisms_cmd" "$path" >"$tmp_log" 2>&1; then
    printf 'PASS %s\n' "$target"
  else
    printf 'FAIL %s\n' "$target"
    while IFS= read -r line; do
      printf '  %s\n' "$line"
    done <"$tmp_log"
    failures=$((failures + 1))
    failed_targets=${failed_targets:+$failed_targets,}$target
  fi
  cleanup-file "$tmp_log"
done <"$targets_file"
trap - EXIT HUP INT TERM
rm -f "$targets_file"

if [ "$failures" -eq 0 ]; then
  printf 'All %d scripts are POSIX-compliant.\n' "$total"
else
  printf '%d of %d scripts failed POSIX compliance.\n' "$failures" "$total"
  printf 'Failing spells: %s\n' "$failed_targets"
  exit 1
fi
}

# Entrypoint for running the project test suite from the system menu, CLI, or CI.
#
# Responsibilities:
# - Provide the full test runner logic in a single spell.
# - Discover tests, filter them, and report coverage in the expected format.

# CRITICAL: Seed a baseline PATH BEFORE set -eu and before any commands
# On macOS GitHub Actions, PATH may be completely empty, causing immediate failure
# when we try to use basename, dirname, cd, pwd, find, sort, awk, etc.
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*)
    # Already has at least one standard directory
    ;;
  *)
    # PATH is empty or missing standard directories, prepend baseline
    PATH="${baseline_path}${PATH:+:}${PATH-}"
    ;;
esac

show_usage() {
  cat <<USAGE
Usage: $cmd_name [--only PATTERN] [--list] [--verbose]

Execute the behavior-driven shell tests located in .tests/.
USAGE
}

cmd_name=$(basename "$0")
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
root_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
test_dir="$root_dir/.tests"

# Add wizardry spells and imps to PATH so we can use them directly
# This allows running test-magic directly without wizardry being installed
if [ -d "$root_dir/spells/.imps" ]; then
  PATH="$root_dir/spells/.imps:$PATH"
  for impdir in "$root_dir"/spells/.imps/*; do
    [ -d "$impdir" ] || continue
    PATH="$impdir:$PATH"
  done
fi

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

export PATH

only_patterns=""
list_only=0
verbose=0
very_verbose=0
rerun_args=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --only)
      if [ "$#" -lt 2 ]; then
        echo "$cmd_name: --only requires a pattern" >&2
        show_usage
        exit 1
      fi
      rerun_args="$rerun_args --only $2"
      if [ -n "$only_patterns" ]; then
        only_patterns="$only_patterns\n$2"
      else
        only_patterns="$2"
      fi
      shift 2
      ;;
    --list)
      list_only=1
      rerun_args="$rerun_args --list"
      shift
      ;;
    --verbose)
      verbose=1
      rerun_args="$rerun_args --verbose"
      shift
      ;;
    --very-verbose)
      very_verbose=1
      rerun_args="$rerun_args --very-verbose"
      shift
      ;;
    --help|--usage|-h)
      show_usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "$cmd_name: unknown option '$1'" >&2
      show_usage
      exit 1
      ;;
  esac
done

find_tests() {
  find "$test_dir" -type f -name 'test-*.sh' | sort
}

pattern_has_match() {
  pattern=$1
  found=1
  while IFS= read -r path; do
    [ -n "$path" ] || continue
    rel=${path#"$test_dir/"}
    case $rel in
      $pattern)
        found=0
        break
        ;;
    esac
  done <<EOF_TESTS
$(find_tests)
EOF_TESTS
  return $found
}

matches_patterns() {
  rel=$1
  if [ -z "$only_patterns" ]; then
    return 0
  fi
  match=1
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    case $rel in
      $pat)
        match=0
        break
        ;;
    esac
  done <<EOF_PATS
$only_patterns
EOF_PATS
  return $match
}

test_files=""

if [ -n "$only_patterns" ]; then
  while IFS= read -r pat; do
    [ -n "$pat" ] || continue
    if ! pattern_has_match "$pat"; then
      echo "$cmd_name: pattern '$pat' matched no tests" >&2
      exit 1
    fi
  done <<EOF_PATS
$only_patterns
EOF_PATS
fi

while IFS= read -r path; do
  short=${path#"$test_dir/"}
  if matches_patterns "$short"; then
    if [ -n "$test_files" ]; then
      test_files=$(printf '%s\n%s' "$test_files" "$short")
    else
      test_files="$short"
    fi
  fi
done <<EOF_TESTS
$(find_tests)
EOF_TESTS

if [ -z "$test_files" ]; then
  echo "$cmd_name: no tests discovered." >&2
  exit 1
fi

if [ "$list_only" -eq 1 ]; then
  printf '%s\n' "$test_files"
  exit 0
fi

spell_path_for_test() {
  test_path=$1
  rel=${test_path#"$test_dir/"}
  dir=$(dirname "$rel")
  base=$(basename "$rel")
  base=${base#test_}
  base=${base%.*}
  printf '%s/%s/%s\n' "$root_dir" "spells/$dir" "$base"
}

record_subtests() {
  counts=$(printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      passed += parts[1]
      total += parts[2]
      next
    }
    /^FAIL_DETAIL:/ { next }
    END { print (passed+0) " " (total+0) }
  ')

  set -- $counts
  if [ "$#" -eq 2 ]; then
    subtests_passed=$((subtests_passed + $1))
    subtests_total=$((subtests_total + $2))
  fi
}

status=0
pass=0
_fail=0
subtests_passed=0
subtests_total=0
failed_scripts=""
incomplete_tests=""
incomplete_count=0
test_number=0
test_total=$(printf '%s\n' "$test_files" | grep -c .)
# Imps have no --help flag, so they need 2 subtests minimum.
# Spells have a --help flag which needs testing, plus 2 additional subtests.
MIN_SUBTESTS_IMP=2
MIN_SUBTESTS_SPELL=3
failure_output_file=$(_temp_file test-magic) || exit 1
trap '_cleanup_file "$failure_output_file"' EXIT HUP INT TERM

spell_name_for_test() {
  test_path=$1
  
  # Special case: test-suite.sh should display as "common tests"
  case "$test_path" in
    */test-suite.sh|test-suite.sh)
      printf '%s\n' "common tests"
      return
      ;;
  esac
  
  spell_path=$(spell_path_for_test "$test_path" 2>/dev/null || true)

  if [ -n "$spell_path" ]; then
    printf '%s\n' "$(basename "$spell_path")"
    return
  fi

  base=${test_path##*/}
  base=${base#test_}
  base=${base%.sh}
  printf '%s\n' "$base"
}

print_failure_debug() {
  test_path=$1
  output=$2

  printf 'Debug (failures only) for %s:\n' "$test_path"
  printf '%s\n' "$output" | awk '
    /^PASS / { next }
    /^[0-9]+\/[0-9]+ tests passed/ { next }
    /^FAIL_DETAIL:/ { next }
    /^$/ { next }
    { printf "  %s\n", $0 }
  '
}

record_failed_script() {
  script=$1
  numbers=$2

  name=$(spell_name_for_test "$script")

  if [ -n "$numbers" ]; then
    entry="$name ($numbers)"
  else
    entry="$name"
  fi

  if [ -n "$failed_scripts" ]; then
    failed_scripts="$failed_scripts, $entry"
  else
    failed_scripts="$entry"
  fi
}

# Extract the total subtest count from test output.
# $1 - test output containing "X/Y tests passed" summary line
# Returns the total (Y) from the summary, or 0 if no summary found.
get_subtest_total() {
  printf '%s\n' "$1" | awk '
    /^[0-9]+\/[0-9]+ tests passed/ {
      split($1, parts, "/")
      print parts[2]
      exit
    }
    END { if (!NR) print 0 }
  '
}

# Check if test output contains a --help test case.
# Looks for test case lines (PASS/FAIL) that mention help or usage.
# $1 - test output
# Returns 0 if help test found, 1 otherwise.
has_help_test() {
  printf '%s\n' "$1" | grep -qiE "(PASS|FAIL).*(--help|-h|help|usage)"
}

# Record a test that has fewer than required subtests or is missing help test.
# $1 - test path
# $2 - reason (e.g., "2 subtests" or "missing --help test")
record_incomplete_test() {
  test_path=$1
  reason=$2
  name=$(spell_name_for_test "$test_path")
  entry="$name ($reason)"
  if [ -n "$incomplete_tests" ]; then
    incomplete_tests="$incomplete_tests, $entry"
  else
    incomplete_tests="$entry"
  fi
}

while IFS= read -r test_path; do
  [ -n "$test_path" ] || continue
  abs="$test_dir/$test_path"
  test_number=$((test_number + 1))
  printf '[%d/%d] %s\n' "$test_number" "$test_total" "$test_path"

  if output=$(sh "$abs" 2>&1); then
    pass=$((pass + 1))
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    [ "$verbose" -eq 1 ] && printf '%s\n' "$cleaned_output" | sed 's/^/  /'
  else
    status=1
    _fail=$((_fail + 1))
    numbers=$(printf '%s\n' "$output" | awk -F ':' '
      /^FAIL_DETAIL:/ {
        if (NF >= 2) {
          n = split($2, parts, ",")
          for (i = 1; i <= n; i++) {
            idx = parts[i]
            gsub(/^ +| +$/, "", idx)
            if (idx ~ /^[0-9]+$/) {
              order[++count] = idx
            }
          }
        }
        next
      }
      END {
        for (i = 1; i <= count; i++) {
          if (i > 1) {
            printf(", ")
          }
          printf("%s", order[i])
        }
        printf("\n")
      }
    ' | sed 's/[[:space:]]*$//')
    cleaned_output=$(printf '%s\n' "$output" | sed '/^FAIL_DETAIL:/d')
    record_subtests "$cleaned_output"
    record_failed_script "$test_path" "$numbers"
    if [ "$very_verbose" -eq 1 ]; then
      print_failure_debug "$test_path" "$cleaned_output"
    fi
    {
      printf '=== %s ===\n' "$test_path"
      printf '%s\n\n' "$cleaned_output"
    } >>"$failure_output_file"
  fi

  # Check minimum subtest requirements based on test type.
  # Imps (in .imps/): Need MIN_SUBTESTS_IMP subtests (no --help).
  # Spells: Need a --help test PLUS MIN_SUBTESTS_IMP additional behavioral subtests.
  # Global tests (test-install.sh, test-suite.sh): Exempt from --help requirement.
  test_subtest_count=$(get_subtest_total "$cleaned_output")
  test_incomplete_reasons=""
  case "$test_path" in
    .imps/*|*/.imps/*)
      # Imps have no --help, just need MIN_SUBTESTS_IMP subtests
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    test-install.sh|test-suite.sh)
      # Global/special tests don't need --help test
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_IMP" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
        test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_IMP"
      fi
      ;;
    *)
      # Spells need a --help test plus additional behavioral subtests.
      # Total must be at least MIN_SUBTESTS_SPELL (1 help + 2 behavioral = 3).
      if ! has_help_test "$cleaned_output"; then
        record_incomplete_test "$test_path" "missing --help test"
        test_incomplete_reasons="missing --help test"
      fi
      if [ -n "$test_subtest_count" ] && [ "$test_subtest_count" -lt "$MIN_SUBTESTS_SPELL" ]; then
        record_incomplete_test "$test_path" "$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        if [ -n "$test_incomplete_reasons" ]; then
          test_incomplete_reasons="$test_incomplete_reasons; $test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        else
          test_incomplete_reasons="$test_subtest_count subtests, need $MIN_SUBTESTS_SPELL"
        fi
      fi
      ;;
  esac

  # Print inline incomplete warning using LACK (not PASS/FAIL)
  if [ -n "$test_incomplete_reasons" ]; then
    incomplete_count=$((incomplete_count + 1))
    printf 'LACK %s (%s)\n' "$(spell_name_for_test "$test_path")" "$test_incomplete_reasons"
  fi

  printf '\n'
done <<EOF_TESTS
$(printf '%s\n' "$test_files")
EOF_TESTS

find_matching_test_for_spell() {
  spell=$1
  rel=${spell#"$root_dir/"}
  rel=${rel#spells/}
  dir=$(dirname "$rel")
  base=$(basename "$rel")

  candidate_sh="$test_dir/$dir/test-${base}.sh"
  if [ -f "$candidate_sh" ]; then
    printf '%s\n' "$candidate_sh"
    return 0
  fi
  return 1
}

scan_coverage() {
  coverage_total=0
  coverage_covered=0
  uncovered_spells=""

  while IFS= read -r spell; do
    [ -n "$spell" ] || continue
    rel=${spell#"$root_dir/"}
    case $rel in
      spells/system/test-magic|spells/system/_verify_posix)
        continue
        ;;
      *.service|*.gitkeep|*.gitignore)
        # Skip non-script files
        continue
        ;;
    esac
    coverage_total=$((coverage_total + 1))
    if find_matching_test_for_spell "$spell" >/dev/null 2>&1; then
      coverage_covered=$((coverage_covered + 1))
    else
      if [ -n "$uncovered_spells" ]; then
        uncovered_spells=$(printf '%s\n%s' "$uncovered_spells" "$rel")
      else
        uncovered_spells="$rel"
      fi
    fi
  done <<EOF_SPELLS
$(cd "$root_dir" && find spells -type f | sort)
EOF_SPELLS
}

scan_extraneous() {
  extraneous_files=""
  
  while IFS= read -r test_file; do
    [ -n "$test_file" ] || continue
    
    # Skip test-suite.sh
    case $test_file in
      */test-suite.sh) continue ;;
    esac
    
    # Extract spell path from test path
    rel=${test_file#"$test_dir/"}
    dir=$(dirname "$rel")
    base=$(basename "$rel")
    # Remove test- prefix and .sh suffix
    base=${base#test-}
    base=${base%.sh}
    
    # Handle special cases for install tests (test the root install script)
    # The install script is in the repo root (not spells/) so its test can be:
    # 1. .tests/test-install.sh (dir="." base="install") 
    # 2. .tests/install/test-install.sh (dir="install" base="install")
    case "$base" in
      install|install-with-old-version)
        if [ "$dir" = "install" ] || [ "$dir" = "." ]; then
          if [ -f "$root_dir/install" ]; then
            continue
          fi
        fi
        ;;
    esac
    
    spell_path="$root_dir/spells/$dir/$base"
    
    if [ ! -f "$spell_path" ]; then
      if [ -n "$extraneous_files" ]; then
        extraneous_files=$(printf '%s\n%s' "$extraneous_files" ".tests/$rel")
      else
        extraneous_files=".tests/$rel"
      fi
    fi
  done <<EOF_TESTS
$(find "$test_dir" -type f -name 'test-*.sh' | sort)
EOF_TESTS
}

scan_coverage
scan_extraneous
coverage_uncovered=$((coverage_total - coverage_covered))

total_scripts=$((pass + _fail))
printf 'Summary: %d passed, %d failed, %d uncovered, %d incomplete, subtests %d/%d.\n' \
  "$pass" "$_fail" "$coverage_uncovered" "$incomplete_count" "$subtests_passed" "$subtests_total"

if [ "$coverage_uncovered" -gt 0 ]; then
  printf 'Uncovered spells:\n'
  printf '  %s\n' "$uncovered_spells"
  status=1
fi

if [ -n "$extraneous_files" ]; then
  printf 'Extraneous test files (no corresponding spell):\n'
  printf '  %s\n' "$extraneous_files"
  status=1
fi

if [ -n "$incomplete_tests" ]; then
  printf 'Incomplete tests (imps need %d+ subtests, spells need %d+ including --help):\n' "$MIN_SUBTESTS_IMP" "$MIN_SUBTESTS_SPELL"
  printf '  %s\n' "$incomplete_tests"
  status=1
fi

if [ "$very_verbose" -eq 1 ] && [ "$_fail" -gt 10 ]; then
  printf 'Too many failures (%d) for --very-verbose; skipping detailed output.\n' "$_fail"
  very_verbose=0
fi

if [ "$status" -ne 0 ] && [ -n "$failed_scripts" ]; then
  show_failure_output=0
  if [ "$very_verbose" -eq 1 ] && [ "$_fail" -le 10 ]; then
    show_failure_output=1
  fi

  if [ "$show_failure_output" -eq 1 ] && [ -s "$failure_output_file" ]; then
    printf 'Failure details (showing %d):\n' "$_fail"
    while IFS= read -r line; do
      case $line in
        "=== "*) printf '%s\n' "$line" ;;
        *) printf '  %s\n' "$line" ;;
      esac
    done <"$failure_output_file"
  fi

  detect_os_label() {
    if [ -n "${WIZARDRY_OS_LABEL-}" ]; then
      printf '%s\n' "$WIZARDRY_OS_LABEL"
      return 0
    fi

    if [ -x "$root_dir/spells/divination/_detect_distro" ]; then
      if label=$("$root_dir/spells/divination/_detect_distro" 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v _detect_distro >/dev/null 2>&1; then
      if label=$(_detect_distro 2>/dev/null || true); then
        if [ -n "$label" ]; then
          printf '%s\n' "$label"
          return 0
        fi
      fi
    fi

    if command -v uname >/dev/null 2>&1; then
      label=$(uname -s 2>/dev/null || true)
      label=$(printf '%s' "$label" | tr ' A-Z' '_a-z')
      if [ -n "$label" ]; then
        printf '%s\n' "$label"
        return 0
      fi
    fi

    printf 'unknown\n'
  }

  os_label=$(detect_os_label)
  printf 'Failed tests (%s): %s\n' "$os_label" "$failed_scripts"
fi

if [ "$status" -ne 0 ] && [ "$_fail" -le 10 ] && [ "${GITHUB_ACTIONS-}" != "" ] \
  && [ "${TEST_MAGIC_DEBUG_RERUN-}" != "1" ] && [ "$very_verbose" -eq 0 ]; then
  trap - EXIT HUP INT TERM
  _cleanup_file "$failure_output_file"
  printf '\nGitHub Actions detected <=10 failing tests; rerunning with --very-verbose for focused debug...\n'
  set -- $rerun_args
  TEST_MAGIC_DEBUG_RERUN=1 exec "$0" --very-verbose "$@"
fi

trap - EXIT HUP INT TERM
_cleanup_file "$failure_output_file"

exit $status
