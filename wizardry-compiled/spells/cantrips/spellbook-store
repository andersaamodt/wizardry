#!/bin/sh
#
# ---------------------------- spellbook-store -----------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: spellbook-store
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined imp: empty
_empty() {
  [ -z "$1" ]
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}


# This spell manages the spellbook storage file for quick-access spell shortcuts.


tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}

show_usage() {
        cat <<'USAGE' >&2
Usage: spellbook-store {add NAME CMD|remove NAME|list|path}

Manage the spellbook storage file for quick-access spell shortcuts. Use add to
save a named command, remove to drop it, list to review entries, and path to
print the backing file location.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

resolve_spellbook_file() {
	if [ -n "${WIZARDRY_SPELLBOOK_FILE-}" ]; then
		file=$WIZARDRY_SPELLBOOK_FILE
	else
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/.tower/spellbook
		else
			file=.wizardry_spellbook
		fi
	fi
	case $file in
	\~)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME
		fi
		;;
	\~/*)
		if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
			file=$HOME/${file#\~/}
		fi
		;;
	esac
	printf '%s' "$file"
}

spellbook_file=$(resolve_spellbook_file)

ensure_parent_directory() {
	dir=${spellbook_file%/*}
	if [ "$dir" != "$spellbook_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_alias() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "spellbook-store: alias names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "spellbook-store: alias names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

validate_command() {
        cmd=$1
        if [ -z "$cmd" ]; then
                printf '%s\n' "spellbook-store: command must not be _empty." >&2
                exit 1
        fi
        case $cmd in
        *"$tab_char"*)
                printf '%s\n' "spellbook-store: command may not contain tabs." >&2
                exit 1
                ;;
        *"$newline_char"*)
                printf '%s\n' "spellbook-store: command must be a single line." >&2
                exit 1
                ;;
        esac
}

add_entry() {
        name=$1
        shift
        cmd=$1
        shift || :
        while [ "$#" -gt 0 ]; do
                cmd="$cmd $1"
                shift
        done
        validate_alias "$name"
        validate_command "$cmd"
        ensure_parent_directory
        tmp=$(_temp_file spellbook-store) || exit 1
        trap '_cleanup_file "$tmp"' EXIT HUP INT TERM
        if [ -f "$spellbook_file" ]; then
                while IFS= read -r line || nonempty "$line"; do
                        entry_name=$line
                        entry_command=''
                        case $line in
                        *"$tab_char"*)
                                entry_name=${line%%"$tab_char"*}
                                entry_command=${line#*"$tab_char"}
                                ;;
                        esac
                        if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                                continue
                        fi
                        printf '%s%s%s\n' "$entry_name" "$tab_char" "$entry_command" >>"$tmp"
                done <"$spellbook_file"
        fi
        printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >>"$tmp"
        trap - EXIT HUP INT TERM
        mv "$tmp" "$spellbook_file"
}

remove_entry() {
	name=$1
	validate_alias "$name"
	if [ ! -f "$spellbook_file" ]; then
		printf '%s\n' "spellbook-store: spell '$name' _is not recorded." >&2
		exit 1
	fi
	tmp=$(_temp_file spellbook-store) || exit 1
	trap '_cleanup_file "$tmp"' EXIT HUP INT TERM
	removed=0
        while IFS= read -r line || nonempty "$line"; do
                entry_name=$line
                case $line in
                *"$tab_char"*)
                        entry_name=${line%%"$tab_char"*}
                        ;;
                esac
                if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
                        if [ "$entry_name" = "$name" ]; then
                                removed=1
                                continue
                        fi
                        continue
                fi
                printf '%s\n' "$line" >>"$tmp"
        done <"$spellbook_file"
	if [ "$removed" -eq 0 ]; then
		trap - EXIT HUP INT TERM
		rm -f "$tmp"
		printf '%s\n' "spellbook-store: spell '$name' _is not recorded." >&2
		exit 1
	fi
	trap - EXIT HUP INT TERM
	mv "$tmp" "$spellbook_file"
}

list_entries() {
	if [ -f "$spellbook_file" ]; then
		cat "$spellbook_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1
shift

case $action in
add)
	if [ "$#" -lt 2 ]; then
		printf '%s\n' "spellbook-store: add expects a NAME followed by COMMAND words." >&2
		show_usage
		exit 1
	fi
	add_entry "$@"
	;;
remove)
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "spellbook-store: remove expects a NAME." >&2
		show_usage
		exit 1
	fi
	remove_entry "$1"
	;;
list)
	if [ "$#" -ne 0 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 0 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$spellbook_file"
	;;
--help|--usage|-h)
	show_usage
	;;
*)
	show_usage
	exit 1
	;;
esac
