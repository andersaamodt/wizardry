#!/bin/sh
#
# ---------------------------------- menu ----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: menu
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: await-keypress
_await_keypress() {

# Read a single key press from the controlling terminal and report it in a
# descriptive form ("enter", "up", literal text, etc.).


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


spell_dir() {
    case $0 in
        */*) CDPATH= cd -- "${0%/*}" && pwd -P ;;
        *) CDPATH= cd -- . && pwd -P ;;
    esac
}

resolve_require_command() {
    if [ -n "${REQUIRE_COMMAND-}" ]; then
        printf '%s\n' "$REQUIRE_COMMAND"
        return 0
    fi
    if [ -x "$(spell_dir)/require-command" ]; then
        printf '%s\n' "$(spell_dir)/require-command"
        return 0
    fi
    printf '%s\n' require-command
}

require() {
    "$(resolve_require_command)" "$@"
}

# Capture raw bytes with dd; bail out immediately when it is missing.
if ! require dd "The await-keypress spell needs 'dd' to capture raw key presses."; then
    exit 1
fi

TTY_DEVICE=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
skip_stty=${AWAIT_KEYPRESS_SKIP_STTY:-0}
keep_raw=${AWAIT_KEYPRESS_KEEP_RAW:-0}

if [ "${AWAIT_KEYPRESS_BUFFER_FILE+set}" = "set" ]; then
    buffer_file=$AWAIT_KEYPRESS_BUFFER_FILE
else
    buffer_key=$(printf '%s' "$TTY_DEVICE" | tr -c '[:alnum:]' '_')
    buffer_file=$(temp-file await-keypress-buffer-"$buffer_key") || exit 1
fi

if [ "$skip_stty" -eq 1 ]; then
    # Allow tests to provide a preconfigured file descriptor instead of
    # toggling terminal attributes.
    if [ ! -r "$TTY_DEVICE" ]; then
        printf '%s\n' "await-keypress: unable to read from '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<"$TTY_DEVICE" || exit 1
    restore() {
        exec 3>&- 2>/dev/null || :
    }
else
    # When interacting with the real terminal, require stty for raw-mode
    # management and open the device read/write.
    if ! require stty "The await-keypress spell needs 'stty' to manage terminal modes."; then
        exit 1
    fi

    if [ ! -r "$TTY_DEVICE" ] || [ ! -w "$TTY_DEVICE" ]; then
        printf '%s\n' "await-keypress: unable to open controlling terminal '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<>"$TTY_DEVICE" || exit 1

    # Persist the existing terminal configuration so we can restore it later.
    saved_state=$(stty -g <&3 2>/dev/null)
    if [ -z "$saved_state" ]; then
        printf '%s\n' 'await-keypress: unable to read terminal settings' >&2
        exit 1
    fi

    restore() {
        stty "$saved_state" <&3 >/dev/null 2>&1 || :
        exec 3>&- 2>/dev/null || :
    }

    trap 'restore; exit 130' INT HUP TERM
    trap 'restore' EXIT

    # Configure canonical mode to wait for exactly one byte of input.
    if ! stty -icanon -echo min 1 time 0 <&3 2>/dev/null; then
        printf '%s\n' 'await-keypress: unable to configure terminal' >&2
        exit 1
    fi
fi

# Helper to slurp a specified number of bytes from the terminal.
read_codes() {
    codes=$(dd bs=1 count="$1" 2>/dev/null <&3 | od -An -t u1 -v | tr -s '[:space:]' ' ')
    codes=${codes# }
    codes=${codes% }
    printf '%s' "$codes"
}

# Convert numeric byte values back to characters.
codes_to_string() {
    result=''
    for code in $1; do
        result=${result}$(printf '\\%03o' "$code")
    done
    printf '%b' "$result"
}

buffer_codes=''
if [ -n "$buffer_file" ] && [ -f "$buffer_file" ] && [ -s "$buffer_file" ]; then
    buffer_codes=$(cat "$buffer_file")
    rm -f "$buffer_file"
fi

codes=''
had_buffer=0
if [ -n "$buffer_codes" ]; then
    had_buffer=1
    codes=$buffer_codes
else
    first_codes=$(read_codes 1)
    if [ -z "$first_codes" ]; then
        exit 1
    fi

    codes=$first_codes
fi

# Allow escape sequences to provide additional bytes.
if [ "$skip_stty" -eq 0 ] && [ "$had_buffer" -eq 0 ]; then
    if ! stty -icanon -echo min 0 time 1 <&3 2>/dev/null; then
        printf '%s\n' 'await-keypress: unable to update terminal timing' >&2
        exit 1
    fi
fi

if [ "$had_buffer" -eq 0 ]; then
    while :; do
        extra=$(read_codes 1)
        [ -z "$extra" ] && break
        if [ -n "$codes" ]; then
            codes="$codes $extra"
        else
            codes=$extra
        fi
    done
fi

trap - EXIT
if [ "$skip_stty" -eq 0 ] && [ "$keep_raw" -eq 1 ]; then
    exec 3>&- 2>/dev/null || :
else
    restore
fi

codes=${codes# }
codes=${codes% }
if [ -z "$codes" ]; then
    printf '\n'
    exit 0
fi

set -- $codes
if [ "$#" -eq 0 ]; then
    printf '\n'
    exit 0
fi

first=$1
shift
leftover="$*"
output=''
buffer_leftover_codes=''

case "$first" in
    9)
        output='tab'
        ;;
    10|13)
        output='enter'
        ;;
    8|127)
        output='backspace'
        ;;
    27)
        escape_rest_codes="$leftover"
        consumed="$first"
        partial=0
        if [ "$#" -eq 0 ]; then
            output='escape'
            buffer_leftover_codes=''
        else
            second=$1
            shift
            consumed="$consumed $second"
            case "$second" in
                91)
                    if [ "$#" -eq 0 ]; then
                        partial=1
                    else
                        third=$1
                        shift
                        consumed="$consumed $third"
                        case "$third" in
                            65)
                                output='up'
                                buffer_leftover_codes="$*"
                                ;;
                            66)
                                output='down'
                                buffer_leftover_codes="$*"
                                ;;
                            67)
                                output='right'
                                buffer_leftover_codes="$*"
                                ;;
                            68)
                                output='left'
                                buffer_leftover_codes="$*"
                                ;;
                            51)
                                if [ "$#" -eq 0 ]; then
                                    partial=1
                                else
                                    fourth=$1
                                    shift
                                    consumed="$consumed $fourth"
                                    if [ "$fourth" -eq 126 ]; then
                                        output='delete'
                                        buffer_leftover_codes="$*"
                                    else
                                        output="escaped key: $(codes_to_string "$escape_rest_codes")"
                                        buffer_leftover_codes=''
                                    fi
                                fi
                                ;;
                            *)
                                output="escaped key: $(codes_to_string "$escape_rest_codes")"
                                buffer_leftover_codes=''
                                ;;
                        esac
                    fi
                    ;;
                *)
                    output="escaped key: $(codes_to_string "$escape_rest_codes")"
                    buffer_leftover_codes=''
                    ;;
            esac
        fi

        if [ "$partial" -eq 1 ]; then
            output=''
            buffer_leftover_codes="$consumed"
        fi
        ;;
    *)
        remainder=$first
        if [ -n "$leftover" ]; then
            remainder="$remainder $leftover"
        fi
        output=$(codes_to_string "$remainder")
        buffer_leftover_codes=''
        ;;
esac

buffer_leftover_codes=${buffer_leftover_codes# }
buffer_leftover_codes=${buffer_leftover_codes% }

if [ -n "$buffer_file" ]; then
    if [ -n "$buffer_leftover_codes" ]; then
        printf '%s\n' "$buffer_leftover_codes" >"$buffer_file"
    else
        rm -f "$buffer_file"
    fi
fi

printf '%s\n' "$output"
}

# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined spell: cursor-blink
_cursor_blink() {

# This spell awakens or stills the cyclic illumination of the cursor.

# Emit the escape sequence that re-enables blinking.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

cursor_blink_on() {
  printf '\033[?25h'
}

# Emit the escape sequence that freezes the cursor in place.
cursor_blink_off() {
  printf '\033[?25l'
}

supports_cursor_control() {
  case ${TERM-} in
    ''|dumb|unknown)
      return 1
      ;;
  esac
  return 0
}

# The helper expects exactly one argument that declares the desired state.
if [ "$#" -ne 1 ]; then
  printf '%s\n' 'Usage: cursor-blink on|off' >&2
  exit 1
fi

if ! supports_cursor_control; then
  # Quietly succeed so scripts keep running even when the terminal lacks ANSI
  # support (for example, on "dumb" terminals).
  exit 0
fi

case "$1" in
  on)
    cursor_blink_on
    ;;
  off)
    cursor_blink_off
    ;;
  *)
    # Treat anything else as misuse so callers notice mistakes quickly.
    printf '%s\n' 'Usage: cursor-blink on|off' >&2
    exit 1
    ;;
esac
}

# Inlined spell: fathom-cursor
_fathom_cursor() {

# Report the cursor position returned by the terminal in response to a DSR
# (Device Status Report) query.



script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Resolve the require-command helper to avoid copy/pasting path logic
# everywhere.
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/require-command" ]; then
    require_cmd="$script_dir/require-command"
else
    require_cmd=require-command
fi

require() {
    "$require_cmd" "$@"
}

verbose=0
want_x=0
want_y=0

# Parse the minimal flag set needed for the menu scripts.
while [ "$#" -gt 0 ]; do
    case "$1" in
        -v|--verbose)
            verbose=1
            ;;
        -x)
            want_x=1
            ;;
        -y)
            want_y=1
            ;;
        --help|--usage|-h)
            show_usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            show_usage
            ;;
        *)
            break
            ;;
    esac

    shift
done

# Default to reporting both coordinates when no axis is specified.
if [ "$want_x" -eq 0 ] && [ "$want_y" -eq 0 ]; then
    want_x=1
    want_y=1
fi

# dd reads the raw response bytes from the terminal.
if ! require dd "The fathom-cursor spell needs 'dd' to read the terminal response."; then
    exit 1
fi

TTY_DEVICE=${FATHOM_CURSOR_DEVICE:-/dev/tty}
skip_stty=${FATHOM_CURSOR_SKIP_STTY:-0}

# Only reach for stty when we are manipulating a real tty.
if [ "$skip_stty" -eq 0 ]; then
    if ! require stty "The fathom-cursor spell needs 'stty' to manage terminal modes."; then
        exit 1
    fi
fi

if [ "$skip_stty" -eq 1 ]; then
    # Test harnesses can feed canned responses via a read-only file.
    if [ ! -r "$TTY_DEVICE" ]; then
        printf '%s\n' "fathom-cursor: unable to read from '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<"$TTY_DEVICE" || exit 1
    restore() {
        exec 3>&- 2>/dev/null || :
    }
else
    # When running interactively, open the tty for both reading and writing so
    # we can send the DSR request and read the reply.
    if [ ! -r "$TTY_DEVICE" ] || [ ! -w "$TTY_DEVICE" ]; then
        printf '%s\n' "fathom-cursor: unable to open controlling terminal '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<>"$TTY_DEVICE" || exit 1

    # Preserve the terminal state and restore it on exit to avoid leaving the
    # user with a broken session.
    saved_state=$(stty -g <&3 2>/dev/null)
    if [ -z "$saved_state" ]; then
        printf '%s\n' 'fathom-cursor: unable to read terminal settings' >&2
        exit 1
    fi

    restore() {
        stty "$saved_state" <&3 >/dev/null 2>&1 || :
        exec 3>&- 2>/dev/null || :
    }

    trap 'restore; exit 130' INT HUP TERM
    trap 'restore' EXIT

    # Configure raw mode with a short timeout so we do not block forever.
    if ! stty -icanon -echo min 0 time 5 <&3 2>/dev/null; then
        printf '%s\n' 'fathom-cursor: unable to configure terminal' >&2
        exit 1
    fi
fi

# Ask for the cursor position by emitting the DSR request when appropriate.
if [ "$skip_stty" -eq 0 ]; then
    printf '\033[6n' >&3
fi

response=''
while :; do
    byte=$(dd bs=1 count=1 2>/dev/null <&3)
    [ -z "$byte" ] && break
    response=${response}${byte}
    [ "$byte" = "R" ] && break
done

trap - EXIT
restore

esc=$(printf '\033')

case "$response" in
    '')
        printf '%s\n' 'fathom-cursor: terminal did not respond' >&2
        exit 1
        ;;
    "$esc"'['*'R')
        :
        ;;
    *)
        printf '%s\n' "fathom-cursor: unexpected response '$response'" >&2
        exit 1
        ;;
esac

# Strip the escape sequence wrapper to isolate "row;column".
coords=${response#??}
coords=${coords%R}
row=${coords%%;*}
column=${coords#*;}

case "$row" in
    *[!0-9]*)
        printf '%s\n' "fathom-cursor: invalid row '$row'" >&2
        exit 1
        ;;
    *) : ;;
esac

case "$column" in
    *[!0-9]*)
        printf '%s\n' "fathom-cursor: invalid column '$column'" >&2
        exit 1
        ;;
    *) : ;;
esac

print_value() {
    label=$1
    value=$2
    if [ "$verbose" -eq 1 ]; then
        printf '%s: %s\n' "$label" "$value"
    else
        printf '%s\n' "$value"
    fi
}

# Honour the axis selection made by the caller.
if [ "$want_x" -eq 1 ] && [ "$want_y" -eq 1 ]; then
    print_value 'X' "$column"
    print_value 'Y' "$row"
elif [ "$want_x" -eq 1 ]; then
    print_value 'X' "$column"
else
    print_value 'Y' "$row"
fi
}

# Inlined spell: fathom-terminal
_fathom_terminal() {

# Report terminal dimensions using terminfo via tput.



case "${1-}" in
--help|--usage|-h)
    show_usage
    exit 0
    ;;
esac


script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Share the same require-command lookup logic with the other cantrips.
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/require-command" ]; then
    require_cmd="$script_dir/require-command"
else
    require_cmd=require-command
fi

require() {
    "$require_cmd" "$@"
}

verbose=0
want_width=0
want_height=0

# Parse the small option set understood by the menu helper.
while [ "$#" -gt 0 ]; do
    case "$1" in
        -v|--verbose)
            verbose=1
            ;;
        -w|--width)
        want_width=1
        ;;
        --help|--usage|-h)
            show_usage
            exit 0
            ;;
        --height)
            want_height=1
            ;;
        --)
            shift
            break
            ;;
        -*)
            show_usage >&2
            exit 1
            ;;
        *)
            break
            ;;
        esac

        shift
done

# Unless told otherwise, report both width and height.
if [ "$want_width" -eq 0 ] && [ "$want_height" -eq 0 ]; then
    want_width=1
    want_height=1
fi

# tput is our interface to terminfo; fail loudly when it is absent.
if ! require tput "The fathom-terminal spell needs 'tput' to query terminfo."; then
    exit 1
fi

cols=$(tput cols 2>/dev/null)
cols_status=$?
lines=$(tput lines 2>/dev/null)
lines_status=$?

if [ "$want_width" -eq 1 ]; then
    if [ $cols_status -ne 0 ] || [ -z "$cols" ]; then
        printf '%s\n' 'fathom-terminal: unable to determine terminal width' >&2
        exit 1
    fi
fi

if [ "$want_height" -eq 1 ]; then
    if [ $lines_status -ne 0 ] || [ -z "$lines" ]; then
        printf '%s\n' 'fathom-terminal: unable to determine terminal height' >&2
        exit 1
    fi
fi

print_dimension() {
    label=$1
    value=$2
    if [ "$verbose" -eq 1 ]; then
        printf '%s: %s\n' "$label" "$value"
    else
        printf '%s\n' "$value"
    fi
}

# Honour the caller's selection of width, height, or both.
if [ "$want_width" -eq 1 ] && [ "$want_height" -eq 1 ]; then
    print_dimension 'Width' "$cols"
    print_dimension 'Height' "$lines"
elif [ "$want_width" -eq 1 ]; then
    print_dimension 'Width' "$cols"
else
    print_dimension 'Height' "$lines"
fi
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined spell: main-menu
_main_menu() {

# This spell displays the ao-mud main menu.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac



# Load color palette (colors handles terminal capability detection internally)
# shellcheck source=/dev/null
. "$(command -v colors)"

if ! require menu "The main menu needs the 'menu' command to present options."; then
  exit 1
fi

# Check if MUD is enabled in config
is_mud_enabled() {
  # Check if mud-config exists and mud-enabled is set to 1
  if command -v mud-config >/dev/null 2>&1; then
    value=$(mud-config get mud-enabled 2>/dev/null) || return 1
    [ "$value" = "1" ]
  else
    return 1
  fi
}

display_menu() {
  cast="Cast%cast"
  spellbook="Spellbook%spellbook"
  install="Arcana%install-menu"
  system="Computer%system-menu"
  exit_label=$(exit-label)
  exit_item="${exit_label}%kill -TERM \$PPID"

  # Only show MUD menu if enabled in config
  if is_mud_enabled; then
    mud="MUD%mud"
    set -- "$cast" "$mud" "$spellbook" "$install" "$system" "$exit_item"
  else
    set -- "$cast" "$spellbook" "$install" "$system" "$exit_item"
  fi
  menu "Main Menu:" "$@"
}

# Catch Ctrl-C and TERM signal to exit cleanly
trap 'exit 0' INT TERM

first_run=1

while true; do
  if [ "$first_run" -eq 0 ]; then
    printf '\n'
  else
    first_run=0
  fi

  display_menu || true
done
}

# Inlined spell: move-cursor
_move_cursor() {

# This spell moves the cursor to the provided column (x) and row (y).



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

if [ "$#" -ne 2 ]; then
    show_usage
fi

x=$1
y=$2

supports_cursor_positioning() {
    case ${TERM-} in
        ''|dumb|unknown)
            return 1
            ;;
    esac
    return 0
}

# Validate that both coordinates are purely numeric.
case "$x" in
    *[!0-9]*)
        printf '%s\n' "move-cursor: invalid column '$x'" >&2
        exit 1
        ;;
    *) : ;;
esac

case "$y" in
    *[!0-9]*)
        printf '%s\n' "move-cursor: invalid row '$y'" >&2
        exit 1
        ;;
    *) : ;;
esac

# ANSI escape sequences count from 1, so reject zero values early.
# The original menu spell passed 0 for the column. Treat that as a request to
# return to the first column so older spells continue to work. Clamp the row as
# well so callers that miscalculate never request an invalid position.
if [ "$x" -le 0 ]; then
    x=1
fi

if [ "$y" -le 0 ]; then
    y=1
fi

if ! supports_cursor_positioning; then
    # Skip emitting escape sequences when the terminal refuses them so menu
    # helpers degrade gracefully.
    exit 0
fi

# Emit the escape sequence that repositions the cursor.
printf '\033[%s;%sH' "$y" "$x"
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}


# Present an interactive menu using only POSIX shell features. This variant
# relies on existing cantrips (_await_keypress, _move_cursor, etc.) to handle the
# terminal work so it can remain portable across macOS, Debian, and NixOS.


show_usage() {
        cat <<'USAGE' >&2
Usage: menu [--spell-mode] [--start-selection N] "Title" "Label%command"...

Draw a keyboard-driven terminal menu using wizardry's cursor and input helpers.
Provide a title followed by one or more "Label%command" entries; --spell-mode
shows the command text as the label, and --start-selection picks the initial
highlighted item.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac
set -eu

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Verify that all helper spells are ready before drawing the menu.
# Uses the shared 'require' imp for dependency checking.
require _fathom_cursor "The menu spell needs '_fathom_cursor' to place the menu." || exit 1
require _fathom_terminal "The menu spell needs '_fathom_terminal' to measure the screen." || exit 1
require _move_cursor "The menu spell needs '_move_cursor' to reposition the cursor." || exit 1
require _await_keypress "The menu spell needs '_await_keypress' to read input." || exit 1
require _cursor_blink "The menu spell needs '_cursor_blink' to restore the cursor." || exit 1
require stty "The menu spell needs 'stty' to manage terminal modes." || exit 1

menu_tty=${AWAIT_KEYPRESS_DEVICE:-/dev/tty}
if [ ! -r "$menu_tty" ] || [ ! -w "$menu_tty" ]; then
        printf '%s\n' "menu: unable to access controlling terminal '$menu_tty'" >&2
        exit 1
fi

if ! menu_saved_tty_state=$(stty -g <"$menu_tty" 2>/dev/null); then
        printf '%s\n' 'menu: unable to read terminal settings' >&2
        exit 1
fi

terminal_restored=0
restore_terminal() {
        if [ "$terminal_restored" -eq 1 ]; then
                return
        fi
        terminal_restored=1
        stty "$menu_saved_tty_state" <"$menu_tty" >/dev/null 2>&1 || :
}

AWAIT_KEYPRESS_KEEP_RAW=1
export AWAIT_KEYPRESS_KEEP_RAW

# Load colour helpers when present; otherwise fall back to plain text.
if [ -r "$script_dir/colors" ]; then
        # shellcheck disable=SC1090
        . "$script_dir/colors"
elif command -v colors >/dev/null 2>&1; then
        # shellcheck disable=SC1091
        . colors
else
        RESET=''
        CYAN=''
        GREY=''
        WHITE=''
        THEME_HIGHLIGHT=''
        THEME_MUTED=''
        THEME_DIVIDER=''
fi

# Check for --spell-mode flag (label _is command, right side _is description)
spell_mode=0
if [ "${1-}" = "--spell-mode" ]; then
        spell_mode=1
        shift
fi

# Check for --start-selection flag (start cursor on specific item)
start_selection=${MENU_START_SELECTION-1}
if [ "${1-}" = "--start-selection" ]; then
        shift
        start_selection=${1-1}
        shift
fi

if [ "$#" -lt 2 ]; then
        if command -v _main_menu >/dev/null 2>&1; then
                _main_menu
                exit 0
        fi
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

description=$1
shift

items_file=$(_temp_file menu-items) || exit 1
commands_file=$(_temp_file menu-commands) || exit 1
cleanup_called=0
cleanup() {
        if [ "$cleanup_called" -eq 1 ]; then
                return
        fi
        cleanup_called=1
        restore_terminal
        _cursor_blink on >/dev/null 2>&1 || :
        _cleanup_file "$items_file"
        _cleanup_file "$commands_file"
}
trap 'cleanup; exit 1' INT TERM
trap 'cleanup' EXIT

max_name_length=0
menu_length=0

# Function to strip ANSI escape codes for length calculation
strip_ansi() {
        printf '%s' "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

for option in "$@"
do
        label=${option%%\%*}
        case $option in
        *%*)
                command=${option#*%}
                ;;
        *)
                command=''
                ;;
        esac
        printf '%s\n' "$label" >>"$items_file"
        printf '%s\n' "$command" >>"$commands_file"
        # Strip ANSI codes before calculating visible length
        clean_label=$(strip_ansi "$label")
        length=$(printf '%s' "$clean_label" | wc -c | tr -d ' ')
        if [ "$length" -gt "$max_name_length" ]; then
                max_name_length=$length
        fi
        menu_length=$((menu_length + 1))

done

if [ "$menu_length" -eq 0 ]; then
        printf '%s\n' "menu: no menu entries provided" >&2
        exit 1
fi

# Use start_selection if valid, otherwise default to 1
selected=1
case $start_selection in
        ''|*[!0-9]*)
                selected=1
                ;;
        *)
                if [ "$start_selection" -ge 1 ] && [ "$start_selection" -le "$menu_length" ]; then
                        selected=$start_selection
                fi
                ;;
esac
menu_column=1
menu_row=1
menu_drawn=0
previous_selected=0
last_window_width=0
last_max_command_length=0
dimensions_changed=1

find_next_selectable() {
        # Find the next selectable (non-divider) item after current position
        # Wraps around to beginning if needed
        start=$selected
        pos=$selected
        pos=$((pos + 1))
        if [ "$pos" -gt "$menu_length" ]; then
                pos=1
        fi
        while [ "$pos" -ne "$start" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos + 1))
                if [ "$pos" -gt "$menu_length" ]; then
                        pos=1
                fi
        done
        # No selectable items found (shouldn't happen in practice)
        return 1
}

find_prev_selectable() {
        # Find the previous selectable (non-divider) item before current position
        # Wraps around to end if needed
        start=$selected
        pos=$selected
        pos=$((pos - 1))
        if [ "$pos" -le 0 ]; then
                pos=$menu_length
        fi
        while [ "$pos" -ne "$start" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos - 1))
                if [ "$pos" -le 0 ]; then
                        pos=$menu_length
                fi
        done
        # No selectable items found (shouldn't happen in practice)
        return 1
}

find_first_selectable() {
        # Find the first selectable item (skip initial dividers)
        pos=1
        while [ "$pos" -le "$menu_length" ]; do
                if ! is_divider "$pos"; then
                        selected=$pos
                        return 0
                fi
                pos=$((pos + 1))
        done
        # No selectable items found
        return 1
}

update_dimensions() {
        # Measure the terminal so we know how much horizontal space each menu
        # row can safely use. We leave room for the two-character prefix ("> ")
        # and at least one separating space before any command preview.
        window_width=$(_fathom_terminal -w)
        max_command_length=$((window_width - max_name_length - 3))
        if [ "$max_command_length" -lt 0 ]; then
                max_command_length=0
        fi

        dimensions_changed=0
        if [ "$window_width" -ne "$last_window_width" ] || [ "$max_command_length" -ne "$last_max_command_length" ]; then
                dimensions_changed=1
        fi

        last_window_width=$window_width
        last_max_command_length=$max_command_length
}

is_divider() {
        # Check if a row _is an unselectable divider
        row_idx=$1
        cmd=$(sed -n "${row_idx}p" "$commands_file")
        case $cmd in
                --divider--) return 0 ;;
                *) return 1 ;;
        esac
}

render_divider() {
        # Render a horizontal divider line (~16 chars, centered within menu width)
        # Menu width _is based on max item (label) width, limited by window width
        # The menu width should be the max_name_length + 2 (for "> " prefix)
        menu_width=$((max_name_length + 2))
        
        # Limit menu_width to window_width (whichever _is less)
        if [ "$window_width" -gt 0 ] && [ "$menu_width" -gt "$window_width" ]; then
                menu_width=$window_width
        fi
        
        # Fixed divider width of 16 chars (or menu_width if smaller)
        divider_width=16
        if [ "$divider_width" -gt "$menu_width" ]; then
                divider_width=$menu_width
        fi
        # Calculate left padding to center the divider within menu_width
        padding=$(( (menu_width - divider_width) / 2 ))
        # Build padding string
        pad=""
        p=0
        while [ "$p" -lt "$padding" ]; do
                pad="$pad "
                p=$((p + 1))
        done
        # Build divider line
        line=""
        i=0
        while [ "$i" -lt "$divider_width" ]; do
                line="${line}─"
                i=$((i + 1))
        done
        printf '%b  %s%s%b' "$THEME_DIVIDER" "$pad" "$line" "$RESET"
}

render_row() {
        # Render a single menu row either in its normal state or highlighted
        # for the currently selected item. Each pass clears the existing row so
        # repeated renders replace text in place instead of scrolling.
        row_index=$1
        highlight=$2

        if [ "$row_index" -lt 1 ] || [ "$row_index" -gt "$menu_length" ]; then
                return
        fi

        label=$(sed -n "${row_index}p" "$items_file")
        command=$(sed -n "${row_index}p" "$commands_file")

        # Handle divider rows
        if [ "$command" = "--divider--" ]; then
                target_row=$((menu_row + row_index - 1))
                if _move_cursor "$menu_column" "$target_row"; then
                        printf '\033[K'
                        render_divider
                        printf '\r'
                else
                        render_divider
                        printf '\n'
                fi
                return
        fi

        if [ "$max_command_length" -gt 0 ]; then
                truncated_command=$(printf '%s' "$command" | cut -c -"$max_command_length")
        else
                truncated_command=''
        fi

        # Calculate visible length (without ANSI codes) for proper padding
        clean_label=$(strip_ansi "$label")
        visible_length=$(printf '%s' "$clean_label" | wc -c | tr -d ' ')
        # Calculate extra padding needed to compensate for invisible ANSI codes
        raw_length=$(printf '%s' "$label" | wc -c | tr -d ' ')
        ansi_extra=$((raw_length - visible_length))
        # Adjust the padding width to account for ANSI codes in label
        adjusted_width=$((max_name_length + ansi_extra))

        target_row=$((menu_row + row_index - 1))
        if _move_cursor "$menu_column" "$target_row"; then
                printf '\033[K'
                if [ "$highlight" -eq 1 ]; then
                        # Use clean_label (ANSI stripped) so highlight color takes precedence
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '%b> %-*s%b %b%-*s%b' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '%b> %-*s%b' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '  %-*s %b%-*s%b' "$adjusted_width" "$label" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '  %-*s' "$adjusted_width" "$label"
                        fi
                fi
                printf '\r'
        else
                if [ "$highlight" -eq 1 ]; then
                        # Use clean_label (ANSI stripped) so highlight color takes precedence
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '%b> %-*s%b %b%-*s%b\n' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '%b> %-*s%b\n' "$THEME_HIGHLIGHT" "$max_name_length" "$clean_label" "$RESET"
                        fi
                else
                        if [ "$max_command_length" -gt 0 ]; then
                                printf '  %-*s %b%-*s%b\n' "$adjusted_width" "$label" "$THEME_MUTED" "$max_command_length" "$truncated_command" "$RESET"
                        else
                                printf '  %-*s\n' "$adjusted_width" "$label"
                        fi
                fi
        fi
}

position_cursor_below_menu() {
        # Park the cursor just beneath the menu so that any subsequent output
        # (selected command logs, prompts, etc.) begins below the reserved
        # region. This keeps the menu intact while commands run.
        below_row=$((menu_row + menu_length))
        if [ "$terminal_height" -gt 0 ] && [ "$below_row" -gt "$terminal_height" ]; then
                below_row=$terminal_height
        fi

        if ! _move_cursor "$menu_column" "$below_row"; then
                printf '\n'
        fi
}

draw_menu() {
        # Redraw the entire menu from scratch. This runs the first time we
        # display the menu or whenever the terminal size changes.
        if _move_cursor "$menu_column" "$menu_row"; then
                printf '\033[J'
        fi

        row=1
        while [ "$row" -le "$menu_length" ]
        do
                if [ "$row" -eq "$selected" ]; then
                        highlight=1
                else
                        highlight=0
                fi
                render_row "$row" "$highlight"
                row=$((row + 1))
        done

        position_cursor_below_menu

        menu_drawn=1
        previous_selected=$selected
}

refresh_selection() {
        # Update only the rows that changed. If the dimensions changed or we
        # have not drawn the menu yet, fall back to a full redraw.
        if [ "$menu_drawn" -eq 0 ] || [ "$dimensions_changed" -eq 1 ]; then
                draw_menu
                return
        fi

        if [ "$selected" -ne "$previous_selected" ]; then
                if [ "$previous_selected" -gt 0 ]; then
                        render_row "$previous_selected" 0
                fi
                render_row "$selected" 1
                position_cursor_below_menu
                previous_selected=$selected
        fi
}

execute_selection() {
        # Run the command paired with the currently highlighted menu item. If
        # there _is no command we simply exit after cleaning up.
        # In spell mode, run the label (spell name) instead of the command (description).
        if [ "$spell_mode" -eq 1 ]; then
                to_run=$(sed -n "${selected}p" "$items_file")
        else
                to_run=$(sed -n "${selected}p" "$commands_file")
        fi
        if [ -n "$to_run" ]; then
                cleanup
                trap - EXIT INT TERM
                # Print newline before running command for visual separation
                printf '\n'
                # shellcheck disable=SC2039,SC3045 # POSIX sh allows eval
                eval "$to_run"
        else
                cleanup
                trap - EXIT INT TERM
        fi
}

_cursor_blink off

if [ -n "$description" ]; then
        # Show the caller-provided heading so the menu has context for the user.
        printf '%s\n' "$description"
fi

menu_row=$(_fathom_cursor -y)
case "$menu_row" in
        ''|*[!0-9]*)
                menu_row=1
                ;;
        0)
                menu_row=1
                ;;
esac

# At this stage the cursor sits on the row immediately following the menu
# heading (or at the top of the screen when no heading was provided). That row
# becomes the anchor for the first menu option so the items render directly
# beneath the title.

terminal_height=$(_fathom_terminal -h)
case "$terminal_height" in
        ''|*[!0-9]*)
                terminal_height=0
                ;;
        0)
                terminal_height=0
                ;;
esac

# Reserve vertical space before drawing anything so that the menu can repaint
# in place without pushing the terminal history around as selections change.
padding=$menu_length
while [ "$padding" -gt 0 ]; do
        printf '\n'
        padding=$((padding - 1))
done

if [ "$terminal_height" -gt 0 ]; then
        max_row=$((terminal_height - menu_length))
        if [ "$max_row" -lt 1 ]; then
                max_row=1
        fi
        if [ "$menu_row" -gt "$max_row" ]; then
                menu_row=$max_row
        fi
fi

if [ "$menu_row" -lt 1 ]; then
        menu_row=1
fi

update_dimensions
# Ensure we start on a selectable item - if selected position (from MENU_START_SELECTION)
# _is valid and not a divider, use it; otherwise find the first selectable item
if [ "$selected" -ge 1 ] && [ "$selected" -le "$menu_length" ] && ! is_divider "$selected"; then
        : # selected position _is valid and not a divider, use it
else
        find_first_selectable || :
fi
draw_menu

while :
do
        key=$(_await_keypress)
        case $key in
        up)
                find_prev_selectable || :
                ;;
        down)
                find_next_selectable || :
                ;;
        enter)
                execute_selection
                exit 0
                ;;
        escape|ESC|esc)
                cleanup
                trap - EXIT INT TERM
                # Signal the parent process to exit its menu loop
                kill -TERM "$PPID" 2>/dev/null || exit 0
                exit 0
                ;;
        esac
        update_dimensions
        refresh_selection
        # Avoid a tight loop if _await_keypress returned empty.
        [ -n "$key" ] || sleep 0.05
done
