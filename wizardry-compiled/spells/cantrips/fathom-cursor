#!/bin/sh
#
# ----------------------------- fathom-cursor ------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: fathom-cursor
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: require-command
_require_command() {

# Guard a script against missing external commands by exiting with a
# descriptive error if the binary is absent.



case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

if [ "$#" -lt 1 ]; then
    show_usage
fi

command_name=$1
shift

auto_install=${REQUIRE_COMMAND_ASSUME_YES:-0}

find_install_spell() {
    name=$1
    script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)

    if has "install-$name"; then
        where "install-$name"
        return 0
    fi

    if [ -x "$script_dir/../install/core/install-$name" ]; then
        say "$script_dir/../install/core/install-$name"
        return 0
    fi

    return 1
}

attempt_install() {
    install_spell=$(find_install_spell "$command_name") || return 1

    if [ "$auto_install" = "1" ] || ! [ -t 0 ]; then
        ASSUME_YES=1 "$install_spell" && has "$command_name"
        return $?
    fi

    printf "%s" "Install '$command_name'? [y/N] " >&2
    IFS= read -r reply || reply=""
    case $reply in
        y|Y|yes|YES)
            ASSUME_YES=1 "$install_spell" && has "$command_name"
            return $?
            ;;
        *)
            return 1
            ;;
    esac
}

# Succeed immediately when the command is already available on PATH.
has "$command_name" && exit 0

if attempt_install; then
    exit 0
fi

if [ "$#" -gt 0 ]; then
    message=$*
else
    # Point users toward the core prerequisite menu so they can resolve the
    # missing dependency the Wizardry way instead of reaching for system
    # package managers.
    message="The '${command_name}' command is required. See 'core-menu' for installation options."
fi

warn "require-command: $message"
exit 1
}


# Report the cursor position returned by the terminal in response to a DSR
# (Device Status Report) query.


show_usage() {
    cat <<'USAGE' >&2
Usage: fathom-cursor [-v|--verbose] [-x] [-y]

Query the terminal with a Device Status Report and print the cursor's current
column and row. Use -x or -y to request a single axis; -v adds labels so menu
scripts can present the measurements clearly.
USAGE
}

script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd)

# Resolve the _require_command helper to avoid copy/pasting path logic
# everywhere.
if [ -n "${REQUIRE_COMMAND-}" ]; then
    require_cmd=$REQUIRE_COMMAND
elif [ -x "$script_dir/_require_command" ]; then
    require_cmd="$script_dir/_require_command"
else
    require_cmd=_require_command
fi

require() {
    "$require_cmd" "$@"
}

verbose=0
want_x=0
want_y=0

# Parse the minimal flag set needed for the menu scripts.
while [ "$#" -gt 0 ]; do
    case "$1" in
        -v|--verbose)
            verbose=1
            ;;
        -x)
            want_x=1
            ;;
        -y)
            want_y=1
            ;;
        --help|--usage|-h)
            show_usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            show_usage
            ;;
        *)
            break
            ;;
    esac
set -eu

    shift
done

# Default to reporting both coordinates when no axis is specified.
if [ "$want_x" -eq 0 ] && [ "$want_y" -eq 0 ]; then
    want_x=1
    want_y=1
fi

# dd reads the raw response bytes from the terminal.
if ! require dd "The fathom-cursor spell needs 'dd' to read the terminal response."; then
    exit 1
fi

TTY_DEVICE=${FATHOM_CURSOR_DEVICE:-/dev/tty}
skip_stty=${FATHOM_CURSOR_SKIP_STTY:-0}

# Only reach for stty when we are manipulating a real tty.
if [ "$skip_stty" -eq 0 ]; then
    if ! require stty "The fathom-cursor spell needs 'stty' to manage terminal modes."; then
        exit 1
    fi
fi

if [ "$skip_stty" -eq 1 ]; then
    # Test harnesses can feed canned responses via a read-only file.
    if [ ! -r "$TTY_DEVICE" ]; then
        printf '%s\n' "fathom-cursor: unable to read from '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<"$TTY_DEVICE" || exit 1
    restore() {
        exec 3>&- 2>/dev/null || :
    }
else
    # When running interactively, open the tty for both reading and writing so
    # we can send the DSR request and read the reply.
    if [ ! -r "$TTY_DEVICE" ] || [ ! -w "$TTY_DEVICE" ]; then
        printf '%s\n' "fathom-cursor: unable to open controlling terminal '$TTY_DEVICE'" >&2
        exit 1
    fi

    exec 3<>"$TTY_DEVICE" || exit 1

    # Preserve the terminal state and restore it on exit to avoid leaving the
    # user with a broken session.
    saved_state=$(stty -g <&3 2>/dev/null)
    if [ -z "$saved_state" ]; then
        printf '%s\n' 'fathom-cursor: unable to read terminal settings' >&2
        exit 1
    fi

    restore() {
        stty "$saved_state" <&3 >/dev/null 2>&1 || :
        exec 3>&- 2>/dev/null || :
    }

    trap 'restore; exit 130' INT HUP TERM
    trap 'restore' EXIT

    # Configure raw mode with a short timeout so we do not block forever.
    if ! stty -icanon -echo min 0 time 5 <&3 2>/dev/null; then
        printf '%s\n' 'fathom-cursor: unable to configure terminal' >&2
        exit 1
    fi
fi

# Ask for the cursor position by emitting the DSR request when appropriate.
if [ "$skip_stty" -eq 0 ]; then
    printf '\033[6n' >&3
fi

response=''
while :; do
    byte=$(dd bs=1 count=1 2>/dev/null <&3)
    [ -z "$byte" ] && break
    response=${response}${byte}
    [ "$byte" = "R" ] && break
done

trap - EXIT
restore

esc=$(printf '\033')

case "$response" in
    '')
        printf '%s\n' 'fathom-cursor: terminal did not respond' >&2
        exit 1
        ;;
    "$esc"'['*'R')
        :
        ;;
    *)
        printf '%s\n' "fathom-cursor: unexpected response '$response'" >&2
        exit 1
        ;;
esac

# Strip the escape sequence wrapper to isolate "row;column".
coords=${response#??}
coords=${coords%R}
row=${coords%%;*}
column=${coords#*;}

case "$row" in
    *[!0-9]*)
        printf '%s\n' "fathom-cursor: invalid row '$row'" >&2
        exit 1
        ;;
    *) : ;;
esac

case "$column" in
    *[!0-9]*)
        printf '%s\n' "fathom-cursor: invalid column '$column'" >&2
        exit 1
        ;;
    *) : ;;
esac

print_value() {
    label=$1
    value=$2
    if [ "$verbose" -eq 1 ]; then
        printf '%s: %s\n' "$label" "$value"
    else
        printf '%s\n' "$value"
    fi
}

# Honour the axis selection made by the caller.
if [ "$want_x" -eq 1 ] && [ "$want_y" -eq 1 ]; then
    print_value 'X' "$column"
    print_value 'Y' "$row"
elif [ "$want_x" -eq 1 ]; then
    print_value 'X' "$column"
else
    print_value 'Y' "$row"
fi
