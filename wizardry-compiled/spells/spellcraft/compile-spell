#!/bin/sh
#
# ----------------------------- compile-spell ------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: compile-spell
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: die
_die() {
  case "$1" in
    [0-9]|[0-9][0-9]|[0-9][0-9][0-9]) _die_code=$1; shift ;;
    *) _die_code=1 ;;
  esac
  printf '%s\n' "$*" >&2
  return "$_die_code"
}

# Inlined imp: empty
_empty() {
  [ -z "$1" ]
}

# Inlined imp: env-or
_env_or() {
  _eo_var=$1
  # Validate variable name contains only alphanumerics and underscores
  case "$_eo_var" in
    *[!A-Za-z0-9_]*|"")
      printf '%s\n' "$2"
      return
      ;;
  esac
  eval "_eo_val=\${$_eo_var-}"
  if [ -n "$_eo_val" ]; then
    printf '%s\n' "$_eo_val"
  else
    printf '%s\n' "$2"
  fi
}

# Inlined imp: fail
_fail() {
  printf '%s\n' "$*" >&2
  return 1
}

# Inlined imp: full
_full() {
  case "$1" in
    file) [ -s "$2" ] ;;
    dir)  [ -d "$2" ] && [ -n "$(ls -A "$2" 2>/dev/null)" ] ;;
    *)    return 1 ;;
  esac
}

# Inlined imp: given
_given() {
  [ -n "$1" ]
}

# Inlined imp: has
_has() {
  command -v "$1" >/dev/null 2>&1
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined imp: lacks
_lacks() {
  ! command -v "$1" >/dev/null 2>&1
}

# Inlined spell: memorize
_memorize() {

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory


spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
	cast_dir=$1
	if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
		file=$(expand_tilde "$WIZARDRY_CAST_FILE")
	elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
		file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
	else
		file=$cast_dir/.memorized
	fi
	printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
	if [ ! -d "$cast_dir" ]; then
		mkdir -p "$cast_dir"
	fi
	dir=${command_file%/*}
	if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_name() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "$spell_name: names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

nonempty() {
	[ -n "$1" ]
}

add_spell() {
	name=$1
	validate_name "$name"
	ensure_parent_directory
	# Memorize just lists existing spells by name - no wrapper scripts needed
	# The spell must already exist in PATH or spellbook
	cmd=$name
	tmp=$(temp-file memorize) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	if [ -f "$command_file" ]; then
		while IFS= read -r line || nonempty "$line"; do
			entry_name=$line
			case $line in
			*"$tab_char"*)
				entry_name=${line%%"$tab_char"*}
				;;
			esac
			if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
				continue
			fi
			printf '%s\n' "$line" >>"$tmp"
		done <"$command_file"
	fi
	printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
	if [ -f "$tmp" ]; then
		cat "$tmp" >>"$command_file"
	fi
	trap - EXIT HUP INT TERM
	rm -f "$tmp"
}

list_entries() {
	if [ -f "$command_file" ]; then
		cat "$command_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1

case $action in
list)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$command_file"
	;;
dir)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$cast_dir"
	;;
--help|--usage|-h)
	show_usage
	;;
-*)
	printf '%s\n' "$spell_name: unknown option '$action'" >&2
	show_usage
	exit 1
	;;
*)
	# Default action: memorize the spell
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "$spell_name: expects exactly one spell name." >&2
		show_usage
		exit 1
	fi
	add_spell "$action"
	;;
esac
}

# Inlined imp: say
_say() {
  printf '%s\n' "$*"
}

# Inlined imp: there
_there() {
  [ -e "$1" ]
}

# Inlined imp: warn
_warn() {
  printf '%s\n' "$*" >&2
}


# Compile a spell into a standalone script by inlining its dependencies.
# Creates a self-contained executable that works without wizardry installed.

show_usage() {
  cat <<'USAGE'
Usage: compile-spell <spell-name>

Compile a spell into a standalone script by inlining all dependencies.
The compiled spell can run without wizardry being installed.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac
set -eu

if [ "$#" -lt 1 ]; then
  printf '%s\n' "compile-spell: spell name required" >&2
  show_usage >&2
  exit 1
fi

spell_name=$1

# Find the spell
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
repo_dir=$(CDPATH= cd -- "$script_dir/../.." && pwd -P)
imps_dir="$repo_dir/spells/.imps"

# Find spell recursively (include imps and .arcana)
spell_path=$(find "$repo_dir/spells" -type f -name "$spell_name" 2>/dev/null | head -1)

if [ -z "$spell_path" ] || [ ! -f "$spell_path" ]; then
  printf '%s\n' "compile-spell: spell '$spell_name' not found" >&2
  exit 1
fi

# Read spell content
spell_content=$(cat "$spell_path")

# Find all potential dependencies - hyphenated commands, common imps, and spell names
# Look in actual command positions (not in strings/comments)
dependencies=$(printf '%s\n' "$spell_content" | \
  grep -v "^#" | \
  grep -v "^[[:space:]]*#" | \
  grep -oE '\b(_say|_warn|_die|_fail|_is|_has|_there|_empty|_full|_given|_lacks|_memorize|_env_or|[a-z][a-z0-9]*(-[a-z0-9]+)+)\b' | \
  sort -u || true)

# Collect inline implementations and track what was inlined
inlined_deps=""
inlined_names=""

for dep in $dependencies; do
  # Skip require-wizardry - doesn't make sense in standalone
  [ "$dep" = "require-wizardry" ] && continue
  
  # Skip if already inlined
  case " $inlined_names " in
    *" $dep "*) continue ;;
  esac
  
  # Find the imp/spell file
  dep_file=$(find "$imps_dir" -type f -name "$dep" 2>/dev/null | head -1)
  
  # If not found in imps, check spells
  if [ -z "$dep_file" ]; then
    dep_file=$(find "$repo_dir/spells" -type f -name "$dep" \
      ! -path "*/\.*" ! -path "$spell_path" 2>/dev/null | head -1)
  fi
  
  # Skip if not found
  [ -z "$dep_file" ] || [ ! -f "$dep_file" ] && continue
  
  # Read dependency content
  dep_content=$(cat "$dep_file")
  
  # Extract function definition (lines from _funcname() to closing })
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  func_def=$(printf '%s\n' "$dep_content" | awk -v fname="$func_name" '
    /^'$func_name'\(\)/ { in_func=1 }
    in_func { print }
    in_func && /^}$/ { exit }
  ')
  
  # If we got a function (it's an imp), inline it
  if [ -n "$func_def" ]; then
    inlined_deps="$inlined_deps
# Inlined imp: $dep
$func_def
"
    inlined_names="$inlined_names $dep"
  else
    # It's a spell without _funcname() pattern - inline entire spell as function
    # Remove shebang, show_usage, --help handler, require-wizardry, and set -eu
    spell_body=$(printf '%s\n' "$dep_content" | awk '
      BEGIN { skip=0; in_usage=0 }
      /^#!/ { next }
      /^show_usage\(\)/ { in_usage=1; next }
      in_usage && /^}$/ { in_usage=0; next }
      in_usage { next }
      /^case.*--help.*--usage/ { skip=1; next }
      skip && /^esac/ { skip=0; next }
      skip { next }
      /^set -eu$/ { next }
      /^require-wizardry/ { next }
      { print }
    ')
    
    # Wrap as function
    inlined_deps="$inlined_deps
# Inlined spell: $dep
$func_name() {
$spell_body
}
"
    inlined_names="$inlined_names $dep"
  fi
done

# Transform spell content:
# 1. Remove shebang and require-wizardry
# 2. Replace imp calls with underscore versions (e.g., _say -> _say, clip-copy -> _clip_copy)
transformed=$(printf '%s\n' "$spell_content" | tail -n +2 | grep -v "^require-wizardry")

# For each inlined imp, replace calls in the spell
# Note: func_name comes from sanitized internal processing (tr '-' '_')
# so special regex characters are not a concern here
for dep in $inlined_names; do
  func_name="_$(printf '%s' "$dep" | tr '-' '_')"
  
  # Use awk for more controlled replacement - skip USAGE blocks
  # Note: This handles common USAGE heredoc patterns including quoted delimiters
  transformed=$(printf '%s\n' "$transformed" | awk -v old="$dep" -v new="$func_name" '
    /^cat <<['\''"]?USAGE['\''"]?/ { usage_start=1 }
    usage_start && /^USAGE$/ { print; usage_start=0; next }
    usage_start { print; next }
    { gsub("\\<" old "\\>", new); print }
  ')
done

# Output compiled spell
printf '#!/bin/sh\n'
printf '#\n'

# Create centered separator with spell name (76 chars total width)
name_len=${#spell_name}
dash_space=$((76 - 2 - name_len - 2))  # 76 - "# " - name - spaces around
# Minimum dash space of 8 ensures readable formatting even with long names
if [ "$dash_space" -lt 8 ]; then
  # Name too long, truncate
  max_name_len=$((76 - 2 - 8 - 2))
  display_name=$(printf '%s' "$spell_name" | cut -c1-"$max_name_len")
  name_len=${#display_name}
  dash_space=$((76 - 2 - name_len - 2))
else
  display_name=$spell_name
fi
left_dashes=$((dash_space / 2))
right_dashes=$((dash_space - left_dashes))

# Build centered separator
separator="# "
i=0
while [ "$i" -lt "$left_dashes" ]; do
  separator="${separator}-"
  i=$((i + 1))
done
separator="${separator} ${display_name} "
i=0
while [ "$i" -lt "$right_dashes" ]; do
  separator="${separator}-"
  i=$((i + 1))
done

printf '%s\n' "$separator"
printf '#\n'
printf '# COMPILED WIZARDRY SPELL\n'
printf '#\n'
printf '# This _is a compiled version of a wizardry spell.\n'
printf '# Wizardry _is a collection of POSIX shell scripts themed as magical spells,\n'
printf '# turning folders into rooms and files into items, like a fantasy MUD.\n'
printf '#\n'
printf '# For the _full clean version of this script and much more, please visit:\n'
printf '# https://github.com/andersaamodt/wizardry\n'
printf '#\n'
printf '# Original spell: %s\n' "$spell_name"
printf '# Generated by: compile-spell\n'
printf '#\n'
printf '# ----------------------------------------------------------------------------\n'
printf '#\n'
printf '#  ,___,   OPEN WIZARDRY LICENSE 1.1\n'
printf '#  (O,O)\n'
printf '#  /)  )   Permission: You may use, copy, modify, and share this project\n'
printf '# ="=="=   for non-commercial purposes, including private, educational,\n'
printf '#          research, and internal organizational use.\n'
printf '#\n'
printf '# Commercial Use: Commercial exploitation _is prohibited. "Commercial exploitation"\n'
printf '# means sale, subscription, paid access, monetized hosting, inclusion in any paid\n'
printf '# product or service, or use as part of any monetized system, even if not the\n'
printf '# primary component. Internal use by commercial entities _is allowed.\n'
printf '#\n'
printf '# Reciprocity: If you make modified versions publicly available—either by\n'
printf '# distributing copies or by operating a public-facing service that meaningfully\n'
printf '# depends on those modified files—you must publish those modified files under\n'
printf '# this license. No other files must be published.\n'
printf '#\n'
printf '# No Enclosure: Modified files you share must remain exclusively under this\n'
printf '# license, without additional restrictions. This license must accompany any public\n'
printf '# distribution of modified files.\n'
printf '#\n'
printf '# Warranty: Provided without warranty or guarantee of any kind.\n'
printf '#\n'
printf '# ----------------------------------------------------------------------------\n'
printf '\n'

# Output inlined dependencies
if [ -n "$inlined_deps" ]; then
  printf '%s\n' "$inlined_deps"
fi

# Output transformed spell content
printf '%s\n' "$transformed"
