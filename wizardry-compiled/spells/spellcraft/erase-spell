#!/bin/sh
#
# ------------------------------ erase-spell -------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: erase-spell
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: env-or
_env_or() {
  _eo_var=$1
  # Validate variable name contains only alphanumerics and underscores
  case "$_eo_var" in
    *[!A-Za-z0-9_]*|"")
      printf '%s\n' "$2"
      return
      ;;
  esac
  eval "_eo_val=\${$_eo_var-}"
  if [ -n "$_eo_val" ]; then
    printf '%s\n' "$_eo_val"
  else
    printf '%s\n' "$2"
  fi
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# erase-spell - Delete a custom spell from $SPELLBOOK_DIR
# Asks for confirmation before deleting.


spell_home=$(_env_or SPELLBOOK_DIR "${HOME:-.}/.spellbook")

show_usage() {
        cat <<'USAGE'
Usage: erase-spell NAME [--force]

Delete a custom spell from $SPELLBOOK_DIR. This action cannot be undone.

Options:
  --force, -f   Skip confirmation prompt
  --help, -h    Show this help message
USAGE
}

find_custom_spell() {
        name=$1
        # Check in spell_home root
        script_path="$spell_home/$name"
        if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                printf '%s' "$script_path"
                return 0
        fi
        # Check in spell_home subfolders
        for subdir in "$spell_home"/*; do
                [ -d "$subdir" ] || continue
                script_path="$subdir/$name"
                if [ -f "$script_path" ] && [ -x "$script_path" ]; then
                        printf '%s' "$script_path"
                        return 0
                fi
        done
        return 1
}

force=0
name=""

while [ "$#" -gt 0 ]; do
        case $1 in
                --help|--usage|-h)
                        show_usage
                        exit 0
                        ;;
                --force|-f)
                        force=1
                        shift
                        ;;
                -*)
                        printf 'erase-spell: unknown option: %s\n' "$1" >&2
                        exit 1
                        ;;
                *)
                        if [ -z "$name" ]; then
                                name=$1
                        else
                                printf 'erase-spell: unexpected argument: %s\n' "$1" >&2
                                exit 1
                        fi
                        shift
                        ;;
        esac
set -eu

done

if [ -z "$name" ]; then
        show_usage >&2
        exit 1
fi

# Find the spell
script_path=$(find_custom_spell "$name") || {
        printf 'erase-spell: spell "%s" not found in %s\n' "$name" "$spell_home" >&2
        exit 1
}

# Check if it's actually in spell_home (not a built-in spell)
case "$script_path" in
        "$spell_home"/*)
                : # OK, it's a custom spell
                ;;
        *)
                printf 'erase-spell: "%s" _is not a custom spell and cannot be erased\n' "$name" >&2
                exit 1
                ;;
esac

# Ask for confirmation unless --force
if [ "$force" -eq 0 ]; then
        printf 'Erase spell "%s"? This cannot be undone. (y/N) ' "$name"
        read -r answer
        case $answer in
                [Yy]|[Yy][Ee][Ss])
                        : # proceed
                        ;;
                *)
                        printf 'Aborted.\n'
                        exit 0
                        ;;
        esac
fi

# Delete the spell
rm -f "$script_path"
printf 'Erased spell "%s".\n' "$name"
