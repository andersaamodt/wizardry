#!/bin/sh
#
# --------------------------------- learn ----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: learn
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined spell: detect-rc-file
_detect_rc_file() {

# This spell selects the best shell rc file for PATH exports or memorization.
# It prints platform, rc_file, and format hints so callers can update startup files safely.



platform="${DETECT_RC_FILE_PLATFORM-}"

while [ "$#" -gt 0 ]; do
        case $1 in
        --platform)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "detect-rc-file: --platform expects a value." >&2
                        show_usage
                        exit 1
                fi
                platform=$2
                shift 2
                ;;
        --platform=*)
                        platform=${1#*=}
                        shift
                        ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "detect-rc-file: unknown option '$1'." >&2
                show_usage
                exit 1
                ;;
        *)
                break
                ;;
        esac

done

if [ "$#" -gt 0 ]; then
        printf '%s\n' "detect-rc-file: unexpected argument '$1'." >&2
        show_usage
        exit 1
fi

add_candidate() {
        file=$1
        if [ -z "$file" ]; then
                return 0
        fi
        for candidate in $RC_CANDIDATES; do
                if [ "$candidate" = "$file" ]; then
                        return 0
                fi
        done
        if [ -z "$RC_CANDIDATES" ]; then
                RC_CANDIDATES=$file
        else
                RC_CANDIDATES="$RC_CANDIDATES $file"
        fi
}

# Decide platform once so the downstream selection stays predictable.
if [ -z "$platform" ]; then
        if command -v detect-distro >/dev/null 2>&1; then
                platform=$(detect-distro 2>/dev/null || printf 'unknown')
        else
                platform=unknown
        fi
fi

RC_CANDIDATES=''

case $platform in
mac)
        # On macOS, Terminal.app and iTerm2 open login shells by default.
        # Login shells source .zprofile (not .zshrc), so we prefer .zprofile
        # for PATH additions to ensure they take effect in new terminal windows.
        # If .zshrc exists but .zprofile doesn't, we use .zshrc since the user
        # may have configured their terminal to use interactive shells.
        add_candidate "$HOME/.zprofile"
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.bash_profile"
        ;;
nixos)
        # On NixOS, prefer nix config if home-manager is available or the config
        # file already exists. Otherwise fall back to shell RC files to ensure
        # PATH changes take effect immediately.
        # Check NIXOS_CONFIG env var first - this is the standard way to specify
        # a custom configuration location on NixOS.
        if [ -n "${NIXOS_CONFIG-}" ] && [ -f "$NIXOS_CONFIG" ]; then
                add_candidate "$NIXOS_CONFIG"
        fi
        # Check if home-manager is installed - if so, prioritize home-manager paths
        # over system-level configuration to avoid requiring sudo.
        home_manager_installed=0
        if command -v home-manager >/dev/null 2>&1; then
                home_manager_installed=1
        fi
        # Check for home-manager configurations in both old and new paths.
        # Newer home-manager uses ~/.config/home-manager/home.nix
        # Older standalone home-manager uses ~/.config/nixpkgs/home.nix
        if [ -f "$HOME/.config/home-manager/home.nix" ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        if [ -f "$HOME/.config/nixpkgs/home.nix" ]; then
                add_candidate "$HOME/.config/nixpkgs/home.nix"
        fi
        # If home-manager is installed but no config exists yet, suggest the new path
        if [ "$home_manager_installed" -eq 1 ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        # Check for system-level configuration (requires sudo to edit).
        # Only add this if home-manager is NOT installed, since home-manager
        # is preferred when available (doesn't require sudo).
        if [ "$home_manager_installed" -eq 0 ] && [ -f /etc/nixos/configuration.nix ]; then
                add_candidate /etc/nixos/configuration.nix
        fi
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        add_candidate "$HOME/.profile"
        ;;
debian|arch|fedora)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.profile"
        ;;
*) : ;;
        esac

shell_name=${SHELL-}
if [ -z "$shell_name" ]; then
# Some non-interactive shells (like dash) do not export SHELL, so default to
# sh to keep the rc-file selection predictable even when the variable is
# unset.
shell_name=sh
fi

case ${shell_name##*/} in
zsh)
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.zprofile"
        ;;
bash)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        ;;
*)
        add_candidate "$HOME/.profile"
        ;;
        esac

add_candidate "$HOME/.bashrc"
add_candidate "$HOME/.profile"

rc_file=''
for candidate in $RC_CANDIDATES; do
        if [ -f "$candidate" ]; then
                rc_file=$candidate
                break
        fi
done

if [ -z "$rc_file" ]; then
        for candidate in $RC_CANDIDATES; do
                rc_file=$candidate
                break
        done
fi

if [ -z "$rc_file" ]; then
        printf '%s\n' "detect-rc-file: unable to determine a startup file." >&2
        exit 1
fi

case $rc_file in
*.nix)
        format=nix
        ;;
*)
        format=shell
        ;;
        esac

printf 'platform=%s\n' "$platform"
printf 'rc_file=%s\n' "$rc_file"
printf 'format=%s\n' "$format"
}

# Inlined imp: invoke-wizardry
_invoke_wizardry() {
  if [ -z "${WIZARDRY_DIR-}" ]; then
    # Default to expected install location; user can set WIZARDRY_DIR manually if different
    _iw_script_dir="${HOME-}/.wizardry/spells/.imps/sys"
    WIZARDRY_DIR=$(CDPATH= cd -- "$_iw_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi
  
  if [ -z "${WIZARDRY_DIR-}" ] || [ ! -d "${WIZARDRY_DIR-}/spells" ]; then
    return 1
  fi
  
  export WIZARDRY_DIR
  
  : "${SPELLBOOK_DIR:=${HOME-}/.spellbook}"
  export SPELLBOOK_DIR
  
  _iw_paths_to_add=""
  _iw_imps_dir="$WIZARDRY_DIR/spells/.imps"
  
  case ":${PATH-}:" in
    *":$WIZARDRY_DIR/spells:"*) ;;
    *) _iw_paths_to_add="$WIZARDRY_DIR/spells" ;;
  esac
  
  for _iw_spell_dir in "$WIZARDRY_DIR"/spells/*; do
    [ -d "$_iw_spell_dir" ] || continue
    case "$_iw_spell_dir" in
      */.imps) continue ;;
    esac
    case ":${PATH-}:" in
      *":$_iw_spell_dir:"*) ;;
      *) 
        if [ -n "$_iw_paths_to_add" ]; then
          _iw_paths_to_add="$_iw_paths_to_add:$_iw_spell_dir"
        else
          _iw_paths_to_add="$_iw_spell_dir"
        fi
        ;;
    esac
  done
  
  if [ -d "$_iw_imps_dir" ]; then
    case ":${PATH-}:" in
      *":$_iw_imps_dir:"*) ;;
      *)
        if [ -n "$_iw_paths_to_add" ]; then
          _iw_paths_to_add="$_iw_paths_to_add:$_iw_imps_dir"
        else
          _iw_paths_to_add="$_iw_imps_dir"
        fi
        ;;
    esac
    
    for _iw_family in "$_iw_imps_dir"/*; do
      [ -d "$_iw_family" ] || continue
      case ":${PATH-}:" in
        *":$_iw_family:"*) ;;
        *)
          if [ -n "$_iw_paths_to_add" ]; then
            _iw_paths_to_add="$_iw_paths_to_add:$_iw_family"
          else
            _iw_paths_to_add="$_iw_family"
          fi
          ;;
      esac
    done
  fi
  
  if [ -d "$SPELLBOOK_DIR" ]; then
    case ":${PATH-}:" in
      *":$SPELLBOOK_DIR:"*) ;;
      *)
        if [ -n "$_iw_paths_to_add" ]; then
          _iw_paths_to_add="$_iw_paths_to_add:$SPELLBOOK_DIR"
        else
          _iw_paths_to_add="$SPELLBOOK_DIR"
        fi
        ;;
    esac
  fi
  
  if [ -n "$_iw_paths_to_add" ]; then
    PATH="${_iw_paths_to_add}${PATH:+:}${PATH-}"
    export PATH
  fi
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined spell: learn-spell
_learn_spell() {

# This spell installs spells that define an install() function.
# It scans files for install() and runs them to set up shell integration.
# Bootstrappable - does not rely on wizardry scripts being installed.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac


case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac


SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Find ask-yn helper
if [ -n "${MEMORIZE_ASK_YN-}" ]; then
  ASK_YN_HELPER=$MEMORIZE_ASK_YN
elif [ -x "$SPELLS_DIR/cantrips/ask-yn" ]; then
  ASK_YN_HELPER="$SPELLS_DIR/cantrips/ask-yn"
elif command -v ask-yn >/dev/null 2>&1; then
  ASK_YN_HELPER=$(command -v ask-yn)
else
  # Fallback to yes for non-interactive use
  ASK_YN_HELPER=""
fi

RECURSIVE=0
DRY_RUN=0
MEMORIZED_COUNT=0
SKIPPED_COUNT=0
MEMORIZE_DETECTED=0
MEMORIZE_PLATFORM=${WIZARDRY_PLATFORM-${MEMORIZE_PLATFORM-}}
MEMORIZE_RC_FILE=${WIZARDRY_RC_FILE-${MEMORIZE_RC_FILE-}}
MEMORIZE_FORMAT=${WIZARDRY_RC_FORMAT-${MEMORIZE_RC_FORMAT-}}
DETECT_RC_FILE=${MEMORIZE_DETECT_RC_FILE-}

warn() {
  printf '%s: %s\n' "$SCRIPT_NAME" "$1" >&2
}

detect_environment() {
  if [ "$MEMORIZE_DETECTED" -eq 1 ]; then
    return 0
  fi
  
  # Track whether DETECT_RC_FILE was explicitly set
  detect_rc_override=0
  if [ -n "${DETECT_RC_FILE-}" ]; then
    detect_rc_override=1
  elif [ -n "${MEMORIZE_DETECT_RC_FILE-}" ]; then
    DETECT_RC_FILE=$MEMORIZE_DETECT_RC_FILE
  else
    DETECT_RC_FILE=$SPELLS_DIR/divination/detect-rc-file
  fi
  
  if [ ! -x "$DETECT_RC_FILE" ]; then
    if [ "$detect_rc_override" -eq 0 ] && command -v detect-rc-file >/dev/null 2>&1; then
      DETECT_RC_FILE=$(command -v detect-rc-file)
    else
      printf '%s\n' "$SCRIPT_NAME: detect-rc-file spell is missing." >&2
      exit 1
    fi
  fi
  
  platform=$MEMORIZE_PLATFORM
  rc_file=$MEMORIZE_RC_FILE
  format=$MEMORIZE_FORMAT
  
  if [ -z "$platform" ] || [ -z "$rc_file" ] || [ -z "$format" ]; then
    output=$("$DETECT_RC_FILE")
    while IFS='=' read -r key value; do
      case $key in
      platform) [ -z "$platform" ] && platform=$value ;;
      rc_file) [ -z "$rc_file" ] && rc_file=$value ;;
      format) [ -z "$format" ] && format=$value ;;
      esac
    done <<EOF_DETECT
$output
EOF_DETECT
  fi
  
  if [ -z "$rc_file" ]; then
    printf '%s\n' "$SCRIPT_NAME: detect-rc-file did not yield an rc file." >&2
    exit 1
  fi
  
  : "${platform:=unknown}"
  : "${format:=shell}"
  
  MEMORIZE_PLATFORM=$platform
  MEMORIZE_RC_FILE=$rc_file
  MEMORIZE_FORMAT=$format
  export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
  export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
  export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
  MEMORIZE_DETECTED=1
}

have_install_function() {
  file=$1
  [ -r "$file" ] || return 1
  grep -Eq '^[[:space:]]*install[[:space:]]*\(\)' "$file" 2>/dev/null
}

create_wrapper() {
  MEMORIZE_WRAPPER=$(temp-file learn-spell) || exit 1
  trap 'cleanup-file "$MEMORIZE_WRAPPER"' EXIT HUP INT TERM
  cat <<'WRAPPER' >"$MEMORIZE_WRAPPER"
TARGET=$1
shift
[ -f "$TARGET" ] || { printf '%s\n' "learn-spell: missing target '$TARGET'" >&2; exit 1; }
WIZARDRY_MEMORIZE_TARGET="$TARGET"
export WIZARDRY_MEMORIZE_TARGET
. "$TARGET"
command -v install >/dev/null 2>&1 || { printf '%s\n' "learn-spell: $TARGET does not define install()" >&2; exit 1; }
install "$@"
WRAPPER
}

get_interpreter() {
  target=$1
  first_line=''
  IFS= read -r first_line <"$target" || true
  case $first_line in
  '#!'*) first_line=${first_line#\#!} ;;
  *) first_line=/bin/sh ;;
  esac
  printf '%s' "$first_line" | tr -d '\r'
}

run_install() {
  target=$1
  [ -z "${MEMORIZE_WRAPPER-}" ] || [ ! -f "$MEMORIZE_WRAPPER" ] && create_wrapper
  detect_environment || return 1
  interpreter=$(get_interpreter "$target")
  : "${interpreter:=/bin/sh}"
  (
    export WIZARDRY_PLATFORM=$MEMORIZE_PLATFORM
    export WIZARDRY_RC_FILE=$MEMORIZE_RC_FILE
    export WIZARDRY_RC_FORMAT=$MEMORIZE_FORMAT
    set -- $interpreter
    [ "$#" -eq 0 ] && set -- /bin/sh
    "$@" "$MEMORIZE_WRAPPER" "$target"
  )
}

scribe_file() {
  path=$1
  if [ ! -f "$path" ] || [ ! -x "$path" ] || ! have_install_function "$path"; then
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  if [ "$DRY_RUN" -eq 1 ]; then
    printf '%s\n' "$path"
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
    return
  fi
  printf 'Memorizing %s...\n' "$path"
  if run_install "$path"; then
    MEMORIZED_COUNT=$((MEMORIZED_COUNT + 1))
  else
    warn "Installation failed for '$path'."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
}

scan_directory() {
  dir=$1
  if [ ! -d "$dir" ]; then
    warn "'$dir' is not a directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    return
  fi
  for entry in "$dir"/*; do
    [ -e "$entry" ] || continue
    if [ -d "$entry" ] && [ "$RECURSIVE" -eq 1 ]; then
      scan_directory "$entry"
    elif [ -f "$entry" ]; then
      scribe_file "$entry"
    fi
  done
}

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --dry-run)
    DRY_RUN=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    warn "Unknown option: $1"
    show_usage
    exit 1
    ;;
  *)
    break
    ;;
  esac
done

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

# Process paths
for path in "$@"; do
  if [ -d "$path" ]; then
    scan_directory "$path"
  elif [ -f "$path" ]; then
    scribe_file "$path"
  else
    warn "'$path' is not a file or directory."
    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
  fi
done

if [ "$DRY_RUN" -eq 1 ]; then
  printf 'Would memorize %d spell(s).\n' "$MEMORIZED_COUNT"
else
  printf 'Memorized %d spell(s).\n' "$MEMORIZED_COUNT"
fi

# Exit with failure if no spells were memorized and paths were skipped
if [ "$MEMORIZED_COUNT" -eq 0 ] && [ "$SKIPPED_COUNT" -gt 0 ]; then
  exit 1
fi

exit 0
}

# Inlined imp: nix-shell-add
_nix_shell_add() {
  _nsa_block_name=${1:-}
  _nsa_nix_file=${2:-}
  _nsa_shell_type=${3:-bash}

  if [ -z "$_nsa_block_name" ] || [ -z "$_nsa_nix_file" ]; then
    printf '%s\n' "nix-shell-add: NAME and FILE are required" >&2
    return 1
  fi

  case $_nsa_shell_type in
    bash|zsh) : ;;
    *) printf '%s\n' "nix-shell-add: shell must be 'bash' or 'zsh'" >&2; return 1 ;;
  esac

  _nsa_is_system_config=0
  case $_nsa_nix_file in /etc/nixos/*) _nsa_is_system_config=1 ;; esac

  if [ "$_nsa_is_system_config" -eq 1 ]; then
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.interactiveShellInit" ;;
      zsh)  _nsa_nix_option="programs.zsh.interactiveShellInit" ;;
    esac
  else
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.initExtra" ;;
      zsh)  _nsa_nix_option="programs.zsh.initExtra" ;;
    esac
  fi

  _nsa_marker="# wizardry: $_nsa_block_name"

  _nsa_needs_sudo=0
  if [ -f "$_nsa_nix_file" ] && [ ! -w "$_nsa_nix_file" ]; then
    _nsa_needs_sudo=1
  fi

  if [ -f "$_nsa_nix_file" ] && grep -Fq "$_nsa_marker" "$_nsa_nix_file" 2>/dev/null; then return 0; fi
  _nsa_shell_code=""
  while IFS= read -r _nsa_line || [ -n "$_nsa_line" ]; do
    if [ -z "$_nsa_shell_code" ]; then _nsa_shell_code=$_nsa_line
    else _nsa_shell_code="$_nsa_shell_code
$_nsa_line"; fi
  done
  if [ -z "$_nsa_shell_code" ]; then
    printf '%s\n' "nix-shell-add: no shell code provided on stdin" >&2
    return 1
  fi
  _nsa_escaped_code=$(printf '%s' "$_nsa_shell_code" | sed "s/''/'''/g; s/\\\${/''\${/g")
  _nsa_marked_code=$(printf '%s' "$_nsa_escaped_code" | sed "s/$/ $_nsa_marker/")
  if [ ! -f "$_nsa_nix_file" ]; then
    _nsa_dir=${_nsa_nix_file%/*}
    [ "$_nsa_dir" != "$_nsa_nix_file" ] && [ ! -d "$_nsa_dir" ] && mkdir -p "$_nsa_dir"
    printf '{ config, pkgs, ... }:\n\n{\n}\n' > "$_nsa_nix_file"
  fi
  _nsa_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add.XXXXXX") || return 1
  # Read file content inline
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then _nsa_content=$(sudo cat "$_nsa_nix_file")
    elif command -v doas >/dev/null 2>&1; then _nsa_content=$(doas cat "$_nsa_nix_file")
    else _nsa_content=$(cat "$_nsa_nix_file"); fi
  else _nsa_content=$(cat "$_nsa_nix_file"); fi
  
  if printf '%s\n' "$_nsa_content" | grep -q "$_nsa_nix_option[[:space:]]*="; then
    _nsa_input_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-input.XXXXXX") || return 1
    printf '%s\n' "$_nsa_content" > "$_nsa_input_file"
    _nsa_in_block=0
    while IFS= read -r _nsa_line; do
      if printf '%s\n' "$_nsa_line" | grep -q "$_nsa_nix_option[[:space:]]*=" && printf '%s\n' "$_nsa_line" | grep -q "''"; then
        _nsa_in_block=1; printf '%s\n' "$_nsa_line"; continue
      fi
      if [ "$_nsa_in_block" -eq 1 ] && printf '%s\n' "$_nsa_line" | grep -q "^[[:space:]]*'';"; then
        printf '%s\n' "$_nsa_marked_code"; printf '%s\n' "$_nsa_line"; _nsa_in_block=0; continue
      fi
      printf '%s\n' "$_nsa_line"
    done < "$_nsa_input_file" > "$_nsa_tmp_file"
    rm -f "$_nsa_input_file"
  else
    # Write the block to a temp file and use it with awk (macOS awk compatible)
    _nsa_block_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-block.XXXXXX") || return 1
    printf '%s\n' "  $_nsa_nix_option = ''" > "$_nsa_block_file"
    printf '%s\n' "$_nsa_marked_code" >> "$_nsa_block_file"
    printf '%s\n' "  '';" >> "$_nsa_block_file"
    
    printf '%s\n' "$_nsa_content" | awk -v blockfile="$_nsa_block_file" '
    BEGIN { while ((getline line < blockfile) > 0) block = block line "\n" }
    { lines[NR] = $0 }
    END {
      last = NR; while (last > 0 && lines[last] ~ /^[[:space:]]*$/) last--
      if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
        for (i = 1; i < last; i++) print lines[i]; print ""; printf "%s", block; print lines[last]
        for (i = last + 1; i <= NR; i++) print lines[i]
      } else { for (i = 1; i <= NR; i++) print lines[i]; print ""; printf "%s", block }
    }' > "$_nsa_tmp_file"
    rm -f "$_nsa_block_file"
  fi
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsa_tmp_file" "$_nsa_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsa_tmp_file" "$_nsa_nix_file"
    else cp "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  else mv "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  rm -f "$_nsa_tmp_file"
  return 0
}

# Inlined imp: nix-shell-remove
_nix_shell_remove() {
  _nsr_block_name=${1:-}
  _nsr_nix_file=${2:-}

  if [ -z "$_nsr_block_name" ] || [ -z "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: NAME and FILE are required" >&2
    return 1
  fi

  _nsr_marker="# wizardry: $_nsr_block_name"

  _nsr_needs_sudo=0
  if [ -f "$_nsr_nix_file" ] && [ ! -w "$_nsr_nix_file" ]; then
    _nsr_needs_sudo=1
  fi

  if [ ! -f "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: file not found: $_nsr_nix_file" >&2
    return 1
  fi
  if ! grep -Fq "$_nsr_marker" "$_nsr_nix_file" 2>/dev/null; then return 0; fi
  _nsr_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-remove.XXXXXX") || return 1
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cat "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cat "$_nsr_nix_file"
    else cat "$_nsr_nix_file"; fi
  else
    cat "$_nsr_nix_file"
  fi | grep -v -F "$_nsr_marker" > "$_nsr_tmp_file"
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsr_tmp_file" "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsr_tmp_file" "$_nsr_nix_file"
    else cp "$_nsr_tmp_file" "$_nsr_nix_file"; fi
  else
    mv "$_nsr_tmp_file" "$_nsr_nix_file"
  fi
  rm -f "$_nsr_tmp_file"
  return 0
}

# Inlined imp: nix-shell-status
_nix_shell_status() {
  _nss_block_name=${1:-}
  _nss_nix_file=${2:-}

  if [ -z "$_nss_block_name" ] || [ -z "$_nss_nix_file" ]; then
    printf '%s\n' "nix-shell-status: NAME and FILE are required" >&2
    return 1
  fi

  _nss_marker="# wizardry: $_nss_block_name"

  [ -f "$_nss_nix_file" ] && grep -Fq "$_nss_marker" "$_nss_nix_file" 2>/dev/null
  return $?
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}


# This spell helps with learning spells:
# - For files: installs spells with install() functions via _learn_spell
# - For directories: informs that they are automatically available via _invoke_wizardry
# It also handles --spell mode for RC file snippet management.


SCRIPT_NAME=$(basename "$0")
SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*) SCRIPT_DIR=${SCRIPT_SOURCE%/*} ;;
*) SCRIPT_DIR=. ;;
esac

show_usage() {
  cat <<USAGE >&2
Usage: $SCRIPT_NAME [-r] PATH...
       $SCRIPT_NAME --spell NAME {add|remove|status}

For files: installs spells with install() functions via _learn_spell.
For directories: informs that they are automatically available via _invoke_wizardry.
Use --spell mode for RC file snippet management.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)
SPELLS_DIR=${SCRIPT_DIR%/*}

# Check for --spell mode first (RC file management)
for arg in "$@"; do
  case $arg in
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --spell|--spell=*)
    MODE=rc
    ;;
  esac
done

# Find helpers
find_learn_spell() {
  helper="$SCRIPT_DIR/_learn_spell"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v _learn_spell >/dev/null 2>&1; then
    command -v _learn_spell
    return 0
  fi
  return 1
}

# Helper function for non-empty check
nonempty() {
  [ -n "$1" ]
}

# ---------------------
# RC MODE IMPLEMENTATION
# ---------------------

rc_usage() {
  cat <<'RCUSAGE' >&2
Usage: learn --spell NAME {add|remove|status}

Reads spell content from standard input for the 'add' action and wraps it with
wizardry comment sentinels so future removals remain deterministic.
Single-line spells receive an inline `# wizardry: NAME` suffix, while
multi-line spells are wrapped with `begin`/`end` sentinels (including a lines
count) to keep rc files readable.

The rc file and format are auto-detected via _detect_rc_file. For nix files
(auto-detected from .nix extension or platform), uses programs.bash.initExtra
or programs.zsh.initExtra to properly add shell code to nix configuration files.

Options:
  --shell SHELL    Shell type for nix format: bash (default) or zsh

Spell names must contain only letters, digits, dashes, underscores, periods, and colons.
RCUSAGE
}

# Find _detect_rc_file helper
find_detect_rc_file() {
  if [ -n "${DETECT_RC_FILE-}" ] && [ -x "$DETECT_RC_FILE" ]; then
    printf '%s' "$DETECT_RC_FILE"
    return 0
  fi
  helper="$SPELLS_DIR/divination/_detect_rc_file"
  if [ -x "$helper" ]; then
    printf '%s' "$helper"
    return 0
  fi
  if command -v _detect_rc_file >/dev/null 2>&1; then
    command -v _detect_rc_file
    return 0
  fi
  return 1
}

auto_detect_rc() {
  if ! detect_helper=$(find_detect_rc_file); then
    printf '%s\n' "learn: _detect_rc_file helper not found." >&2
    return 1
  fi
  output=$("$detect_helper")
  rc_file_detected=''
  platform_detected=''
  format_detected=''
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file_detected=$value ;;
    platform) platform_detected=$value ;;
    format) format_detected=$value ;;
    esac
  done <<EOF_ENV
$output
EOF_ENV
  if [ -z "$rc_file_detected" ]; then
    printf '%s\n' "learn: _detect_rc_file did not provide an rc file." >&2
    return 1
  fi
  printf '%s\n' "rc_file=$rc_file_detected"
  printf '%s\n' "platform=${platform_detected:-unknown}"
  printf '%s\n' "format=${format_detected:-shell}"
}

rc_run() {
  action=""
  spell=""
  rc_format=""
  shell_type="bash"

  while [ "$#" -gt 0 ]; do
    case $1 in
    --spell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --spell expects a name." >&2
        rc_usage
        exit 1
      fi
      spell=$2
      shift 2
      ;;
    --spell=*)
      spell=${1#*=}
      shift
      ;;
    --shell)
      if [ "$#" -lt 2 ]; then
        printf '%s\n' "learn: --shell expects a value." >&2
        rc_usage
        exit 1
      fi
      shell_type=$2
      shift 2
      ;;
    --shell=*)
      shell_type=${1#*=}
      shift
      ;;
    add|remove|status)
      if [ -n "$action" ]; then
        printf '%s\n' "learn: only one action may be specified." >&2
        rc_usage
        exit 1
      fi
      action=$1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      printf '%s\n' "learn: unknown option '$1'." >&2
      rc_usage
      exit 1
      ;;
    *)
      printf '%s\n' "learn: unexpected argument '$1'." >&2
      rc_usage
      exit 1
      ;;
    esac
  done

  if [ -z "$action" ] || [ -z "$spell" ]; then
    rc_usage
    exit 1
  fi

  # Always auto-detect rc file and format
  if ! detect_output=$(auto_detect_rc); then
    exit 1
  fi
  rc_file=""
  while IFS='=' read -r key value; do
    case $key in
    rc_file) rc_file=$value ;;
    format) rc_format=$value ;;
    esac
  done <<EOF_DETECT
$detect_output
EOF_DETECT

  if [ -z "$rc_file" ]; then
    printf '%s\n' "learn: unable to determine rc file." >&2
    exit 1
  fi

  # Default format to shell if not detected
  if [ -z "$rc_format" ]; then
    rc_format="shell"
  fi

  # Auto-detect format from file extension (overrides detected format)
  case $rc_file in
  *.nix) rc_format=nix ;;
  esac

  case $spell in
  *[!A-Za-z0-9._:-]*)
    printf '%s\n' "learn: spell names may contain only letters, digits, dots, underscores, dashes, and colons." >&2
    exit 1
    ;;
  esac

  spell_tag="# wizardry: $spell"
  legacy_spell_tag="# wizardry-spell: $spell"
  inline_marker=" $spell_tag"
  legacy_inline_marker=" $legacy_spell_tag"
  block_start="$spell_tag begin"
  legacy_block_start="$legacy_spell_tag begin"
  block_end="$spell_tag end"
  legacy_block_end="$legacy_spell_tag end"
  block_prefix="$spell_tag lines="
  legacy_prefix="$legacy_spell_tag lines="

  ensure_rc_directory() {
    dir=${rc_file%/*}
    if [ "$dir" != "$rc_file" ] && [ ! -d "$dir" ]; then
      mkdir -p "$dir"
    fi
  }

  spell_status() {
    if [ ! -f "$rc_file" ]; then
      return 1
    fi
    if grep -Fq "$spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    if grep -Fq "$legacy_spell_tag" "$rc_file" 2>/dev/null; then
      return 0
    fi
    return 1
  }

  ensure_trailing_newline() {
    if [ ! -f "$rc_file" ] || [ ! -s "$rc_file" ]; then
      return 0
    fi
    last_char=$(tail -c 1 "$rc_file" 2>/dev/null | od -An -t o1 | tr -d ' ')
    if [ "$last_char" != "012" ]; then
      printf '\n' >>"$rc_file"
    fi
  }

  add_spell() {
    ensure_rc_directory
    tmp_file=$(_temp_file learn) || exit 1
    trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
    line_count=0
    while IFS= read -r line || nonempty "$line"; do
      printf '%s\n' "$line" >>"$tmp_file"
      line_count=$((line_count + 1))
    done
    if [ "$line_count" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: no spell content provided on stdin." >&2
      exit 1
    fi
    if spell_status; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    if [ ! -f "$rc_file" ]; then
      : >"$rc_file"
    fi
    ensure_trailing_newline
    if [ "$line_count" -eq 1 ]; then
      first_line=$(sed -n '1p' "$tmp_file")
      printf '%s%s\n' "$first_line" "$inline_marker" >>"$rc_file"
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      return 0
    fi
    block_header="$block_start lines=$line_count"
    printf '%s\n' "$block_header" >>"$rc_file"
    cat "$tmp_file" >>"$rc_file"
    printf '%s\n' "$block_end" >>"$rc_file"
    trap - EXIT HUP INT TERM
    rm -f "$tmp_file"
  }

  remove_spell() {
    if [ ! -f "$rc_file" ]; then
      printf '%s\n' "learn: cannot remove from missing file '$rc_file'." >&2
      exit 1
    fi
    tmp_file=$(_temp_file learn) || exit 1
    trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
    removing_block=0
    to_skip=0
    removed=0
    while IFS= read -r line || nonempty "$line"; do
      if [ "$removing_block" -eq 1 ]; then
        case $line in
        "$block_end"|"$legacy_block_end")
          removing_block=0
          ;;
        esac
        continue
      fi
      if [ "$to_skip" -gt 0 ]; then
        to_skip=$((to_skip - 1))
        continue
      fi
      case $line in
      "$block_start"*|"$legacy_block_start"*)
        removing_block=1
        removed=1
        continue
        ;;
      "$block_prefix"*)
        count=${line#"$block_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      "$legacy_prefix"*)
        count=${line#"$legacy_prefix"}
        case $count in
        *[!0-9]*) to_skip=0 ;;
        *) to_skip=$count ;;
        esac
        removed=1
        continue
        ;;
      *"$inline_marker"|*"$legacy_inline_marker")
        removed=1
        continue
        ;;
      esac
      printf '%s\n' "$line" >>"$tmp_file"
    done <"$rc_file"
    if [ "$removed" -eq 0 ]; then
      trap - EXIT HUP INT TERM
      rm -f "$tmp_file"
      printf '%s\n' "learn: spell '$spell' not found in '$rc_file'." >&2
      exit 1
    fi
    trap - EXIT HUP INT TERM
    mv "$tmp_file" "$rc_file"
  }

  # Find nix-shell-* helpers
  find_nix_shell_imp() {
    _imp_name=$1
    if [ -x "$SCRIPT_DIR/../.imps/sys/$_imp_name" ]; then
      printf '%s' "$SCRIPT_DIR/../.imps/sys/$_imp_name"
      return 0
    fi
    if command -v "$_imp_name" >/dev/null 2>&1; then
      command -v "$_imp_name"
      return 0
    fi
    return 1
  }

  nix_spell_status() {
    if ! nix_helper=$(find_nix_shell_imp _nix_shell_status); then
      printf '%s\n' "learn: _nix_shell_status imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  nix_add_spell() {
    if ! nix_helper=$(find_nix_shell_imp _nix_shell_add); then
      printf '%s\n' "learn: _nix_shell_add imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file" "$shell_type"
  }

  nix_remove_spell() {
    if ! nix_helper=$(find_nix_shell_imp _nix_shell_remove); then
      printf '%s\n' "learn: _nix_shell_remove imp not found." >&2
      exit 1
    fi
    "$nix_helper" "$spell" "$rc_file"
  }

  if [ "$rc_format" = "nix" ]; then
    case $action in
    add) nix_add_spell ;;
    remove) nix_remove_spell ;;
    status)
      if nix_spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  else
    case $action in
    add) add_spell ;;
    remove) remove_spell ;;
    status)
      if spell_status; then exit 0; fi
      exit 1
      ;;
    *) rc_usage; exit 1 ;;
    esac
  fi
}

if [ "${MODE-}" = "rc" ]; then
  rc_run "$@"
  exit $?
fi

# ---------------------
# FILE/DIR MODE - Process paths
# With the word-of-binding paradigm, directories are automatically available
# via _invoke_wizardry. For files with install() functions, use _learn_spell.
# ---------------------

RECURSIVE=0
paths=""

# Parse arguments
while [ $# -gt 0 ]; do
  case $1 in
  -r|--recursive)
    RECURSIVE=1
    shift
    ;;
  --help|--usage|-h)
    show_usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    printf '%s\n' "learn: unknown option '$1'." >&2
    show_usage
    exit 1
    ;;
  *)
    paths="$paths $1"
    shift
    ;;
  esac
done

# Add remaining args
for arg in "$@"; do
  paths="$paths $arg"
done

# Require at least one path
if [ -z "$paths" ]; then
  show_usage
  exit 1
fi

# Find _learn_spell helper for files
LEARN_SPELL=""
if ! LEARN_SPELL=$(find_learn_spell); then
  printf '%s\n' "learn: _learn_spell helper not found." >&2
  exit 1
fi

# Process each path
for path in $paths; do
  if [ -f "$path" ]; then
    # File -> _learn_spell (for spells with install() functions)
    "$LEARN_SPELL" "$path"
  elif [ -d "$path" ]; then
    # With the word-of-binding paradigm (PR #410), directories no longer need
    # to be manually added to PATH. _invoke_wizardry handles this automatically.
    # Inform the user instead.
    printf '%s\n' "learn: directories are now automatically available via _invoke_wizardry."
    printf '%s\n' "learn: spells in '$path' will be accessible after opening a new terminal."
  else
    printf '%s\n' "learn: '$path' _is not a file or directory." >&2
  fi
done

exit 0
