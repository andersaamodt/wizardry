#!/bin/sh
#
# -------------------------- configure-tor-bridge --------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: configure-tor-bridge
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: ask-yn
_ask_yn() {

# ask-yn coaxes a yes or no from the adventurer.  Defaults guide hesitant
# wanderers, and every response is echoed so other spells can heed the choice.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        show_usage
        exit 1
fi

question=$1
default_choice=""
default_hint="[y/n]"
if [ "$#" -eq 2 ]; then
        case $2 in
        y|Y|yes|YES)
                default_choice=yes
                default_hint="[Y/n]"
                ;;
        n|N|no|NO)
                default_choice=no
                default_hint="[y/N]"
                ;;
        *)
                printf '%s\n' "ask-yn: default must be 'yes' or 'no'." >&2
                exit 1
                ;;
        esac
fi

select_input() {
        case ${ASK_CANTRIP_INPUT:-auto} in
        stdin)
                printf '%s\n' stdin
                return 0
                ;;
        none)
                return 1
                ;;
        esac
        # Prefer stdin whenever something is piped to us, even if a tty is also
        # present, so scripted callers can answer without interactivity.
        if [ -t 0 ] || [ -p /dev/stdin ] || [ -s /dev/stdin ]; then
                printf '%s\n' stdin
                return 0
        fi
        if [ -r /dev/tty ]; then
                printf '%s\n' tty
                return 0
        fi
        return 1
}

prompt_and_read() {
        printf '%s %s ' "$question" "$default_hint" >&2
        input=$(select_input) || return 1
        case $input in
        stdin)
                IFS= read -r reply || reply=
                ;;
        tty)
                IFS= read -r reply </dev/tty || reply=
                ;;
        *)
                return 1
                ;;
        esac
        printf '%s' "$reply"
        return 0
}

while :; do
        if ! response=$(prompt_and_read); then
                if [ -n "$default_choice" ]; then
                        response=$default_choice
                else
                        printf '%s\n' "ask-yn: No interactive input available." >&2
                        exit 1
                fi
        elif [ -z "$response" ] && [ -n "$default_choice" ]; then
                response=$default_choice
        fi

        case $response in
        y|Y|yes|YES)
                printf '%s\n' "yes"
                exit 0
                ;;
        n|N|no|NO)
                printf '%s\n' "no"
                exit 1
                ;;
        esac

        printf '%s\n' "Yes or no?" >&2
        default_hint="[y/n]" # remove default hint after invalid input
        default_choice=""
done
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}


# Ensure user _is root

show_usage() {
        cat <<'USAGE' >&2
Usage: configure-tor-bridge

Guides a root user through enabling or disabling Tor bridge mode by updating torrc and restarting tor after confirmation.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu
if [ "$(id -u)" -ne 0 ]; then
    echo "configure-tor-bridge: root privileges required."
    exit 1
fi

# Identify torrc file location based on OS
torrc_location=$(torrc-path)

# Instructions and warning
cat << EOF
This script will enable or disable bridge mode for your Tor relay.

Becoming a bridge relay helps users in countries that block access to the Tor network. 
However, be aware that this could increase your network traffic and may have other unforeseen consequences.

Make sure to review the Tor documentation and fully understand the implications before proceeding.
EOF

# Check if bridge mode _is currently enabled
bridge_enabled=$(tor-bridge-status)

if [ "$bridge_enabled" = "1" ]; then
    # Bridge mode _is currently enabled, ask if user wants to disable
    _ask_yn "Bridge mode _is currently enabled. Do you want to disable it?" "N"
    if [ $? -eq 0 ]; then
        # Use awk to comment out the BridgeRelay line
        awk '{if ($1 == "BridgeRelay" && $2 == "1") {$0 = "# " $0} print}' "$torrc_location" > "$torrc_location.tmp" && mv "$torrc_location.tmp" "$torrc_location"
        echo "Bridge mode disabled."
        sudo systemctl restart tor
    else
        echo "Bridge mode remains enabled."
    fi
else
    # Bridge mode _is currently disabled, ask if user wants to enable
    _ask_yn "Bridge mode _is currently disabled. Do you want to enable it?" "N"
    if [ $? -eq 0 ]; then
        # Append necessary lines to torrc if they don't already exist
        awk '!/^BridgeRelay 1$/ && !/^ORPort 9001$/ && !/^PublishServerDescriptor 0$/ {print} END {if (!/^BridgeRelay 1$/) {print "BridgeRelay 1"} if (!/^ORPort 9001$/) {print "ORPort 9001"} if (!/^PublishServerDescriptor 0$/) {print "PublishServerDescriptor 0"}}' "$torrc_location" > "$torrc_location.tmp" && mv "$torrc_location.tmp" "$torrc_location"
        echo "Bridge mode enabled. You are now acting as a Tor bridge relay."
        sudo systemctl restart tor
    else
        echo "Bridge mode remains disabled."
    fi
fi
