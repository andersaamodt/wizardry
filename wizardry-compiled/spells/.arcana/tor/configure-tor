#!/bin/sh
#
# ----------------------------- configure-tor ------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: configure-tor
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}


# Configure the local torrc with common options.

show_usage() {
        cat <<'USAGE' >&2
Usage: configure-tor

Guides you through setting common torrc options such as SocksPort and ControlPort,
then restarts Tor if the service _is available.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

set -eu

ask() {
  prompt=${1-}
  default=${2-}
  if [ -n "$default" ]; then
    printf "%s [%s]: " "$prompt" "$default"
  else
    printf "%s: " "$prompt"
  fi
  read -r reply
  if [ -z "$reply" ] && [ -n "$default" ]; then
    reply=$default
  fi
  printf '%s' "$reply"
}

ask_yes_no() {
  prompt=${1-}
  default=${2:-y}
  default_lower=$(printf '%s' "$default" | tr 'A-Z' 'a-z')
  case "$default_lower" in
    y|yes) hint='Y/n' ;;
    n|no) hint='y/N' ;;
    *) hint='y/n' ;;
  esac
  printf "%s [%s]: " "$prompt" "$hint"
  read -r reply
  reply=${reply:-$default_lower}
  case "$reply" in
    y|Y|yes|Yes) return 0 ;;
    *) return 1 ;;
  esac
}

torrc_path=$(torrc-path)

ensure_torrc_exists() {
  torrc_dir=$(dirname "$torrc_path")
  if [ ! -d "$torrc_dir" ]; then
    mkdir -p "$torrc_dir" || sudo mkdir -p "$torrc_dir"
  fi
  if [ ! -f "$torrc_path" ]; then
    : > "$torrc_path" 2>/dev/null || sudo sh -c ": > '$torrc_path'"
  fi
}

rewrite_torrc() {
  socks_port=$1
  enable_control=$2
  control_port=$3

  tmp=$(_temp_file configure-tor) || exit 1
  trap '_cleanup_file "$tmp"' EXIT HUP INT TERM
  awk -v socks="$socks_port" -v enable_control="$enable_control" -v control="$control_port" '
    BEGIN {added_socks=0; added_control=0; added_cookie=0}
    /^SocksPort / { if (!added_socks) { print "SocksPort " socks; added_socks=1 } ; next }
    /^ControlPort / { next }
    /^CookieAuthentication / { next }
    { print }
    END {
      if (!added_socks) { print "SocksPort " socks }
      if (enable_control == 1) {
        print "ControlPort " control
        print "CookieAuthentication 1"
      }
    }
  ' "$torrc_path" > "$tmp"

  if mv "$tmp" "$torrc_path" 2>/dev/null; then
    :
  else
    sudo mv "$tmp" "$torrc_path"
  fi
  trap - EXIT HUP INT TERM
}

restart_service_if_possible() {
  if command -v systemctl >/dev/null 2>&1 && systemctl list-unit-files | grep -q '^tor\.service'; then
    if ask_yes_no "Restart tor.service to apply changes?" "y"; then
      sudo systemctl restart tor || true
    fi
  fi
}

main() {
  ensure_torrc_exists

  current_socks=$(awk '/^SocksPort / {print $2; exit}' "$torrc_path" 2>/dev/null || true)
  socks_port=$(ask "SocksPort" "${current_socks:-9050}")

  control_enabled=$(awk '/^ControlPort / {print $2; exit}' "$torrc_path" 2>/dev/null || true)
  control_default=${control_enabled:+y}
  control_default=${control_default:-n}

  if ask_yes_no "Enable ControlPort?" "$control_default"; then
    control_port=$(ask "ControlPort" "${control_enabled:-9051}")
    enable_control=1
  else
    control_port=""
    enable_control=0
  fi

  rewrite_torrc "$socks_port" "$enable_control" "$control_port"
  printf '%s\n' "Updated torrc at $torrc_path."

  restart_service_if_possible
}

main
