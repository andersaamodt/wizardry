#!/bin/sh
#
# ----------------------------------- cd -----------------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: cd
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined spell: ask-yn
_ask_yn() {

# ask-yn coaxes a yes or no from the adventurer.  Defaults guide hesitant
# wanderers, and every response is echoed so other spells can heed the choice.


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        show_usage
        exit 1
fi

question=$1
default_choice=""
default_hint="[y/n]"
if [ "$#" -eq 2 ]; then
        case $2 in
        y|Y|yes|YES)
                default_choice=yes
                default_hint="[Y/n]"
                ;;
        n|N|no|NO)
                default_choice=no
                default_hint="[y/N]"
                ;;
        *)
                printf '%s\n' "ask-yn: default must be 'yes' or 'no'." >&2
                exit 1
                ;;
        esac
fi

select_input() {
        case ${ASK_CANTRIP_INPUT:-auto} in
        stdin)
                printf '%s\n' stdin
                return 0
                ;;
        none)
                return 1
                ;;
        esac
        # Prefer stdin whenever something is piped to us, even if a tty is also
        # present, so scripted callers can answer without interactivity.
        if [ -t 0 ] || [ -p /dev/stdin ] || [ -s /dev/stdin ]; then
                printf '%s\n' stdin
                return 0
        fi
        if [ -r /dev/tty ]; then
                printf '%s\n' tty
                return 0
        fi
        return 1
}

prompt_and_read() {
        printf '%s %s ' "$question" "$default_hint" >&2
        input=$(select_input) || return 1
        case $input in
        stdin)
                IFS= read -r reply || reply=
                ;;
        tty)
                IFS= read -r reply </dev/tty || reply=
                ;;
        *)
                return 1
                ;;
        esac
        printf '%s' "$reply"
        return 0
}

while :; do
        if ! response=$(prompt_and_read); then
                if [ -n "$default_choice" ]; then
                        response=$default_choice
                else
                        printf '%s\n' "ask-yn: No interactive input available." >&2
                        exit 1
                fi
        elif [ -z "$response" ] && [ -n "$default_choice" ]; then
                response=$default_choice
        fi

        case $response in
        y|Y|yes|YES)
                printf '%s\n' "yes"
                exit 0
                ;;
        n|N|no|NO)
                printf '%s\n' "no"
                exit 1
                ;;
        esac

        printf '%s\n' "Yes or no?" >&2
        default_hint="[y/n]" # remove default hint after invalid input
        default_choice=""
done
}

# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined spell: detect-rc-file
_detect_rc_file() {

# This spell selects the best shell rc file for PATH exports or memorization.
# It prints platform, rc_file, and format hints so callers can update startup files safely.



platform="${DETECT_RC_FILE_PLATFORM-}"

while [ "$#" -gt 0 ]; do
        case $1 in
        --platform)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "detect-rc-file: --platform expects a value." >&2
                        show_usage
                        exit 1
                fi
                platform=$2
                shift 2
                ;;
        --platform=*)
                        platform=${1#*=}
                        shift
                        ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "detect-rc-file: unknown option '$1'." >&2
                show_usage
                exit 1
                ;;
        *)
                break
                ;;
        esac

done

if [ "$#" -gt 0 ]; then
        printf '%s\n' "detect-rc-file: unexpected argument '$1'." >&2
        show_usage
        exit 1
fi

add_candidate() {
        file=$1
        if [ -z "$file" ]; then
                return 0
        fi
        for candidate in $RC_CANDIDATES; do
                if [ "$candidate" = "$file" ]; then
                        return 0
                fi
        done
        if [ -z "$RC_CANDIDATES" ]; then
                RC_CANDIDATES=$file
        else
                RC_CANDIDATES="$RC_CANDIDATES $file"
        fi
}

# Decide platform once so the downstream selection stays predictable.
if [ -z "$platform" ]; then
        if command -v detect-distro >/dev/null 2>&1; then
                platform=$(detect-distro 2>/dev/null || printf 'unknown')
        else
                platform=unknown
        fi
fi

RC_CANDIDATES=''

case $platform in
mac)
        # On macOS, Terminal.app and iTerm2 open login shells by default.
        # Login shells source .zprofile (not .zshrc), so we prefer .zprofile
        # for PATH additions to ensure they take effect in new terminal windows.
        # If .zshrc exists but .zprofile doesn't, we use .zshrc since the user
        # may have configured their terminal to use interactive shells.
        add_candidate "$HOME/.zprofile"
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.bash_profile"
        ;;
nixos)
        # On NixOS, prefer nix config if home-manager is available or the config
        # file already exists. Otherwise fall back to shell RC files to ensure
        # PATH changes take effect immediately.
        # Check NIXOS_CONFIG env var first - this is the standard way to specify
        # a custom configuration location on NixOS.
        if [ -n "${NIXOS_CONFIG-}" ] && [ -f "$NIXOS_CONFIG" ]; then
                add_candidate "$NIXOS_CONFIG"
        fi
        # Check if home-manager is installed - if so, prioritize home-manager paths
        # over system-level configuration to avoid requiring sudo.
        home_manager_installed=0
        if command -v home-manager >/dev/null 2>&1; then
                home_manager_installed=1
        fi
        # Check for home-manager configurations in both old and new paths.
        # Newer home-manager uses ~/.config/home-manager/home.nix
        # Older standalone home-manager uses ~/.config/nixpkgs/home.nix
        if [ -f "$HOME/.config/home-manager/home.nix" ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        if [ -f "$HOME/.config/nixpkgs/home.nix" ]; then
                add_candidate "$HOME/.config/nixpkgs/home.nix"
        fi
        # If home-manager is installed but no config exists yet, suggest the new path
        if [ "$home_manager_installed" -eq 1 ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        # Check for system-level configuration (requires sudo to edit).
        # Only add this if home-manager is NOT installed, since home-manager
        # is preferred when available (doesn't require sudo).
        if [ "$home_manager_installed" -eq 0 ] && [ -f /etc/nixos/configuration.nix ]; then
                add_candidate /etc/nixos/configuration.nix
        fi
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        add_candidate "$HOME/.profile"
        ;;
debian|arch|fedora)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.profile"
        ;;
*) : ;;
        esac

shell_name=${SHELL-}
if [ -z "$shell_name" ]; then
# Some non-interactive shells (like dash) do not export SHELL, so default to
# sh to keep the rc-file selection predictable even when the variable is
# unset.
shell_name=sh
fi

case ${shell_name##*/} in
zsh)
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.zprofile"
        ;;
bash)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        ;;
*)
        add_candidate "$HOME/.profile"
        ;;
        esac

add_candidate "$HOME/.bashrc"
add_candidate "$HOME/.profile"

rc_file=''
for candidate in $RC_CANDIDATES; do
        if [ -f "$candidate" ]; then
                rc_file=$candidate
                break
        fi
done

if [ -z "$rc_file" ]; then
        for candidate in $RC_CANDIDATES; do
                rc_file=$candidate
                break
        done
fi

if [ -z "$rc_file" ]; then
        printf '%s\n' "detect-rc-file: unable to determine a startup file." >&2
        exit 1
fi

case $rc_file in
*.nix)
        format=nix
        ;;
*)
        format=shell
        ;;
        esac

printf 'platform=%s\n' "$platform"
printf 'rc_file=%s\n' "$rc_file"
printf 'format=%s\n' "$format"
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined spell: memorize
_memorize() {

# This spell memorizes spells for the Cast menu.
# It keeps a tiny spellbook of spell names in a dotfile so
# Wizards can queue their favorite incantations without editing menus by hand.
#
# Usage: memorize SPELL_NAME
#        memorize list         - list all memorized spells
#        memorize path         - print the command list file path
#        memorize dir          - print the cast directory


spell_name="memorize"
tab_char=$(printf '\t')
newline_char=$(printf '\ny')
newline_char=${newline_char%y}


case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac


expand_tilde() {
        path=$1
        case $path in
        \~)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME
                fi
                ;;
        \~/*)
                if [ -n "${HOME-}" ] && [ -n "$HOME" ]; then
                        path=$HOME/${path#\~/}
                fi
                ;;
        esac

        printf '%s' "$path"
}

resolve_cast_dir() {
        if [ -n "${WIZARDRY_CAST_DIR-}" ]; then
                dir=$(expand_tilde "$WIZARDRY_CAST_DIR")
                printf '%s' "$dir"
                return 0
        fi

        env-or SPELLBOOK_DIR "${HOME:-.}/.spellbook"
}

resolve_command_file() {
	cast_dir=$1
	if [ -n "${WIZARDRY_CAST_FILE-}" ]; then
		file=$(expand_tilde "$WIZARDRY_CAST_FILE")
	elif [ -n "${MEMORIZE_COMMAND_FILE-}" ]; then
		file=$(expand_tilde "$MEMORIZE_COMMAND_FILE")
	else
		file=$cast_dir/.memorized
	fi
	printf '%s' "$file"
}

cast_dir=$(resolve_cast_dir)
command_file=$(resolve_command_file "$cast_dir")

ensure_parent_directory() {
	if [ ! -d "$cast_dir" ]; then
		mkdir -p "$cast_dir"
	fi
	dir=${command_file%/*}
	if [ "$dir" != "$command_file" ] && [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi
}

validate_name() {
	name=$1
	case $name in
	''|*[!A-Za-z0-9._-]*)
		printf '%s\n' "$spell_name: names may contain only letters, digits, dots, underscores, and dashes." >&2
		exit 1
		;;
	-*)
		printf '%s\n' "$spell_name: names may not begin with a dash." >&2
		exit 1
		;;
	esac
}

nonempty() {
	[ -n "$1" ]
}

add_spell() {
	name=$1
	validate_name "$name"
	ensure_parent_directory
	# Memorize just lists existing spells by name - no wrapper scripts needed
	# The spell must already exist in PATH or spellbook
	cmd=$name
	tmp=$(temp-file memorize) || exit 1
	trap 'cleanup-file "$tmp"' EXIT HUP INT TERM
	if [ -f "$command_file" ]; then
		while IFS= read -r line || nonempty "$line"; do
			entry_name=$line
			case $line in
			*"$tab_char"*)
				entry_name=${line%%"$tab_char"*}
				;;
			esac
			if [ "$entry_name" = "$name" ] || [ -z "$entry_name" ]; then
				continue
			fi
			printf '%s\n' "$line" >>"$tmp"
		done <"$command_file"
	fi
	printf '%s%s%s\n' "$name" "$tab_char" "$cmd" >"$command_file"
	if [ -f "$tmp" ]; then
		cat "$tmp" >>"$command_file"
	fi
	trap - EXIT HUP INT TERM
	rm -f "$tmp"
}

list_entries() {
	if [ -f "$command_file" ]; then
		cat "$command_file"
	fi
}

if [ "$#" -eq 0 ]; then
	show_usage
	exit 1
fi

action=$1

case $action in
list)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	list_entries
	;;
path)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$command_file"
	;;
dir)
	if [ "$#" -ne 1 ]; then
		show_usage
		exit 1
	fi
	printf '%s\n' "$cast_dir"
	;;
--help|--usage|-h)
	show_usage
	;;
-*)
	printf '%s\n' "$spell_name: unknown option '$action'" >&2
	show_usage
	exit 1
	;;
*)
	# Default action: memorize the spell
	if [ "$#" -ne 1 ]; then
		printf '%s\n' "$spell_name: expects exactly one spell name." >&2
		show_usage
		exit 1
	fi
	add_spell "$action"
	;;
esac
}

# Inlined imp: nix-shell-add
_nix_shell_add() {
  _nsa_block_name=${1:-}
  _nsa_nix_file=${2:-}
  _nsa_shell_type=${3:-bash}

  if [ -z "$_nsa_block_name" ] || [ -z "$_nsa_nix_file" ]; then
    printf '%s\n' "nix-shell-add: NAME and FILE are required" >&2
    return 1
  fi

  case $_nsa_shell_type in
    bash|zsh) : ;;
    *) printf '%s\n' "nix-shell-add: shell must be 'bash' or 'zsh'" >&2; return 1 ;;
  esac

  _nsa_is_system_config=0
  case $_nsa_nix_file in /etc/nixos/*) _nsa_is_system_config=1 ;; esac

  if [ "$_nsa_is_system_config" -eq 1 ]; then
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.interactiveShellInit" ;;
      zsh)  _nsa_nix_option="programs.zsh.interactiveShellInit" ;;
    esac
  else
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.initExtra" ;;
      zsh)  _nsa_nix_option="programs.zsh.initExtra" ;;
    esac
  fi

  _nsa_marker="# wizardry: $_nsa_block_name"

  _nsa_needs_sudo=0
  if [ -f "$_nsa_nix_file" ] && [ ! -w "$_nsa_nix_file" ]; then
    _nsa_needs_sudo=1
  fi

  if [ -f "$_nsa_nix_file" ] && grep -Fq "$_nsa_marker" "$_nsa_nix_file" 2>/dev/null; then return 0; fi
  _nsa_shell_code=""
  while IFS= read -r _nsa_line || [ -n "$_nsa_line" ]; do
    if [ -z "$_nsa_shell_code" ]; then _nsa_shell_code=$_nsa_line
    else _nsa_shell_code="$_nsa_shell_code
$_nsa_line"; fi
  done
  if [ -z "$_nsa_shell_code" ]; then
    printf '%s\n' "nix-shell-add: no shell code provided on stdin" >&2
    return 1
  fi
  _nsa_escaped_code=$(printf '%s' "$_nsa_shell_code" | sed "s/''/'''/g; s/\\\${/''\${/g")
  _nsa_marked_code=$(printf '%s' "$_nsa_escaped_code" | sed "s/$/ $_nsa_marker/")
  if [ ! -f "$_nsa_nix_file" ]; then
    _nsa_dir=${_nsa_nix_file%/*}
    [ "$_nsa_dir" != "$_nsa_nix_file" ] && [ ! -d "$_nsa_dir" ] && mkdir -p "$_nsa_dir"
    printf '{ config, pkgs, ... }:\n\n{\n}\n' > "$_nsa_nix_file"
  fi
  _nsa_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add.XXXXXX") || return 1
  # Read file content inline
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then _nsa_content=$(sudo cat "$_nsa_nix_file")
    elif command -v doas >/dev/null 2>&1; then _nsa_content=$(doas cat "$_nsa_nix_file")
    else _nsa_content=$(cat "$_nsa_nix_file"); fi
  else _nsa_content=$(cat "$_nsa_nix_file"); fi
  
  if printf '%s\n' "$_nsa_content" | grep -q "$_nsa_nix_option[[:space:]]*="; then
    _nsa_input_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-input.XXXXXX") || return 1
    printf '%s\n' "$_nsa_content" > "$_nsa_input_file"
    _nsa_in_block=0
    while IFS= read -r _nsa_line; do
      if printf '%s\n' "$_nsa_line" | grep -q "$_nsa_nix_option[[:space:]]*=" && printf '%s\n' "$_nsa_line" | grep -q "''"; then
        _nsa_in_block=1; printf '%s\n' "$_nsa_line"; continue
      fi
      if [ "$_nsa_in_block" -eq 1 ] && printf '%s\n' "$_nsa_line" | grep -q "^[[:space:]]*'';"; then
        printf '%s\n' "$_nsa_marked_code"; printf '%s\n' "$_nsa_line"; _nsa_in_block=0; continue
      fi
      printf '%s\n' "$_nsa_line"
    done < "$_nsa_input_file" > "$_nsa_tmp_file"
    rm -f "$_nsa_input_file"
  else
    # Write the block to a temp file and use it with awk (macOS awk compatible)
    _nsa_block_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-block.XXXXXX") || return 1
    printf '%s\n' "  $_nsa_nix_option = ''" > "$_nsa_block_file"
    printf '%s\n' "$_nsa_marked_code" >> "$_nsa_block_file"
    printf '%s\n' "  '';" >> "$_nsa_block_file"
    
    printf '%s\n' "$_nsa_content" | awk -v blockfile="$_nsa_block_file" '
    BEGIN { while ((getline line < blockfile) > 0) block = block line "\n" }
    { lines[NR] = $0 }
    END {
      last = NR; while (last > 0 && lines[last] ~ /^[[:space:]]*$/) last--
      if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
        for (i = 1; i < last; i++) print lines[i]; print ""; printf "%s", block; print lines[last]
        for (i = last + 1; i <= NR; i++) print lines[i]
      } else { for (i = 1; i <= NR; i++) print lines[i]; print ""; printf "%s", block }
    }' > "$_nsa_tmp_file"
    rm -f "$_nsa_block_file"
  fi
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsa_tmp_file" "$_nsa_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsa_tmp_file" "$_nsa_nix_file"
    else cp "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  else mv "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  rm -f "$_nsa_tmp_file"
  return 0
}

# Inlined imp: nix-shell-remove
_nix_shell_remove() {
  _nsr_block_name=${1:-}
  _nsr_nix_file=${2:-}

  if [ -z "$_nsr_block_name" ] || [ -z "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: NAME and FILE are required" >&2
    return 1
  fi

  _nsr_marker="# wizardry: $_nsr_block_name"

  _nsr_needs_sudo=0
  if [ -f "$_nsr_nix_file" ] && [ ! -w "$_nsr_nix_file" ]; then
    _nsr_needs_sudo=1
  fi

  if [ ! -f "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: file not found: $_nsr_nix_file" >&2
    return 1
  fi
  if ! grep -Fq "$_nsr_marker" "$_nsr_nix_file" 2>/dev/null; then return 0; fi
  _nsr_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-remove.XXXXXX") || return 1
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cat "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cat "$_nsr_nix_file"
    else cat "$_nsr_nix_file"; fi
  else
    cat "$_nsr_nix_file"
  fi | grep -v -F "$_nsr_marker" > "$_nsr_tmp_file"
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsr_tmp_file" "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsr_tmp_file" "$_nsr_nix_file"
    else cp "$_nsr_tmp_file" "$_nsr_nix_file"; fi
  else
    mv "$_nsr_tmp_file" "$_nsr_nix_file"
  fi
  rm -f "$_nsr_tmp_file"
  return 0
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}

# Inlined imp: warn
_warn() {
  printf '%s\n' "$*" >&2
}


# The cd cantrip keeps a tiny shell hook that immediately runs `look`
# after every successful directory change. The hook stays intentionally
# small so wizards can tweak it at a glance while still whispering just
# enough lore to keep the spell recognizable.

show_usage() {
cat <<'USAGE'
Usage: cd [DIRECTORY]
       cd {install|uninstall}

Replace builtin cd so it runs 'look' after each directory change, keeping the MUD view in sync. Use install or uninstall to add or remove the hook from your shell.
USAGE
}

case "${1-}" in
--help|--usage|-h)
        show_usage
        exit 0
        ;;
esac

# Add imps to PATH so we can use _temp_file, _cleanup_file, etc.
# This allows running the spell directly without wizardry being fully installed
_cd_script_source=$0
case $_cd_script_source in
*/*)
        _cd_script_dir=${_cd_script_source%/*}
        ;;
*)
        _cd_script_dir=.
        ;;
esac
_cd_repo_dir=$(CDPATH= cd -- "$_cd_script_dir/../../.." && pwd -P)
if [ -d "$_cd_repo_dir/spells/.imps" ]; then
        for _impdir in "$_cd_repo_dir"/spells/.imps/*; do
                [ -d "$_impdir" ] || continue
                PATH="$_impdir:$PATH"
        done
fi
export PATH

set -eu


SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
        SCRIPT_DIR=${SCRIPT_SOURCE%/*}
        ;;
*)
        SCRIPT_DIR=.
        ;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

_warn() {
        printf '%s\n' "cd cantrip: $1" >&2
}

# Run nixos-rebuild or home-manager switch to apply NixOS configuration changes
# This function follows project ethos: automatically fix things instead of telling users to do it.
# Returns 0 if rebuild succeeded, 1 if it could not be run automatically.
run_nix_rebuild() {
        # Allow tests to skip the rebuild
        if [ "${WIZARDRY_SKIP_NIX_REBUILD-}" = "1" ]; then
                return 0
        fi

        rebuild_success=0

        # Try to detect if we should use sudo or doas
        priv_cmd=""
        if command -v sudo >/dev/null 2>&1; then
                priv_cmd="sudo"
        elif command -v doas >/dev/null 2>&1; then
                priv_cmd="doas"
        fi

        # Try home-manager first (doesn't need privileges)
        if command -v home-manager >/dev/null 2>&1; then
                printf '%s\n' "cd cantrip: running home-manager switch..."
                if home-manager switch; then
                        printf '%s\n' "cd cantrip: user environment rebuilt successfully."
                        rebuild_success=1
                fi
        fi

        # If home-manager didn't work and we have privilege escalation, try nixos-rebuild
        if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
                printf '%s\n' "cd cantrip: running $priv_cmd nixos-rebuild switch..."
                if "$priv_cmd" nixos-rebuild switch; then
                        printf '%s\n' "cd cantrip: NixOS system rebuilt successfully."
                        rebuild_success=1
                fi
        fi

        if [ "$rebuild_success" -eq 0 ]; then
                _warn "NixOS configuration could not be automatically rebuilt."
                return 1
        fi

        return 0
}

# Cache for _detect_rc_file output to avoid multiple calls
# This cache _is intentionally global so that resolve_rc_file() and resolve_rc_format()
# can share the same _detect_rc_file output without running the command multiple times.
_detect_rc_cache=""

run_detect_rc_file() {
        if [ -n "$_detect_rc_cache" ]; then
                printf '%s\n' "$_detect_rc_cache"
                return 0
        fi
        if command -v _detect_rc_file >/dev/null 2>&1; then
                if _detect_rc_cache=$(_detect_rc_file 2>/dev/null); then
                        printf '%s\n' "$_detect_rc_cache"
                        return 0
                fi
        fi
        return 1
}

resolve_rc_file() {
        if [ -n "${WIZARDRY_RC_FILE-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FILE"
                return 0
        fi

        # Try to use _detect_rc_file for cross-platform support
        if detected=$(run_detect_rc_file); then
                # Parse rc_file= line using shell parameter expansion
                while IFS= read -r line; do
                        case $line in
                        rc_file=*)
                                rc_file=${line#rc_file=}
                                if [ -n "$rc_file" ]; then
                                        printf '%s\n' "$rc_file"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi

        # Fallback to shell-specific defaults
        if [ -z "${HOME-}" ]; then
                _warn "HOME _is not set; cannot determine rc file."
                return 1
        fi

        shell_name=${SHELL-}
        case ${shell_name##*/} in
        zsh)
                printf '%s/.zshrc\n' "$HOME"
                ;;
        *)
                printf '%s/.bashrc\n' "$HOME"
                ;;
        esac
}

resolve_rc_format() {
        # Check env var override first
        if [ -n "${WIZARDRY_RC_FORMAT-}" ]; then
                printf '%s\n' "$WIZARDRY_RC_FORMAT"
                return 0
        fi

        # Try to get format from _detect_rc_file output
        if detected=$(run_detect_rc_file); then
                while IFS= read -r line; do
                        case $line in
                        format=*)
                                format=${line#format=}
                                if [ -n "$format" ]; then
                                        printf '%s\n' "$format"
                                        return 0
                                fi
                                ;;
                        esac
                done <<EOF
$detected
EOF
        fi

        # Fallback: detect from file extension
        if rc_file=$(resolve_rc_file 2>/dev/null); then
                case $rc_file in
                *.nix) printf 'nix\n'; return 0 ;;
                esac
        fi

        printf 'shell\n'
}

cd_block_present() {
        rc_file=$1
        if [ ! -f "$rc_file" ]; then
                return 1
        fi
        # Check for shell format marker
        if grep -Fq '# >>> wizardry cd cantrip >>>' "$rc_file"; then
                return 0
        fi
        # Check for nix format marker (used by _nix_shell_add)
        # Note: _nix_shell_add adds " # wizardry: cd-cantrip" (with space before #)
        if grep -Eq '#[ ]?wizardry: cd-cantrip' "$rc_file"; then
                return 0
        fi
        return 1
}

ensure_rc_dir() {
        target=$1
        rc_dir=${target%/*}
        [ "$rc_dir" = "$target" ] && rc_dir=.
        if [ -d "$rc_dir" ]; then
                return 0
        fi
        if mkdir -p "$rc_dir"; then
                return 0
        fi
        _warn "unable to create directory '$rc_dir'."
        return 1
}

install() {
        # Detect nix format from _detect_rc_file output
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1

        # For nix format, use _nix_shell_add imp to add shell init code
        if [ "$rc_format" = "nix" ]; then
                # Find _nix_shell_add helper
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/_nix_shell_add" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/_nix_shell_add"
                elif command -v _nix_shell_add >/dev/null 2>&1; then
                        nix_helper=$(command -v _nix_shell_add)
                fi

                
                if [ -z "$nix_helper" ]; then
                        printf '%s\n' "cd cantrip: _nix_shell_add imp not found for NixOS installation."
                        return 1
                fi

                # Create the shell hook code - uses a function instead of storing path in a variable
                hook_code='cd() { command cd "$@" && { look 2>/dev/null || true; }; }'

                if printf '%s\n' "$hook_code" | "$nix_helper" cd-cantrip "$rc_file" bash; then
                        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
                        # Run nixos-rebuild to apply the changes
                        run_nix_rebuild || true
                else
                        _warn "unable to update '$rc_file'."
                        return 1
                fi
                return 0
        fi

        # Standard shell format installation
        if ! ensure_rc_dir "$rc_file"; then
                return 1
        fi
        tmp_file=$(_temp_file wizardry-cd) || return 1
        trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
        if [ -f "$rc_file" ]; then
                sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        else
                : >"$tmp_file"
        fi
        # Use a function instead of storing path in a variable - simpler and no pseudo-global needed
        cat <<'HOOK' >>"$tmp_file"
# >>> wizardry cd cantrip >>>
cd() { command cd "$@" && { look 2>/dev/null || true; }; }
# <<< wizardry cd cantrip <<<
HOOK
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                _warn "unable to update '$rc_file'."
                return 1
        fi
        trap - EXIT HUP INT TERM
        printf '%s\n' "cd cantrip: installed wizardry hooks in '$rc_file'."
}

uninstall() {
        rc_format=$(resolve_rc_format)
        rc_file=$(resolve_rc_file) || return 1
        if [ ! -f "$rc_file" ]; then
                printf '%s\n' "cd cantrip: no rc file found at '$rc_file'."
                return 0
        fi
        if ! cd_block_present "$rc_file"; then
                printf '%s\n' "cd cantrip: not installed in '$rc_file'."
                return 0
        fi

        # For nix format, use _nix_shell_remove to remove the block
        if [ "$rc_format" = "nix" ]; then
                nix_helper=""
                if [ -x "$SCRIPT_DIR/../../.imps/sys/_nix_shell_remove" ]; then
                        nix_helper="$SCRIPT_DIR/../../.imps/sys/_nix_shell_remove"
                elif command -v _nix_shell_remove >/dev/null 2>&1; then
                        nix_helper=$(command -v _nix_shell_remove)
                fi

                if [ -n "$nix_helper" ]; then
                        if "$nix_helper" cd-cantrip "$rc_file"; then
                                printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
                                # Run nixos-rebuild to apply the changes
                                run_nix_rebuild || true
                                return 0
                        else
                                _warn "unable to update '$rc_file'."
                                return 1
                        fi
                fi
                # _nix_shell_remove helper not found - _warn and attempt shell method fallback
                # This may not work correctly for nix format files
                _warn "_nix_shell_remove imp not found; attempting shell-style removal which may not work for nix files."
        fi

        # Shell format: use sed to remove the block
        tmp_file=$(_temp_file wizardry-cd) || return 1
        trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
        sed '/^# >>> wizardry cd cantrip >>>$/,/^# <<< wizardry cd cantrip <<</d' "$rc_file" >"$tmp_file"
        if ! mv "$tmp_file" "$rc_file"; then
                trap - EXIT HUP INT TERM
                rm -f "$tmp_file"
                _warn "unable to update '$rc_file'."
                return 1
        fi
        trap - EXIT HUP INT TERM
        printf '%s\n' "cd cantrip: uninstalled wizardry hooks from '$rc_file'."
}

locate_ask_yn() {
        if command -v _ask_yn >/dev/null 2>&1; then
                command -v _ask_yn
                return 0
        fi
        if [ -x "$SCRIPT_DIR/_ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/_ask_yn"
                return 0
        fi
        if [ -x "$SCRIPT_DIR/cantrips/_ask_yn" ]; then
                printf '%s\n' "$SCRIPT_DIR/cantrips/_ask_yn"
                return 0
        fi
        _warn "_ask_yn spell _is missing; skipping installation prompt."
        return 1
}

prompt_install_if_needed() {
        rc_file=$(resolve_rc_file) || return
        if cd_block_present "$rc_file"; then
                return
        fi
        if ! ask_yn_cmd=$(locate_ask_yn); then
                return
        fi
        rc_display=$(basename "$rc_file")
        printf '%s\n' "The cd cantrip can sprinkle the 'look' spell on every hop."
        if "$ask_yn_cmd" "Memorize the cd cantrip in $rc_display so each teleport reveals the room?" yes >/dev/null; then
                install || return
                printf '%s\n' "The hook _is etched into $rc_display."
        else
                printf '%s\n' "Very well—cast '_memorize spells/cantrips/cd' when you crave automatic scouting."
        fi
}

wizardry_cd_cast_look() {
        if command -v look >/dev/null 2>&1; then
                look "$@"
                return
        fi
        _warn "look spell _is not available."
}

wizardry_cd_main() {
        # Use 'command cd' to call the builtin cd and avoid alias recursion
        command cd "$@" && wizardry_cd_cast_look
}

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
        install
        exit $?
        ;;
uninstall)
        uninstall
        exit $?
        ;;
esac

# If run directly (not sourced via alias and not install/uninstall),
# prompt to install and then run the cd
if [ -z "${WIZARDRY_MEMORIZE_TARGET-}" ]; then
        prompt_install_if_needed || true
        wizardry_cd_main "$@"
fi
