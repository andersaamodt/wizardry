#!/bin/sh
#
# ------------------------ handle-command-not-found ------------------------
#
# COMPILED WIZARDRY SPELL
#
# This is a compiled version of a wizardry spell.
# Wizardry is a collection of POSIX shell scripts themed as magical spells,
# turning folders into rooms and files into items, like a fantasy MUD.
#
# For the full clean version of this script and much more, please visit:
# https://github.com/andersaamodt/wizardry
#
# Original spell: handle-command-not-found
# Generated by: compile-spell
#
# ----------------------------------------------------------------------------
#
#  ,___,   OPEN WIZARDRY LICENSE 1.1
#  (O,O)
#  /)  )   Permission: You may use, copy, modify, and share this project
# ="=="=   for non-commercial purposes, including private, educational,
#          research, and internal organizational use.
#
# Commercial Use: Commercial exploitation is prohibited. "Commercial exploitation"
# means sale, subscription, paid access, monetized hosting, inclusion in any paid
# product or service, or use as part of any monetized system, even if not the
# primary component. Internal use by commercial entities is allowed.
#
# Reciprocity: If you make modified versions publicly available—either by
# distributing copies or by operating a public-facing service that meaningfully
# depends on those modified files—you must publish those modified files under
# this license. No other files must be published.
#
# No Enclosure: Modified files you share must remain exclusively under this
# license, without additional restrictions. This license must accompany any public
# distribution of modified files.
#
# Warranty: Provided without warranty or guarantee of any kind.
#
# ----------------------------------------------------------------------------


# Inlined imp: cleanup-file
_cleanup_file() {
  [ -n "${1:-}" ] && [ -f "$1" ] && rm -f "$1"
  return 0
}

# Inlined spell: detect-rc-file
_detect_rc_file() {

# This spell selects the best shell rc file for PATH exports or memorization.
# It prints platform, rc_file, and format hints so callers can update startup files safely.



platform="${DETECT_RC_FILE_PLATFORM-}"

while [ "$#" -gt 0 ]; do
        case $1 in
        --platform)
                if [ "$#" -lt 2 ]; then
                        printf '%s\n' "detect-rc-file: --platform expects a value." >&2
                        show_usage
                        exit 1
                fi
                platform=$2
                shift 2
                ;;
        --platform=*)
                        platform=${1#*=}
                        shift
                        ;;
        --help|--usage|-h)
                show_usage
                exit 0
                ;;
        --)
                shift
                break
                ;;
        -*)
                printf '%s\n' "detect-rc-file: unknown option '$1'." >&2
                show_usage
                exit 1
                ;;
        *)
                break
                ;;
        esac

done

if [ "$#" -gt 0 ]; then
        printf '%s\n' "detect-rc-file: unexpected argument '$1'." >&2
        show_usage
        exit 1
fi

add_candidate() {
        file=$1
        if [ -z "$file" ]; then
                return 0
        fi
        for candidate in $RC_CANDIDATES; do
                if [ "$candidate" = "$file" ]; then
                        return 0
                fi
        done
        if [ -z "$RC_CANDIDATES" ]; then
                RC_CANDIDATES=$file
        else
                RC_CANDIDATES="$RC_CANDIDATES $file"
        fi
}

# Decide platform once so the downstream selection stays predictable.
if [ -z "$platform" ]; then
        if command -v detect-distro >/dev/null 2>&1; then
                platform=$(detect-distro 2>/dev/null || printf 'unknown')
        else
                platform=unknown
        fi
fi

RC_CANDIDATES=''

case $platform in
mac)
        # On macOS, Terminal.app and iTerm2 open login shells by default.
        # Login shells source .zprofile (not .zshrc), so we prefer .zprofile
        # for PATH additions to ensure they take effect in new terminal windows.
        # If .zshrc exists but .zprofile doesn't, we use .zshrc since the user
        # may have configured their terminal to use interactive shells.
        add_candidate "$HOME/.zprofile"
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.bash_profile"
        ;;
nixos)
        # On NixOS, prefer nix config if home-manager is available or the config
        # file already exists. Otherwise fall back to shell RC files to ensure
        # PATH changes take effect immediately.
        # Check NIXOS_CONFIG env var first - this is the standard way to specify
        # a custom configuration location on NixOS.
        if [ -n "${NIXOS_CONFIG-}" ] && [ -f "$NIXOS_CONFIG" ]; then
                add_candidate "$NIXOS_CONFIG"
        fi
        # Check if home-manager is installed - if so, prioritize home-manager paths
        # over system-level configuration to avoid requiring sudo.
        home_manager_installed=0
        if command -v home-manager >/dev/null 2>&1; then
                home_manager_installed=1
        fi
        # Check for home-manager configurations in both old and new paths.
        # Newer home-manager uses ~/.config/home-manager/home.nix
        # Older standalone home-manager uses ~/.config/nixpkgs/home.nix
        if [ -f "$HOME/.config/home-manager/home.nix" ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        if [ -f "$HOME/.config/nixpkgs/home.nix" ]; then
                add_candidate "$HOME/.config/nixpkgs/home.nix"
        fi
        # If home-manager is installed but no config exists yet, suggest the new path
        if [ "$home_manager_installed" -eq 1 ]; then
                add_candidate "$HOME/.config/home-manager/home.nix"
        fi
        # Check for system-level configuration (requires sudo to edit).
        # Only add this if home-manager is NOT installed, since home-manager
        # is preferred when available (doesn't require sudo).
        if [ "$home_manager_installed" -eq 0 ] && [ -f /etc/nixos/configuration.nix ]; then
                add_candidate /etc/nixos/configuration.nix
        fi
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        add_candidate "$HOME/.profile"
        ;;
debian|arch|fedora)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.profile"
        ;;
*) : ;;
        esac

shell_name=${SHELL-}
if [ -z "$shell_name" ]; then
# Some non-interactive shells (like dash) do not export SHELL, so default to
# sh to keep the rc-file selection predictable even when the variable is
# unset.
shell_name=sh
fi

case ${shell_name##*/} in
zsh)
        add_candidate "$HOME/.zshrc"
        add_candidate "$HOME/.zprofile"
        ;;
bash)
        add_candidate "$HOME/.bashrc"
        add_candidate "$HOME/.bash_profile"
        ;;
*)
        add_candidate "$HOME/.profile"
        ;;
        esac

add_candidate "$HOME/.bashrc"
add_candidate "$HOME/.profile"

rc_file=''
for candidate in $RC_CANDIDATES; do
        if [ -f "$candidate" ]; then
                rc_file=$candidate
                break
        fi
done

if [ -z "$rc_file" ]; then
        for candidate in $RC_CANDIDATES; do
                rc_file=$candidate
                break
        done
fi

if [ -z "$rc_file" ]; then
        printf '%s\n' "detect-rc-file: unable to determine a startup file." >&2
        exit 1
fi

case $rc_file in
*.nix)
        format=nix
        ;;
*)
        format=shell
        ;;
        esac

printf 'platform=%s\n' "$platform"
printf 'rc_file=%s\n' "$rc_file"
printf 'format=%s\n' "$format"
}

# Inlined imp: is
_is() {
  case "$1" in
    file)     [ -f "$2" ] ;;
    dir)      [ -d "$2" ] ;;
    link)     [ -L "$2" ] ;;
    exec)     [ -x "$2" ] ;;
    readable) [ -r "$2" ] ;;
    writable) [ -w "$2" ] ;;
    empty)    if [ -f "$2" ]; then [ ! -s "$2" ]; elif [ -d "$2" ]; then [ -z "$(ls -A "$2" 2>/dev/null)" ]; else return 1; fi ;;
    set)      [ -n "$2" ] ;;
    unset)    [ -z "$2" ] ;;
    *)        return 1 ;;
  esac
}

# Inlined imp: nix-shell-add
_nix_shell_add() {
  _nsa_block_name=${1:-}
  _nsa_nix_file=${2:-}
  _nsa_shell_type=${3:-bash}

  if [ -z "$_nsa_block_name" ] || [ -z "$_nsa_nix_file" ]; then
    printf '%s\n' "nix-shell-add: NAME and FILE are required" >&2
    return 1
  fi

  case $_nsa_shell_type in
    bash|zsh) : ;;
    *) printf '%s\n' "nix-shell-add: shell must be 'bash' or 'zsh'" >&2; return 1 ;;
  esac

  _nsa_is_system_config=0
  case $_nsa_nix_file in /etc/nixos/*) _nsa_is_system_config=1 ;; esac

  if [ "$_nsa_is_system_config" -eq 1 ]; then
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.interactiveShellInit" ;;
      zsh)  _nsa_nix_option="programs.zsh.interactiveShellInit" ;;
    esac
  else
    case $_nsa_shell_type in
      bash) _nsa_nix_option="programs.bash.initExtra" ;;
      zsh)  _nsa_nix_option="programs.zsh.initExtra" ;;
    esac
  fi

  _nsa_marker="# wizardry: $_nsa_block_name"

  _nsa_needs_sudo=0
  if [ -f "$_nsa_nix_file" ] && [ ! -w "$_nsa_nix_file" ]; then
    _nsa_needs_sudo=1
  fi

  if [ -f "$_nsa_nix_file" ] && grep -Fq "$_nsa_marker" "$_nsa_nix_file" 2>/dev/null; then return 0; fi
  _nsa_shell_code=""
  while IFS= read -r _nsa_line || [ -n "$_nsa_line" ]; do
    if [ -z "$_nsa_shell_code" ]; then _nsa_shell_code=$_nsa_line
    else _nsa_shell_code="$_nsa_shell_code
$_nsa_line"; fi
  done
  if [ -z "$_nsa_shell_code" ]; then
    printf '%s\n' "nix-shell-add: no shell code provided on stdin" >&2
    return 1
  fi
  _nsa_escaped_code=$(printf '%s' "$_nsa_shell_code" | sed "s/''/'''/g; s/\\\${/''\${/g")
  _nsa_marked_code=$(printf '%s' "$_nsa_escaped_code" | sed "s/$/ $_nsa_marker/")
  if [ ! -f "$_nsa_nix_file" ]; then
    _nsa_dir=${_nsa_nix_file%/*}
    [ "$_nsa_dir" != "$_nsa_nix_file" ] && [ ! -d "$_nsa_dir" ] && mkdir -p "$_nsa_dir"
    printf '{ config, pkgs, ... }:\n\n{\n}\n' > "$_nsa_nix_file"
  fi
  _nsa_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add.XXXXXX") || return 1
  # Read file content inline
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then _nsa_content=$(sudo cat "$_nsa_nix_file")
    elif command -v doas >/dev/null 2>&1; then _nsa_content=$(doas cat "$_nsa_nix_file")
    else _nsa_content=$(cat "$_nsa_nix_file"); fi
  else _nsa_content=$(cat "$_nsa_nix_file"); fi
  
  if printf '%s\n' "$_nsa_content" | grep -q "$_nsa_nix_option[[:space:]]*="; then
    _nsa_input_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-input.XXXXXX") || return 1
    printf '%s\n' "$_nsa_content" > "$_nsa_input_file"
    _nsa_in_block=0
    while IFS= read -r _nsa_line; do
      if printf '%s\n' "$_nsa_line" | grep -q "$_nsa_nix_option[[:space:]]*=" && printf '%s\n' "$_nsa_line" | grep -q "''"; then
        _nsa_in_block=1; printf '%s\n' "$_nsa_line"; continue
      fi
      if [ "$_nsa_in_block" -eq 1 ] && printf '%s\n' "$_nsa_line" | grep -q "^[[:space:]]*'';"; then
        printf '%s\n' "$_nsa_marked_code"; printf '%s\n' "$_nsa_line"; _nsa_in_block=0; continue
      fi
      printf '%s\n' "$_nsa_line"
    done < "$_nsa_input_file" > "$_nsa_tmp_file"
    rm -f "$_nsa_input_file"
  else
    # Write the block to a temp file and use it with awk (macOS awk compatible)
    _nsa_block_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-add-block.XXXXXX") || return 1
    printf '%s\n' "  $_nsa_nix_option = ''" > "$_nsa_block_file"
    printf '%s\n' "$_nsa_marked_code" >> "$_nsa_block_file"
    printf '%s\n' "  '';" >> "$_nsa_block_file"
    
    printf '%s\n' "$_nsa_content" | awk -v blockfile="$_nsa_block_file" '
    BEGIN { while ((getline line < blockfile) > 0) block = block line "\n" }
    { lines[NR] = $0 }
    END {
      last = NR; while (last > 0 && lines[last] ~ /^[[:space:]]*$/) last--
      if (last > 0 && lines[last] ~ /^[[:space:]]*}/) {
        for (i = 1; i < last; i++) print lines[i]; print ""; printf "%s", block; print lines[last]
        for (i = last + 1; i <= NR; i++) print lines[i]
      } else { for (i = 1; i <= NR; i++) print lines[i]; print ""; printf "%s", block }
    }' > "$_nsa_tmp_file"
    rm -f "$_nsa_block_file"
  fi
  if [ "$_nsa_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsa_tmp_file" "$_nsa_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsa_tmp_file" "$_nsa_nix_file"
    else cp "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  else mv "$_nsa_tmp_file" "$_nsa_nix_file"; fi
  rm -f "$_nsa_tmp_file"
  return 0
}

# Inlined imp: nix-shell-remove
_nix_shell_remove() {
  _nsr_block_name=${1:-}
  _nsr_nix_file=${2:-}

  if [ -z "$_nsr_block_name" ] || [ -z "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: NAME and FILE are required" >&2
    return 1
  fi

  _nsr_marker="# wizardry: $_nsr_block_name"

  _nsr_needs_sudo=0
  if [ -f "$_nsr_nix_file" ] && [ ! -w "$_nsr_nix_file" ]; then
    _nsr_needs_sudo=1
  fi

  if [ ! -f "$_nsr_nix_file" ]; then
    printf '%s\n' "nix-shell-remove: file not found: $_nsr_nix_file" >&2
    return 1
  fi
  if ! grep -Fq "$_nsr_marker" "$_nsr_nix_file" 2>/dev/null; then return 0; fi
  _nsr_tmp_file=$(mktemp "${TMPDIR:-/tmp}/nix-shell-remove.XXXXXX") || return 1
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cat "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cat "$_nsr_nix_file"
    else cat "$_nsr_nix_file"; fi
  else
    cat "$_nsr_nix_file"
  fi | grep -v -F "$_nsr_marker" > "$_nsr_tmp_file"
  if [ "$_nsr_needs_sudo" -eq 1 ]; then
    if command -v sudo >/dev/null 2>&1; then sudo cp "$_nsr_tmp_file" "$_nsr_nix_file"
    elif command -v doas >/dev/null 2>&1; then doas cp "$_nsr_tmp_file" "$_nsr_nix_file"
    else cp "$_nsr_tmp_file" "$_nsr_nix_file"; fi
  else
    mv "$_nsr_tmp_file" "$_nsr_nix_file"
  fi
  rm -f "$_nsr_tmp_file"
  return 0
}

# Inlined imp: temp-file
_temp_file() {
  _tf_prefix=${1:-wizardry}
  mktemp "${TMPDIR:-/tmp}/${_tf_prefix}.XXXXXX"
}

# Inlined imp: warn
_warn() {
  printf '%s\n' "$*" >&2
}

# Inlined imp: word-of-binding
_word_of_binding() {
  if [ $# -eq 0 ]; then
    printf '%s\n' "word-of-binding: command name required" >&2
    return 1
  fi

  _wob_name=$1
  shift

  if [ -z "${WIZARDRY_DIR-}" ]; then
    _wob_script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
    WIZARDRY_DIR=$(CDPATH= cd -- "$_wob_script_dir/../../.." 2>/dev/null && pwd -P) || true
  fi

  # Convert hyphenated name to true-name: clip-copy -> _clip_copy
  _wob_true_name=$(printf '_%s\n' "$_wob_name" | sed 's/-/_/g')

  # Find module file
  _wob_module=""
  if [ -n "${WIZARDRY_DIR-}" ]; then
    _wob_imps_dir="$WIZARDRY_DIR/spells/.imps"
    if [ -d "$_wob_imps_dir" ]; then
      if [ -f "$_wob_imps_dir/$_wob_name" ]; then
        _wob_module="$_wob_imps_dir/$_wob_name"
      else
        for _wob_family_dir in "$_wob_imps_dir"/*; do
          [ -d "$_wob_family_dir" ] || continue
          if [ -f "$_wob_family_dir/$_wob_name" ]; then
            _wob_module="$_wob_family_dir/$_wob_name"
            break
          fi
        done
      fi
    fi
    
    if [ -z "$_wob_module" ]; then
      for _wob_spell_dir in "$WIZARDRY_DIR"/spells/*; do
        [ -d "$_wob_spell_dir" ] || continue
        case "$_wob_spell_dir" in */.imps) continue ;; esac
        if [ -f "$_wob_spell_dir/$_wob_name" ]; then
          _wob_module="$_wob_spell_dir/$_wob_name"
          break
        fi
      done
    fi
  fi
  
  if [ -z "$_wob_module" ]; then
    if [ -n "${SPELLBOOK_DIR-}" ] && [ -d "$SPELLBOOK_DIR" ]; then
      if [ -f "$SPELLBOOK_DIR/$_wob_name" ]; then
        _wob_module="$SPELLBOOK_DIR/$_wob_name"
      fi
    elif [ -n "${HOME-}" ] && [ -d "$HOME/.spellbook" ]; then
      if [ -f "$HOME/.spellbook/$_wob_name" ]; then
        _wob_module="$HOME/.spellbook/$_wob_name"
      fi
    fi
  fi

  if [ -z "$_wob_module" ]; then
    printf '%s\n' "word-of-binding: unknown command '$_wob_name'" >&2
    return 127
  fi

  # Check if module has true-name function (for binding/sourcing)
  if grep -qE "^[[:space:]]*${_wob_true_name}[[:space:]]*\\(\\)" "$_wob_module" 2>/dev/null; then
    # Bind (source) the module to load its function
    # shellcheck disable=SC1090
    . "$_wob_module"
    
    # Create alias for future calls
    alias "$_wob_name=$_wob_true_name" 2>/dev/null || true
    
    if command -v "$_wob_true_name" >/dev/null 2>&1; then
      "$_wob_true_name" "$@"
    else
      printf '%s\n' "word-of-binding: failed to bind '$_wob_name' - function not defined" >&2
      return 1
    fi
  else
    # Evoke (execute) the script directly in a subshell
    "$_wob_module" "$@"
  fi
}


# The command-not-found cantrip installs a hook that intercepts unknown commands
# and displays helpful messages. When installed, unrecognized commands will print
# a notice instead of the default shell error.

show_usage() {
cat <<'USAGE'
Usage: handle-command-not-found {install|uninstall}

Install or uninstall the command-not-found hook in your shell rc file. When enabled, unknown commands display a helpful message. On NixOS, rebuilds the configuration automatically.
USAGE
}

case "${1-}" in
--help|--usage|-h)
	show_usage
	exit 0
	;;
esac

set -eu

SCRIPT_SOURCE=$0
case $SCRIPT_SOURCE in
*/*)
	SCRIPT_DIR=${SCRIPT_SOURCE%/*}
	;;
*)
	SCRIPT_DIR=.
	;;
esac
SCRIPT_DIR=$(cd "$SCRIPT_DIR" && pwd -P)

_warn() {
	printf '%s\n' "handle-command-not-found: $1" >&2
}

# Run nixos-rebuild or home-manager switch to apply NixOS configuration changes
# Returns 0 if rebuild succeeded, 1 if it could not be run automatically.
run_nix_rebuild() {
	# Allow tests to skip the rebuild
	if [ "${WIZARDRY_SKIP_NIX_REBUILD-}" = "1" ]; then
		return 0
	fi

	rebuild_success=0

	# Try to detect if we should use sudo or doas
	priv_cmd=""
	if command -v sudo >/dev/null 2>&1; then
		priv_cmd="sudo"
	elif command -v doas >/dev/null 2>&1; then
		priv_cmd="doas"
	fi

	# Try home-manager first (doesn't need privileges)
	if command -v home-manager >/dev/null 2>&1; then
		printf '%s\n' "handle-command-not-found: running home-manager switch..."
		if home-manager switch; then
			printf '%s\n' "handle-command-not-found: user environment rebuilt successfully."
			rebuild_success=1
		fi
	fi

	# If home-manager didn't work and we have privilege escalation, try nixos-rebuild
	if [ "$rebuild_success" -eq 0 ] && [ -n "$priv_cmd" ] && command -v nixos-rebuild >/dev/null 2>&1; then
		printf '%s\n' "handle-command-not-found: running $priv_cmd nixos-rebuild switch..."
		if "$priv_cmd" nixos-rebuild switch; then
			printf '%s\n' "handle-command-not-found: NixOS system rebuilt successfully."
			rebuild_success=1
		fi
	fi

	if [ "$rebuild_success" -eq 0 ]; then
		_warn "NixOS configuration could not be automatically rebuilt."
		return 1
	fi

	return 0
}

absolute_spell_path() {
	spell=${1:-$0}
	case $spell in
	/*)
		printf '%s\n' "$spell"
		return 0
		;;
	*)
		printf '%s/%s\n' "${PWD:-.}" "$spell"
		;;
	esac
}

# Cache for _detect_rc_file output to avoid multiple calls
_detect_rc_cache=""

run_detect_rc_file() {
	if [ -n "$_detect_rc_cache" ]; then
		printf '%s\n' "$_detect_rc_cache"
		return 0
	fi
	if command -v _detect_rc_file >/dev/null 2>&1; then
		if _detect_rc_cache=$(_detect_rc_file 2>/dev/null); then
			printf '%s\n' "$_detect_rc_cache"
			return 0
		fi
	fi
	return 1
}

resolve_rc_file() {
	if [ -n "${WIZARDRY_RC_FILE-}" ]; then
		printf '%s\n' "$WIZARDRY_RC_FILE"
		return 0
	fi

	# Try to use _detect_rc_file for cross-platform support
	if detected=$(run_detect_rc_file); then
		# Parse rc_file= line using shell parameter expansion
		while IFS= read -r line; do
			case $line in
			rc_file=*)
				rc_file=${line#rc_file=}
				if [ -n "$rc_file" ]; then
					printf '%s\n' "$rc_file"
					return 0
				fi
				;;
			esac
		done <<EOF
$detected
EOF
	fi

	# Fallback to shell-specific defaults
	if [ -z "${HOME-}" ]; then
		_warn "HOME _is not set; cannot determine rc file."
		return 1
	fi

	shell_name=${SHELL-}
	case ${shell_name##*/} in
	zsh)
		printf '%s/.zshrc\n' "$HOME"
		;;
	*)
		printf '%s/.bashrc\n' "$HOME"
		;;
	esac
}

resolve_rc_format() {
	# Check env var override first
	if [ -n "${WIZARDRY_RC_FORMAT-}" ]; then
		printf '%s\n' "$WIZARDRY_RC_FORMAT"
		return 0
	fi

	# Try to get format from _detect_rc_file output
	if detected=$(run_detect_rc_file); then
		while IFS= read -r line; do
			case $line in
			format=*)
				format=${line#format=}
				if [ -n "$format" ]; then
					printf '%s\n' "$format"
					return 0
				fi
				;;
			esac
		done <<EOF
$detected
EOF
	fi

	# Fallback: detect from file extension
	if rc_file=$(resolve_rc_file 2>/dev/null); then
		case $rc_file in
		*.nix) printf 'nix\n'; return 0 ;;
		esac
	fi

	printf 'shell\n'
}

hook_block_present() {
	rc_file=$1
	if [ ! -f "$rc_file" ]; then
		return 1
	fi
	# Check for shell format marker
	if grep -Fq '# >>> wizardry command-not-found >>>' "$rc_file"; then
		return 0
	fi
	# Check for nix format marker (used by _nix_shell_add)
	if grep -Fq '#wizardry: command-not-found' "$rc_file"; then
		return 0
	fi
	# Legacy check for WIZARDRY_COMMAND_NOT_FOUND variable
	if grep -Fq 'WIZARDRY_COMMAND_NOT_FOUND' "$rc_file"; then
		return 0
	fi
	return 1
}

ensure_rc_dir() {
	target=$1
	rc_dir=${target%/*}
	[ "$rc_dir" = "$target" ] && rc_dir=.
	if [ -d "$rc_dir" ]; then
		return 0
	fi
	if mkdir -p "$rc_dir"; then
		return 0
	fi
	_warn "unable to create directory '$rc_dir'."
	return 1
}

install() {
	# Detect nix format from _detect_rc_file output
	rc_format=$(resolve_rc_format)
	rc_file=$(resolve_rc_file) || return 1

	# For nix format, use _nix_shell_add imp to add shell init code
	if [ "$rc_format" = "nix" ]; then
		# Find _nix_shell_add helper
		nix_helper=""
		if [ -x "$SCRIPT_DIR/../../.imps/sys/_nix_shell_add" ]; then
			nix_helper="$SCRIPT_DIR/../../.imps/sys/_nix_shell_add"
		elif command -v _nix_shell_add >/dev/null 2>&1; then
			nix_helper=$(command -v _nix_shell_add)
		fi

		if [ -z "$nix_helper" ]; then
			printf '%s\n' "handle-command-not-found: _nix_shell_add imp not found for NixOS installation."
			return 1
		fi

		# Create the shell hook code for bash
		# command_not_found_handle _is the standard bash function for handling unknown commands
		# Defers to _word_of_binding for wizardry commands, falls back to parse for grammar parsing
		hook_code='command_not_found_handle() {
  # Try _word_of_binding first for autoloading wizardry commands
  if command -v _word_of_binding >/dev/null 2>&1; then
    if _word_of_binding "$@" 2>/dev/null; then
      return $?
    fi
  fi
  # Fall back to parse for recursive grammar parsing
  if command -v parse >/dev/null 2>&1; then
    parse "$@"
    return $?
  fi
  printf '\''%s: command not found. Try '\''menu'\'' for available spells.\n'\'' "$1" >&2
  return 127
}'

		if printf '%s\n' "$hook_code" | "$nix_helper" command-not-found "$rc_file" bash; then
			printf '%s\n' "handle-command-not-found: installed hook in '$rc_file'."
			# Run nixos-rebuild to apply the changes
			run_nix_rebuild || true
		else
			_warn "unable to update '$rc_file'."
			return 1
		fi
		return 0
	fi

	# Standard shell format installation
	if ! ensure_rc_dir "$rc_file"; then
		return 1
	fi
	tmp_file=$(_temp_file wizardry-cnf) || return 1
	trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
	if [ -f "$rc_file" ]; then
		sed '/^# >>> wizardry command-not-found >>>$/,/^# <<< wizardry command-not-found <<</d' "$rc_file" >"$tmp_file"
	else
		: >"$tmp_file"
	fi
	# Install the command_not_found_handle function which _is the standard bash
	# mechanism for intercepting unknown commands
	# Defers to _word_of_binding for autoloading, falls back to parse for grammar parsing
	cat <<'HOOK' >>"$tmp_file"
# >>> wizardry command-not-found >>>
command_not_found_handle() {
  # Try _word_of_binding first for autoloading wizardry commands
  if command -v _word_of_binding >/dev/null 2>&1; then
    if _word_of_binding "$@" 2>/dev/null; then
      return $?
    fi
  fi
  # Fall back to parse for recursive grammar parsing
  if command -v parse >/dev/null 2>&1; then
    parse "$@"
    return $?
  fi
  printf '%s: command not found. Try '\''menu'\'' for available spells.\n' "$1" >&2
  return 127
}
# <<< wizardry command-not-found <<<
HOOK
	if ! mv "$tmp_file" "$rc_file"; then
		trap - EXIT HUP INT TERM
		rm -f "$tmp_file"
		_warn "unable to update '$rc_file'."
		return 1
	fi
	trap - EXIT HUP INT TERM
	printf '%s\n' "handle-command-not-found: installed hook in '$rc_file'."
}

uninstall() {
	rc_format=$(resolve_rc_format)
	rc_file=$(resolve_rc_file) || return 1
	if [ ! -f "$rc_file" ]; then
		printf '%s\n' "handle-command-not-found: no rc file found at '$rc_file'."
		return 0
	fi
	if ! hook_block_present "$rc_file"; then
		printf '%s\n' "handle-command-not-found: not installed in '$rc_file'."
		return 0
	fi

	# For nix format, use _nix_shell_remove to remove the block
	if [ "$rc_format" = "nix" ]; then
		nix_helper=""
		if [ -x "$SCRIPT_DIR/../../.imps/sys/_nix_shell_remove" ]; then
			nix_helper="$SCRIPT_DIR/../../.imps/sys/_nix_shell_remove"
		elif command -v _nix_shell_remove >/dev/null 2>&1; then
			nix_helper=$(command -v _nix_shell_remove)
		fi

		if [ -n "$nix_helper" ]; then
			if "$nix_helper" command-not-found "$rc_file"; then
				printf '%s\n' "handle-command-not-found: uninstalled hook from '$rc_file'."
				# Run nixos-rebuild to apply the changes
				run_nix_rebuild || true
				return 0
			else
				_warn "unable to update '$rc_file'."
				return 1
			fi
		fi
		# _nix_shell_remove helper not found - _warn and attempt shell method fallback
		_warn "_nix_shell_remove imp not found; attempting shell-style removal (may not work for nix files)."
	fi

	# Shell format: use sed to remove the block
	tmp_file=$(_temp_file wizardry-cnf) || return 1
	trap '_cleanup_file "$tmp_file"' EXIT HUP INT TERM
	sed '/^# >>> wizardry command-not-found >>>$/,/^# <<< wizardry command-not-found <<</d' "$rc_file" >"$tmp_file"
	if ! mv "$tmp_file" "$rc_file"; then
		trap - EXIT HUP INT TERM
		rm -f "$tmp_file"
		_warn "unable to update '$rc_file'."
		return 1
	fi
	trap - EXIT HUP INT TERM
	printf '%s\n' "handle-command-not-found: uninstalled hook from '$rc_file'."
}

# Handle command-line invocation for install/uninstall commands
case "${1-}" in
install)
	install
	exit $?
	;;
uninstall)
	uninstall
	exit $?
	;;
*)
	show_usage >&2
	exit 1
	;;
esac
