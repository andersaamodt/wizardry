#!/bin/sh

test_root=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
while [ ! -f "$test_root/spells/.imps/test/test-bootstrap" ] && [ "$test_root" != "/" ]; do
  test_root=$(dirname "$test_root")
done
# shellcheck source=/dev/null
. "$test_root/spells/.imps/test/test-bootstrap"

test_help() {
  run_spell spells/.wizardry/generate-glosses --help
  assert_success || return 1
  assert_output_contains "Usage:" || return 1
  assert_output_contains "generate-glosses" || return 1
}

test_basic_execution() {
  # Run generate-glosses and capture output
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Check that output contains function definitions (new paradigm)
  # For large outputs like generate-glosses, read the file directly
  # Functions are multi-line, so check for function definition and parse call separately
  grep -q '()' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  grep -q 'parse' "${WIZARDRY_TMPDIR}/_test_output" || return 1
}

test_gloss_content() {
  # Run generate-glosses
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Check that output contains first-word gloss functions
  # For large outputs, read the file directly
  # Functions are multi-line, so we can't check everything on one line
  # Just verify that ask() function exists (for ask-* spells)
  grep -q '^ask()' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  
  # NOTE: Hyphenated aliases are no longer generated by generate-glosses
  # because spells are now natively available via PATH (invoke-wizardry adds all spell dirs to PATH)
  # Only first-word glosses and user synonyms are generated now
}

test_quiet_option() {
  # Run with --quiet to suppress info messages
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Output should contain gloss definitions
  # For large outputs, read the file directly
  # Functions are multi-line, so check for function definition and parse call separately
  grep -q '()' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  grep -q 'parse' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  
  # Error stream should not contain info messages (only errors/warnings)
  # In quiet mode, diagnostic messages go to stderr, function definitions to stdout
}

test_output_option() {
  tmpdir=$(make_tempdir)
  output_file="$tmpdir/glosses.sh"
  
  # Run with --output to save to file
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet --output "$output_file"
  assert_success || return 1
  
  # Check that file was created
  [ -f "$output_file" ] || return 1
  
  # Check that file contains gloss definitions (multi-line functions)
  # Functions are defined as: funcname() {\n  content\n}
  grep -q '() {$' "$output_file" || return 1
  grep -q 'parse' "$output_file" || return 1
}

test_all_spell_categories() {
  # Run generate-glosses
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Verify critical spell glosses exist in output
  # These are first-word glosses for multi-word spells
  # For large outputs, read the file directly
  # Functions are multi-line, so just check function exists
  
  # Check for first-word glosses (these exist for multi-word commands)
  # ask() for ask-yn and other ask-* spells
  grep -q '^ask()' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  
  # generate() for generate-glosses  
  grep -q '^generate()' "${WIZARDRY_TMPDIR}/_test_output" || return 1
  
  # NOTE: Hyphenated aliases (like ask-yn, mud-menu) are no longer generated
  # because spells are now natively available via PATH
}

test_invalid_default_synonyms_hard_fail() {
  # Test that invalid default synonyms cause script to fail
  # This catches bad default synonyms at development time
  tmpdir=$(make_tempdir)
  
  # Create a default-synonyms file with an invalid synonym
  cat > "$tmpdir/.default-synonyms" << 'EOF'
# Invalid synonym - starts with dash
-invalid=echo
# Valid synonym
valid=echo
EOF
  
  # Run generate-glosses - should fail due to invalid default synonym
  WIZARDRY_DIR="$ROOT_DIR" SPELLBOOK_DIR="$tmpdir" \
    run_spell spells/.wizardry/generate-glosses --quiet
  
  # Should fail (exit non-zero) to catch bad default synonyms at dev time
  if [ "$STATUS" -eq 0 ]; then
    TEST_FAILURE_REASON="Expected failure for invalid default synonym, but got success"
    return 1
  fi
  
  # Error message should mention invalid default synonym
  if ! printf '%s' "$ERROR" | grep -q "invalid default synonym"; then
    TEST_FAILURE_REASON="Expected error message about invalid default synonym in stderr"
    return 1
  fi
  
  # Should have ERROR prefix to indicate severity
  if ! printf '%s' "$ERROR" | grep -q "ERROR.*invalid default synonym"; then
    TEST_FAILURE_REASON="Expected ERROR prefix in message about invalid synonyms"
    return 1
  fi
}

test_synonym_multi_word_invocation() {
  # Test that multi-word synonym invocations work correctly
  # This tests the fix where first-word glosses must pass the reconstructed
  # multi-word spell name to parse (e.g., "leap-to-location") instead of
  # just the first word (e.g., "leap")
  
  tmpdir=$(make_tempdir)
  
  # Create custom synonym file with hyphenated synonym
  cat > "$tmpdir/.synonyms" << 'EOF'
leap-to-marker=translocation/jump-to-marker
warp=translocation/jump-to-marker
leap-to-location=translocation/jump-to-marker
EOF
  
  # Generate glosses with custom synonyms
  WIZARDRY_DIR="$ROOT_DIR" SPELLBOOK_DIR="$tmpdir" \
    run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Verify the glosses contain (read from file for large outputs):
  _output_file="${WIZARDRY_TMPDIR}/_test_output"
  
  # 1. Alias for hyphenated synonym (leap-to-marker)
  if ! grep -q "alias leap-to-marker=" "$_output_file"; then
    TEST_FAILURE_REASON="Expected alias for leap-to-marker synonym"
    return 1
  fi
  
  # 2. Function for non-hyphenated synonym (warp)
  if ! grep -q "warp()" "$_output_file"; then
    TEST_FAILURE_REASON="Expected function for warp synonym"
    return 1
  fi
  
  # 3. First-word gloss for 'leap' (extracted from leap-to-marker)
  if ! grep -q "leap()" "$_output_file"; then
    TEST_FAILURE_REASON="Expected first-word gloss function for leap"
    return 1
  fi
  
  # 4. NEW: The leap() gloss should source parse after setting args
  #    It prepends the first word to args, then sources parse
  #    Parse will handle finding the longest match and resolving synonyms
  if ! grep -q 'set -- "leap"' "$_output_file"; then
    TEST_FAILURE_REASON="Expected leap() gloss to set args with first word before sourcing parse"
    return 1
  fi
  
  if ! grep -q '\. parse' "$_output_file"; then
    TEST_FAILURE_REASON="Expected leap() gloss to source parse"
    return 1
  fi
  
  # 5. CRITICAL FIX: Aliases with directory paths must preserve the directory
  #    E.g., "leap-to-location=translocation/jump-to-marker" should generate
  #    alias leap-to-location='translocation/jump to marker'
  #    NOT alias leap-to-location='translocation/jump to marker'  (with / â†’ space)
  if ! grep -q "alias leap-to-location='translocation/jump to marker'" "$_output_file"; then
    TEST_FAILURE_REASON="Expected alias to preserve directory path: translocation/jump to marker"
    return 1
  fi
}

run_test_case "generate-glosses shows usage" test_help
run_test_case "generate-glosses generates glosses" test_basic_execution
run_test_case "generate-glosses creates valid gloss content" test_gloss_content
run_test_case "generate-glosses --quiet suppresses diagnostics" test_quiet_option
run_test_case "generate-glosses --output writes to file" test_output_option
run_test_case "generate-glosses creates glosses for all spell categories" test_all_spell_categories
run_test_case "generate-glosses hard fails on invalid default synonyms" test_invalid_default_synonyms_hard_fail
run_test_case "synonym multi-word invocations work (leap to location)" test_synonym_multi_word_invocation

#!/bin/sh
# Test custom synonyms with multi-word gloss commands
# This reproduces the bugs reported with warp and leap-to-location


# Note: These tests require custom synonyms to be set up
# They test that the gloss/parse system correctly handles user-defined synonyms

test_custom_synonym_single_word() {
  # This test verifies that a single-word synonym (warp) works
  # To test locally, add to ~/.spellbook/.synonyms: warp=jump-to-marker
  
  # Create temporary synonym
  tmpspellbook=$(make_tempdir)
  mkdir -p "$tmpspellbook"
  printf 'warp=jump-to-marker\n' > "$tmpspellbook/.synonyms"
  
  # Save current state
  saved_spellbook="${SPELLBOOK_DIR-}"
  saved_home="${HOME-}"
  
  # Set up environment and regenerate glosses  
  export SPELLBOOK_DIR="$tmpspellbook"
  export HOME="$tmpspellbook"
  
  # Regenerate glosses
  tmpgloss="$tmpspellbook/glosses"
  export WIZARDRY_DIR="$ROOT_DIR"
  "$ROOT_DIR/spells/.wizardry/generate-glosses" --output "$tmpgloss" --quiet
  
  # Source glosses in current shell
  . "$tmpgloss"
  
  # Test warp command
  OUTPUT=$(warp --help 2>&1)
  STATUS=$?
  
  # Restore environment
  if [ -n "$saved_spellbook" ]; then export SPELLBOOK_DIR="$saved_spellbook"; else unset SPELLBOOK_DIR; fi
  if [ -n "$saved_home" ]; then export HOME="$saved_home"; else unset HOME; fi
  
  if [ $STATUS -ne 0 ]; then
    TEST_FAILURE_REASON="warp failed with status $STATUS"
    return 1
  fi
  
  if ! printf '%s' "$OUTPUT" | grep -q "Usage:"; then
    TEST_FAILURE_REASON="warp output missing 'Usage:'"
    return 1
  fi
}

test_custom_synonym_multi_word_spaces() {
  # This test verifies that a multi-word synonym works with spaces (leap to location)
  # To test locally, add to ~/.spellbook/.synonyms: leap-to-location=jump-to-marker
  
  # Create temporary synonym
  tmpspellbook=$(make_tempdir)
  mkdir -p "$tmpspellbook"
  printf 'leap-to-location=jump-to-marker\n' > "$tmpspellbook/.synonyms"
  
  # Save current state
  saved_spellbook="${SPELLBOOK_DIR-}"
  saved_home="${HOME-}"
  
  # Set up environment and regenerate glosses
  export SPELLBOOK_DIR="$tmpspellbook"
  export HOME="$tmpspellbook"
  
  # Regenerate glosses
  tmpgloss="$tmpspellbook/glosses"
  export WIZARDRY_DIR="$ROOT_DIR"
  "$ROOT_DIR/spells/.wizardry/generate-glosses" --output "$tmpgloss" --quiet
  
  # Source glosses in current shell
  . "$tmpgloss"
  
  # Test "leap to location" command (spaces)
  OUTPUT=$(leap to location --help 2>&1)
  STATUS=$?
  
  # Restore environment
  if [ -n "$saved_spellbook" ]; then export SPELLBOOK_DIR="$saved_spellbook"; else unset SPELLBOOK_DIR; fi
  if [ -n "$saved_home" ]; then export HOME="$saved_home"; else unset HOME; fi
  
  if [ $STATUS -ne 0 ]; then
    TEST_FAILURE_REASON="leap to location failed with status $STATUS"
    return 1
  fi
  
  if ! printf '%s' "$OUTPUT" | grep -q "Usage:"; then
    TEST_FAILURE_REASON="leap to location output missing 'Usage:'"
    return 1
  fi
}

run_test_case "custom synonym single-word (warp)" test_custom_synonym_single_word
run_test_case "custom synonym multi-word with spaces (leap to location)" test_custom_synonym_multi_word_spaces

finish_tests
