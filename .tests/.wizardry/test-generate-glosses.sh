#!/bin/sh

test_root=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
while [ ! -f "$test_root/spells/.imps/test/test-bootstrap" ] && [ "$test_root" != "/" ]; do
  test_root=$(dirname "$test_root")
done
# shellcheck source=/dev/null
. "$test_root/spells/.imps/test/test-bootstrap"

test_help() {
  run_spell spells/.wizardry/generate-glosses --help
  assert_success || return 1
  assert_output_contains "Usage:" || return 1
  assert_output_contains "generate-glosses" || return 1
}

test_basic_execution() {
  # Run generate-glosses and capture output
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Check that output contains function definitions (new paradigm)
  # Should have first-word gloss functions like: menu() { parse "menu" "$@"; }
  printf '%s' "$OUTPUT" | grep -q '() { parse' || return 1
}

test_gloss_content() {
  # Run generate-glosses
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Check that output contains first-word gloss functions
  # Example: ask() { parse "ask" "$@"; } for ask-yn spell
  printf '%s' "$OUTPUT" | grep -q 'ask.*parse.*"ask"' || return 1
  
  # NOTE: Hyphenated aliases are no longer generated by generate-glosses
  # because spells are now natively available via PATH (invoke-wizardry adds all spell dirs to PATH)
  # Only first-word glosses and user synonyms are generated now
}

test_quiet_option() {
  # Run with --quiet to suppress info messages
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Output should contain gloss definitions
  printf '%s' "$OUTPUT" | grep -q '() { parse' || return 1
  
  # Error stream should not contain info messages (only errors/warnings)
  # In quiet mode, diagnostic messages go to stderr, function definitions to stdout
}

test_output_option() {
  tmpdir=$(make_tempdir)
  output_file="$tmpdir/glosses.sh"
  
  # Run with --output to save to file
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet --output "$output_file"
  assert_success || return 1
  
  # Check that file was created
  [ -f "$output_file" ] || return 1
  
  # Check that file contains gloss definitions
  grep -q '() { parse' "$output_file" || return 1
}

test_all_spell_categories() {
  # Run generate-glosses
  WIZARDRY_DIR="$ROOT_DIR" run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Verify critical spell glosses exist in output
  # These are first-word glosses for multi-word spells
  
  # Check for first-word glosses (these exist for multi-word commands)
  # ask() for ask-yn
  printf '%s' "$OUTPUT" | grep -q 'ask.*parse' || return 1
  
  # generate() for generate-glosses  
  printf '%s' "$OUTPUT" | grep -q 'generate.*parse' || return 1
  
  # NOTE: Hyphenated aliases (like ask-yn, mud-menu) are no longer generated
  # because spells are now natively available via PATH
}

test_invalid_default_synonyms_hard_fail() {
  # Test that invalid default synonyms cause an error
  tmpdir=$(make_tempdir)
  
  # Create a default-synonyms file with an invalid synonym
  cat > "$tmpdir/.default-synonyms" << 'EOF'
# Invalid synonym - starts with dash
-invalid=echo
# Valid synonym
valid=echo
EOF
  
  # Run generate-glosses - should report error for invalid synonym
  WIZARDRY_DIR="$ROOT_DIR" SPELLBOOK_DIR="$tmpdir" \
    run_spell spells/.wizardry/generate-glosses --quiet
  
  # Should succeed (doesn't exit with error, but reports to stderr)
  assert_success || return 1
  
  # Error message should mention invalid default synonym
  if ! printf '%s' "$ERROR" | grep -q "invalid default synonym"; then
    TEST_FAILURE_REASON="Expected error message about invalid default synonym"
    return 1
  fi
  
  # Should also have error count message
  if ! printf '%s' "$ERROR" | grep -q "ERROR.*invalid default synonym"; then
    TEST_FAILURE_REASON="Expected ERROR message about invalid synonyms"
    return 1
  fi
}

test_synonym_multi_word_invocation() {
  # Test that multi-word synonym invocations work correctly
  # This tests the fix where first-word glosses must pass the reconstructed
  # multi-word spell name to parse (e.g., "leap-to-location") instead of
  # just the first word (e.g., "leap")
  
  tmpdir=$(make_tempdir)
  
  # Create custom synonym file with hyphenated synonym
  cat > "$tmpdir/.synonyms" << 'EOF'
leap-to-marker=translocation/jump-to-marker
warp=translocation/jump-to-marker
leap-to-location=translocation/jump-to-marker
EOF
  
  # Generate glosses with custom synonyms
  WIZARDRY_DIR="$ROOT_DIR" SPELLBOOK_DIR="$tmpdir" \
    run_spell spells/.wizardry/generate-glosses --quiet
  assert_success || return 1
  
  # Verify the glosses contain:
  # 1. Alias for hyphenated synonym (leap-to-marker)
  if ! printf '%s' "$OUTPUT" | grep -q "alias leap-to-marker="; then
    TEST_FAILURE_REASON="Expected alias for leap-to-marker synonym"
    return 1
  fi
  
  # 2. Function for non-hyphenated synonym (warp)
  if ! printf '%s' "$OUTPUT" | grep -q "warp()"; then
    TEST_FAILURE_REASON="Expected function for warp synonym"
    return 1
  fi
  
  # 3. First-word gloss for 'leap' (extracted from leap-to-marker)
  if ! printf '%s' "$OUTPUT" | grep -q "leap()"; then
    TEST_FAILURE_REASON="Expected first-word gloss function for leap"
    return 1
  fi
  
  # 4. Critical: The leap() gloss must use \$_fw_spell not hardcoded "leap"
  #    in the final parse call, so multi-word invocations work
  if ! printf '%s' "$OUTPUT" | grep -q 'parse.*\$_fw_spell'; then
    TEST_FAILURE_REASON="Expected leap() gloss to use \$_fw_spell for multi-word reconstruction"
    return 1
  fi
  
  # 5. CRITICAL FIX: Aliases with directory paths must preserve the directory
  #    E.g., "leap-to-location=translocation/jump-to-marker" should generate
  #    alias leap-to-location='translocation/jump to marker'
  #    NOT alias leap-to-location='translocation/jump to marker'  (with / â†’ space)
  if ! printf '%s' "$OUTPUT" | grep -q "alias leap-to-location='translocation/jump to marker'"; then
    TEST_FAILURE_REASON="Expected alias to preserve directory path: translocation/jump to marker"
    return 1
  fi
  
  # 6. CRITICAL FIX: First-word glosses must invoke aliases via eval, not parse
  #    because parse skips aliases to avoid recursion. When "leap to location" is typed,
  #    the leap() gloss reconstructs it to "leap-to-location" and must check if it's an alias.
  #    If it is, it must eval it directly instead of calling parse.
  if ! printf '%s' "$OUTPUT" | grep -q 'type.*\$_fw_spell'; then
    TEST_FAILURE_REASON="Expected leap() gloss to check type of reconstructed spell name"
    return 1
  fi
  
  if ! printf '%s' "$OUTPUT" | grep -q 'eval.*\$_fw_spell'; then
    TEST_FAILURE_REASON="Expected leap() gloss to eval aliases directly (parse skips aliases)"
    return 1
  fi
}

run_test_case "generate-glosses shows usage" test_help
run_test_case "generate-glosses generates glosses" test_basic_execution
run_test_case "generate-glosses creates valid gloss content" test_gloss_content
run_test_case "generate-glosses --quiet suppresses diagnostics" test_quiet_option
run_test_case "generate-glosses --output writes to file" test_output_option
run_test_case "generate-glosses creates glosses for all spell categories" test_all_spell_categories
run_test_case "generate-glosses hard fails on invalid default synonyms" test_invalid_default_synonyms_hard_fail
run_test_case "synonym multi-word invocations work (leap to location)" test_synonym_multi_word_invocation

finish_tests
