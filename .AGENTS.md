# Wizardry - AI Agent Quick Reference

**Primary Documentation:** See `.github/copilot-instructions.md` for comprehensive coding standards, templates, and workflows.

**Most Canonical:** See `README.md` for project philosophy, values, and standards.

**Technical Specification:** See `.github/FULL_SPEC.md` for complete atomic specification. Reference frequently and keep updated.

## Quick Start

**Core Documentation** (keep content non-redundant):
0. **README.md** ‚Äî **MOST CANONICAL** ‚Äî Philosophy, values, standards ‚≠ê‚≠ê‚≠ê
1. **FULL_SPEC.md** ‚Äî Technical specification ‚≠ê‚≠ê‚≠ê
2. **SHELL_CODE_PATTERNS.md** ‚Äî POSIX patterns/best practices ‚≠ê
3. **CROSS_PLATFORM_PATTERNS.md** ‚Äî Cross-platform compatibility ‚≠ê
4. **EXEMPTIONS.md** ‚Äî Documented exceptions
5. **LESSONS.md** ‚Äî Debugging insights

**Start here:**
1. **README.md** ‚Äî Project philosophy (read first)
2. **FULL_SPEC.md** ‚Äî Complete technical spec (reference frequently)
3. **copilot-instructions.md** ‚Äî Templates, rules, workflows
4. **Topic guides** ‚Äî See `.github/` for spells.md, imps.md, tests.md, logging.md, etc.

## Critical Rules (AI Agents Often Miss These)

### 1. Tests Are NON-NEGOTIABLE
```sh
# Creating spell: spells/category/spell-name
# MUST create: .tests/category/test-spell-name.sh
# MUST run tests and report ACTUAL results (never guess!)
```

### 2. Shebang and Strict Mode
```sh
#!/bin/sh
set -eu  # ALWAYS (except conditional imps)
```

### 3. POSIX Only (No Bash-isms)
| Wrong | Right |
|-------|-------|
| `[[ ]]` or `==` | `[ ]` and `=` |
| `echo` | `printf '%s\n'` |
| `$var` | `"$var"` (always quote) |
| `value=$1` | `value=${1-}` (default) |

### 4. Function Naming
- **Spells:** `snake_case` for helper functions (maximum 1 helper, e.g., `detect_os`, `validate_input`)
- **Imps:** NO functions allowed (completely flat scripts)
- **Usage:** MUST be inline in case statement, NOT in a function
- **Never:** hyphens in function names (not POSIX-compliant)

### 5. Error Messages: Descriptive, Not Imperative
```sh
# ‚úó WRONG: "Please install git"
# ‚úì RIGHT: "spell-name: git not found"
```

### 6. set -eu Placement

**Spells (flat, linear scripts):**
```sh
#!/bin/sh
# Brief description

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: spell-name [args]
USAGE
  exit 0
  ;;
esac

set -eu  # After help handler, before main logic

# Main logic here (flat, linear code)
```

**Action imps:**
```sh
#!/bin/sh
# imp-name ARG - brief description
set -eu
# Flat linear code here
printf '%s\n' "$1"
```

**Conditional imps (NO set -eu):**
```sh
#!/bin/sh
# has COMMAND - test if exists
# Note: No set -eu (conditional imp)
command -v "$1" >/dev/null 2>&1
```

### 7. Document New Shell Patterns üìùüêö
**Wizardry is about codifying obscure POSIX knowledge.**

When you discover a new shell pattern, quirk, or cross-platform issue:
- Add shell patterns/quirks to `.github/SHELL_CODE_PATTERNS.md`
- Add cross-platform patterns to `.github/CROSS_PLATFORM_PATTERNS.md`
- Make entries succinct, AI-optimized, but readable

## Templates

### Spell
```sh
#!/bin/sh
# Brief description

case "${1-}" in
--help|--usage|-h)
  cat <<'USAGE'
Usage: spell-name [args]
Description.
USAGE
  exit 0
  ;;
esac

set -eu

# Main logic
# Call other spells by hyphenated name:
env-clear
has git || exit 1
```

### Test
```sh
#!/bin/sh
test_root=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
while [ ! -f "$test_root/spells/.imps/test/test-bootstrap" ] && [ "$test_root" != "/" ]; do
  test_root=$(dirname "$test_root")
done
. "$test_root/spells/.imps/test/test-bootstrap"

test_feature() {
  _run_spell "spells/category/name" arg
  _assert_success && _assert_output_contains "expected"
}

_run_test_case "description" test_feature
_finish_tests
```

## Common Patterns

```sh
# Command existence
has git || fail "git required"

# Variable defaults
name=${1-}                  # Empty if unset
path=${1:-/default/path}    # Default if unset/empty

# Output (respects WIZARDRY_LOG_LEVEL)
say "message"               # Always shown
success "done"              # Always shown
info "processing..."        # Level >= 1
debug "var=$var"            # Level >= 2

# Errors
warn "spell-name: warning"
die "spell-name: fatal error"
die 2 "spell-name: usage error"
```

## Workflow: New Spell

1. Plan: One thing? < 100 lines? ‚â§ 3 functions?
2. Create `spells/category/spell-name` from template
3. Create `.tests/category/test-spell-name.sh` (REQUIRED!)
4. Run test: `test-spell category/test-spell-name.sh`
5. Lint: `lint-magic spells/category/spell-name`
6. Check POSIX: `checkbashisms spells/category/spell-name`

## Workflow: New Imp

1. Verify: Used in 2+ spells? (If not, don't create imp!)
2. Determine type: Conditional (no `set -eu`) or Action (`set -eu`)
3. Create `spells/.imps/family/imp-name` from template
4. Create `.tests/.imps/family/test-imp-name.sh` (REQUIRED!)
5. Run test: `test-spell .imps/family/test-imp-name.sh`

## Architecture

| Component | Location | Purpose |
|-----------|----------|---------|
| **Spells** | `spells/category/` | User-facing commands |
| **Imps** | `spells/.imps/family/` | Micro-helpers (reusable) |
| **Tests** | `.tests/` (mirrors spells/) | ALWAYS required |
| **Bootstrap** | `install`, `spells/install/core/` | Pre-wizardry scripts |

## Interactive Testing with socat

**CRITICAL:** Use socat for real interactive testing, not mocks.

```sh
test_interactive() {
  # Skip if socat unavailable
  if ! command -v socat >/dev/null 2>&1; then
    test_skip "requires socat"
    return 0
  fi
  
  # Run with real PTY
  output=$(socat-pty "$ROOT_DIR/spells/cantrips/ask-yn" "Proceed?")
  
  # Normalize (strip ANSI, CR)
  normalized=$(printf '%s' "$output" | socat-normalize-output)
  
  # Assert on normalized transcript
  assert_output_contains "Proceed?" || return 1
}
```

**socat Helpers:**
- `socat-pty COMMAND ARGS` ‚Äî Run with real PTY
- `socat-send-keys KEYS` ‚Äî Convert symbolic to raw bytes (enter, up, down, etc.)
- `socat-normalize-output` ‚Äî Strip ANSI codes and CR

**Installation:**
- `banish 8` checks and auto-installs socat
- Core menu: toggleable install
- Fail loudly if unavailable

**Never mock interactive behavior** ‚Äî use socat or skip the test.

## Function vs Command Names

**Key insight:** Spells use **underscore names** internally, **hyphen names** externally (via glosses).

```sh
# ‚úì In spell code: use underscore
require_wizardry || return 1
env_or SPELLBOOK_DIR "$HOME/.spellbook"

# ‚úó In spell code: DON'T use hyphen (causes parse loop!)
require-wizardry  # WRONG!
env-or SPELLBOOK_DIR "$HOME/.spellbook"  # WRONG!

# ‚úì User commands: hyphenated (via glosses in PATH)
$ require-wizardry
$ env-or SPELLBOOK_DIR "$HOME/.spellbook"
```

## Documentation Map

**Core Documentation** (keep content non-redundant):
0. **README.md** ‚≠ê‚≠ê‚≠ê ‚Äî **MOST CANONICAL** ‚Äî Philosophy, values, standards
1. **FULL_SPEC.md** ‚≠ê‚≠ê‚≠ê ‚Äî Technical spec (reference frequently, keep updated)
2. **SHELL_CODE_PATTERNS.md** ‚≠ê ‚Äî POSIX patterns (document new discoveries)
3. **CROSS_PLATFORM_PATTERNS.md** ‚≠ê ‚Äî Cross-platform (document new discoveries)
4. **EXEMPTIONS.md** ‚Äî Documented exceptions
5. **LESSONS.md** ‚Äî Debugging insights (check when debugging)

**Quick Access:**
- **copilot-instructions.md** ‚Äî Main guide
- **Topic guides** (all in `.github/`):
  - `spells.md` ‚Äî Spell writing
  - `imps.md` ‚Äî Imps
  - `tests.md` ‚Äî Testing
  - `logging.md` ‚Äî Output/logging
  - `glossary-and-function-architecture.md` ‚Äî Glossary

## Before Submitting

- [ ] Read `README.md` and `.github/copilot-instructions.md`
- [ ] Created tests (NON-NEGOTIABLE)
- [ ] Ran tests and verified ACTUAL results (never guess!)
- [ ] Passed `lint-magic` and `checkbashisms`
- [ ] All variables quoted with `${var-}` defaults
- [ ] Error messages descriptive, not imperative
- [ ] No new exemptions without permission
- [ ] Made minimal, surgical changes

---

**Remember:** Spells are scrolls, not programs. Keep them clean, readable, and minimal. Always TDD. Always use imps (if used in 2+ spells). Always follow ALL project rules.
