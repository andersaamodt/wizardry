# Agent Instructions

Always read and follow the principles documented in `README.md` before making changes.

> **Note**: For quick reference, see also:
> - `.github/copilot-instructions.md` ‚Äî Concise project overview (Copilot)
> - `.github/CODEX.md` ‚Äî Project guidance for OpenAI Codex
> - `.github/instructions/spells.instructions.md` ‚Äî Spell style guide
> - `.github/instructions/imps.instructions.md` ‚Äî Imp (micro-helper) guide
> - `.github/instructions/cross-platform.instructions.md` ‚Äî Platform compatibility
> - `.github/instructions/tests.instructions.md` ‚Äî Testing patterns

## AI Directives

* **Preserve the spec**: Do not edit spec comments at top of scripts or `--help` usage text unless specifically instructed.
* **Preserve the lore**: Do not modify flavor text unless specifically instructed.
* **Script qualities**: Brevity, well-commented for novice POSIX shell devs, flat/linear flow, clarity, portability, composability, minimalism.
* **No globals**: Use parameters or stdout instead of shell variables.
* **No wrappers**: All files are standalone, portable, and front-facing.
* **Bootstrap awareness**: `./install` and `spells/install/core/` cannot assume wizardry is in PATH.
* **Arguments over variables**: Use documented `--help` arguments to pass data, not shell variables.
* **CI must pass**: All GitHub Actions, tests, and style checks must pass to merge.
* **Test imps**: Tests use imps in `spells/.imps`; test-only imps are prefixed `test-`.
* **Self-healing failures**: When a spell encounters a missing prerequisite or failed assumption, it must fix the problem automatically or offer to fix it‚Äînever quit with an error that tells the user to fix it themselves. This is the core philosophy of wizardry.
* **Never speak imperatively**: Error messages and output must never use imperative language (e.g., "Please install X", "Run Y", "Note: you must..."). Describe what went wrong, then fix it. Never tell the user to do something on their own‚Äîtaking care of it for the user is the whole point of wizardry.

## Spell Style Guide

Run `vet-spell` to check style compliance:
```sh
vet-spell                              # Core checks only
vet-spell --strict                     # Full strict mode
vet-spell --strict spells/category/spell-name  # Specific spell
```

### Spell Template

```sh
#!/bin/sh

# Brief description of what this spell does.
# Additional context (optional second line).

show_usage() {
  cat <<'USAGE'
Usage: spell-name [options] [arguments]

Description of what the spell does.
USAGE
}

case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac

set -eu

# Main logic here
```

### Required Elements (enforced by `vet-spell`)

#### 1. Shebang
```sh
#!/bin/sh
```
Also acceptable: `#!/usr/bin/env sh`. Never use `#!/bin/bash`.

#### 2. Opening Description Comment
```sh
# This spell does X.
# Use it when Y (optional second line).
```
Keep to 1-2 lines. Start with "This spell..."

#### 3. Strict Mode

Enable strict mode:

```sh
set -eu
```

- `-e`: Exit on error
- `-u`: Error on undefined variables

Note: `set -e` alone is also accepted, but `set -eu` is preferred.

---

### Recommended Elements

These elements are checked by `vet-spell --strict` but not enforced by default.

#### 4. Usage Function (Recommended)

Define a `show_usage` or `usage` function with a heredoc:

```sh
show_usage() {
  cat <<'USAGE'
Usage: spell-name [options] [arguments]

Brief description of what the spell does and how to use it.
USAGE
}
```

Guidelines:
- Use single-quoted heredoc delimiter `'USAGE'` to prevent variable expansion
- First line: `Usage:` followed by synopsis
- The --help message **is** the spell's spec
- **Keep usage notes short**: 2-5 lines after the `Usage:` line is ideal
- **Avoid long argument lists**: Spells with many arguments may need refactoring
- **No detailed option descriptions**: If options need explanation, the spell is too complex
- **One sentence per line**: Each line should convey one clear idea

**Good usage note** (brief, clear):

```sh
show_usage() {
  cat <<'USAGE'
Usage: look [path]

Display a location's name and description extended attributes using read-magic,
offering to memorize the spell into your shell rc for persistent availability.
Defaults to the current directory when no path is supplied.
USAGE
}
```

**Anti-pattern** (too verbose, too many options):

```sh
# AVOID: Long usage notes with many options suggest the spell needs refactoring
show_usage() {
  cat <<'USAGE'
Usage: complex-spell [--option1] [--option2 VALUE] [--option3] ...

Arguments:
  --option1       First option that does X
  --option2 VALUE Second option requiring a value
  --option3       Third option that does Y
  ...
USAGE
}
```

If a spell requires extensive documentation, consider:
1. Breaking it into smaller, focused spells
2. Moving complexity into helper imps
3. Using subcommands via separate spells instead of flags

#### 5. Help Handler (Recommended)

Handle `--help`, `--usage`, and `-h` before `set -eu`:

```sh
case "${1-}" in
--help|--usage|-h)
  show_usage
  exit 0
  ;;
esac
```

Why before `set -eu`? So `${1-}` works when no arguments are provided.

---

### Imps (Short Spells)

Imps are brief utility spells that live in `spells/.imps/`. They have relaxed requirements:

- **No `--help` required**: The opening comment serves as their spec
- **Opening comment required**: Must describe what the imp does
- **Shebang required**: `#!/bin/sh`
- **Strict mode required**: `set -eu`

Example imp:

```sh
#!/bin/sh

# Print the current date in ISO 8601 format.

set -eu

date +%Y-%m-%d
```

---

### Code Style

#### Variable Assignment

Use proper empty assignment syntax:

```sh
# CORRECT
var=''
var=""

# WRONG - creates variable with trailing space
var= 
```

#### Variable Expansion

Always use proper expansion with defaults:

```sh
# CORRECT
value=${1-}              # Empty default
value=${1:-default}      # Non-empty default

# WRONG
value=$1                 # Fails with set -u if $1 unset
```

#### Quoting

Always quote variables unless word splitting is intended:

```sh
# CORRECT
printf '%s\n' "$message"
path="$HOME/wizardry"

# WRONG
printf '%s\n' $message
path=$HOME/wizardry
```

#### Functions

Keep functions minimal. Prefer linear, flat code flow:

```sh
# PREFERRED - linear flow
if [ -z "$input" ]; then
  printf 'Error: no input\n' >&2
  exit 1
fi
# continue with logic...

# AVOID - excessive function wrapping
validate_input() { ... }
process_input() { ... }
output_result() { ... }
validate_input "$1"
process_input "$1"
output_result
```

#### Error Messages

Print errors to stderr with the spell name as prefix:

```sh
printf '%s\n' "spell-name: error message here." >&2
exit 1
```

**Error messages must not be imperative.** Do not tell users what to do‚Äîdescribe what went wrong:

```sh
# WRONG - imperative language
printf '%s\n' "Please install sshfs." >&2
printf '%s\n' "Run 'menu' to install dependencies." >&2
printf '%s\n' "Error: file argument required." >&2

# CORRECT - declarative/descriptive
printf '%s\n' "spell-name: sshfs not found." >&2
printf '%s\n' "spell-name: file path required." >&2
printf '%s\n' "spell-name: root privileges required." >&2
```

When a spell encounters a missing prerequisite, it should fix the problem automatically or offer to fix it‚Äînever quit telling the user to fix it themselves.

#### Temporary Files

Use `mktemp` with proper cleanup:

```sh
tmp_file=$(mktemp "${TMPDIR:-/tmp}/spell-name.XXXXXX") || exit 1
# ... use tmp_file ...
rm -f "$tmp_file"
```

#### Command Substitution

Use `$()` syntax, not backticks:

```sh
# CORRECT
result=$(command)

# WRONG
result=`command`
```

#### Exit Codes

- `0`: Success
- `1`: General error
- `2`: Usage/argument error
- `126`: Command cannot execute
- `127`: Command not found
- `130`: Interrupted (Ctrl-C)

---

### Spell Complexity

Spells should be **simple and focused**. Complex argument structures are a code smell.

#### Signs a Spell Needs Refactoring

- **Many flags or options**: More than 2-3 optional flags suggests splitting the spell
- **Multiple modes**: If `--help` shows different "Usage:" lines, break into separate spells
- **Long usage notes**: More than 5-10 lines of help text indicates complexity
- **Subcommands**: Patterns like `spell action [args]` should be separate spells (e.g., `spell-add`, `spell-remove`)
- **Deeply nested logic**: Complex conditionals handling many argument combinations

#### Refactoring Strategies

1. **Split by mode**: `learn --rc-file ... add` ‚Üí separate `learn-rc-add` spell
2. **Extract helpers**: Move shared logic to imps in `spells/.imps/`
3. **Use composition**: Small spells that pipe to each other
4. **Default to sensible behavior**: Fewer options needed when defaults are good

#### Example: Good vs Complex

```sh
# GOOD: Simple, focused spell
# Usage: mark-location [marker] [path]

# COMPLEX: Multiple modes, many options - consider refactoring
# Usage: learn --rc-file FILE --spell NAME {add|remove|status}
#        learn [OPTIONS] [PATH ...]
```

When a spell grows complex, ask: "Can this be 2-3 simpler spells instead?"

---

### POSIX Compliance

All spells must pass `checkbashisms`. Avoid:

- `[[ ]]` - use `[ ]` instead
- `read -d` - not POSIX
- `$'string'` - ANSI-C quoting not portable
- `{1..10}` - brace expansion not POSIX
- `local` - use plain variable assignment
- `source` - use `.` instead
- Arrays - not available in POSIX sh

#### Portable Patterns

```sh
# String contains (instead of [[ =~ ]])
case "$string" in
  *substring*)
    # contains substring
    ;;
esac

# Default value
value=${1:-default}

# Conditional assignment
: "${VAR:=default}"
```

---

### Cross-Platform Considerations

#### Path Handling

Don't assume paths exist on all systems:

```sh
# CORRECT - use command -v
if command -v tool >/dev/null 2>&1; then
  tool "$@"
fi

# WRONG - assume path
if [ -x /usr/bin/tool ]; then
  /usr/bin/tool "$@"
fi
```

#### Color Support

Load colors gracefully with fallback:

```sh
if colors_path=$(command -v colors 2>/dev/null); then
  # shellcheck disable=SC1090
  . "$colors_path"
else
  RESET=''
  BLUE=''
fi
```

---

### Requiring Wizardry

Spells that depend on wizardry features (imps, other spells) should handle the case when wizardry is not installed.

#### Using require-wizardry (Recommended)

For most spells that can assume wizardry is on PATH, use the `require-wizardry` cantrip:

```sh
#!/bin/sh

# Brief description of what this spell does.

# Ensure wizardry is available before using any imps
require-wizardry || exit 1

set -eu

# Now safe to use wizardry imps and spells
say "Hello from wizardry!"
```

#### Bootstrapping Snippet (for standalone scripts)

For scripts that may run before wizardry is installed (like custom install scripts),
embed the require-wizardry snippet directly in your script. Get the snippet with:

```sh
require-wizardry --snippet
```

The snippet provides a self-contained check that works without any wizardry dependencies:

```sh
#!/bin/sh

# --- require-wizardry snippet ---
_require_wizardry() {
  if command -v menu >/dev/null 2>&1; then
    return 0
  fi
  printf '%s\n' "Error: wizardry is not installed or not in PATH." >&2
  printf '%s\n' "Install it with:" >&2
  printf '%s\n' "  curl -fsSL https://raw.githubusercontent.com/andersaamodt/wizardry/main/install | sh" >&2
  exit 1
}
_require_wizardry
# --- end require-wizardry snippet ---

set -eu

# Your script continues here...
```

#### Graceful Fallbacks

For spells that should work with or without wizardry (like `arcane/copy`),
provide inline fallbacks:

```sh
# Helper that works with or without wizardry imps
_say() {
  if command -v say >/dev/null 2>&1; then
    say "$@"
  else
    printf '%s\n' "$*"
  fi
}

_has() {
  command -v "$1" >/dev/null 2>&1
}
```

---

### Menu Commands

When building menu items in wizardry menu spells, always use **spell names** rather than full paths for commands. Since users are only accessing menus after wizardry is installed, all spells are guaranteed to be on PATH.

**Good** (use spell name):
```sh
cd_hook="[ ] CD hook%toggle-cd"
system="System Menu%system-menu"
```

**Avoid** (full paths):
```sh
cd_hook="[ ] CD hook%$SCRIPT_DIR/../install/mud/toggle-cd"
system="System Menu%$SCRIPT_DIR/system-menu"
```

This keeps menu definitions cleaner and ensures commands work regardless of installation location.

---

### Documentation

#### Spell Headers

Model header:

```sh
#!/bin/sh

# This spell displays a location's extended attributes as a description.
# It can prompt to memorize itself so the `look` incantation stays available.
```

#### Help Text

Help text should be **brief and scannable**. Aim for 2-5 lines after the `Usage:` line.

Model help (good):

```sh
show_usage() {
  cat <<'USAGE'
Usage: look [path]

Display a location's name and description extended attributes using read-magic,
offering to memorize the spell into your shell rc for persistent availability.
Defaults to the current directory when no path is supplied.
USAGE
}
```

Principles for help text:
- **Brevity over completeness**: Users can read the source for details
- **No argument tables**: If you need a table, the spell is too complex
- **One-liner descriptions**: Each option/argument should be obvious from its name
- **Defaults stated simply**: "Defaults to current directory" not elaborate explanations

Signs that help text (and the spell) needs refactoring:
- More than 10 lines in the usage block
- Multiple `Usage:` lines for different modes
- Argument descriptions longer than one line
- Options that require their own sub-options

---

### Testing

Every spell should have a corresponding test file:

- Location: `.tests/<category>/test_<spell-name>.sh`
- Pattern: Source `test_common.sh`, use `run_test_case`, call `finish_tests`
- Coverage: Test `--help`, success cases, error cases

Example:

```sh
#!/bin/sh

test_root=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
while [ ! -f "$test_root/test_common.sh" ] && [ "$test_root" != "/" ]; do
  test_root=$(dirname "$test_root")
done
# shellcheck source=/dev/null
. "$test_root/test_common.sh"

test_help() {
  run_spell "spells/category/spell-name" --help
  assert_success && assert_output_contains "Usage:"
}

run_test_case "spell prints usage" test_help
finish_tests
```

---

### Model Spells

Study these spells as templates:

1. **`spells/arcane/look`** - Excellent help, error handling, self-installation
2. **`spells/spellcraft/forall`** - Minimal, focused, well-documented
3. **`spells/cantrips/menu`** - Complex but well-structured

---

### Spell Checklist

Before submitting a spell, verify:

- [ ] Shebang is `#!/bin/sh`
- [ ] Opening description comment exists (1-2 lines)
- [ ] `show_usage` function exists (unless it's an imp)
- [ ] Help handler handles `--help`, `--usage`, `-h` (unless it's an imp)
- [ ] `set -eu` is present
- [ ] Variables are properly quoted
- [ ] Empty variables use `var=''` not `var= `
- [ ] Errors go to stderr with spell name prefix
- [ ] Passes `checkbashisms`
- [ ] Test file exists at `.tests/<category>/test_<spell-name>.sh`

---

## Cross-Platform Reference

> **Full details**: See `.github/instructions/cross-platform.instructions.md`

### Essential Patterns

#### Platform Detection
```sh
kernel=$(uname -s 2>/dev/null || printf 'unknown')
case $kernel in
    Darwin) platform=mac ;;
    Linux)  platform=linux ;;
esac
```

#### Command Availability
```sh
# CORRECT
if command -v tool >/dev/null 2>&1; then tool "$@"; fi

# WRONG
if which tool >/dev/null; then ...
```

#### Path Resolution
```sh
# Use pwd -P, not realpath (always disable CDPATH)
script_dir=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)

# Normalize double slashes (macOS TMPDIR issue)
path=$(printf '%s' "$path" | sed 's|//|/|g')
```

#### Temporary Files
```sh
tmpdir=$(mktemp -d "${TMPDIR:-/tmp}/prefix.XXXXXX")
```

#### Download with Fallback
```sh
if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url" -o "$dest" || exit 1
elif command -v wget >/dev/null 2>&1; then
    wget -qO "$dest" "$url" || exit 1
fi
```

#### PATH Initialization (Bootstrap Scripts)
Set baseline PATH BEFORE `set -eu`:
```sh
#!/bin/sh
baseline_path="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
case ":${PATH-}:" in
  *":/usr/bin:"*|*":/bin:"*) ;;
  *) PATH="${baseline_path}${PATH:+:}${PATH-}" ;;
esac
export PATH

set -eu
```

### Bash-isms to Avoid

| Bash-ism | POSIX Alternative |
|----------|-------------------|
| `[[ ]]` | `[ ]` |
| `==` | `=` |
| `source` | `.` |
| `$RANDOM` | `awk 'BEGIN{srand();print int(rand()*N)}'` |
| Arrays | Space-separated strings |
| `local` | Plain variable assignment |

### Testing Cross-Platform

- Include both `/bin` and `/usr/bin` when setting PATH in tests
- Normalize paths before assertions
- Create symlinks for essential utilities in test stub directories

---

*May your spells cast true!* üßô‚Äç‚ôÇÔ∏è‚ú®
