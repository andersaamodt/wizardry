# Wizardry - AI Agent Quick Reference

**Primary Documentation:** See `.github/copilot-instructions.md` for comprehensive coding standards, templates, and workflows.

**Canonical Specification:** See `.github/FULL_SPEC.md` for complete atomic specification organized by spell levels. Reference frequently and keep updated.

## Quick Start

**Documentation Hierarchy** (precedence order):
1. **FULL_SPEC.md** â€” Canonical specification (what/constraints) â­â­â­
2. **SHELL_CODE_PATTERNS.md** â€” POSIX shell patterns/best practices (how/idioms) â­
3. **CROSS_PLATFORM_PATTERNS.md** â€” Cross-platform compatibility â­
4. **EXEMPTIONS.md** â€” Documented exceptions
5. **LESSONS.md** â€” Debugging insights

**Start here:**
1. **Read first:** `README.md` (project philosophy)
2. **Reference frequently:** `.github/FULL_SPEC.md` (complete spec)
3. **Main guide:** `.github/copilot-instructions.md` (templates, rules, workflows)
4. **Detailed guides:** `.github/instructions/*.md` (topic-specific details)

## Critical Rules (AI Agents Often Miss These)

### 1. Tests Are NON-NEGOTIABLE
```sh
# Creating spell: spells/category/spell-name
# MUST create: .tests/category/test-spell-name.sh
# MUST run tests and report ACTUAL results (never guess!)
```

### 2. Shebang and Strict Mode
```sh
#!/bin/sh
set -eu  # ALWAYS (except conditional imps)
```

### 3. POSIX Only (No Bash-isms)
| Wrong | Right |
|-------|-------|
| `[[ ]]` or `==` | `[ ]` and `=` |
| `echo` | `printf '%s\n'` |
| `$var` | `"$var"` (always quote) |
| `value=$1` | `value=${1-}` (default) |

### 4. Function Naming
- **Spells:** `snake_case` (e.g., `show_usage`, `detect_os`)
- **Imps:** `_snake_case` for internal (e.g., `_has`, `_say`)
- **Never:** hyphens in function names

### 5. Error Messages: Descriptive, Not Imperative
```sh
# âœ— WRONG: "Please install git"
# âœ“ RIGHT: "spell-name: git not found"
```

### 6. set -eu Placement

**Spells (flat, linear scripts):**
```sh
#!/bin/sh
# Brief description

case "${1-}" in
--help|--usage|-h) show_usage; exit 0 ;; esac

set -eu  # After help handler, before main logic

# Main logic here (flat, linear code)
```

**Action imps:**
```sh
#!/bin/sh
# imp-name ARG - brief description
set -eu
# Flat linear code here
printf '%s\n' "$1"
```

**Conditional imps (NO set -eu):**
```sh
#!/bin/sh
# has COMMAND - test if exists
# Note: No set -eu (conditional imp)
command -v "$1" >/dev/null 2>&1
```

### 7. Document New Shell Patterns ğŸ“ğŸš
**Wizardry is about codifying obscure POSIX knowledge.**

When you discover a new shell pattern, quirk, or cross-platform issue:
- Add shell patterns/quirks to `.github/SHELL_CODE_PATTERNS.md`
- Add cross-platform patterns to `.github/CROSS_PLATFORM_PATTERNS.md`
- Make entries succinct, AI-optimized, but readable

## Templates

### Spell
```sh
#!/bin/sh
# Brief description

show_usage() { cat <<'USAGE'
Usage: spell-name [args]
Description.
USAGE
}

case "${1-}" in
--help|--usage|-h) show_usage; exit 0 ;; esac

require-wizardry || exit 1
set -eu
. env-clear

# Main logic
```

### Test
```sh
#!/bin/sh
test_root=$(CDPATH= cd -- "$(dirname "$0")" && pwd -P)
while [ ! -f "$test_root/spells/.imps/test/test-bootstrap" ] && [ "$test_root" != "/" ]; do
  test_root=$(dirname "$test_root")
done
. "$test_root/spells/.imps/test/test-bootstrap"

test_feature() {
  _run_spell "spells/category/name" arg
  _assert_success && _assert_output_contains "expected"
}

_run_test_case "description" test_feature
_finish_tests
```

## Common Patterns

```sh
# Command existence
has git || fail "git required"

# Variable defaults
name=${1-}                  # Empty if unset
path=${1:-/default/path}    # Default if unset/empty

# Output (respects WIZARDRY_LOG_LEVEL)
say "message"               # Always shown
success "done"              # Always shown
info "processing..."        # Level >= 1
debug "var=$var"            # Level >= 2

# Errors
warn "spell-name: warning"
die "spell-name: fatal error"
die 2 "spell-name: usage error"
```

## Workflow: New Spell

1. Plan: One thing? < 100 lines? â‰¤ 3 functions?
2. Create `spells/category/spell-name` from template
3. Create `.tests/category/test-spell-name.sh` (REQUIRED!)
4. Run test: `test-spell category/test-spell-name.sh`
5. Lint: `lint-magic spells/category/spell-name`
6. Check POSIX: `checkbashisms spells/category/spell-name`

## Workflow: New Imp

1. Verify: Used in 2+ spells? (If not, don't create imp!)
2. Determine type: Conditional (no `set -eu`) or Action (`set -eu`)
3. Create `spells/.imps/family/imp-name` from template
4. Create `.tests/.imps/family/test-imp-name.sh` (REQUIRED!)
5. Run test: `test-spell .imps/family/test-imp-name.sh`

## Architecture

| Component | Location | Purpose |
|-----------|----------|---------|
| **Spells** | `spells/category/` | User-facing commands |
| **Imps** | `spells/.imps/family/` | Micro-helpers (reusable) |
| **Tests** | `.tests/` (mirrors spells/) | ALWAYS required |
| **Bootstrap** | `install`, `spells/install/core/` | Pre-wizardry scripts |

## Function vs Command Names

**Key insight:** Spells use **underscore names** internally, **hyphen names** externally (via glosses).

```sh
# âœ“ In spell code: use underscore
require_wizardry || return 1
env_or SPELLBOOK_DIR "$HOME/.spellbook"

# âœ— In spell code: DON'T use hyphen (causes parse loop!)
require-wizardry  # WRONG!
env-or SPELLBOOK_DIR "$HOME/.spellbook"  # WRONG!

# âœ“ User commands: hyphenated (via glosses in PATH)
$ require-wizardry
$ env-or SPELLBOOK_DIR "$HOME/.spellbook"
```

## Documentation Map

**Hierarchy (Precedence Order):**
1. **FULL_SPEC.md** â­â­â­ â€” Canonical spec (reference frequently, keep updated)
2. **SHELL_CODE_PATTERNS.md** â­ â€” POSIX patterns (document new discoveries)
3. **CROSS_PLATFORM_PATTERNS.md** â­ â€” Cross-platform (document new discoveries)
4. **EXEMPTIONS.md** â€” Documented exceptions
5. **LESSONS.md** â€” Debugging insights (check when debugging)

**Quick Access:**
- **Philosophy:** `README.md`
- **Main guide:** `.github/copilot-instructions.md`
- **Spell-specific:** `.github/instructions/spells.instructions.md`
- **Imps:** `.github/instructions/imps.instructions.md`
- **Tests:** `.github/instructions/tests.instructions.md`
- **Logging:** `.github/instructions/logging.instructions.md`
- **Best practices quick ref:** `.github/instructions/best-practices.instructions.md` (â†’ SHELL_CODE_PATTERNS)
- **Cross-platform quick ref:** `.github/instructions/cross-platform.instructions.md` (â†’ CROSS_PLATFORM_PATTERNS)

## Before Submitting

- [ ] Read `README.md` and `.github/copilot-instructions.md`
- [ ] Created tests (NON-NEGOTIABLE)
- [ ] Ran tests and verified ACTUAL results (never guess!)
- [ ] Passed `lint-magic` and `checkbashisms`
- [ ] All variables quoted with `${var-}` defaults
- [ ] Error messages descriptive, not imperative
- [ ] No new exemptions without permission
- [ ] Made minimal, surgical changes

---

**Remember:** Spells are scrolls, not programs. Keep them clean, readable, and minimal. Always TDD. Always use imps (if used in 2+ spells). Always follow ALL project rules.
